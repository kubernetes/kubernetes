//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by validation-gen. DO NOT EDIT.

package v1beta1

import (
	context "context"
	fmt "fmt"

	resourcev1beta1 "k8s.io/api/resource/v1beta1"
	equality "k8s.io/apimachinery/pkg/api/equality"
	operation "k8s.io/apimachinery/pkg/api/operation"
	safe "k8s.io/apimachinery/pkg/api/safe"
	validate "k8s.io/apimachinery/pkg/api/validate"
	runtime "k8s.io/apimachinery/pkg/runtime"
	field "k8s.io/apimachinery/pkg/util/validation/field"
)

func init() { localSchemeBuilder.Register(RegisterValidations) }

// RegisterValidations adds validation functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterValidations(scheme *runtime.Scheme) error {
	// type ResourceClaim
	scheme.AddValidationFunc((*resourcev1beta1.ResourceClaim)(nil), func(ctx context.Context, op operation.Operation, obj, oldObj interface{}) field.ErrorList {
		switch op.Request.SubresourcePath() {
		case "/", "/status":
			return Validate_ResourceClaim(ctx, op, nil /* fldPath */, obj.(*resourcev1beta1.ResourceClaim), safe.Cast[*resourcev1beta1.ResourceClaim](oldObj))
		}
		return field.ErrorList{field.InternalError(nil, fmt.Errorf("no validation found for %T, subresource: %v", obj, op.Request.SubresourcePath()))}
	})
	// type ResourceClaimList
	scheme.AddValidationFunc((*resourcev1beta1.ResourceClaimList)(nil), func(ctx context.Context, op operation.Operation, obj, oldObj interface{}) field.ErrorList {
		switch op.Request.SubresourcePath() {
		case "/":
			return Validate_ResourceClaimList(ctx, op, nil /* fldPath */, obj.(*resourcev1beta1.ResourceClaimList), safe.Cast[*resourcev1beta1.ResourceClaimList](oldObj))
		}
		return field.ErrorList{field.InternalError(nil, fmt.Errorf("no validation found for %T, subresource: %v", obj, op.Request.SubresourcePath()))}
	})
	return nil
}

// Validate_AllocationResult validates an instance of AllocationResult according
// to declarative validation rules in the API schema.
func Validate_AllocationResult(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *resourcev1beta1.AllocationResult) (errs field.ErrorList) {
	// field resourcev1beta1.AllocationResult.Devices
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *resourcev1beta1.DeviceAllocationResult) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_DeviceAllocationResult(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("devices"), &obj.Devices, safe.Field(oldObj, func(oldObj *resourcev1beta1.AllocationResult) *resourcev1beta1.DeviceAllocationResult {
			return &oldObj.Devices
		}))...)

	// field resourcev1beta1.AllocationResult.NodeSelector has no validation
	// field resourcev1beta1.AllocationResult.AllocationTimestamp has no validation
	return errs
}

// Validate_DeviceAllocationResult validates an instance of DeviceAllocationResult according
// to declarative validation rules in the API schema.
func Validate_DeviceAllocationResult(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *resourcev1beta1.DeviceAllocationResult) (errs field.ErrorList) {
	// field resourcev1beta1.DeviceAllocationResult.Results
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []resourcev1beta1.DeviceRequestAllocationResult) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// iterate the list and call the type's validation function
			errs = append(errs, validate.EachSliceVal(ctx, op, fldPath, obj, oldObj, nil, nil, Validate_DeviceRequestAllocationResult)...)
			return
		}(fldPath.Child("results"), obj.Results, safe.Field(oldObj, func(oldObj *resourcev1beta1.DeviceAllocationResult) []resourcev1beta1.DeviceRequestAllocationResult {
			return oldObj.Results
		}))...)

	// field resourcev1beta1.DeviceAllocationResult.Config has no validation
	return errs
}

// Validate_DeviceRequestAllocationResult validates an instance of DeviceRequestAllocationResult according
// to declarative validation rules in the API schema.
func Validate_DeviceRequestAllocationResult(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *resourcev1beta1.DeviceRequestAllocationResult) (errs field.ErrorList) {
	// field resourcev1beta1.DeviceRequestAllocationResult.Request has no validation
	// field resourcev1beta1.DeviceRequestAllocationResult.Driver has no validation

	// field resourcev1beta1.DeviceRequestAllocationResult.Pool
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			if e := validate.RequiredValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				errs = append(errs, e...)
				return // do not proceed
			}
			errs = append(errs, validate.ResourcePoolName(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("pool"), &obj.Pool, safe.Field(oldObj, func(oldObj *resourcev1beta1.DeviceRequestAllocationResult) *string { return &oldObj.Pool }))...)

	// field resourcev1beta1.DeviceRequestAllocationResult.Device has no validation
	// field resourcev1beta1.DeviceRequestAllocationResult.AdminAccess has no validation
	// field resourcev1beta1.DeviceRequestAllocationResult.Tolerations has no validation
	// field resourcev1beta1.DeviceRequestAllocationResult.BindingConditions has no validation
	// field resourcev1beta1.DeviceRequestAllocationResult.BindingFailureConditions has no validation
	// field resourcev1beta1.DeviceRequestAllocationResult.ShareID has no validation
	// field resourcev1beta1.DeviceRequestAllocationResult.ConsumedCapacity has no validation
	return errs
}

// Validate_ResourceClaim validates an instance of ResourceClaim according
// to declarative validation rules in the API schema.
func Validate_ResourceClaim(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *resourcev1beta1.ResourceClaim) (errs field.ErrorList) {
	// field resourcev1beta1.ResourceClaim.TypeMeta has no validation
	// field resourcev1beta1.ResourceClaim.ObjectMeta has no validation
	// field resourcev1beta1.ResourceClaim.Spec has no validation

	// field resourcev1beta1.ResourceClaim.Status
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *resourcev1beta1.ResourceClaimStatus) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_ResourceClaimStatus(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("status"), &obj.Status, safe.Field(oldObj, func(oldObj *resourcev1beta1.ResourceClaim) *resourcev1beta1.ResourceClaimStatus {
			return &oldObj.Status
		}))...)

	return errs
}

// Validate_ResourceClaimList validates an instance of ResourceClaimList according
// to declarative validation rules in the API schema.
func Validate_ResourceClaimList(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *resourcev1beta1.ResourceClaimList) (errs field.ErrorList) {
	// field resourcev1beta1.ResourceClaimList.TypeMeta has no validation
	// field resourcev1beta1.ResourceClaimList.ListMeta has no validation

	// field resourcev1beta1.ResourceClaimList.Items
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []resourcev1beta1.ResourceClaim) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// iterate the list and call the type's validation function
			errs = append(errs, validate.EachSliceVal(ctx, op, fldPath, obj, oldObj, nil, nil, Validate_ResourceClaim)...)
			return
		}(fldPath.Child("items"), obj.Items, safe.Field(oldObj, func(oldObj *resourcev1beta1.ResourceClaimList) []resourcev1beta1.ResourceClaim { return oldObj.Items }))...)

	return errs
}

// Validate_ResourceClaimStatus validates an instance of ResourceClaimStatus according
// to declarative validation rules in the API schema.
func Validate_ResourceClaimStatus(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *resourcev1beta1.ResourceClaimStatus) (errs field.ErrorList) {
	// field resourcev1beta1.ResourceClaimStatus.Allocation
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *resourcev1beta1.AllocationResult) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			if e := validate.OptionalPointer(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				return // do not proceed
			}
			// call the type's validation function
			errs = append(errs, Validate_AllocationResult(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("allocation"), obj.Allocation, safe.Field(oldObj, func(oldObj *resourcev1beta1.ResourceClaimStatus) *resourcev1beta1.AllocationResult {
			return oldObj.Allocation
		}))...)

	// field resourcev1beta1.ResourceClaimStatus.ReservedFor
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []resourcev1beta1.ResourceClaimConsumerReference) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			if e := validate.OptionalSlice(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				return // do not proceed
			}
			return
		}(fldPath.Child("reservedFor"), obj.ReservedFor, safe.Field(oldObj, func(oldObj *resourcev1beta1.ResourceClaimStatus) []resourcev1beta1.ResourceClaimConsumerReference {
			return oldObj.ReservedFor
		}))...)

	// field resourcev1beta1.ResourceClaimStatus.Devices
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []resourcev1beta1.AllocatedDeviceStatus) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			if e := validate.OptionalSlice(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				return // do not proceed
			}
			return
		}(fldPath.Child("devices"), obj.Devices, safe.Field(oldObj, func(oldObj *resourcev1beta1.ResourceClaimStatus) []resourcev1beta1.AllocatedDeviceStatus {
			return oldObj.Devices
		}))...)

	return errs
}
