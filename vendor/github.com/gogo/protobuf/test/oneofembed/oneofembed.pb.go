// Code generated by protoc-gen-gogo.
// source: oneofembed.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	oneofembed.proto

It has these top-level messages:
	Foo
	Bar
*/
package proto

import proto1 "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Foo struct {
	*Bar `protobuf:"bytes,1,opt,name=bar,embedded=bar" json:"bar,omitempty"`
}

func (m *Foo) Reset()         { *m = Foo{} }
func (m *Foo) String() string { return proto1.CompactTextString(m) }
func (*Foo) ProtoMessage()    {}

type Bar struct {
	// Types that are valid to be assigned to Pick:
	//	*Bar_A
	//	*Bar_B
	Pick isBar_Pick `protobuf_oneof:"pick"`
}

func (m *Bar) Reset()         { *m = Bar{} }
func (m *Bar) String() string { return proto1.CompactTextString(m) }
func (*Bar) ProtoMessage()    {}

type isBar_Pick interface {
	isBar_Pick()
	Equal(interface{}) bool
}

type Bar_A struct {
	A bool `protobuf:"varint,11,opt,name=a,proto3,oneof"`
}
type Bar_B struct {
	B bool `protobuf:"varint,12,opt,name=b,proto3,oneof"`
}

func (*Bar_A) isBar_Pick() {}
func (*Bar_B) isBar_Pick() {}

func (m *Bar) GetPick() isBar_Pick {
	if m != nil {
		return m.Pick
	}
	return nil
}

func (m *Bar) GetA() bool {
	if x, ok := m.GetPick().(*Bar_A); ok {
		return x.A
	}
	return false
}

func (m *Bar) GetB() bool {
	if x, ok := m.GetPick().(*Bar_B); ok {
		return x.B
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Bar) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), []interface{}) {
	return _Bar_OneofMarshaler, _Bar_OneofUnmarshaler, []interface{}{
		(*Bar_A)(nil),
		(*Bar_B)(nil),
	}
}

func _Bar_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Bar)
	// pick
	switch x := m.Pick.(type) {
	case *Bar_A:
		t := uint64(0)
		if x.A {
			t = 1
		}
		_ = b.EncodeVarint(11<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(t)
	case *Bar_B:
		t := uint64(0)
		if x.B {
			t = 1
		}
		_ = b.EncodeVarint(12<<3 | proto1.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("Bar.Pick has unexpected type %T", x)
	}
	return nil
}

func _Bar_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Bar)
	switch tag {
	case 11: // pick.a
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Pick = &Bar_A{x != 0}
		return true, err
	case 12: // pick.b
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Pick = &Bar_B{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func init() {
	proto1.RegisterType((*Foo)(nil), "proto.Foo")
	proto1.RegisterType((*Bar)(nil), "proto.Bar")
}
func (this *Foo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Foo)
	if !ok {
		that2, ok := that.(Foo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Bar.Equal(that1.Bar) {
		return false
	}
	return true
}
func (this *Bar) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Bar)
	if !ok {
		that2, ok := that.(Bar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Pick == nil {
		if this.Pick != nil {
			return false
		}
	} else if this.Pick == nil {
		return false
	} else if !this.Pick.Equal(that1.Pick) {
		return false
	}
	return true
}
func (this *Bar_A) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Bar_A)
	if !ok {
		that2, ok := that.(Bar_A)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.A != that1.A {
		return false
	}
	return true
}
func (this *Bar_B) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Bar_B)
	if !ok {
		that2, ok := that.(Bar_B)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.B != that1.B {
		return false
	}
	return true
}
func NewPopulatedFoo(r randyOneofembed, easy bool) *Foo {
	this := &Foo{}
	if r.Intn(10) != 0 {
		this.Bar = NewPopulatedBar(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBar(r randyOneofembed, easy bool) *Bar {
	this := &Bar{}
	oneofNumber_Pick := []int32{11, 12}[r.Intn(2)]
	switch oneofNumber_Pick {
	case 11:
		this.Pick = NewPopulatedBar_A(r, easy)
	case 12:
		this.Pick = NewPopulatedBar_B(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBar_A(r randyOneofembed, easy bool) *Bar_A {
	this := &Bar_A{}
	this.A = bool(bool(r.Intn(2) == 0))
	return this
}
func NewPopulatedBar_B(r randyOneofembed, easy bool) *Bar_B {
	this := &Bar_B{}
	this.B = bool(bool(r.Intn(2) == 0))
	return this
}

type randyOneofembed interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneOneofembed(r randyOneofembed) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringOneofembed(r randyOneofembed) string {
	v1 := r.Intn(100)
	tmps := make([]rune, v1)
	for i := 0; i < v1; i++ {
		tmps[i] = randUTF8RuneOneofembed(r)
	}
	return string(tmps)
}
func randUnrecognizedOneofembed(r randyOneofembed, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldOneofembed(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldOneofembed(data []byte, r randyOneofembed, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateOneofembed(data, uint64(key))
		v2 := r.Int63()
		if r.Intn(2) == 0 {
			v2 *= -1
		}
		data = encodeVarintPopulateOneofembed(data, uint64(v2))
	case 1:
		data = encodeVarintPopulateOneofembed(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateOneofembed(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateOneofembed(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateOneofembed(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateOneofembed(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
