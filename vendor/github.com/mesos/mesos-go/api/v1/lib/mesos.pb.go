// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mesos.proto

/*
	Package mesos is a generated protocol buffer package.

	It is generated from these files:
		mesos.proto

	It has these top-level messages:
		FrameworkID
		OfferID
		AgentID
		TaskID
		ExecutorID
		ContainerID
		ResourceProviderID
		OperationID
		TimeInfo
		DurationInfo
		Address
		URL
		Unavailability
		MachineID
		MachineInfo
		FrameworkInfo
		CheckInfo
		HealthCheck
		KillPolicy
		CommandInfo
		ExecutorInfo
		DomainInfo
		MasterInfo
		AgentInfo
		CSIPluginContainerInfo
		CSIPluginInfo
		ResourceProviderInfo
		Value
		Attribute
		Resource
		TrafficControlStatistics
		IpStatistics
		IcmpStatistics
		TcpStatistics
		UdpStatistics
		SNMPStatistics
		DiskStatistics
		ResourceStatistics
		ResourceUsage
		PerfStatistics
		Request
		Offer
		InverseOffer
		TaskInfo
		TaskGroupInfo
		Task
		TaskResourceLimitation
		UUID
		Operation
		OperationStatus
		CheckStatusInfo
		TaskStatus
		Filters
		Environment
		Parameter
		Parameters
		Credential
		Credentials
		Secret
		RateLimit
		RateLimits
		Image
		MountPropagation
		Volume
		NetworkInfo
		CapabilityInfo
		LinuxInfo
		RLimitInfo
		TTYInfo
		ContainerInfo
		ContainerStatus
		CgroupInfo
		Labels
		Label
		Port
		Ports
		DiscoveryInfo
		WeightInfo
		VersionInfo
		Flag
		Role
		Metric
		FileInfo
		Device
		DeviceAccess
		DeviceWhitelist
*/
package mesos

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// *
// Status is used to indicate the state of the scheduler and executor
// driver after function calls.
type Status int32

const (
	DRIVER_NOT_STARTED Status = 1
	DRIVER_RUNNING     Status = 2
	DRIVER_ABORTED     Status = 3
	DRIVER_STOPPED     Status = 4
)

var Status_name = map[int32]string{
	1: "DRIVER_NOT_STARTED",
	2: "DRIVER_RUNNING",
	3: "DRIVER_ABORTED",
	4: "DRIVER_STOPPED",
}
var Status_value = map[string]int32{
	"DRIVER_NOT_STARTED": 1,
	"DRIVER_RUNNING":     2,
	"DRIVER_ABORTED":     3,
	"DRIVER_STOPPED":     4,
}

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}
func (x Status) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Status_name, int32(x))
}
func (x *Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Status_value, data, "Status")
	if err != nil {
		return err
	}
	*x = Status(value)
	return nil
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{0} }

// *
// Describes possible task states. IMPORTANT: Mesos assumes tasks that
// enter terminal states (see below) imply the task is no longer
// running and thus clean up any thing associated with the task
// (ultimately offering any resources being consumed by that task to
// another task).
type TaskState int32

const (
	TASK_STAGING  TaskState = 6
	TASK_STARTING TaskState = 0
	TASK_RUNNING  TaskState = 1
	// NOTE: This should only be sent when the framework has
	// the TASK_KILLING_STATE capability.
	TASK_KILLING TaskState = 8
	// The task finished successfully on its own without external interference.
	TASK_FINISHED TaskState = 2
	TASK_FAILED   TaskState = 3
	TASK_KILLED   TaskState = 4
	TASK_ERROR    TaskState = 7
	// In Mesos 1.3, this will only be sent when the framework does NOT
	// opt-in to the PARTITION_AWARE capability.
	//
	// NOTE: This state is not always terminal. For example, tasks might
	// transition from TASK_LOST to TASK_RUNNING or other states when a
	// partitioned agent reregisters.
	TASK_LOST TaskState = 5
	// The task failed to launch because of a transient error. The
	// task's executor never started running. Unlike TASK_ERROR, the
	// task description is valid -- attempting to launch the task again
	// may be successful.
	TASK_DROPPED TaskState = 9
	// The task was running on an agent that has lost contact with the
	// master, typically due to a network failure or partition. The task
	// may or may not still be running.
	TASK_UNREACHABLE TaskState = 10
	// The task is no longer running. This can occur if the agent has
	// been terminated along with all of its tasks (e.g., the host that
	// was running the agent was rebooted). It might also occur if the
	// task was terminated due to an agent or containerizer error, or if
	// the task was preempted by the QoS controller in an
	// oversubscription scenario.
	TASK_GONE TaskState = 11
	// The task was running on an agent that the master cannot contact;
	// the operator has asserted that the agent has been shutdown, but
	// this has not been directly confirmed by the master. If the
	// operator is correct, the task is not running and this is a
	// terminal state; if the operator is mistaken, the task may still
	// be running and might return to RUNNING in the future.
	TASK_GONE_BY_OPERATOR TaskState = 12
	// The master has no knowledge of the task. This is typically
	// because either (a) the master never had knowledge of the task, or
	// (b) the master forgot about the task because it garbage collected
	// its metadata about the task. The task may or may not still be
	// running.
	TASK_UNKNOWN TaskState = 13
)

var TaskState_name = map[int32]string{
	6:  "TASK_STAGING",
	0:  "TASK_STARTING",
	1:  "TASK_RUNNING",
	8:  "TASK_KILLING",
	2:  "TASK_FINISHED",
	3:  "TASK_FAILED",
	4:  "TASK_KILLED",
	7:  "TASK_ERROR",
	5:  "TASK_LOST",
	9:  "TASK_DROPPED",
	10: "TASK_UNREACHABLE",
	11: "TASK_GONE",
	12: "TASK_GONE_BY_OPERATOR",
	13: "TASK_UNKNOWN",
}
var TaskState_value = map[string]int32{
	"TASK_STAGING":          6,
	"TASK_STARTING":         0,
	"TASK_RUNNING":          1,
	"TASK_KILLING":          8,
	"TASK_FINISHED":         2,
	"TASK_FAILED":           3,
	"TASK_KILLED":           4,
	"TASK_ERROR":            7,
	"TASK_LOST":             5,
	"TASK_DROPPED":          9,
	"TASK_UNREACHABLE":      10,
	"TASK_GONE":             11,
	"TASK_GONE_BY_OPERATOR": 12,
	"TASK_UNKNOWN":          13,
}

func (x TaskState) Enum() *TaskState {
	p := new(TaskState)
	*p = x
	return p
}
func (x TaskState) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TaskState_name, int32(x))
}
func (x *TaskState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TaskState_value, data, "TaskState")
	if err != nil {
		return err
	}
	*x = TaskState(value)
	return nil
}
func (TaskState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{1} }

// *
// Describes possible operation states.
type OperationState int32

const (
	// Default value if the enum is not set. See MESOS-4997.
	OPERATION_UNSUPPORTED OperationState = 0
	// Initial state.
	OPERATION_PENDING OperationState = 1
	// TERMINAL: The operation was successfully applied.
	OPERATION_FINISHED OperationState = 2
	// TERMINAL: The operation failed to apply.
	OPERATION_FAILED OperationState = 3
	// TERMINAL: The operation description contains an error.
	OPERATION_ERROR OperationState = 4
	// TERMINAL: The operation was dropped due to a transient error.
	OPERATION_DROPPED OperationState = 5
	// The operation affects an agent that has lost contact with the master,
	// typically due to a network failure or partition. The operation may or may
	// not still be pending.
	OPERATION_UNREACHABLE OperationState = 6
	// The operation affected an agent that the master cannot contact;
	// the operator has asserted that the agent has been shutdown, but this has
	// not been directly confirmed by the master.
	//
	// If the operator is correct, the operation is not pending and this is a
	// terminal state; if the operator is mistaken, the operation may still be
	// pending and might return to a different state in the future.
	OPERATION_GONE_BY_OPERATOR OperationState = 7
	// The operation affects an agent that the master recovered from its
	// state, but that agent has not yet re-registered.
	//
	// The operation can transition to `OPERATION_UNREACHABLE` if the
	// corresponding agent is marked as unreachable, and will transition to
	// another status if the agent re-registers.
	OPERATION_RECOVERING OperationState = 8
	// The master has no knowledge of the operation. This is typically
	// because either (a) the master never had knowledge of the operation, or
	// (b) the master forgot about the operation because it garbage collected
	// its metadata about the operation. The operation may or may not still be
	// pending.
	OPERATION_UNKNOWN OperationState = 9
)

var OperationState_name = map[int32]string{
	0: "OPERATION_UNSUPPORTED",
	1: "OPERATION_PENDING",
	2: "OPERATION_FINISHED",
	3: "OPERATION_FAILED",
	4: "OPERATION_ERROR",
	5: "OPERATION_DROPPED",
	6: "OPERATION_UNREACHABLE",
	7: "OPERATION_GONE_BY_OPERATOR",
	8: "OPERATION_RECOVERING",
	9: "OPERATION_UNKNOWN",
}
var OperationState_value = map[string]int32{
	"OPERATION_UNSUPPORTED":      0,
	"OPERATION_PENDING":          1,
	"OPERATION_FINISHED":         2,
	"OPERATION_FAILED":           3,
	"OPERATION_ERROR":            4,
	"OPERATION_DROPPED":          5,
	"OPERATION_UNREACHABLE":      6,
	"OPERATION_GONE_BY_OPERATOR": 7,
	"OPERATION_RECOVERING":       8,
	"OPERATION_UNKNOWN":          9,
}

func (x OperationState) Enum() *OperationState {
	p := new(OperationState)
	*p = x
	return p
}
func (x OperationState) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(OperationState_name, int32(x))
}
func (x *OperationState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OperationState_value, data, "OperationState")
	if err != nil {
		return err
	}
	*x = OperationState(value)
	return nil
}
func (OperationState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{2} }

// Describes the several states that a machine can be in.  A `Mode`
// applies to a machine and to all associated agents on the machine.
type MachineInfo_Mode int32

const (
	// In this mode, a machine is behaving normally;
	// offering resources, executing tasks, etc.
	UP MachineInfo_Mode = 1
	// In this mode, all agents on the machine are expected to cooperate with
	// frameworks to drain resources.  In general, draining is done ahead of
	// a pending `unavailability`.  The resources should be drained so as to
	// maximize utilization prior to the maintenance but without knowingly
	// violating the frameworks' requirements.
	DRAINING MachineInfo_Mode = 2
	// In this mode, a machine is not running any tasks and will not offer
	// any of its resources.  Agents on the machine will not be allowed to
	// register with the master.
	DOWN MachineInfo_Mode = 3
)

var MachineInfo_Mode_name = map[int32]string{
	1: "UP",
	2: "DRAINING",
	3: "DOWN",
}
var MachineInfo_Mode_value = map[string]int32{
	"UP":       1,
	"DRAINING": 2,
	"DOWN":     3,
}

func (x MachineInfo_Mode) Enum() *MachineInfo_Mode {
	p := new(MachineInfo_Mode)
	*p = x
	return p
}
func (x MachineInfo_Mode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MachineInfo_Mode_name, int32(x))
}
func (x *MachineInfo_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MachineInfo_Mode_value, data, "MachineInfo_Mode")
	if err != nil {
		return err
	}
	*x = MachineInfo_Mode(value)
	return nil
}
func (MachineInfo_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{14, 0} }

type FrameworkInfo_Capability_Type int32

const (
	// This must be the first enum value in this list, to
	// ensure that if 'type' is not set, the default value
	// is UNKNOWN. This enables enum values to be added
	// in a backwards-compatible way. See: MESOS-4997.
	FrameworkInfo_Capability_UNKNOWN FrameworkInfo_Capability_Type = 0
	// Receive offers with revocable resources. See 'Resource'
	// message for details.
	FrameworkInfo_Capability_REVOCABLE_RESOURCES FrameworkInfo_Capability_Type = 1
	// Receive the TASK_KILLING TaskState when a task is being
	// killed by an executor. The executor will examine this
	// capability to determine whether it can send TASK_KILLING.
	FrameworkInfo_Capability_TASK_KILLING_STATE FrameworkInfo_Capability_Type = 2
	// Indicates whether the framework is aware of GPU resources.
	// Frameworks that are aware of GPU resources are expected to
	// avoid placing non-GPU workloads on GPU agents, in order
	// to avoid occupying a GPU agent and preventing GPU workloads
	// from running! Currently, if a framework is unaware of GPU
	// resources, it will not be offered *any* of the resources on
	// an agent with GPUs. This restriction is in place because we
	// do not have a revocation mechanism that ensures GPU workloads
	// can evict GPU agent occupants if necessary.
	//
	// TODO(bmahler): As we add revocation we can relax the
	// restriction here. See MESOS-5634 for more information.
	FrameworkInfo_Capability_GPU_RESOURCES FrameworkInfo_Capability_Type = 3
	// Receive offers with resources that are shared.
	FrameworkInfo_Capability_SHARED_RESOURCES FrameworkInfo_Capability_Type = 4
	// Indicates that (1) the framework is prepared to handle the
	// following TaskStates: TASK_UNREACHABLE, TASK_DROPPED,
	// TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN, and (2)
	// the framework will assume responsibility for managing
	// partitioned tasks that reregister with the master.
	//
	// Frameworks that enable this capability can define how they
	// would like to handle partitioned tasks. Frameworks will
	// receive TASK_UNREACHABLE for tasks on agents that are
	// partitioned from the master.
	//
	// Without this capability, frameworks will receive TASK_LOST
	// for tasks on partitioned agents.
	// NOTE: Prior to Mesos 1.5, such tasks will be killed by Mesos
	// when the agent reregisters (unless the master has failed over).
	// However due to the lack of benefit in maintaining different
	// behaviors depending on whether the master has failed over
	// (see MESOS-7215), as of 1.5, Mesos will not kill these
	// tasks in either case.
	FrameworkInfo_Capability_PARTITION_AWARE FrameworkInfo_Capability_Type = 5
	// This expresses the ability for the framework to be
	// "multi-tenant" via using the newly introduced `roles`
	// field, and examining `Offer.allocation_info` to determine
	// which role the offers are being made to. We also
	// expect that "single-tenant" schedulers eventually
	// provide this and move away from the deprecated
	// `role` field.
	FrameworkInfo_Capability_MULTI_ROLE FrameworkInfo_Capability_Type = 6
	// This capability has two effects for a framework.
	//
	// (1) The framework is offered resources in a new format.
	//
	//     The offered resources have the `Resource.reservations` field set
	//     rather than `Resource.role` and `Resource.reservation`. In short,
	//     an empty `reservations` field denotes unreserved resources, and
	//     each `ReservationInfo` in the `reservations` field denotes a
	//     reservation that refines the previous one.
	//
	//     See the 'Resource Format' section for more details.
	//
	// (2) The framework can create refined reservations.
	//
	//     A framework can refine an existing reservation via the
	//     `Resource.reservations` field. For example, a reservation for role
	//     `eng` can be refined to `eng/front_end`.
	//
	//     See `ReservationInfo.reservations` for more details.
	//
	// NOTE: Without this capability, a framework is not offered resources
	// that have refined reservations. A resource is said to have refined
	// reservations if it uses the `Resource.reservations` field, and
	// `Resource.reservations_size() > 1`.
	FrameworkInfo_Capability_RESERVATION_REFINEMENT FrameworkInfo_Capability_Type = 7
	// Indicates that the framework is prepared to receive offers
	// for agents whose region is different from the master's
	// region. Network links between hosts in different regions
	// typically have higher latency and lower bandwidth than
	// network links within a region, so frameworks should be
	// careful to only place suitable workloads in remote regions.
	// Frameworks that are not region-aware will never receive
	// offers for remote agents; region-aware frameworks are assumed
	// to implement their own logic to decide which workloads (if
	// any) are suitable for placement on remote agents.
	FrameworkInfo_Capability_REGION_AWARE FrameworkInfo_Capability_Type = 8
)

var FrameworkInfo_Capability_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "REVOCABLE_RESOURCES",
	2: "TASK_KILLING_STATE",
	3: "GPU_RESOURCES",
	4: "SHARED_RESOURCES",
	5: "PARTITION_AWARE",
	6: "MULTI_ROLE",
	7: "RESERVATION_REFINEMENT",
	8: "REGION_AWARE",
}
var FrameworkInfo_Capability_Type_value = map[string]int32{
	"UNKNOWN":                0,
	"REVOCABLE_RESOURCES":    1,
	"TASK_KILLING_STATE":     2,
	"GPU_RESOURCES":          3,
	"SHARED_RESOURCES":       4,
	"PARTITION_AWARE":        5,
	"MULTI_ROLE":             6,
	"RESERVATION_REFINEMENT": 7,
	"REGION_AWARE":           8,
}

func (x FrameworkInfo_Capability_Type) Enum() *FrameworkInfo_Capability_Type {
	p := new(FrameworkInfo_Capability_Type)
	*p = x
	return p
}
func (x FrameworkInfo_Capability_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(FrameworkInfo_Capability_Type_name, int32(x))
}
func (x *FrameworkInfo_Capability_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FrameworkInfo_Capability_Type_value, data, "FrameworkInfo_Capability_Type")
	if err != nil {
		return err
	}
	*x = FrameworkInfo_Capability_Type(value)
	return nil
}
func (FrameworkInfo_Capability_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{15, 0, 0}
}

type CheckInfo_Type int32

const (
	CheckInfo_UNKNOWN CheckInfo_Type = 0
	CheckInfo_COMMAND CheckInfo_Type = 1
	CheckInfo_HTTP    CheckInfo_Type = 2
	CheckInfo_TCP     CheckInfo_Type = 3
)

var CheckInfo_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "COMMAND",
	2: "HTTP",
	3: "TCP",
}
var CheckInfo_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"COMMAND": 1,
	"HTTP":    2,
	"TCP":     3,
}

func (x CheckInfo_Type) Enum() *CheckInfo_Type {
	p := new(CheckInfo_Type)
	*p = x
	return p
}
func (x CheckInfo_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(CheckInfo_Type_name, int32(x))
}
func (x *CheckInfo_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CheckInfo_Type_value, data, "CheckInfo_Type")
	if err != nil {
		return err
	}
	*x = CheckInfo_Type(value)
	return nil
}
func (CheckInfo_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{16, 0} }

type HealthCheck_Type int32

const (
	HealthCheck_UNKNOWN HealthCheck_Type = 0
	HealthCheck_COMMAND HealthCheck_Type = 1
	HealthCheck_HTTP    HealthCheck_Type = 2
	HealthCheck_TCP     HealthCheck_Type = 3
)

var HealthCheck_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "COMMAND",
	2: "HTTP",
	3: "TCP",
}
var HealthCheck_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"COMMAND": 1,
	"HTTP":    2,
	"TCP":     3,
}

func (x HealthCheck_Type) Enum() *HealthCheck_Type {
	p := new(HealthCheck_Type)
	*p = x
	return p
}
func (x HealthCheck_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(HealthCheck_Type_name, int32(x))
}
func (x *HealthCheck_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HealthCheck_Type_value, data, "HealthCheck_Type")
	if err != nil {
		return err
	}
	*x = HealthCheck_Type(value)
	return nil
}
func (HealthCheck_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{17, 0} }

type ExecutorInfo_Type int32

const (
	ExecutorInfo_UNKNOWN ExecutorInfo_Type = 0
	// Mesos provides a simple built-in default executor that frameworks can
	// leverage to run shell commands and containers.
	//
	// NOTES:
	//
	// 1) `command` must not be set when using a default executor.
	//
	// 2) Default executor only accepts a *single* `LAUNCH` or `LAUNCH_GROUP`
	//    operation.
	//
	// 3) If `container` is set, `container.type` must be `MESOS`
	//    and `container.mesos.image` must not be set.
	ExecutorInfo_DEFAULT ExecutorInfo_Type = 1
	// For frameworks that need custom functionality to run tasks, a `CUSTOM`
	// executor can be used. Note that `command` must be set when using a
	// `CUSTOM` executor.
	ExecutorInfo_CUSTOM ExecutorInfo_Type = 2
)

var ExecutorInfo_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "DEFAULT",
	2: "CUSTOM",
}
var ExecutorInfo_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"DEFAULT": 1,
	"CUSTOM":  2,
}

func (x ExecutorInfo_Type) Enum() *ExecutorInfo_Type {
	p := new(ExecutorInfo_Type)
	*p = x
	return p
}
func (x ExecutorInfo_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ExecutorInfo_Type_name, int32(x))
}
func (x *ExecutorInfo_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExecutorInfo_Type_value, data, "ExecutorInfo_Type")
	if err != nil {
		return err
	}
	*x = ExecutorInfo_Type(value)
	return nil
}
func (ExecutorInfo_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{20, 0} }

type MasterInfo_Capability_Type int32

const (
	MasterInfo_Capability_UNKNOWN MasterInfo_Capability_Type = 0
	// The master can handle slaves whose state
	// changes after reregistering.
	MasterInfo_Capability_AGENT_UPDATE MasterInfo_Capability_Type = 1
)

var MasterInfo_Capability_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "AGENT_UPDATE",
}
var MasterInfo_Capability_Type_value = map[string]int32{
	"UNKNOWN":      0,
	"AGENT_UPDATE": 1,
}

func (x MasterInfo_Capability_Type) Enum() *MasterInfo_Capability_Type {
	p := new(MasterInfo_Capability_Type)
	*p = x
	return p
}
func (x MasterInfo_Capability_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MasterInfo_Capability_Type_name, int32(x))
}
func (x *MasterInfo_Capability_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MasterInfo_Capability_Type_value, data, "MasterInfo_Capability_Type")
	if err != nil {
		return err
	}
	*x = MasterInfo_Capability_Type(value)
	return nil
}
func (MasterInfo_Capability_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{22, 0, 0}
}

type AgentInfo_Capability_Type int32

const (
	// This must be the first enum value in this list, to
	// ensure that if 'type' is not set, the default value
	// is UNKNOWN. This enables enum values to be added
	// in a backwards-compatible way. See: MESOS-4997.
	AgentInfo_Capability_UNKNOWN AgentInfo_Capability_Type = 0
	// This expresses the ability for the agent to be able
	// to launch tasks of a 'multi-role' framework.
	AgentInfo_Capability_MULTI_ROLE AgentInfo_Capability_Type = 1
	// This expresses the ability for the agent to be able to launch
	// tasks, reserve resources, and create volumes using resources
	// allocated to a 'hierarchical-role'.
	// NOTE: This capability is required specifically for creating
	// volumes because a hierchical role includes '/' (slashes) in them.
	// Agents with this capability know to transform the '/' (slashes)
	// into ' ' (spaces).
	AgentInfo_Capability_HIERARCHICAL_ROLE AgentInfo_Capability_Type = 2
	// This capability has three effects for an agent.
	//
	// (1) The format of the checkpointed resources, and
	//     the resources reported to master.
	//
	//     These resources are reported in the "pre-reservation-refinement"
	//     format if none of the resources have refined reservations. If any
	//     of the resources have refined reservations, they are reported in
	//     the "post-reservation-refinement" format. The purpose is to allow
	//     downgrading of an agent as well as communication with a pre-1.4.0
	//     master until the reservation refinement feature is actually used.
	//
	//     See the 'Resource Format' section for more details.
	//
	// (2) The format of the resources reported by the HTTP endpoints.
	//
	//     For resources reported by agent endpoints, the
	//     "pre-reservation-refinement" format is "injected" if possible.
	//     That is, resources without refined reservations will have the
	//     `Resource.role` and `Resource.reservation` set, whereas
	//     resources with refined reservations will not.
	//
	//     See the 'Resource Format' section for more details.
	//
	// (3) The ability for the agent to launch tasks, reserve resources, and
	//     create volumes using resources that have refined reservations.
	//
	//     See `ReservationInfo.reservations` section for more details.
	//
	// NOTE: Resources are said to have refined reservations if it uses the
	// `Resource.reservations` field, and `Resource.reservations_size() > 1`.
	AgentInfo_Capability_RESERVATION_REFINEMENT AgentInfo_Capability_Type = 3
	// This expresses the ability for the agent to handle resource
	// provider related operations. This includes the following:
	//
	// (1) The ability to report resources that are provided by some
	//     local resource providers through the resource provider API.
	//
	// (2) The ability to provide operation feedback.
	AgentInfo_Capability_RESOURCE_PROVIDER AgentInfo_Capability_Type = 4
	// This expresses the capability for the agent to handle persistent volume
	// resize operations safely. This capability is turned on by default.
	AgentInfo_Capability_RESIZE_VOLUME AgentInfo_Capability_Type = 5
)

var AgentInfo_Capability_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "MULTI_ROLE",
	2: "HIERARCHICAL_ROLE",
	3: "RESERVATION_REFINEMENT",
	4: "RESOURCE_PROVIDER",
	5: "RESIZE_VOLUME",
}
var AgentInfo_Capability_Type_value = map[string]int32{
	"UNKNOWN":                0,
	"MULTI_ROLE":             1,
	"HIERARCHICAL_ROLE":      2,
	"RESERVATION_REFINEMENT": 3,
	"RESOURCE_PROVIDER":      4,
	"RESIZE_VOLUME":          5,
}

func (x AgentInfo_Capability_Type) Enum() *AgentInfo_Capability_Type {
	p := new(AgentInfo_Capability_Type)
	*p = x
	return p
}
func (x AgentInfo_Capability_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(AgentInfo_Capability_Type_name, int32(x))
}
func (x *AgentInfo_Capability_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AgentInfo_Capability_Type_value, data, "AgentInfo_Capability_Type")
	if err != nil {
		return err
	}
	*x = AgentInfo_Capability_Type(value)
	return nil
}
func (AgentInfo_Capability_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{23, 0, 0}
}

type CSIPluginContainerInfo_Service int32

const (
	CSIPluginContainerInfo_UNKNOWN            CSIPluginContainerInfo_Service = 0
	CSIPluginContainerInfo_CONTROLLER_SERVICE CSIPluginContainerInfo_Service = 1
	CSIPluginContainerInfo_NODE_SERVICE       CSIPluginContainerInfo_Service = 2
)

var CSIPluginContainerInfo_Service_name = map[int32]string{
	0: "UNKNOWN",
	1: "CONTROLLER_SERVICE",
	2: "NODE_SERVICE",
}
var CSIPluginContainerInfo_Service_value = map[string]int32{
	"UNKNOWN":            0,
	"CONTROLLER_SERVICE": 1,
	"NODE_SERVICE":       2,
}

func (x CSIPluginContainerInfo_Service) Enum() *CSIPluginContainerInfo_Service {
	p := new(CSIPluginContainerInfo_Service)
	*p = x
	return p
}
func (x CSIPluginContainerInfo_Service) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(CSIPluginContainerInfo_Service_name, int32(x))
}
func (x *CSIPluginContainerInfo_Service) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CSIPluginContainerInfo_Service_value, data, "CSIPluginContainerInfo_Service")
	if err != nil {
		return err
	}
	*x = CSIPluginContainerInfo_Service(value)
	return nil
}
func (CSIPluginContainerInfo_Service) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{24, 0}
}

type Value_Type int32

const (
	SCALAR Value_Type = 0
	RANGES Value_Type = 1
	SET    Value_Type = 2
	TEXT   Value_Type = 3
)

var Value_Type_name = map[int32]string{
	0: "SCALAR",
	1: "RANGES",
	2: "SET",
	3: "TEXT",
}
var Value_Type_value = map[string]int32{
	"SCALAR": 0,
	"RANGES": 1,
	"SET":    2,
	"TEXT":   3,
}

func (x Value_Type) Enum() *Value_Type {
	p := new(Value_Type)
	*p = x
	return p
}
func (x Value_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Value_Type_name, int32(x))
}
func (x *Value_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Value_Type_value, data, "Value_Type")
	if err != nil {
		return err
	}
	*x = Value_Type(value)
	return nil
}
func (Value_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{27, 0} }

type Resource_ReservationInfo_Type int32

const (
	Resource_ReservationInfo_UNKNOWN Resource_ReservationInfo_Type = 0
	Resource_ReservationInfo_STATIC  Resource_ReservationInfo_Type = 1
	Resource_ReservationInfo_DYNAMIC Resource_ReservationInfo_Type = 2
)

var Resource_ReservationInfo_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "STATIC",
	2: "DYNAMIC",
}
var Resource_ReservationInfo_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"STATIC":  1,
	"DYNAMIC": 2,
}

func (x Resource_ReservationInfo_Type) Enum() *Resource_ReservationInfo_Type {
	p := new(Resource_ReservationInfo_Type)
	*p = x
	return p
}
func (x Resource_ReservationInfo_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Resource_ReservationInfo_Type_name, int32(x))
}
func (x *Resource_ReservationInfo_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Resource_ReservationInfo_Type_value, data, "Resource_ReservationInfo_Type")
	if err != nil {
		return err
	}
	*x = Resource_ReservationInfo_Type(value)
	return nil
}
func (Resource_ReservationInfo_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{29, 1, 0}
}

type Resource_DiskInfo_Source_Type int32

const (
	Resource_DiskInfo_Source_UNKNOWN Resource_DiskInfo_Source_Type = 0
	Resource_DiskInfo_Source_PATH    Resource_DiskInfo_Source_Type = 1
	Resource_DiskInfo_Source_MOUNT   Resource_DiskInfo_Source_Type = 2
	Resource_DiskInfo_Source_BLOCK   Resource_DiskInfo_Source_Type = 3
	Resource_DiskInfo_Source_RAW     Resource_DiskInfo_Source_Type = 4
)

var Resource_DiskInfo_Source_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "PATH",
	2: "MOUNT",
	3: "BLOCK",
	4: "RAW",
}
var Resource_DiskInfo_Source_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"PATH":    1,
	"MOUNT":   2,
	"BLOCK":   3,
	"RAW":     4,
}

func (x Resource_DiskInfo_Source_Type) Enum() *Resource_DiskInfo_Source_Type {
	p := new(Resource_DiskInfo_Source_Type)
	*p = x
	return p
}
func (x Resource_DiskInfo_Source_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Resource_DiskInfo_Source_Type_name, int32(x))
}
func (x *Resource_DiskInfo_Source_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Resource_DiskInfo_Source_Type_value, data, "Resource_DiskInfo_Source_Type")
	if err != nil {
		return err
	}
	*x = Resource_DiskInfo_Source_Type(value)
	return nil
}
func (Resource_DiskInfo_Source_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{29, 2, 1, 0}
}

type Offer_Operation_Type int32

const (
	Offer_Operation_UNKNOWN       Offer_Operation_Type = 0
	Offer_Operation_LAUNCH        Offer_Operation_Type = 1
	Offer_Operation_LAUNCH_GROUP  Offer_Operation_Type = 6
	Offer_Operation_RESERVE       Offer_Operation_Type = 2
	Offer_Operation_UNRESERVE     Offer_Operation_Type = 3
	Offer_Operation_CREATE        Offer_Operation_Type = 4
	Offer_Operation_DESTROY       Offer_Operation_Type = 5
	Offer_Operation_GROW_VOLUME   Offer_Operation_Type = 11
	Offer_Operation_SHRINK_VOLUME Offer_Operation_Type = 12
	Offer_Operation_CREATE_DISK   Offer_Operation_Type = 13
	Offer_Operation_DESTROY_DISK  Offer_Operation_Type = 14
)

var Offer_Operation_Type_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "LAUNCH",
	6:  "LAUNCH_GROUP",
	2:  "RESERVE",
	3:  "UNRESERVE",
	4:  "CREATE",
	5:  "DESTROY",
	11: "GROW_VOLUME",
	12: "SHRINK_VOLUME",
	13: "CREATE_DISK",
	14: "DESTROY_DISK",
}
var Offer_Operation_Type_value = map[string]int32{
	"UNKNOWN":       0,
	"LAUNCH":        1,
	"LAUNCH_GROUP":  6,
	"RESERVE":       2,
	"UNRESERVE":     3,
	"CREATE":        4,
	"DESTROY":       5,
	"GROW_VOLUME":   11,
	"SHRINK_VOLUME": 12,
	"CREATE_DISK":   13,
	"DESTROY_DISK":  14,
}

func (x Offer_Operation_Type) Enum() *Offer_Operation_Type {
	p := new(Offer_Operation_Type)
	*p = x
	return p
}
func (x Offer_Operation_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Offer_Operation_Type_name, int32(x))
}
func (x *Offer_Operation_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Offer_Operation_Type_value, data, "Offer_Operation_Type")
	if err != nil {
		return err
	}
	*x = Offer_Operation_Type(value)
	return nil
}
func (Offer_Operation_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 0}
}

// Describes the source of the task status update.
type TaskStatus_Source int32

const (
	SOURCE_MASTER   TaskStatus_Source = 0
	SOURCE_AGENT    TaskStatus_Source = 1
	SOURCE_EXECUTOR TaskStatus_Source = 2
)

var TaskStatus_Source_name = map[int32]string{
	0: "SOURCE_MASTER",
	1: "SOURCE_AGENT",
	2: "SOURCE_EXECUTOR",
}
var TaskStatus_Source_value = map[string]int32{
	"SOURCE_MASTER":   0,
	"SOURCE_AGENT":    1,
	"SOURCE_EXECUTOR": 2,
}

func (x TaskStatus_Source) Enum() *TaskStatus_Source {
	p := new(TaskStatus_Source)
	*p = x
	return p
}
func (x TaskStatus_Source) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TaskStatus_Source_name, int32(x))
}
func (x *TaskStatus_Source) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TaskStatus_Source_value, data, "TaskStatus_Source")
	if err != nil {
		return err
	}
	*x = TaskStatus_Source(value)
	return nil
}
func (TaskStatus_Source) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{51, 0} }

// Detailed reason for the task status update.
// Refer to docs/task-state-reasons.md for additional explanation.
type TaskStatus_Reason int32

const (
	// TODO(jieyu): The default value when a caller doesn't check for
	// presence is 0 and so ideally the 0 reason is not a valid one.
	// Since this is not used anywhere, consider removing this reason.
	REASON_COMMAND_EXECUTOR_FAILED          TaskStatus_Reason = 0
	REASON_CONTAINER_LAUNCH_FAILED          TaskStatus_Reason = 21
	REASON_CONTAINER_LIMITATION             TaskStatus_Reason = 19
	REASON_CONTAINER_LIMITATION_DISK        TaskStatus_Reason = 20
	REASON_CONTAINER_LIMITATION_MEMORY      TaskStatus_Reason = 8
	REASON_CONTAINER_PREEMPTED              TaskStatus_Reason = 17
	REASON_CONTAINER_UPDATE_FAILED          TaskStatus_Reason = 22
	REASON_MAX_COMPLETION_TIME_REACHED      TaskStatus_Reason = 33
	REASON_EXECUTOR_REGISTRATION_TIMEOUT    TaskStatus_Reason = 23
	REASON_EXECUTOR_REREGISTRATION_TIMEOUT  TaskStatus_Reason = 24
	REASON_EXECUTOR_TERMINATED              TaskStatus_Reason = 1
	REASON_EXECUTOR_UNREGISTERED            TaskStatus_Reason = 2
	REASON_FRAMEWORK_REMOVED                TaskStatus_Reason = 3
	REASON_GC_ERROR                         TaskStatus_Reason = 4
	REASON_INVALID_FRAMEWORKID              TaskStatus_Reason = 5
	REASON_INVALID_OFFERS                   TaskStatus_Reason = 6
	REASON_IO_SWITCHBOARD_EXITED            TaskStatus_Reason = 27
	REASON_MASTER_DISCONNECTED              TaskStatus_Reason = 7
	REASON_RECONCILIATION                   TaskStatus_Reason = 9
	REASON_RESOURCES_UNKNOWN                TaskStatus_Reason = 18
	REASON_AGENT_DISCONNECTED               TaskStatus_Reason = 10
	REASON_AGENT_REMOVED                    TaskStatus_Reason = 11
	REASON_AGENT_REMOVED_BY_OPERATOR        TaskStatus_Reason = 31
	REASON_AGENT_REREGISTERED               TaskStatus_Reason = 32
	REASON_AGENT_RESTARTED                  TaskStatus_Reason = 12
	REASON_AGENT_UNKNOWN                    TaskStatus_Reason = 13
	REASON_TASK_KILLED_DURING_LAUNCH        TaskStatus_Reason = 30
	REASON_TASK_CHECK_STATUS_UPDATED        TaskStatus_Reason = 28
	REASON_TASK_HEALTH_CHECK_STATUS_UPDATED TaskStatus_Reason = 29
	REASON_TASK_GROUP_INVALID               TaskStatus_Reason = 25
	REASON_TASK_GROUP_UNAUTHORIZED          TaskStatus_Reason = 26
	REASON_TASK_INVALID                     TaskStatus_Reason = 14
	REASON_TASK_UNAUTHORIZED                TaskStatus_Reason = 15
	REASON_TASK_UNKNOWN                     TaskStatus_Reason = 16
)

var TaskStatus_Reason_name = map[int32]string{
	0:  "REASON_COMMAND_EXECUTOR_FAILED",
	21: "REASON_CONTAINER_LAUNCH_FAILED",
	19: "REASON_CONTAINER_LIMITATION",
	20: "REASON_CONTAINER_LIMITATION_DISK",
	8:  "REASON_CONTAINER_LIMITATION_MEMORY",
	17: "REASON_CONTAINER_PREEMPTED",
	22: "REASON_CONTAINER_UPDATE_FAILED",
	33: "REASON_MAX_COMPLETION_TIME_REACHED",
	23: "REASON_EXECUTOR_REGISTRATION_TIMEOUT",
	24: "REASON_EXECUTOR_REREGISTRATION_TIMEOUT",
	1:  "REASON_EXECUTOR_TERMINATED",
	2:  "REASON_EXECUTOR_UNREGISTERED",
	3:  "REASON_FRAMEWORK_REMOVED",
	4:  "REASON_GC_ERROR",
	5:  "REASON_INVALID_FRAMEWORKID",
	6:  "REASON_INVALID_OFFERS",
	27: "REASON_IO_SWITCHBOARD_EXITED",
	7:  "REASON_MASTER_DISCONNECTED",
	9:  "REASON_RECONCILIATION",
	18: "REASON_RESOURCES_UNKNOWN",
	10: "REASON_AGENT_DISCONNECTED",
	11: "REASON_AGENT_REMOVED",
	31: "REASON_AGENT_REMOVED_BY_OPERATOR",
	32: "REASON_AGENT_REREGISTERED",
	12: "REASON_AGENT_RESTARTED",
	13: "REASON_AGENT_UNKNOWN",
	30: "REASON_TASK_KILLED_DURING_LAUNCH",
	28: "REASON_TASK_CHECK_STATUS_UPDATED",
	29: "REASON_TASK_HEALTH_CHECK_STATUS_UPDATED",
	25: "REASON_TASK_GROUP_INVALID",
	26: "REASON_TASK_GROUP_UNAUTHORIZED",
	14: "REASON_TASK_INVALID",
	15: "REASON_TASK_UNAUTHORIZED",
	16: "REASON_TASK_UNKNOWN",
}
var TaskStatus_Reason_value = map[string]int32{
	"REASON_COMMAND_EXECUTOR_FAILED":          0,
	"REASON_CONTAINER_LAUNCH_FAILED":          21,
	"REASON_CONTAINER_LIMITATION":             19,
	"REASON_CONTAINER_LIMITATION_DISK":        20,
	"REASON_CONTAINER_LIMITATION_MEMORY":      8,
	"REASON_CONTAINER_PREEMPTED":              17,
	"REASON_CONTAINER_UPDATE_FAILED":          22,
	"REASON_MAX_COMPLETION_TIME_REACHED":      33,
	"REASON_EXECUTOR_REGISTRATION_TIMEOUT":    23,
	"REASON_EXECUTOR_REREGISTRATION_TIMEOUT":  24,
	"REASON_EXECUTOR_TERMINATED":              1,
	"REASON_EXECUTOR_UNREGISTERED":            2,
	"REASON_FRAMEWORK_REMOVED":                3,
	"REASON_GC_ERROR":                         4,
	"REASON_INVALID_FRAMEWORKID":              5,
	"REASON_INVALID_OFFERS":                   6,
	"REASON_IO_SWITCHBOARD_EXITED":            27,
	"REASON_MASTER_DISCONNECTED":              7,
	"REASON_RECONCILIATION":                   9,
	"REASON_RESOURCES_UNKNOWN":                18,
	"REASON_AGENT_DISCONNECTED":               10,
	"REASON_AGENT_REMOVED":                    11,
	"REASON_AGENT_REMOVED_BY_OPERATOR":        31,
	"REASON_AGENT_REREGISTERED":               32,
	"REASON_AGENT_RESTARTED":                  12,
	"REASON_AGENT_UNKNOWN":                    13,
	"REASON_TASK_KILLED_DURING_LAUNCH":        30,
	"REASON_TASK_CHECK_STATUS_UPDATED":        28,
	"REASON_TASK_HEALTH_CHECK_STATUS_UPDATED": 29,
	"REASON_TASK_GROUP_INVALID":               25,
	"REASON_TASK_GROUP_UNAUTHORIZED":          26,
	"REASON_TASK_INVALID":                     14,
	"REASON_TASK_UNAUTHORIZED":                15,
	"REASON_TASK_UNKNOWN":                     16,
}

func (x TaskStatus_Reason) Enum() *TaskStatus_Reason {
	p := new(TaskStatus_Reason)
	*p = x
	return p
}
func (x TaskStatus_Reason) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(TaskStatus_Reason_name, int32(x))
}
func (x *TaskStatus_Reason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TaskStatus_Reason_value, data, "TaskStatus_Reason")
	if err != nil {
		return err
	}
	*x = TaskStatus_Reason(value)
	return nil
}
func (TaskStatus_Reason) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{51, 1} }

type Environment_Variable_Type int32

const (
	Environment_Variable_UNKNOWN Environment_Variable_Type = 0
	Environment_Variable_VALUE   Environment_Variable_Type = 1
	Environment_Variable_SECRET  Environment_Variable_Type = 2
)

var Environment_Variable_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "VALUE",
	2: "SECRET",
}
var Environment_Variable_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"VALUE":   1,
	"SECRET":  2,
}

func (x Environment_Variable_Type) Enum() *Environment_Variable_Type {
	p := new(Environment_Variable_Type)
	*p = x
	return p
}
func (x Environment_Variable_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Environment_Variable_Type_name, int32(x))
}
func (x *Environment_Variable_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Environment_Variable_Type_value, data, "Environment_Variable_Type")
	if err != nil {
		return err
	}
	*x = Environment_Variable_Type(value)
	return nil
}
func (Environment_Variable_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{53, 0, 0}
}

type Secret_Type int32

const (
	Secret_UNKNOWN   Secret_Type = 0
	Secret_REFERENCE Secret_Type = 1
	Secret_VALUE     Secret_Type = 2
)

var Secret_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "REFERENCE",
	2: "VALUE",
}
var Secret_Type_value = map[string]int32{
	"UNKNOWN":   0,
	"REFERENCE": 1,
	"VALUE":     2,
}

func (x Secret_Type) Enum() *Secret_Type {
	p := new(Secret_Type)
	*p = x
	return p
}
func (x Secret_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Secret_Type_name, int32(x))
}
func (x *Secret_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Secret_Type_value, data, "Secret_Type")
	if err != nil {
		return err
	}
	*x = Secret_Type(value)
	return nil
}
func (Secret_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{58, 0} }

type Image_Type int32

const (
	Image_APPC   Image_Type = 1
	Image_DOCKER Image_Type = 2
)

var Image_Type_name = map[int32]string{
	1: "APPC",
	2: "DOCKER",
}
var Image_Type_value = map[string]int32{
	"APPC":   1,
	"DOCKER": 2,
}

func (x Image_Type) Enum() *Image_Type {
	p := new(Image_Type)
	*p = x
	return p
}
func (x Image_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Image_Type_name, int32(x))
}
func (x *Image_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Image_Type_value, data, "Image_Type")
	if err != nil {
		return err
	}
	*x = Image_Type(value)
	return nil
}
func (Image_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{61, 0} }

type MountPropagation_Mode int32

const (
	MountPropagation_UNKNOWN MountPropagation_Mode = 0
	// The volume in a container will receive new mounts from the host
	// or other containers, but filesystems mounted inside the
	// container won't be propagated to the host or other containers.
	// This is currently the default behavior for all volumes.
	MountPropagation_HOST_TO_CONTAINER MountPropagation_Mode = 1
	// The volume in a container will receive new mounts from the host
	// or other containers, and its own mounts will be propagated from
	// the container to the host or other containers.
	MountPropagation_BIDIRECTIONAL MountPropagation_Mode = 2
)

var MountPropagation_Mode_name = map[int32]string{
	0: "UNKNOWN",
	1: "HOST_TO_CONTAINER",
	2: "BIDIRECTIONAL",
}
var MountPropagation_Mode_value = map[string]int32{
	"UNKNOWN":           0,
	"HOST_TO_CONTAINER": 1,
	"BIDIRECTIONAL":     2,
}

func (x MountPropagation_Mode) Enum() *MountPropagation_Mode {
	p := new(MountPropagation_Mode)
	*p = x
	return p
}
func (x MountPropagation_Mode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(MountPropagation_Mode_name, int32(x))
}
func (x *MountPropagation_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MountPropagation_Mode_value, data, "MountPropagation_Mode")
	if err != nil {
		return err
	}
	*x = MountPropagation_Mode(value)
	return nil
}
func (MountPropagation_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{62, 0}
}

type Volume_Mode int32

const (
	RW Volume_Mode = 1
	RO Volume_Mode = 2
)

var Volume_Mode_name = map[int32]string{
	1: "RW",
	2: "RO",
}
var Volume_Mode_value = map[string]int32{
	"RW": 1,
	"RO": 2,
}

func (x Volume_Mode) Enum() *Volume_Mode {
	p := new(Volume_Mode)
	*p = x
	return p
}
func (x Volume_Mode) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Volume_Mode_name, int32(x))
}
func (x *Volume_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Volume_Mode_value, data, "Volume_Mode")
	if err != nil {
		return err
	}
	*x = Volume_Mode(value)
	return nil
}
func (Volume_Mode) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{63, 0} }

type Volume_Source_Type int32

const (
	// This must be the first enum value in this list, to
	// ensure that if 'type' is not set, the default value
	// is UNKNOWN. This enables enum values to be added
	// in a backwards-compatible way. See: MESOS-4997.
	Volume_Source_UNKNOWN Volume_Source_Type = 0
	// TODO(gyliu513): Add IMAGE as volume source type.
	Volume_Source_DOCKER_VOLUME Volume_Source_Type = 1
	Volume_Source_HOST_PATH     Volume_Source_Type = 4
	Volume_Source_SANDBOX_PATH  Volume_Source_Type = 2
	Volume_Source_SECRET        Volume_Source_Type = 3
)

var Volume_Source_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "DOCKER_VOLUME",
	4: "HOST_PATH",
	2: "SANDBOX_PATH",
	3: "SECRET",
}
var Volume_Source_Type_value = map[string]int32{
	"UNKNOWN":       0,
	"DOCKER_VOLUME": 1,
	"HOST_PATH":     4,
	"SANDBOX_PATH":  2,
	"SECRET":        3,
}

func (x Volume_Source_Type) Enum() *Volume_Source_Type {
	p := new(Volume_Source_Type)
	*p = x
	return p
}
func (x Volume_Source_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Volume_Source_Type_name, int32(x))
}
func (x *Volume_Source_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Volume_Source_Type_value, data, "Volume_Source_Type")
	if err != nil {
		return err
	}
	*x = Volume_Source_Type(value)
	return nil
}
func (Volume_Source_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{63, 0, 0}
}

type Volume_Source_SandboxPath_Type int32

const (
	Volume_Source_SandboxPath_UNKNOWN Volume_Source_SandboxPath_Type = 0
	Volume_Source_SandboxPath_SELF    Volume_Source_SandboxPath_Type = 1
	Volume_Source_SandboxPath_PARENT  Volume_Source_SandboxPath_Type = 2
)

var Volume_Source_SandboxPath_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "SELF",
	2: "PARENT",
}
var Volume_Source_SandboxPath_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"SELF":    1,
	"PARENT":  2,
}

func (x Volume_Source_SandboxPath_Type) Enum() *Volume_Source_SandboxPath_Type {
	p := new(Volume_Source_SandboxPath_Type)
	*p = x
	return p
}
func (x Volume_Source_SandboxPath_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(Volume_Source_SandboxPath_Type_name, int32(x))
}
func (x *Volume_Source_SandboxPath_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Volume_Source_SandboxPath_Type_value, data, "Volume_Source_SandboxPath_Type")
	if err != nil {
		return err
	}
	*x = Volume_Source_SandboxPath_Type(value)
	return nil
}
func (Volume_Source_SandboxPath_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{63, 0, 2, 0}
}

type NetworkInfo_Protocol int32

const (
	IPv4 NetworkInfo_Protocol = 1
	IPv6 NetworkInfo_Protocol = 2
)

var NetworkInfo_Protocol_name = map[int32]string{
	1: "IPv4",
	2: "IPv6",
}
var NetworkInfo_Protocol_value = map[string]int32{
	"IPv4": 1,
	"IPv6": 2,
}

func (x NetworkInfo_Protocol) Enum() *NetworkInfo_Protocol {
	p := new(NetworkInfo_Protocol)
	*p = x
	return p
}
func (x NetworkInfo_Protocol) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(NetworkInfo_Protocol_name, int32(x))
}
func (x *NetworkInfo_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkInfo_Protocol_value, data, "NetworkInfo_Protocol")
	if err != nil {
		return err
	}
	*x = NetworkInfo_Protocol(value)
	return nil
}
func (NetworkInfo_Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{64, 0} }

// We start the actual values at an offset(1000) because Protobuf 2
// uses the first value as the default one. Separating the default
// value from the real first value helps to disambiguate them. This
// is especially valuable for backward compatibility.
// See: MESOS-4997.
type CapabilityInfo_Capability int32

const (
	CapabilityInfo_UNKNOWN          CapabilityInfo_Capability = 0
	CapabilityInfo_CHOWN            CapabilityInfo_Capability = 1000
	CapabilityInfo_DAC_OVERRIDE     CapabilityInfo_Capability = 1001
	CapabilityInfo_DAC_READ_SEARCH  CapabilityInfo_Capability = 1002
	CapabilityInfo_FOWNER           CapabilityInfo_Capability = 1003
	CapabilityInfo_FSETID           CapabilityInfo_Capability = 1004
	CapabilityInfo_KILL             CapabilityInfo_Capability = 1005
	CapabilityInfo_SETGID           CapabilityInfo_Capability = 1006
	CapabilityInfo_SETUID           CapabilityInfo_Capability = 1007
	CapabilityInfo_SETPCAP          CapabilityInfo_Capability = 1008
	CapabilityInfo_LINUX_IMMUTABLE  CapabilityInfo_Capability = 1009
	CapabilityInfo_NET_BIND_SERVICE CapabilityInfo_Capability = 1010
	CapabilityInfo_NET_BROADCAST    CapabilityInfo_Capability = 1011
	CapabilityInfo_NET_ADMIN        CapabilityInfo_Capability = 1012
	CapabilityInfo_NET_RAW          CapabilityInfo_Capability = 1013
	CapabilityInfo_IPC_LOCK         CapabilityInfo_Capability = 1014
	CapabilityInfo_IPC_OWNER        CapabilityInfo_Capability = 1015
	CapabilityInfo_SYS_MODULE       CapabilityInfo_Capability = 1016
	CapabilityInfo_SYS_RAWIO        CapabilityInfo_Capability = 1017
	CapabilityInfo_SYS_CHROOT       CapabilityInfo_Capability = 1018
	CapabilityInfo_SYS_PTRACE       CapabilityInfo_Capability = 1019
	CapabilityInfo_SYS_PACCT        CapabilityInfo_Capability = 1020
	CapabilityInfo_SYS_ADMIN        CapabilityInfo_Capability = 1021
	CapabilityInfo_SYS_BOOT         CapabilityInfo_Capability = 1022
	CapabilityInfo_SYS_NICE         CapabilityInfo_Capability = 1023
	CapabilityInfo_SYS_RESOURCE     CapabilityInfo_Capability = 1024
	CapabilityInfo_SYS_TIME         CapabilityInfo_Capability = 1025
	CapabilityInfo_SYS_TTY_CONFIG   CapabilityInfo_Capability = 1026
	CapabilityInfo_MKNOD            CapabilityInfo_Capability = 1027
	CapabilityInfo_LEASE            CapabilityInfo_Capability = 1028
	CapabilityInfo_AUDIT_WRITE      CapabilityInfo_Capability = 1029
	CapabilityInfo_AUDIT_CONTROL    CapabilityInfo_Capability = 1030
	CapabilityInfo_SETFCAP          CapabilityInfo_Capability = 1031
	CapabilityInfo_MAC_OVERRIDE     CapabilityInfo_Capability = 1032
	CapabilityInfo_MAC_ADMIN        CapabilityInfo_Capability = 1033
	CapabilityInfo_SYSLOG           CapabilityInfo_Capability = 1034
	CapabilityInfo_WAKE_ALARM       CapabilityInfo_Capability = 1035
	CapabilityInfo_BLOCK_SUSPEND    CapabilityInfo_Capability = 1036
	CapabilityInfo_AUDIT_READ       CapabilityInfo_Capability = 1037
)

var CapabilityInfo_Capability_name = map[int32]string{
	0:    "UNKNOWN",
	1000: "CHOWN",
	1001: "DAC_OVERRIDE",
	1002: "DAC_READ_SEARCH",
	1003: "FOWNER",
	1004: "FSETID",
	1005: "KILL",
	1006: "SETGID",
	1007: "SETUID",
	1008: "SETPCAP",
	1009: "LINUX_IMMUTABLE",
	1010: "NET_BIND_SERVICE",
	1011: "NET_BROADCAST",
	1012: "NET_ADMIN",
	1013: "NET_RAW",
	1014: "IPC_LOCK",
	1015: "IPC_OWNER",
	1016: "SYS_MODULE",
	1017: "SYS_RAWIO",
	1018: "SYS_CHROOT",
	1019: "SYS_PTRACE",
	1020: "SYS_PACCT",
	1021: "SYS_ADMIN",
	1022: "SYS_BOOT",
	1023: "SYS_NICE",
	1024: "SYS_RESOURCE",
	1025: "SYS_TIME",
	1026: "SYS_TTY_CONFIG",
	1027: "MKNOD",
	1028: "LEASE",
	1029: "AUDIT_WRITE",
	1030: "AUDIT_CONTROL",
	1031: "SETFCAP",
	1032: "MAC_OVERRIDE",
	1033: "MAC_ADMIN",
	1034: "SYSLOG",
	1035: "WAKE_ALARM",
	1036: "BLOCK_SUSPEND",
	1037: "AUDIT_READ",
}
var CapabilityInfo_Capability_value = map[string]int32{
	"UNKNOWN":          0,
	"CHOWN":            1000,
	"DAC_OVERRIDE":     1001,
	"DAC_READ_SEARCH":  1002,
	"FOWNER":           1003,
	"FSETID":           1004,
	"KILL":             1005,
	"SETGID":           1006,
	"SETUID":           1007,
	"SETPCAP":          1008,
	"LINUX_IMMUTABLE":  1009,
	"NET_BIND_SERVICE": 1010,
	"NET_BROADCAST":    1011,
	"NET_ADMIN":        1012,
	"NET_RAW":          1013,
	"IPC_LOCK":         1014,
	"IPC_OWNER":        1015,
	"SYS_MODULE":       1016,
	"SYS_RAWIO":        1017,
	"SYS_CHROOT":       1018,
	"SYS_PTRACE":       1019,
	"SYS_PACCT":        1020,
	"SYS_ADMIN":        1021,
	"SYS_BOOT":         1022,
	"SYS_NICE":         1023,
	"SYS_RESOURCE":     1024,
	"SYS_TIME":         1025,
	"SYS_TTY_CONFIG":   1026,
	"MKNOD":            1027,
	"LEASE":            1028,
	"AUDIT_WRITE":      1029,
	"AUDIT_CONTROL":    1030,
	"SETFCAP":          1031,
	"MAC_OVERRIDE":     1032,
	"MAC_ADMIN":        1033,
	"SYSLOG":           1034,
	"WAKE_ALARM":       1035,
	"BLOCK_SUSPEND":    1036,
	"AUDIT_READ":       1037,
}

func (x CapabilityInfo_Capability) Enum() *CapabilityInfo_Capability {
	p := new(CapabilityInfo_Capability)
	*p = x
	return p
}
func (x CapabilityInfo_Capability) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(CapabilityInfo_Capability_name, int32(x))
}
func (x *CapabilityInfo_Capability) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CapabilityInfo_Capability_value, data, "CapabilityInfo_Capability")
	if err != nil {
		return err
	}
	*x = CapabilityInfo_Capability(value)
	return nil
}
func (CapabilityInfo_Capability) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{65, 0}
}

type RLimitInfo_RLimit_Type int32

const (
	RLimitInfo_RLimit_UNKNOWN         RLimitInfo_RLimit_Type = 0
	RLimitInfo_RLimit_RLMT_AS         RLimitInfo_RLimit_Type = 1
	RLimitInfo_RLimit_RLMT_CORE       RLimitInfo_RLimit_Type = 2
	RLimitInfo_RLimit_RLMT_CPU        RLimitInfo_RLimit_Type = 3
	RLimitInfo_RLimit_RLMT_DATA       RLimitInfo_RLimit_Type = 4
	RLimitInfo_RLimit_RLMT_FSIZE      RLimitInfo_RLimit_Type = 5
	RLimitInfo_RLimit_RLMT_LOCKS      RLimitInfo_RLimit_Type = 6
	RLimitInfo_RLimit_RLMT_MEMLOCK    RLimitInfo_RLimit_Type = 7
	RLimitInfo_RLimit_RLMT_MSGQUEUE   RLimitInfo_RLimit_Type = 8
	RLimitInfo_RLimit_RLMT_NICE       RLimitInfo_RLimit_Type = 9
	RLimitInfo_RLimit_RLMT_NOFILE     RLimitInfo_RLimit_Type = 10
	RLimitInfo_RLimit_RLMT_NPROC      RLimitInfo_RLimit_Type = 11
	RLimitInfo_RLimit_RLMT_RSS        RLimitInfo_RLimit_Type = 12
	RLimitInfo_RLimit_RLMT_RTPRIO     RLimitInfo_RLimit_Type = 13
	RLimitInfo_RLimit_RLMT_RTTIME     RLimitInfo_RLimit_Type = 14
	RLimitInfo_RLimit_RLMT_SIGPENDING RLimitInfo_RLimit_Type = 15
	RLimitInfo_RLimit_RLMT_STACK      RLimitInfo_RLimit_Type = 16
)

var RLimitInfo_RLimit_Type_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "RLMT_AS",
	2:  "RLMT_CORE",
	3:  "RLMT_CPU",
	4:  "RLMT_DATA",
	5:  "RLMT_FSIZE",
	6:  "RLMT_LOCKS",
	7:  "RLMT_MEMLOCK",
	8:  "RLMT_MSGQUEUE",
	9:  "RLMT_NICE",
	10: "RLMT_NOFILE",
	11: "RLMT_NPROC",
	12: "RLMT_RSS",
	13: "RLMT_RTPRIO",
	14: "RLMT_RTTIME",
	15: "RLMT_SIGPENDING",
	16: "RLMT_STACK",
}
var RLimitInfo_RLimit_Type_value = map[string]int32{
	"UNKNOWN":         0,
	"RLMT_AS":         1,
	"RLMT_CORE":       2,
	"RLMT_CPU":        3,
	"RLMT_DATA":       4,
	"RLMT_FSIZE":      5,
	"RLMT_LOCKS":      6,
	"RLMT_MEMLOCK":    7,
	"RLMT_MSGQUEUE":   8,
	"RLMT_NICE":       9,
	"RLMT_NOFILE":     10,
	"RLMT_NPROC":      11,
	"RLMT_RSS":        12,
	"RLMT_RTPRIO":     13,
	"RLMT_RTTIME":     14,
	"RLMT_SIGPENDING": 15,
	"RLMT_STACK":      16,
}

func (x RLimitInfo_RLimit_Type) Enum() *RLimitInfo_RLimit_Type {
	p := new(RLimitInfo_RLimit_Type)
	*p = x
	return p
}
func (x RLimitInfo_RLimit_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(RLimitInfo_RLimit_Type_name, int32(x))
}
func (x *RLimitInfo_RLimit_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RLimitInfo_RLimit_Type_value, data, "RLimitInfo_RLimit_Type")
	if err != nil {
		return err
	}
	*x = RLimitInfo_RLimit_Type(value)
	return nil
}
func (RLimitInfo_RLimit_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{67, 0, 0}
}

// All container implementation types.
type ContainerInfo_Type int32

const (
	ContainerInfo_DOCKER ContainerInfo_Type = 1
	ContainerInfo_MESOS  ContainerInfo_Type = 2
)

var ContainerInfo_Type_name = map[int32]string{
	1: "DOCKER",
	2: "MESOS",
}
var ContainerInfo_Type_value = map[string]int32{
	"DOCKER": 1,
	"MESOS":  2,
}

func (x ContainerInfo_Type) Enum() *ContainerInfo_Type {
	p := new(ContainerInfo_Type)
	*p = x
	return p
}
func (x ContainerInfo_Type) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ContainerInfo_Type_name, int32(x))
}
func (x *ContainerInfo_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContainerInfo_Type_value, data, "ContainerInfo_Type")
	if err != nil {
		return err
	}
	*x = ContainerInfo_Type(value)
	return nil
}
func (ContainerInfo_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesos, []int{69, 0} }

// Network options.
type ContainerInfo_DockerInfo_Network int32

const (
	ContainerInfo_DockerInfo_HOST   ContainerInfo_DockerInfo_Network = 1
	ContainerInfo_DockerInfo_BRIDGE ContainerInfo_DockerInfo_Network = 2
	ContainerInfo_DockerInfo_NONE   ContainerInfo_DockerInfo_Network = 3
	ContainerInfo_DockerInfo_USER   ContainerInfo_DockerInfo_Network = 4
)

var ContainerInfo_DockerInfo_Network_name = map[int32]string{
	1: "HOST",
	2: "BRIDGE",
	3: "NONE",
	4: "USER",
}
var ContainerInfo_DockerInfo_Network_value = map[string]int32{
	"HOST":   1,
	"BRIDGE": 2,
	"NONE":   3,
	"USER":   4,
}

func (x ContainerInfo_DockerInfo_Network) Enum() *ContainerInfo_DockerInfo_Network {
	p := new(ContainerInfo_DockerInfo_Network)
	*p = x
	return p
}
func (x ContainerInfo_DockerInfo_Network) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ContainerInfo_DockerInfo_Network_name, int32(x))
}
func (x *ContainerInfo_DockerInfo_Network) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ContainerInfo_DockerInfo_Network_value, data, "ContainerInfo_DockerInfo_Network")
	if err != nil {
		return err
	}
	*x = ContainerInfo_DockerInfo_Network(value)
	return nil
}
func (ContainerInfo_DockerInfo_Network) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{69, 0, 0}
}

type CgroupInfo_Blkio_Operation int32

const (
	CgroupInfo_Blkio_UNKNOWN CgroupInfo_Blkio_Operation = 0
	CgroupInfo_Blkio_TOTAL   CgroupInfo_Blkio_Operation = 1
	CgroupInfo_Blkio_READ    CgroupInfo_Blkio_Operation = 2
	CgroupInfo_Blkio_WRITE   CgroupInfo_Blkio_Operation = 3
	CgroupInfo_Blkio_SYNC    CgroupInfo_Blkio_Operation = 4
	CgroupInfo_Blkio_ASYNC   CgroupInfo_Blkio_Operation = 5
)

var CgroupInfo_Blkio_Operation_name = map[int32]string{
	0: "UNKNOWN",
	1: "TOTAL",
	2: "READ",
	3: "WRITE",
	4: "SYNC",
	5: "ASYNC",
}
var CgroupInfo_Blkio_Operation_value = map[string]int32{
	"UNKNOWN": 0,
	"TOTAL":   1,
	"READ":    2,
	"WRITE":   3,
	"SYNC":    4,
	"ASYNC":   5,
}

func (x CgroupInfo_Blkio_Operation) Enum() *CgroupInfo_Blkio_Operation {
	p := new(CgroupInfo_Blkio_Operation)
	*p = x
	return p
}
func (x CgroupInfo_Blkio_Operation) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(CgroupInfo_Blkio_Operation_name, int32(x))
}
func (x *CgroupInfo_Blkio_Operation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CgroupInfo_Blkio_Operation_value, data, "CgroupInfo_Blkio_Operation")
	if err != nil {
		return err
	}
	*x = CgroupInfo_Blkio_Operation(value)
	return nil
}
func (CgroupInfo_Blkio_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{71, 0, 0}
}

type DiscoveryInfo_Visibility int32

const (
	FRAMEWORK DiscoveryInfo_Visibility = 0
	CLUSTER   DiscoveryInfo_Visibility = 1
	EXTERNAL  DiscoveryInfo_Visibility = 2
)

var DiscoveryInfo_Visibility_name = map[int32]string{
	0: "FRAMEWORK",
	1: "CLUSTER",
	2: "EXTERNAL",
}
var DiscoveryInfo_Visibility_value = map[string]int32{
	"FRAMEWORK": 0,
	"CLUSTER":   1,
	"EXTERNAL":  2,
}

func (x DiscoveryInfo_Visibility) Enum() *DiscoveryInfo_Visibility {
	p := new(DiscoveryInfo_Visibility)
	*p = x
	return p
}
func (x DiscoveryInfo_Visibility) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(DiscoveryInfo_Visibility_name, int32(x))
}
func (x *DiscoveryInfo_Visibility) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DiscoveryInfo_Visibility_value, data, "DiscoveryInfo_Visibility")
	if err != nil {
		return err
	}
	*x = DiscoveryInfo_Visibility(value)
	return nil
}
func (DiscoveryInfo_Visibility) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{76, 0}
}

// *
// A unique ID assigned to a framework. A framework can reuse this ID
// in order to do failover (see MesosSchedulerDriver).
type FrameworkID struct {
	Value string `protobuf:"bytes,1,req,name=value" json:"value"`
}

func (m *FrameworkID) Reset()                    { *m = FrameworkID{} }
func (*FrameworkID) ProtoMessage()               {}
func (*FrameworkID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{0} }

func (m *FrameworkID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// A unique ID assigned to an offer.
type OfferID struct {
	Value string `protobuf:"bytes,1,req,name=value" json:"value"`
}

func (m *OfferID) Reset()                    { *m = OfferID{} }
func (*OfferID) ProtoMessage()               {}
func (*OfferID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{1} }

func (m *OfferID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// A unique ID assigned to an agent. Currently, an agent gets a new ID
// whenever it (re)registers with Mesos. Framework writers shouldn't
// assume any binding between an agent ID and and a hostname.
type AgentID struct {
	Value string `protobuf:"bytes,1,req,name=value" json:"value"`
}

func (m *AgentID) Reset()                    { *m = AgentID{} }
func (*AgentID) ProtoMessage()               {}
func (*AgentID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{2} }

func (m *AgentID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// A framework-generated ID to distinguish a task. The ID must remain
// unique while the task is active. A framework can reuse an ID _only_
// if the previous task with the same ID has reached a terminal state
// (e.g., TASK_FINISHED, TASK_KILLED, etc.). However, reusing task IDs
// is strongly discouraged (MESOS-2198).
type TaskID struct {
	Value string `protobuf:"bytes,1,req,name=value" json:"value"`
}

func (m *TaskID) Reset()                    { *m = TaskID{} }
func (*TaskID) ProtoMessage()               {}
func (*TaskID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{3} }

func (m *TaskID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// A framework-generated ID to distinguish an executor. Only one
// executor with the same ID can be active on the same agent at a
// time. However, reusing executor IDs is discouraged.
type ExecutorID struct {
	Value string `protobuf:"bytes,1,req,name=value" json:"value"`
}

func (m *ExecutorID) Reset()                    { *m = ExecutorID{} }
func (*ExecutorID) ProtoMessage()               {}
func (*ExecutorID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{4} }

func (m *ExecutorID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// ID used to uniquely identify a container. If the `parent` is not
// specified, the ID is a UUID generated by the agent to uniquely
// identify the container of an executor run. If the `parent` field is
// specified, it represents a nested container.
type ContainerID struct {
	Value  string       `protobuf:"bytes,1,req,name=value" json:"value"`
	Parent *ContainerID `protobuf:"bytes,2,opt,name=parent" json:"parent,omitempty"`
}

func (m *ContainerID) Reset()                    { *m = ContainerID{} }
func (*ContainerID) ProtoMessage()               {}
func (*ContainerID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{5} }

func (m *ContainerID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *ContainerID) GetParent() *ContainerID {
	if m != nil {
		return m.Parent
	}
	return nil
}

// *
// A unique ID assigned to a resource provider. Currently, a resource
// provider gets a new ID whenever it (re)registers with Mesos.
type ResourceProviderID struct {
	Value string `protobuf:"bytes,1,req,name=value" json:"value"`
}

func (m *ResourceProviderID) Reset()                    { *m = ResourceProviderID{} }
func (*ResourceProviderID) ProtoMessage()               {}
func (*ResourceProviderID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{6} }

func (m *ResourceProviderID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// A framework-generated ID to distinguish an operation. The ID
// must be unique within the framework.
type OperationID struct {
	Value string `protobuf:"bytes,1,req,name=value" json:"value"`
}

func (m *OperationID) Reset()                    { *m = OperationID{} }
func (*OperationID) ProtoMessage()               {}
func (*OperationID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{7} }

func (m *OperationID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// Represents time since the epoch, in nanoseconds.
type TimeInfo struct {
	Nanoseconds int64 `protobuf:"varint,1,req,name=nanoseconds" json:"nanoseconds"`
}

func (m *TimeInfo) Reset()                    { *m = TimeInfo{} }
func (*TimeInfo) ProtoMessage()               {}
func (*TimeInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{8} }

func (m *TimeInfo) GetNanoseconds() int64 {
	if m != nil {
		return m.Nanoseconds
	}
	return 0
}

// *
// Represents duration in nanoseconds.
type DurationInfo struct {
	Nanoseconds int64 `protobuf:"varint,1,req,name=nanoseconds" json:"nanoseconds"`
}

func (m *DurationInfo) Reset()                    { *m = DurationInfo{} }
func (*DurationInfo) ProtoMessage()               {}
func (*DurationInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{9} }

func (m *DurationInfo) GetNanoseconds() int64 {
	if m != nil {
		return m.Nanoseconds
	}
	return 0
}

// *
// A network address.
//
// TODO(bmahler): Use this more widely.
type Address struct {
	// May contain a hostname, IP address, or both.
	Hostname *string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	IP       *string `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	Port     int32   `protobuf:"varint,3,req,name=port" json:"port"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{10} }

func (m *Address) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Address) GetIP() string {
	if m != nil && m.IP != nil {
		return *m.IP
	}
	return ""
}

func (m *Address) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// *
// Represents a URL.
type URL struct {
	Scheme   string      `protobuf:"bytes,1,req,name=scheme" json:"scheme"`
	Address  Address     `protobuf:"bytes,2,req,name=address" json:"address"`
	Path     *string     `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
	Query    []Parameter `protobuf:"bytes,4,rep,name=query" json:"query"`
	Fragment *string     `protobuf:"bytes,5,opt,name=fragment" json:"fragment,omitempty"`
}

func (m *URL) Reset()                    { *m = URL{} }
func (*URL) ProtoMessage()               {}
func (*URL) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{11} }

func (m *URL) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *URL) GetAddress() Address {
	if m != nil {
		return m.Address
	}
	return Address{}
}

func (m *URL) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *URL) GetQuery() []Parameter {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *URL) GetFragment() string {
	if m != nil && m.Fragment != nil {
		return *m.Fragment
	}
	return ""
}

// *
// Represents an interval, from a given start time over a given duration.
// This interval pertains to an unavailability event, such as maintenance,
// and is not a generic interval.
type Unavailability struct {
	Start TimeInfo `protobuf:"bytes,1,req,name=start" json:"start"`
	// When added to `start`, this represents the end of the interval.
	// If unspecified, the duration is assumed to be infinite.
	Duration *DurationInfo `protobuf:"bytes,2,opt,name=duration" json:"duration,omitempty"`
}

func (m *Unavailability) Reset()                    { *m = Unavailability{} }
func (*Unavailability) ProtoMessage()               {}
func (*Unavailability) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{12} }

func (m *Unavailability) GetStart() TimeInfo {
	if m != nil {
		return m.Start
	}
	return TimeInfo{}
}

func (m *Unavailability) GetDuration() *DurationInfo {
	if m != nil {
		return m.Duration
	}
	return nil
}

// *
// Represents a single machine, which may hold one or more agents.
//
// NOTE: In order to match an agent to a machine, both the `hostname` and
// `ip` must match the values advertised by the agent to the master.
// Hostname is not case-sensitive.
type MachineID struct {
	Hostname *string `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	IP       *string `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
}

func (m *MachineID) Reset()                    { *m = MachineID{} }
func (*MachineID) ProtoMessage()               {}
func (*MachineID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{13} }

func (m *MachineID) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *MachineID) GetIP() string {
	if m != nil && m.IP != nil {
		return *m.IP
	}
	return ""
}

// *
// Holds information about a single machine, its `mode`, and any other
// relevant information which may affect the behavior of the machine.
type MachineInfo struct {
	ID   MachineID         `protobuf:"bytes,1,req,name=id" json:"id"`
	Mode *MachineInfo_Mode `protobuf:"varint,2,opt,name=mode,enum=mesos.MachineInfo_Mode" json:"mode,omitempty"`
	// Signifies that the machine may be unavailable during the given interval.
	// See comments in `Unavailability` and for the `unavailability` fields
	// in `Offer` and `InverseOffer` for more information.
	Unavailability *Unavailability `protobuf:"bytes,3,opt,name=unavailability" json:"unavailability,omitempty"`
}

func (m *MachineInfo) Reset()                    { *m = MachineInfo{} }
func (*MachineInfo) ProtoMessage()               {}
func (*MachineInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{14} }

func (m *MachineInfo) GetID() MachineID {
	if m != nil {
		return m.ID
	}
	return MachineID{}
}

func (m *MachineInfo) GetMode() MachineInfo_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return UP
}

func (m *MachineInfo) GetUnavailability() *Unavailability {
	if m != nil {
		return m.Unavailability
	}
	return nil
}

// *
// Describes a framework.
type FrameworkInfo struct {
	// Used to determine the Unix user that an executor or task should be
	// launched as.
	//
	// When using the MesosSchedulerDriver, if the field is set to an
	// empty string, it will automagically set it to the current user.
	//
	// When using the HTTP Scheduler API, the user has to be set
	// explicitly.
	User string `protobuf:"bytes,1,req,name=user" json:"user"`
	// Name of the framework that shows up in the Mesos Web UI.
	Name string `protobuf:"bytes,2,req,name=name" json:"name"`
	// Note that 'id' is only available after a framework has
	// registered, however, it is included here in order to facilitate
	// scheduler failover (i.e., if it is set then the
	// MesosSchedulerDriver expects the scheduler is performing
	// failover).
	ID *FrameworkID `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	// The amount of time (in seconds) that the master will wait for the
	// scheduler to failover before it tears down the framework by
	// killing all its tasks/executors. This should be non-zero if a
	// framework expects to reconnect after a failure and not lose its
	// tasks/executors.
	//
	// NOTE: To avoid accidental destruction of tasks, production
	// frameworks typically set this to a large value (e.g., 1 week).
	FailoverTimeout *float64 `protobuf:"fixed64,4,opt,name=failover_timeout,json=failoverTimeout,def=0" json:"failover_timeout,omitempty"`
	// If set, agents running tasks started by this framework will write
	// the framework pid, executor pids and status updates to disk. If
	// the agent exits (e.g., due to a crash or as part of upgrading
	// Mesos), this checkpointed data allows the restarted agent to
	// reconnect to executors that were started by the old instance of
	// the agent. Enabling checkpointing improves fault tolerance, at
	// the cost of a (usually small) increase in disk I/O.
	Checkpoint *bool `protobuf:"varint,5,opt,name=checkpoint,def=0" json:"checkpoint,omitempty"`
	// Roles are the entities to which allocations are made.
	// The framework must have at least one role in order to
	// be offered resources. Note that `role` is deprecated
	// in favor of `roles` and only one of these fields must
	// be used. Since we cannot distinguish between empty
	// `roles` and the default unset `role`, we require that
	// frameworks set the `MULTI_ROLE` capability if
	// setting the `roles` field.
	Role  *string  `protobuf:"bytes,6,opt,name=role,def=*" json:"role,omitempty"`
	Roles []string `protobuf:"bytes,12,rep,name=roles" json:"roles,omitempty"`
	// Used to indicate the current host from which the scheduler is
	// registered in the Mesos Web UI. If set to an empty string Mesos
	// will automagically set it to the current hostname if one is
	// available.
	Hostname *string `protobuf:"bytes,7,opt,name=hostname" json:"hostname,omitempty"`
	// This field should match the credential's principal the framework
	// uses for authentication. This field is used for framework API
	// rate limiting and dynamic reservations. It should be set even
	// if authentication is not enabled if these features are desired.
	Principal *string `protobuf:"bytes,8,opt,name=principal" json:"principal,omitempty"`
	// This field allows a framework to advertise its web UI, so that
	// the Mesos web UI can link to it. It is expected to be a full URL,
	// for example http://my-scheduler.example.com:8080/.
	WebUiURL *string `protobuf:"bytes,9,opt,name=webui_url,json=webuiUrl" json:"webui_url,omitempty"`
	// This field allows a framework to advertise its set of
	// capabilities (e.g., ability to receive offers for revocable
	// resources).
	Capabilities []FrameworkInfo_Capability `protobuf:"bytes,10,rep,name=capabilities" json:"capabilities"`
	// Labels are free-form key value pairs supplied by the framework
	// scheduler (e.g., to describe additional functionality offered by
	// the framework). These labels are not interpreted by Mesos itself.
	// Labels should not contain duplicate key-value pairs.
	Labels *Labels `protobuf:"bytes,11,opt,name=labels" json:"labels,omitempty"`
}

func (m *FrameworkInfo) Reset()                    { *m = FrameworkInfo{} }
func (*FrameworkInfo) ProtoMessage()               {}
func (*FrameworkInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{15} }

const Default_FrameworkInfo_FailoverTimeout float64 = 0
const Default_FrameworkInfo_Checkpoint bool = false
const Default_FrameworkInfo_Role string = "*"

func (m *FrameworkInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *FrameworkInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FrameworkInfo) GetID() *FrameworkID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *FrameworkInfo) GetFailoverTimeout() float64 {
	if m != nil && m.FailoverTimeout != nil {
		return *m.FailoverTimeout
	}
	return Default_FrameworkInfo_FailoverTimeout
}

func (m *FrameworkInfo) GetCheckpoint() bool {
	if m != nil && m.Checkpoint != nil {
		return *m.Checkpoint
	}
	return Default_FrameworkInfo_Checkpoint
}

func (m *FrameworkInfo) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_FrameworkInfo_Role
}

func (m *FrameworkInfo) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *FrameworkInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *FrameworkInfo) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

func (m *FrameworkInfo) GetWebUiURL() string {
	if m != nil && m.WebUiURL != nil {
		return *m.WebUiURL
	}
	return ""
}

func (m *FrameworkInfo) GetCapabilities() []FrameworkInfo_Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *FrameworkInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

type FrameworkInfo_Capability struct {
	// Enum fields should be optional, see: MESOS-4997.
	Type FrameworkInfo_Capability_Type `protobuf:"varint,1,opt,name=type,enum=mesos.FrameworkInfo_Capability_Type" json:"type"`
}

func (m *FrameworkInfo_Capability) Reset()      { *m = FrameworkInfo_Capability{} }
func (*FrameworkInfo_Capability) ProtoMessage() {}
func (*FrameworkInfo_Capability) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{15, 0}
}

func (m *FrameworkInfo_Capability) GetType() FrameworkInfo_Capability_Type {
	if m != nil {
		return m.Type
	}
	return FrameworkInfo_Capability_UNKNOWN
}

// *
// Describes a general non-interpreting non-killing check for a task or
// executor (or any arbitrary process/command). A type is picked by
// specifying one of the optional fields. Specifying more than one type
// is an error.
//
// NOTE: This API is subject to change and the related feature is experimental.
type CheckInfo struct {
	// The type of the check.
	Type CheckInfo_Type `protobuf:"varint,1,opt,name=type,enum=mesos.CheckInfo_Type" json:"type"`
	// Command check.
	Command *CheckInfo_Command `protobuf:"bytes,2,opt,name=command" json:"command,omitempty"`
	// HTTP check.
	HTTP *CheckInfo_Http `protobuf:"bytes,3,opt,name=http" json:"http,omitempty"`
	// TCP check.
	TCP *CheckInfo_Tcp `protobuf:"bytes,7,opt,name=tcp" json:"tcp,omitempty"`
	// Amount of time to wait to start checking the task after it
	// transitions to `TASK_RUNNING` or `TASK_STARTING` if the latter
	// is used by the executor.
	DelaySeconds *float64 `protobuf:"fixed64,4,opt,name=delay_seconds,json=delaySeconds,def=15" json:"delay_seconds,omitempty"`
	// Interval between check attempts, i.e., amount of time to wait after
	// the previous check finished or timed out to start the next check.
	IntervalSeconds *float64 `protobuf:"fixed64,5,opt,name=interval_seconds,json=intervalSeconds,def=10" json:"interval_seconds,omitempty"`
	// Amount of time to wait for the check to complete. Zero means infinite
	// timeout.
	//
	// After this timeout, the check attempt is aborted and no result is
	// reported. Note that this may be considered a state change and hence
	// may trigger a check status change delivery to the corresponding
	// scheduler. See `CheckStatusInfo` for more details.
	TimeoutSeconds *float64 `protobuf:"fixed64,6,opt,name=timeout_seconds,json=timeoutSeconds,def=20" json:"timeout_seconds,omitempty"`
}

func (m *CheckInfo) Reset()                    { *m = CheckInfo{} }
func (*CheckInfo) ProtoMessage()               {}
func (*CheckInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{16} }

const Default_CheckInfo_DelaySeconds float64 = 15
const Default_CheckInfo_IntervalSeconds float64 = 10
const Default_CheckInfo_TimeoutSeconds float64 = 20

func (m *CheckInfo) GetType() CheckInfo_Type {
	if m != nil {
		return m.Type
	}
	return CheckInfo_UNKNOWN
}

func (m *CheckInfo) GetCommand() *CheckInfo_Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *CheckInfo) GetHTTP() *CheckInfo_Http {
	if m != nil {
		return m.HTTP
	}
	return nil
}

func (m *CheckInfo) GetTCP() *CheckInfo_Tcp {
	if m != nil {
		return m.TCP
	}
	return nil
}

func (m *CheckInfo) GetDelaySeconds() float64 {
	if m != nil && m.DelaySeconds != nil {
		return *m.DelaySeconds
	}
	return Default_CheckInfo_DelaySeconds
}

func (m *CheckInfo) GetIntervalSeconds() float64 {
	if m != nil && m.IntervalSeconds != nil {
		return *m.IntervalSeconds
	}
	return Default_CheckInfo_IntervalSeconds
}

func (m *CheckInfo) GetTimeoutSeconds() float64 {
	if m != nil && m.TimeoutSeconds != nil {
		return *m.TimeoutSeconds
	}
	return Default_CheckInfo_TimeoutSeconds
}

// Describes a command check. If applicable, enters mount and/or network
// namespaces of the task.
type CheckInfo_Command struct {
	Command CommandInfo `protobuf:"bytes,1,req,name=command" json:"command"`
}

func (m *CheckInfo_Command) Reset()                    { *m = CheckInfo_Command{} }
func (*CheckInfo_Command) ProtoMessage()               {}
func (*CheckInfo_Command) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{16, 0} }

func (m *CheckInfo_Command) GetCommand() CommandInfo {
	if m != nil {
		return m.Command
	}
	return CommandInfo{}
}

// Describes an HTTP check. Sends a GET request to
// http://<host>:port/path. Note that <host> is not configurable and is
// resolved automatically to 127.0.0.1.
type CheckInfo_Http struct {
	// Port to send the HTTP request.
	Port uint32 `protobuf:"varint,1,req,name=port" json:"port"`
	// HTTP request path.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *CheckInfo_Http) Reset()                    { *m = CheckInfo_Http{} }
func (*CheckInfo_Http) ProtoMessage()               {}
func (*CheckInfo_Http) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{16, 1} }

func (m *CheckInfo_Http) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *CheckInfo_Http) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

// Describes a TCP check, i.e. based on establishing a TCP connection to
// the specified port. Note that <host> is not configurable and is resolved
// automatically to 127.0.0.1.
type CheckInfo_Tcp struct {
	Port uint32 `protobuf:"varint,1,req,name=port" json:"port"`
}

func (m *CheckInfo_Tcp) Reset()                    { *m = CheckInfo_Tcp{} }
func (*CheckInfo_Tcp) ProtoMessage()               {}
func (*CheckInfo_Tcp) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{16, 2} }

func (m *CheckInfo_Tcp) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// *
// Describes a health check for a task or executor (or any arbitrary
// process/command). A type is picked by specifying one of the
// optional fields. Specifying more than one type is an error.
type HealthCheck struct {
	// Amount of time to wait to start health checking the task after it
	// transitions to `TASK_RUNNING` or `TASK_STATING` if the latter is
	// used by the executor.
	DelaySeconds *float64 `protobuf:"fixed64,2,opt,name=delay_seconds,json=delaySeconds,def=15" json:"delay_seconds,omitempty"`
	// Interval between health checks, i.e., amount of time to wait after
	// the previous health check finished or timed out to start the next
	// health check.
	IntervalSeconds *float64 `protobuf:"fixed64,3,opt,name=interval_seconds,json=intervalSeconds,def=10" json:"interval_seconds,omitempty"`
	// Amount of time to wait for the health check to complete. After this
	// timeout, the health check is aborted and treated as a failure. Zero
	// means infinite timeout.
	TimeoutSeconds *float64 `protobuf:"fixed64,4,opt,name=timeout_seconds,json=timeoutSeconds,def=20" json:"timeout_seconds,omitempty"`
	// Number of consecutive failures until the task is killed by the executor.
	ConsecutiveFailures *uint32 `protobuf:"varint,5,opt,name=consecutive_failures,json=consecutiveFailures,def=3" json:"consecutive_failures,omitempty"`
	// Amount of time after the task is launched during which health check
	// failures are ignored. Once a check succeeds for the first time,
	// the grace period does not apply anymore. Note that it includes
	// `delay_seconds`, i.e., setting `grace_period_seconds` < `delay_seconds`
	// has no effect.
	GracePeriodSeconds *float64 `protobuf:"fixed64,6,opt,name=grace_period_seconds,json=gracePeriodSeconds,def=10" json:"grace_period_seconds,omitempty"`
	// The type of health check.
	Type HealthCheck_Type `protobuf:"varint,8,opt,name=type,enum=mesos.HealthCheck_Type" json:"type"`
	// Command health check.
	Command *CommandInfo `protobuf:"bytes,7,opt,name=command" json:"command,omitempty"`
	// HTTP health check.
	HTTP *HealthCheck_HTTPCheckInfo `protobuf:"bytes,1,opt,name=http" json:"http,omitempty"`
	// TCP health check.
	TCP *HealthCheck_TCPCheckInfo `protobuf:"bytes,9,opt,name=tcp" json:"tcp,omitempty"`
}

func (m *HealthCheck) Reset()                    { *m = HealthCheck{} }
func (*HealthCheck) ProtoMessage()               {}
func (*HealthCheck) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{17} }

const Default_HealthCheck_DelaySeconds float64 = 15
const Default_HealthCheck_IntervalSeconds float64 = 10
const Default_HealthCheck_TimeoutSeconds float64 = 20
const Default_HealthCheck_ConsecutiveFailures uint32 = 3
const Default_HealthCheck_GracePeriodSeconds float64 = 10

func (m *HealthCheck) GetDelaySeconds() float64 {
	if m != nil && m.DelaySeconds != nil {
		return *m.DelaySeconds
	}
	return Default_HealthCheck_DelaySeconds
}

func (m *HealthCheck) GetIntervalSeconds() float64 {
	if m != nil && m.IntervalSeconds != nil {
		return *m.IntervalSeconds
	}
	return Default_HealthCheck_IntervalSeconds
}

func (m *HealthCheck) GetTimeoutSeconds() float64 {
	if m != nil && m.TimeoutSeconds != nil {
		return *m.TimeoutSeconds
	}
	return Default_HealthCheck_TimeoutSeconds
}

func (m *HealthCheck) GetConsecutiveFailures() uint32 {
	if m != nil && m.ConsecutiveFailures != nil {
		return *m.ConsecutiveFailures
	}
	return Default_HealthCheck_ConsecutiveFailures
}

func (m *HealthCheck) GetGracePeriodSeconds() float64 {
	if m != nil && m.GracePeriodSeconds != nil {
		return *m.GracePeriodSeconds
	}
	return Default_HealthCheck_GracePeriodSeconds
}

func (m *HealthCheck) GetType() HealthCheck_Type {
	if m != nil {
		return m.Type
	}
	return HealthCheck_UNKNOWN
}

func (m *HealthCheck) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *HealthCheck) GetHTTP() *HealthCheck_HTTPCheckInfo {
	if m != nil {
		return m.HTTP
	}
	return nil
}

func (m *HealthCheck) GetTCP() *HealthCheck_TCPCheckInfo {
	if m != nil {
		return m.TCP
	}
	return nil
}

// Describes an HTTP health check. Sends a GET request to
// scheme://<host>:port/path. Note that <host> is not configurable and is
// resolved automatically, in most cases to 127.0.0.1. Default executors
// treat return codes between 200 and 399 as success; custom executors
// may employ a different strategy, e.g. leveraging the `statuses` field.
type HealthCheck_HTTPCheckInfo struct {
	Protocol *NetworkInfo_Protocol `protobuf:"varint,5,opt,name=protocol,enum=mesos.NetworkInfo_Protocol,def=1" json:"protocol,omitempty"`
	// Currently "http" and "https" are supported.
	Scheme *string `protobuf:"bytes,3,opt,name=scheme" json:"scheme,omitempty"`
	// Port to send the HTTP request.
	Port uint32 `protobuf:"varint,1,req,name=port" json:"port"`
	// HTTP request path.
	Path *string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// NOTE: It is up to the custom executor to interpret and act on this
	// field. Setting this field has no effect on the default executors.
	//
	// TODO(haosdent): Deprecate this field when we add better support for
	// success and possibly failure statuses, e.g. ranges of success and
	// failure statuses.
	Statuses []uint32 `protobuf:"varint,4,rep,name=statuses" json:"statuses,omitempty"`
}

func (m *HealthCheck_HTTPCheckInfo) Reset()      { *m = HealthCheck_HTTPCheckInfo{} }
func (*HealthCheck_HTTPCheckInfo) ProtoMessage() {}
func (*HealthCheck_HTTPCheckInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{17, 0}
}

const Default_HealthCheck_HTTPCheckInfo_Protocol NetworkInfo_Protocol = IPv4

func (m *HealthCheck_HTTPCheckInfo) GetProtocol() NetworkInfo_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return Default_HealthCheck_HTTPCheckInfo_Protocol
}

func (m *HealthCheck_HTTPCheckInfo) GetScheme() string {
	if m != nil && m.Scheme != nil {
		return *m.Scheme
	}
	return ""
}

func (m *HealthCheck_HTTPCheckInfo) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *HealthCheck_HTTPCheckInfo) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *HealthCheck_HTTPCheckInfo) GetStatuses() []uint32 {
	if m != nil {
		return m.Statuses
	}
	return nil
}

// Describes a TCP health check, i.e. based on establishing
// a TCP connection to the specified port.
type HealthCheck_TCPCheckInfo struct {
	Protocol *NetworkInfo_Protocol `protobuf:"varint,2,opt,name=protocol,enum=mesos.NetworkInfo_Protocol,def=1" json:"protocol,omitempty"`
	// Port expected to be open.
	Port uint32 `protobuf:"varint,1,req,name=port" json:"port"`
}

func (m *HealthCheck_TCPCheckInfo) Reset()      { *m = HealthCheck_TCPCheckInfo{} }
func (*HealthCheck_TCPCheckInfo) ProtoMessage() {}
func (*HealthCheck_TCPCheckInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{17, 1}
}

const Default_HealthCheck_TCPCheckInfo_Protocol NetworkInfo_Protocol = IPv4

func (m *HealthCheck_TCPCheckInfo) GetProtocol() NetworkInfo_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return Default_HealthCheck_TCPCheckInfo_Protocol
}

func (m *HealthCheck_TCPCheckInfo) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// *
// Describes a kill policy for a task. Currently does not express
// different policies (e.g. hitting HTTP endpoints), only controls
// how long to wait between graceful and forcible task kill:
//
//     graceful kill --------------> forcible kill
//                    grace_period
//
// Kill policies are best-effort, because machine failures / forcible
// terminations may occur.
//
// NOTE: For executor-less command-based tasks, the kill is performed
// via sending a signal to the task process: SIGTERM for the graceful
// kill and SIGKILL for the forcible kill. For the docker executor-less
// tasks the grace period is passed to 'docker stop --time'.
type KillPolicy struct {
	// The grace period specifies how long to wait before forcibly
	// killing the task. It is recommended to attempt to gracefully
	// kill the task (and send TASK_KILLING) to indicate that the
	// graceful kill is in progress. Once the grace period elapses,
	// if the task has not terminated, a forcible kill should occur.
	// The task should not assume that it will always be allotted
	// the full grace period. For example, the executor may be
	// shutdown more quickly by the agent, or failures / forcible
	// terminations may occur.
	GracePeriod *DurationInfo `protobuf:"bytes,1,opt,name=grace_period,json=gracePeriod" json:"grace_period,omitempty"`
}

func (m *KillPolicy) Reset()                    { *m = KillPolicy{} }
func (*KillPolicy) ProtoMessage()               {}
func (*KillPolicy) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{18} }

func (m *KillPolicy) GetGracePeriod() *DurationInfo {
	if m != nil {
		return m.GracePeriod
	}
	return nil
}

// *
// Describes a command, executed via: '/bin/sh -c value'. Any URIs specified
// are fetched before executing the command.  If the executable field for an
// uri is set, executable file permission is set on the downloaded file.
// Otherwise, if the downloaded file has a recognized archive extension
// (currently [compressed] tar and zip) it is extracted into the executor's
// working directory. This extraction can be disabled by setting `extract` to
// false. In addition, any environment variables are set before executing
// the command (so they can be used to "parameterize" your command).
type CommandInfo struct {
	URIs        []CommandInfo_URI `protobuf:"bytes,1,rep,name=uris" json:"uris"`
	Environment *Environment      `protobuf:"bytes,2,opt,name=environment" json:"environment,omitempty"`
	// There are two ways to specify the command:
	// 1) If 'shell == true', the command will be launched via shell
	// 		(i.e., /bin/sh -c 'value'). The 'value' specified will be
	// 		treated as the shell command. The 'arguments' will be ignored.
	// 2) If 'shell == false', the command will be launched by passing
	// 		arguments to an executable. The 'value' specified will be
	// 		treated as the filename of the executable. The 'arguments'
	// 		will be treated as the arguments to the executable. This is
	// 		similar to how POSIX exec families launch processes (i.e.,
	// 		execlp(value, arguments(0), arguments(1), ...)).
	// NOTE: The field 'value' is changed from 'required' to 'optional'
	// in 0.20.0. It will only cause issues if a new framework is
	// connecting to an old master.
	Shell     *bool    `protobuf:"varint,6,opt,name=shell,def=1" json:"shell,omitempty"`
	Value     *string  `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	Arguments []string `protobuf:"bytes,7,rep,name=arguments" json:"arguments,omitempty"`
	// Enables executor and tasks to run as a specific user. If the user
	// field is present both in FrameworkInfo and here, the CommandInfo
	// user value takes precedence.
	User *string `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
}

func (m *CommandInfo) Reset()                    { *m = CommandInfo{} }
func (*CommandInfo) ProtoMessage()               {}
func (*CommandInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{19} }

const Default_CommandInfo_Shell bool = true

func (m *CommandInfo) GetURIs() []CommandInfo_URI {
	if m != nil {
		return m.URIs
	}
	return nil
}

func (m *CommandInfo) GetEnvironment() *Environment {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *CommandInfo) GetShell() bool {
	if m != nil && m.Shell != nil {
		return *m.Shell
	}
	return Default_CommandInfo_Shell
}

func (m *CommandInfo) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *CommandInfo) GetArguments() []string {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *CommandInfo) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

type CommandInfo_URI struct {
	Value      string `protobuf:"bytes,1,req,name=value" json:"value"`
	Executable *bool  `protobuf:"varint,2,opt,name=executable" json:"executable,omitempty"`
	// In case the fetched file is recognized as an archive, extract
	// its contents into the sandbox. Note that a cached archive is
	// not copied from the cache to the sandbox in case extraction
	// originates from an archive in the cache.
	Extract *bool `protobuf:"varint,3,opt,name=extract,def=1" json:"extract,omitempty"`
	// If this field is "true", the fetcher cache will be used. If not,
	// fetching bypasses the cache and downloads directly into the
	// sandbox directory, no matter whether a suitable cache file is
	// available or not. The former directs the fetcher to download to
	// the file cache, then copy from there to the sandbox. Subsequent
	// fetch attempts with the same URI will omit downloading and copy
	// from the cache as long as the file is resident there. Cache files
	// may get evicted at any time, which then leads to renewed
	// downloading. See also "docs/fetcher.md" and
	// "docs/fetcher-cache-internals.md".
	Cache *bool `protobuf:"varint,4,opt,name=cache" json:"cache,omitempty"`
	// The fetcher's default behavior is to use the URI string's basename to
	// name the local copy. If this field is provided, the local copy will be
	// named with its value instead. If there is a directory component (which
	// must be a relative path), the local copy will be stored in that
	// subdirectory inside the sandbox.
	OutputFile *string `protobuf:"bytes,5,opt,name=output_file,json=outputFile" json:"output_file,omitempty"`
}

func (m *CommandInfo_URI) Reset()                    { *m = CommandInfo_URI{} }
func (*CommandInfo_URI) ProtoMessage()               {}
func (*CommandInfo_URI) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{19, 0} }

const Default_CommandInfo_URI_Extract bool = true

func (m *CommandInfo_URI) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *CommandInfo_URI) GetExecutable() bool {
	if m != nil && m.Executable != nil {
		return *m.Executable
	}
	return false
}

func (m *CommandInfo_URI) GetExtract() bool {
	if m != nil && m.Extract != nil {
		return *m.Extract
	}
	return Default_CommandInfo_URI_Extract
}

func (m *CommandInfo_URI) GetCache() bool {
	if m != nil && m.Cache != nil {
		return *m.Cache
	}
	return false
}

func (m *CommandInfo_URI) GetOutputFile() string {
	if m != nil && m.OutputFile != nil {
		return *m.OutputFile
	}
	return ""
}

// *
// Describes information about an executor.
type ExecutorInfo struct {
	// For backwards compatibility, if this field is not set when using `LAUNCH`
	// operation, Mesos will infer the type by checking if `command` is set
	// (`CUSTOM`) or unset (`DEFAULT`). `type` must be set when using
	// `LAUNCH_GROUP` operation.
	//
	// TODO(vinod): Add support for explicitly setting `type` to `DEFAULT` in
	// `LAUNCH` operation.
	Type        ExecutorInfo_Type `protobuf:"varint,15,opt,name=type,enum=mesos.ExecutorInfo_Type" json:"type"`
	ExecutorID  ExecutorID        `protobuf:"bytes,1,req,name=executor_id,json=executorId" json:"executor_id"`
	FrameworkID *FrameworkID      `protobuf:"bytes,8,opt,name=framework_id,json=frameworkId" json:"framework_id,omitempty"`
	Command     *CommandInfo      `protobuf:"bytes,7,opt,name=command" json:"command,omitempty"`
	// Executor provided with a container will launch the container
	// with the executor's CommandInfo and we expect the container to
	// act as a Mesos executor.
	Container *ContainerInfo `protobuf:"bytes,11,opt,name=container" json:"container,omitempty"`
	Resources []Resource     `protobuf:"bytes,5,rep,name=resources" json:"resources"`
	Name      *string        `protobuf:"bytes,9,opt,name=name" json:"name,omitempty"`
	// 'source' is an identifier style string used by frameworks to
	// track the source of an executor. This is useful when it's
	// possible for different executor ids to be related semantically.
	//
	// NOTE: 'source' is exposed alongside the resource usage of the
	// executor via JSON on the agent. This allows users to import usage
	// information into a time series database for monitoring.
	//
	// This field is deprecated since 1.0. Please use labels for
	// free-form metadata instead.
	Source *string `protobuf:"bytes,10,opt,name=source" json:"source,omitempty"`
	// This field can be used to pass arbitrary bytes to an executor.
	Data []byte `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	// Service discovery information for the executor. It is not
	// interpreted or acted upon by Mesos. It is up to a service
	// discovery system to use this information as needed and to handle
	// executors without service discovery information.
	Discovery *DiscoveryInfo `protobuf:"bytes,12,opt,name=discovery" json:"discovery,omitempty"`
	// When shutting down an executor the agent will wait in a
	// best-effort manner for the grace period specified here
	// before forcibly destroying the container. The executor
	// must not assume that it will always be allotted the full
	// grace period, as the agent may decide to allot a shorter
	// period and failures / forcible terminations may occur.
	ShutdownGracePeriod *DurationInfo `protobuf:"bytes,13,opt,name=shutdown_grace_period,json=shutdownGracePeriod" json:"shutdown_grace_period,omitempty"`
	// Labels are free-form key value pairs which are exposed through
	// master and agent endpoints. Labels will not be interpreted or
	// acted upon by Mesos itself. As opposed to the data field, labels
	// will be kept in memory on master and agent processes. Therefore,
	// labels should be used to tag executors with lightweight metadata.
	// Labels should not contain duplicate key-value pairs.
	Labels *Labels `protobuf:"bytes,14,opt,name=labels" json:"labels,omitempty"`
}

func (m *ExecutorInfo) Reset()                    { *m = ExecutorInfo{} }
func (*ExecutorInfo) ProtoMessage()               {}
func (*ExecutorInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{20} }

func (m *ExecutorInfo) GetType() ExecutorInfo_Type {
	if m != nil {
		return m.Type
	}
	return ExecutorInfo_UNKNOWN
}

func (m *ExecutorInfo) GetExecutorID() ExecutorID {
	if m != nil {
		return m.ExecutorID
	}
	return ExecutorID{}
}

func (m *ExecutorInfo) GetFrameworkID() *FrameworkID {
	if m != nil {
		return m.FrameworkID
	}
	return nil
}

func (m *ExecutorInfo) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ExecutorInfo) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *ExecutorInfo) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ExecutorInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExecutorInfo) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *ExecutorInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ExecutorInfo) GetDiscovery() *DiscoveryInfo {
	if m != nil {
		return m.Discovery
	}
	return nil
}

func (m *ExecutorInfo) GetShutdownGracePeriod() *DurationInfo {
	if m != nil {
		return m.ShutdownGracePeriod
	}
	return nil
}

func (m *ExecutorInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

// *
// Describes a domain. A domain is a collection of hosts that have
// similar characteristics. Mesos currently only supports "fault
// domains", which identify groups of hosts with similar failure
// characteristics.
//
// Frameworks can generally assume that network links between hosts in
// the same fault domain have lower latency, higher bandwidth, and better
// availability than network links between hosts in different domains.
// Schedulers may prefer to place network-intensive workloads in the
// same domain, as this may improve performance. Conversely, a single
// failure that affects a host in a domain may be more likely to
// affect other hosts in the same domain; hence, schedulers may prefer
// to place workloads that require high availability in multiple
// domains. (For example, all the hosts in a single rack might lose
// power or network connectivity simultaneously.)
//
// There are two kinds of fault domains: regions and zones. Regions
// offer the highest degree of fault isolation, but network latency
// between regions is typically high (typically >50 ms). Zones offer a
// modest degree of fault isolation along with reasonably low network
// latency (typically <10 ms).
//
// The mapping from fault domains to physical infrastructure is up to
// the operator to configure. In cloud environments, regions and zones
// can be mapped to the "region" and "availability zone" concepts
// exposed by most cloud providers, respectively. In on-premise
// deployments, regions and zones can be mapped to data centers and
// racks, respectively.
//
// Both masters and agents can be configured with domains. Frameworks
// can compare the domains of two hosts to determine if the hosts are
// in the same zone, in different zones in the same region, or in
// different regions. Note that all masters in a given Mesos cluster
// must be in the same region.
type DomainInfo struct {
	FaultDomain *DomainInfo_FaultDomain `protobuf:"bytes,1,opt,name=fault_domain,json=faultDomain" json:"fault_domain,omitempty"`
}

func (m *DomainInfo) Reset()                    { *m = DomainInfo{} }
func (*DomainInfo) ProtoMessage()               {}
func (*DomainInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{21} }

func (m *DomainInfo) GetFaultDomain() *DomainInfo_FaultDomain {
	if m != nil {
		return m.FaultDomain
	}
	return nil
}

type DomainInfo_FaultDomain struct {
	Region DomainInfo_FaultDomain_RegionInfo `protobuf:"bytes,1,req,name=region" json:"region"`
	Zone   DomainInfo_FaultDomain_ZoneInfo   `protobuf:"bytes,2,req,name=zone" json:"zone"`
}

func (m *DomainInfo_FaultDomain) Reset()                    { *m = DomainInfo_FaultDomain{} }
func (*DomainInfo_FaultDomain) ProtoMessage()               {}
func (*DomainInfo_FaultDomain) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{21, 0} }

func (m *DomainInfo_FaultDomain) GetRegion() DomainInfo_FaultDomain_RegionInfo {
	if m != nil {
		return m.Region
	}
	return DomainInfo_FaultDomain_RegionInfo{}
}

func (m *DomainInfo_FaultDomain) GetZone() DomainInfo_FaultDomain_ZoneInfo {
	if m != nil {
		return m.Zone
	}
	return DomainInfo_FaultDomain_ZoneInfo{}
}

type DomainInfo_FaultDomain_RegionInfo struct {
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
}

func (m *DomainInfo_FaultDomain_RegionInfo) Reset()      { *m = DomainInfo_FaultDomain_RegionInfo{} }
func (*DomainInfo_FaultDomain_RegionInfo) ProtoMessage() {}
func (*DomainInfo_FaultDomain_RegionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{21, 0, 0}
}

func (m *DomainInfo_FaultDomain_RegionInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DomainInfo_FaultDomain_ZoneInfo struct {
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
}

func (m *DomainInfo_FaultDomain_ZoneInfo) Reset()      { *m = DomainInfo_FaultDomain_ZoneInfo{} }
func (*DomainInfo_FaultDomain_ZoneInfo) ProtoMessage() {}
func (*DomainInfo_FaultDomain_ZoneInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{21, 0, 1}
}

func (m *DomainInfo_FaultDomain_ZoneInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// *
// Describes a master. This will probably have more fields in the
// future which might be used, for example, to link a framework webui
// to a master webui.
type MasterInfo struct {
	ID string `protobuf:"bytes,1,req,name=id" json:"id"`
	// The IP address (only IPv4) as a packed 4-bytes integer,
	// stored in network order.  Deprecated, use `address.ip` instead.
	IP uint32 `protobuf:"varint,2,req,name=ip" json:"ip"`
	// The TCP port the Master is listening on for incoming
	// HTTP requests; deprecated, use `address.port` instead.
	Port *uint32 `protobuf:"varint,3,req,name=port,def=5050" json:"port,omitempty"`
	// In the default implementation, this will contain information
	// about both the IP address, port and Master name; it should really
	// not be relied upon by external tooling/frameworks and be
	// considered an "internal" implementation field.
	PID *string `protobuf:"bytes,4,opt,name=pid" json:"pid,omitempty"`
	// The server's hostname, if available; it may be unreliable
	// in environments where the DNS configuration does not resolve
	// internal hostnames (eg, some public cloud providers).
	// Deprecated, use `address.hostname` instead.
	Hostname *string `protobuf:"bytes,5,opt,name=hostname" json:"hostname,omitempty"`
	// The running Master version, as a string; taken from the
	// generated "master/version.hpp".
	Version *string `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
	// The full IP address (supports both IPv4 and IPv6 formats)
	// and supersedes the use of `ip`, `port` and `hostname`.
	// Since Mesos 0.24.
	Address *Address `protobuf:"bytes,7,opt,name=address" json:"address,omitempty"`
	// The domain that this master belongs to. All masters in a Mesos
	// cluster should belong to the same region.
	Domain       *DomainInfo             `protobuf:"bytes,8,opt,name=domain" json:"domain,omitempty"`
	Capabilities []MasterInfo_Capability `protobuf:"bytes,9,rep,name=capabilities" json:"capabilities"`
}

func (m *MasterInfo) Reset()                    { *m = MasterInfo{} }
func (*MasterInfo) ProtoMessage()               {}
func (*MasterInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{22} }

const Default_MasterInfo_Port uint32 = 5050

func (m *MasterInfo) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *MasterInfo) GetIP() uint32 {
	if m != nil {
		return m.IP
	}
	return 0
}

func (m *MasterInfo) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return Default_MasterInfo_Port
}

func (m *MasterInfo) GetPID() string {
	if m != nil && m.PID != nil {
		return *m.PID
	}
	return ""
}

func (m *MasterInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *MasterInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *MasterInfo) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *MasterInfo) GetDomain() *DomainInfo {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *MasterInfo) GetCapabilities() []MasterInfo_Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

type MasterInfo_Capability struct {
	Type MasterInfo_Capability_Type `protobuf:"varint,1,opt,name=type,enum=mesos.MasterInfo_Capability_Type" json:"type"`
}

func (m *MasterInfo_Capability) Reset()                    { *m = MasterInfo_Capability{} }
func (*MasterInfo_Capability) ProtoMessage()               {}
func (*MasterInfo_Capability) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{22, 0} }

func (m *MasterInfo_Capability) GetType() MasterInfo_Capability_Type {
	if m != nil {
		return m.Type
	}
	return MasterInfo_Capability_UNKNOWN
}

// *
// Describes an agent. Note that the 'id' field is only available
// after an agent is registered with the master, and is made available
// here to facilitate re-registration.
type AgentInfo struct {
	Hostname string `protobuf:"bytes,1,req,name=hostname" json:"hostname"`
	Port     *int32 `protobuf:"varint,8,opt,name=port,def=5051" json:"port,omitempty"`
	// The configured resources at the agent. This does not include any
	// dynamic reservations or persistent volumes that may currently
	// exist at the agent.
	Resources  []Resource  `protobuf:"bytes,3,rep,name=resources" json:"resources"`
	Attributes []Attribute `protobuf:"bytes,5,rep,name=attributes" json:"attributes"`
	ID         *AgentID    `protobuf:"bytes,6,opt,name=id" json:"id,omitempty"`
	// The domain that this agent belongs to. If the agent's region
	// differs from the master's region, it will not appear in resource
	// offers to frameworks that have not enabled the REGION_AWARE
	// capability.
	Domain *DomainInfo `protobuf:"bytes,10,opt,name=domain" json:"domain,omitempty"`
}

func (m *AgentInfo) Reset()                    { *m = AgentInfo{} }
func (*AgentInfo) ProtoMessage()               {}
func (*AgentInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{23} }

const Default_AgentInfo_Port int32 = 5051

func (m *AgentInfo) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AgentInfo) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return Default_AgentInfo_Port
}

func (m *AgentInfo) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *AgentInfo) GetAttributes() []Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *AgentInfo) GetID() *AgentID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *AgentInfo) GetDomain() *DomainInfo {
	if m != nil {
		return m.Domain
	}
	return nil
}

type AgentInfo_Capability struct {
	// Enum fields should be optional, see: MESOS-4997.
	Type AgentInfo_Capability_Type `protobuf:"varint,1,opt,name=type,enum=mesos.AgentInfo_Capability_Type" json:"type"`
}

func (m *AgentInfo_Capability) Reset()                    { *m = AgentInfo_Capability{} }
func (*AgentInfo_Capability) ProtoMessage()               {}
func (*AgentInfo_Capability) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{23, 0} }

func (m *AgentInfo_Capability) GetType() AgentInfo_Capability_Type {
	if m != nil {
		return m.Type
	}
	return AgentInfo_Capability_UNKNOWN
}

// *
// Describes the container configuration to run a CSI plugin component.
type CSIPluginContainerInfo struct {
	Services  []CSIPluginContainerInfo_Service `protobuf:"varint,1,rep,name=services,enum=mesos.CSIPluginContainerInfo_Service" json:"services,omitempty"`
	Command   *CommandInfo                     `protobuf:"bytes,2,opt,name=command" json:"command,omitempty"`
	Resources []Resource                       `protobuf:"bytes,3,rep,name=resources" json:"resources"`
	Container *ContainerInfo                   `protobuf:"bytes,4,opt,name=container" json:"container,omitempty"`
}

func (m *CSIPluginContainerInfo) Reset()                    { *m = CSIPluginContainerInfo{} }
func (*CSIPluginContainerInfo) ProtoMessage()               {}
func (*CSIPluginContainerInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{24} }

func (m *CSIPluginContainerInfo) GetServices() []CSIPluginContainerInfo_Service {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *CSIPluginContainerInfo) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *CSIPluginContainerInfo) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *CSIPluginContainerInfo) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

// *
// Describes a CSI plugin.
type CSIPluginInfo struct {
	// The type of the CSI service. This uniquely identifies a CSI
	// implementation. For instance:
	//     org.apache.mesos.csi.test
	//
	// Please follow to Java package naming convention
	// (https://en.wikipedia.org/wiki/Java_package#Package_naming_conventions)
	// to avoid conflicts on type names.
	Type string `protobuf:"bytes,1,req,name=type" json:"type"`
	// The name of the CSI service. There could be mutliple instances of a
	// type of CSI service. The name field is used to distinguish these
	// instances. It should be a legal Java identifier
	// (https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html)
	// to avoid conflicts on concatenation of type and name.
	Name string `protobuf:"bytes,2,req,name=name" json:"name"`
	// A list of container configurations to run CSI plugin components.
	// The controller service will be served by the first configuration
	// that contains `CONTROLLER_SERVICE`, and the node service will be
	// served by the first configuration that contains `NODE_SERVICE`.
	Containers []CSIPluginContainerInfo `protobuf:"bytes,3,rep,name=containers" json:"containers"`
}

func (m *CSIPluginInfo) Reset()                    { *m = CSIPluginInfo{} }
func (*CSIPluginInfo) ProtoMessage()               {}
func (*CSIPluginInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{25} }

func (m *CSIPluginInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CSIPluginInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CSIPluginInfo) GetContainers() []CSIPluginContainerInfo {
	if m != nil {
		return m.Containers
	}
	return nil
}

// *
// Describes a resource provider. Note that the 'id' field is only available
// after a resource provider is registered with the master, and is made
// available here to facilitate re-registration.
type ResourceProviderInfo struct {
	ID         *ResourceProviderID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Attributes []Attribute         `protobuf:"bytes,2,rep,name=attributes" json:"attributes"`
	// The type of the resource provider. This uniquely identifies a
	// resource provider implementation. For instance:
	//     org.apache.mesos.rp.local.storage
	//
	// Please follow to Java package naming convention
	// (https://en.wikipedia.org/wiki/Java_package#Package_naming_conventions)
	// to avoid conflicts on type names.
	Type string `protobuf:"bytes,3,req,name=type" json:"type"`
	// The name of the resource provider. There could be multiple
	// instances of a type of resource provider. The name field is used
	// to distinguish these instances. It should be a legal Java identifier
	// (https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html)
	// to avoid conflicts on concatenation of type and name.
	Name string `protobuf:"bytes,4,req,name=name" json:"name"`
	// The stack of default reservations. If this field is not empty, it
	// indicates that resources from this resource provider are reserved
	// by default, except for the resources that have been reserved or
	// unreserved through operations. The first `ReservationInfo`
	// may have type `STATIC` or `DYNAMIC`, but the rest must have
	// `DYNAMIC`. One can create a new reservation on top of an existing
	// one by pushing a new `ReservationInfo` to the back. The last
	// `ReservationInfo` in this stack is the "current" reservation. The
	// new reservation's role must be a child of the current one.
	DefaultReservations []Resource_ReservationInfo    `protobuf:"bytes,5,rep,name=default_reservations,json=defaultReservations" json:"default_reservations"`
	Storage             *ResourceProviderInfo_Storage `protobuf:"bytes,6,opt,name=storage" json:"storage,omitempty"`
}

func (m *ResourceProviderInfo) Reset()                    { *m = ResourceProviderInfo{} }
func (*ResourceProviderInfo) ProtoMessage()               {}
func (*ResourceProviderInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{26} }

func (m *ResourceProviderInfo) GetID() *ResourceProviderID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *ResourceProviderInfo) GetAttributes() []Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *ResourceProviderInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ResourceProviderInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResourceProviderInfo) GetDefaultReservations() []Resource_ReservationInfo {
	if m != nil {
		return m.DefaultReservations
	}
	return nil
}

func (m *ResourceProviderInfo) GetStorage() *ResourceProviderInfo_Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

// Storage resource provider related information.
type ResourceProviderInfo_Storage struct {
	Plugin CSIPluginInfo `protobuf:"bytes,1,req,name=plugin" json:"plugin"`
}

func (m *ResourceProviderInfo_Storage) Reset()      { *m = ResourceProviderInfo_Storage{} }
func (*ResourceProviderInfo_Storage) ProtoMessage() {}
func (*ResourceProviderInfo_Storage) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{26, 0}
}

func (m *ResourceProviderInfo_Storage) GetPlugin() CSIPluginInfo {
	if m != nil {
		return m.Plugin
	}
	return CSIPluginInfo{}
}

// *
// Describes an Attribute or Resource "value". A value is described
// using the standard protocol buffer "union" trick.
type Value struct {
	Type   Value_Type    `protobuf:"varint,1,req,name=type,enum=mesos.Value_Type" json:"type"`
	Scalar *Value_Scalar `protobuf:"bytes,2,opt,name=scalar" json:"scalar,omitempty"`
	Ranges *Value_Ranges `protobuf:"bytes,3,opt,name=ranges" json:"ranges,omitempty"`
	Set    *Value_Set    `protobuf:"bytes,4,opt,name=set" json:"set,omitempty"`
	Text   *Value_Text   `protobuf:"bytes,5,opt,name=text" json:"text,omitempty"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{27} }

func (m *Value) GetType() Value_Type {
	if m != nil {
		return m.Type
	}
	return SCALAR
}

func (m *Value) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Value) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Value) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Value) GetText() *Value_Text {
	if m != nil {
		return m.Text
	}
	return nil
}

type Value_Scalar struct {
	// Scalar values are represented using floating point. To reduce
	// the chance of unpredictable floating point behavior due to
	// roundoff error, Mesos only supports three decimal digits of
	// precision for scalar resource values. That is, floating point
	// values are converted to a fixed point format that supports
	// three decimal digits of precision, and then converted back to
	// floating point on output. Any additional precision in scalar
	// resource values is discarded (via rounding).
	Value float64 `protobuf:"fixed64,1,req,name=value" json:"value"`
}

func (m *Value_Scalar) Reset()                    { *m = Value_Scalar{} }
func (*Value_Scalar) ProtoMessage()               {}
func (*Value_Scalar) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{27, 0} }

func (m *Value_Scalar) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type Value_Range struct {
	Begin uint64 `protobuf:"varint,1,req,name=begin" json:"begin"`
	End   uint64 `protobuf:"varint,2,req,name=end" json:"end"`
}

func (m *Value_Range) Reset()                    { *m = Value_Range{} }
func (*Value_Range) ProtoMessage()               {}
func (*Value_Range) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{27, 1} }

func (m *Value_Range) GetBegin() uint64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *Value_Range) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

type Value_Ranges struct {
	Range []Value_Range `protobuf:"bytes,1,rep,name=range" json:"range"`
}

func (m *Value_Ranges) Reset()                    { *m = Value_Ranges{} }
func (*Value_Ranges) ProtoMessage()               {}
func (*Value_Ranges) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{27, 2} }

func (m *Value_Ranges) GetRange() []Value_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

type Value_Set struct {
	Item []string `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
}

func (m *Value_Set) Reset()                    { *m = Value_Set{} }
func (*Value_Set) ProtoMessage()               {}
func (*Value_Set) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{27, 3} }

func (m *Value_Set) GetItem() []string {
	if m != nil {
		return m.Item
	}
	return nil
}

type Value_Text struct {
	Value string `protobuf:"bytes,1,req,name=value" json:"value"`
}

func (m *Value_Text) Reset()                    { *m = Value_Text{} }
func (*Value_Text) ProtoMessage()               {}
func (*Value_Text) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{27, 4} }

func (m *Value_Text) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// Describes an attribute that can be set on a machine. For now,
// attributes and resources share the same "value" type, but this may
// change in the future and attributes may only be string based.
type Attribute struct {
	Name   string        `protobuf:"bytes,1,req,name=name" json:"name"`
	Type   Value_Type    `protobuf:"varint,2,req,name=type,enum=mesos.Value_Type" json:"type"`
	Scalar *Value_Scalar `protobuf:"bytes,3,opt,name=scalar" json:"scalar,omitempty"`
	Ranges *Value_Ranges `protobuf:"bytes,4,opt,name=ranges" json:"ranges,omitempty"`
	Set    *Value_Set    `protobuf:"bytes,6,opt,name=set" json:"set,omitempty"`
	Text   *Value_Text   `protobuf:"bytes,5,opt,name=text" json:"text,omitempty"`
}

func (m *Attribute) Reset()                    { *m = Attribute{} }
func (*Attribute) ProtoMessage()               {}
func (*Attribute) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{28} }

func (m *Attribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Attribute) GetType() Value_Type {
	if m != nil {
		return m.Type
	}
	return SCALAR
}

func (m *Attribute) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Attribute) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Attribute) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Attribute) GetText() *Value_Text {
	if m != nil {
		return m.Text
	}
	return nil
}

// *
// Describes a resource from a resource provider. The `name` field is
// a string like "cpus" or "mem" that indicates which kind of resource
// this is; the rest of the fields describe the properties of the
// resource. A resource can take on one of three types: scalar
// (double), a list of finite and discrete ranges (e.g., [1-10,
// 20-30]), or a set of items. A resource is described using the
// standard protocol buffer "union" trick.
//
// Note that "disk" and "mem" resources are scalar values expressed in
// megabytes. Fractional "cpus" values are allowed (e.g., "0.5"),
// which correspond to partial shares of a CPU.
type Resource struct {
	ProviderID *ResourceProviderID `protobuf:"bytes,12,opt,name=provider_id,json=providerId" json:"provider_id,omitempty"`
	Name       string              `protobuf:"bytes,1,req,name=name" json:"name"`
	Type       *Value_Type         `protobuf:"varint,2,req,name=type,enum=mesos.Value_Type" json:"type,omitempty"`
	Scalar     *Value_Scalar       `protobuf:"bytes,3,opt,name=scalar" json:"scalar,omitempty"`
	Ranges     *Value_Ranges       `protobuf:"bytes,4,opt,name=ranges" json:"ranges,omitempty"`
	Set        *Value_Set          `protobuf:"bytes,5,opt,name=set" json:"set,omitempty"`
	// The role that this resource is reserved for. If "*", this indicates
	// that the resource is unreserved. Otherwise, the resource will only
	// be offered to frameworks that belong to this role.
	//
	// NOTE: Frameworks must not set this field if `reservations` is set.
	//       See the 'Resource Format' section for more details.
	//
	// TODO(mpark): Deprecate once `reservations` is no longer experimental.
	Role           *string                  `protobuf:"bytes,6,opt,name=role,def=*" json:"role,omitempty"`
	AllocationInfo *Resource_AllocationInfo `protobuf:"bytes,11,opt,name=allocation_info,json=allocationInfo" json:"allocation_info,omitempty"`
	// If this is set, this resource was dynamically reserved by an
	// operator or a framework. Otherwise, this resource is either unreserved
	// or statically reserved by an operator via the --resources flag.
	//
	// NOTE: Frameworks must not set this field if `reservations` is set.
	//       See the 'Resource Format' section for more details.
	//
	// TODO(mpark): Deprecate once `reservations` is no longer experimental.
	Reservation *Resource_ReservationInfo `protobuf:"bytes,8,opt,name=reservation" json:"reservation,omitempty"`
	// The stack of reservations. If this field is empty, it indicates that this
	// resource is unreserved. Otherwise, the resource is reserved. The first
	// `ReservationInfo` may have type `STATIC` or `DYNAMIC`, but the rest must
	// have `DYNAMIC`. One can create a new reservation on top of an existing
	// one by pushing a new `ReservationInfo` to the back. The last
	// `ReservationInfo` in this stack is the "current" reservation. The new
	// reservation's role must be a child of the current reservation's role.
	//
	// NOTE: Frameworks must not set this field if `reservation` is set.
	//       See the 'Resource Format' section for more details.
	//
	// TODO(mpark): Deprecate `role` and `reservation` once this is stable.
	Reservations []Resource_ReservationInfo `protobuf:"bytes,13,rep,name=reservations" json:"reservations"`
	Disk         *Resource_DiskInfo         `protobuf:"bytes,7,opt,name=disk" json:"disk,omitempty"`
	// If this is set, the resources are revocable, i.e., any tasks or
	// executors launched using these resources could get preempted or
	// throttled at any time. This could be used by frameworks to run
	// best effort tasks that do not need strict uptime or performance
	// guarantees. Note that if this is set, 'disk' or 'reservation'
	// cannot be set.
	Revocable *Resource_RevocableInfo `protobuf:"bytes,9,opt,name=revocable" json:"revocable,omitempty"`
	// If this is set, the resources are shared, i.e. multiple tasks
	// can be launched using this resource and all of them shall refer
	// to the same physical resource on the cluster. Note that only
	// persistent volumes can be shared currently.
	Shared *Resource_SharedInfo `protobuf:"bytes,10,opt,name=shared" json:"shared,omitempty"`
}

func (m *Resource) Reset()                    { *m = Resource{} }
func (*Resource) ProtoMessage()               {}
func (*Resource) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{29} }

const Default_Resource_Role string = "*"

func (m *Resource) GetProviderID() *ResourceProviderID {
	if m != nil {
		return m.ProviderID
	}
	return nil
}

func (m *Resource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Resource) GetType() Value_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return SCALAR
}

func (m *Resource) GetScalar() *Value_Scalar {
	if m != nil {
		return m.Scalar
	}
	return nil
}

func (m *Resource) GetRanges() *Value_Ranges {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *Resource) GetSet() *Value_Set {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *Resource) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_Resource_Role
}

func (m *Resource) GetAllocationInfo() *Resource_AllocationInfo {
	if m != nil {
		return m.AllocationInfo
	}
	return nil
}

func (m *Resource) GetReservation() *Resource_ReservationInfo {
	if m != nil {
		return m.Reservation
	}
	return nil
}

func (m *Resource) GetReservations() []Resource_ReservationInfo {
	if m != nil {
		return m.Reservations
	}
	return nil
}

func (m *Resource) GetDisk() *Resource_DiskInfo {
	if m != nil {
		return m.Disk
	}
	return nil
}

func (m *Resource) GetRevocable() *Resource_RevocableInfo {
	if m != nil {
		return m.Revocable
	}
	return nil
}

func (m *Resource) GetShared() *Resource_SharedInfo {
	if m != nil {
		return m.Shared
	}
	return nil
}

// This was initially introduced to support MULTI_ROLE capable
// frameworks. Frameworks that are not MULTI_ROLE capable can
// continue to assume that the offered resources are allocated
// to their role.
type Resource_AllocationInfo struct {
	// If set, this resource is allocated to a role. Note that in the
	// future, this may be unset and the scheduler may be responsible
	// for allocating to one of its roles.
	Role *string `protobuf:"bytes,1,opt,name=role" json:"role,omitempty"`
}

func (m *Resource_AllocationInfo) Reset()                    { *m = Resource_AllocationInfo{} }
func (*Resource_AllocationInfo) ProtoMessage()               {}
func (*Resource_AllocationInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{29, 0} }

func (m *Resource_AllocationInfo) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return ""
}

type Resource_ReservationInfo struct {
	// The type of this reservation.
	//
	// NOTE: This field must not be set for `Resource.reservation`.
	//       See the 'Resource Format' section for more details.
	Type *Resource_ReservationInfo_Type `protobuf:"varint,4,opt,name=type,enum=mesos.Resource_ReservationInfo_Type" json:"type,omitempty"`
	// The role to which this reservation is made for.
	//
	// NOTE: This field must not be set for `Resource.reservation`.
	//       See the 'Resource Format' section for more details.
	Role *string `protobuf:"bytes,3,opt,name=role" json:"role,omitempty"`
	// Indicates the principal, if any, of the framework or operator
	// that reserved this resource. If reserved by a framework, the
	// field should match the `FrameworkInfo.principal`. It is used in
	// conjunction with the `UnreserveResources` ACL to determine
	// whether the entity attempting to unreserve this resource is
	// permitted to do so.
	Principal *string `protobuf:"bytes,1,opt,name=principal" json:"principal,omitempty"`
	// Labels are free-form key value pairs that can be used to
	// associate arbitrary metadata with a reserved resource.  For
	// example, frameworks can use labels to identify the intended
	// purpose for a portion of the resources the framework has
	// reserved at a given agent. Labels should not contain duplicate
	// key-value pairs.
	Labels *Labels `protobuf:"bytes,2,opt,name=labels" json:"labels,omitempty"`
}

func (m *Resource_ReservationInfo) Reset()      { *m = Resource_ReservationInfo{} }
func (*Resource_ReservationInfo) ProtoMessage() {}
func (*Resource_ReservationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{29, 1}
}

func (m *Resource_ReservationInfo) GetType() Resource_ReservationInfo_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Resource_ReservationInfo_UNKNOWN
}

func (m *Resource_ReservationInfo) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return ""
}

func (m *Resource_ReservationInfo) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

func (m *Resource_ReservationInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Resource_DiskInfo struct {
	Persistence *Resource_DiskInfo_Persistence `protobuf:"bytes,1,opt,name=persistence" json:"persistence,omitempty"`
	// Describes how this disk resource will be mounted in the
	// container. If not set, the disk resource will be used as the
	// sandbox. Otherwise, it will be mounted according to the
	// 'container_path' inside 'volume'. The 'host_path' inside
	// 'volume' is ignored.
	// NOTE: If 'volume' is set but 'persistence' is not set, the
	// volume will be automatically garbage collected after
	// task/executor terminates. Currently, if 'persistence' is set,
	// 'volume' must be set.
	Volume *Volume                   `protobuf:"bytes,2,opt,name=volume" json:"volume,omitempty"`
	Source *Resource_DiskInfo_Source `protobuf:"bytes,3,opt,name=source" json:"source,omitempty"`
}

func (m *Resource_DiskInfo) Reset()                    { *m = Resource_DiskInfo{} }
func (*Resource_DiskInfo) ProtoMessage()               {}
func (*Resource_DiskInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{29, 2} }

func (m *Resource_DiskInfo) GetPersistence() *Resource_DiskInfo_Persistence {
	if m != nil {
		return m.Persistence
	}
	return nil
}

func (m *Resource_DiskInfo) GetVolume() *Volume {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *Resource_DiskInfo) GetSource() *Resource_DiskInfo_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

// Describes a persistent disk volume.
//
// A persistent disk volume will not be automatically garbage
// collected if the task/executor/agent terminates, but will be
// re-offered to the framework(s) belonging to the 'role'.
//
// NOTE: Currently, we do not allow persistent disk volumes
// without a reservation (i.e., 'role' cannot be '*').
type Resource_DiskInfo_Persistence struct {
	// A unique ID for the persistent disk volume. This ID must be
	// unique per role on each agent. Although it is possible to use
	// the same ID on different agents in the cluster and to reuse
	// IDs after a volume with that ID has been destroyed, both
	// practices are discouraged.
	ID string `protobuf:"bytes,1,req,name=id" json:"id"`
	// This field indicates the principal of the operator or
	// framework that created this volume. It is used in conjunction
	// with the "destroy" ACL to determine whether an entity
	// attempting to destroy the volume is permitted to do so.
	//
	// NOTE: This field should match the FrameworkInfo.principal of
	// the framework that created the volume.
	Principal *string `protobuf:"bytes,2,opt,name=principal" json:"principal,omitempty"`
}

func (m *Resource_DiskInfo_Persistence) Reset()      { *m = Resource_DiskInfo_Persistence{} }
func (*Resource_DiskInfo_Persistence) ProtoMessage() {}
func (*Resource_DiskInfo_Persistence) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{29, 2, 0}
}

func (m *Resource_DiskInfo_Persistence) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Resource_DiskInfo_Persistence) GetPrincipal() string {
	if m != nil && m.Principal != nil {
		return *m.Principal
	}
	return ""
}

// Describes where a disk originates from.
type Resource_DiskInfo_Source struct {
	Type  Resource_DiskInfo_Source_Type   `protobuf:"varint,1,req,name=type,enum=mesos.Resource_DiskInfo_Source_Type" json:"type"`
	Path  *Resource_DiskInfo_Source_Path  `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	Mount *Resource_DiskInfo_Source_Mount `protobuf:"bytes,3,opt,name=mount" json:"mount,omitempty"`
	// An identifier for this source. This field maps onto CSI
	// volume IDs and is not expected to be set by frameworks.
	ID *string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// Additional metadata for this source. This field maps onto CSI
	// volume metadata and is not expected to be set by frameworks.
	Metadata *Labels `protobuf:"bytes,5,opt,name=metadata" json:"metadata,omitempty"`
	// This field serves as an indirection to a set of storage
	// vendor specific disk parameters which describe the properties
	// of the disk. The operator will setup mappings between a
	// profile name to a set of vendor specific disk parameters. And
	// the framework will do disk selection based on profile names,
	// instead of vendor specific disk parameters.
	//
	// Also see the DiskProfileAdaptor module.
	Profile *string `protobuf:"bytes,6,opt,name=profile" json:"profile,omitempty"`
}

func (m *Resource_DiskInfo_Source) Reset()      { *m = Resource_DiskInfo_Source{} }
func (*Resource_DiskInfo_Source) ProtoMessage() {}
func (*Resource_DiskInfo_Source) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{29, 2, 1}
}

func (m *Resource_DiskInfo_Source) GetType() Resource_DiskInfo_Source_Type {
	if m != nil {
		return m.Type
	}
	return Resource_DiskInfo_Source_UNKNOWN
}

func (m *Resource_DiskInfo_Source) GetPath() *Resource_DiskInfo_Source_Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Resource_DiskInfo_Source) GetMount() *Resource_DiskInfo_Source_Mount {
	if m != nil {
		return m.Mount
	}
	return nil
}

func (m *Resource_DiskInfo_Source) GetID() string {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return ""
}

func (m *Resource_DiskInfo_Source) GetMetadata() *Labels {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Resource_DiskInfo_Source) GetProfile() string {
	if m != nil && m.Profile != nil {
		return *m.Profile
	}
	return ""
}

// A folder that can be located on a separate disk device. This
// can be shared and carved up as necessary between frameworks.
type Resource_DiskInfo_Source_Path struct {
	// Path to the folder (e.g., /mnt/raid/disk0). If the path is a
	// relative path, it is relative to the agent work directory.
	Root *string `protobuf:"bytes,1,opt,name=root" json:"root,omitempty"`
}

func (m *Resource_DiskInfo_Source_Path) Reset()      { *m = Resource_DiskInfo_Source_Path{} }
func (*Resource_DiskInfo_Source_Path) ProtoMessage() {}
func (*Resource_DiskInfo_Source_Path) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{29, 2, 1, 0}
}

func (m *Resource_DiskInfo_Source_Path) GetRoot() string {
	if m != nil && m.Root != nil {
		return *m.Root
	}
	return ""
}

// A mounted file-system set up by the Agent administrator. This
// can only be used exclusively: a framework cannot accept a
// partial amount of this disk.
type Resource_DiskInfo_Source_Mount struct {
	// Path to mount point (e.g., /mnt/raid/disk0). If the path is a
	// relative path, it is relative to the agent work directory.
	Root *string `protobuf:"bytes,1,opt,name=root" json:"root,omitempty"`
}

func (m *Resource_DiskInfo_Source_Mount) Reset()      { *m = Resource_DiskInfo_Source_Mount{} }
func (*Resource_DiskInfo_Source_Mount) ProtoMessage() {}
func (*Resource_DiskInfo_Source_Mount) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{29, 2, 1, 1}
}

func (m *Resource_DiskInfo_Source_Mount) GetRoot() string {
	if m != nil && m.Root != nil {
		return *m.Root
	}
	return ""
}

type Resource_RevocableInfo struct {
}

func (m *Resource_RevocableInfo) Reset()                    { *m = Resource_RevocableInfo{} }
func (*Resource_RevocableInfo) ProtoMessage()               {}
func (*Resource_RevocableInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{29, 3} }

// Allow the resource to be shared across tasks.
type Resource_SharedInfo struct {
}

func (m *Resource_SharedInfo) Reset()                    { *m = Resource_SharedInfo{} }
func (*Resource_SharedInfo) ProtoMessage()               {}
func (*Resource_SharedInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{29, 4} }

// *
// When the network bandwidth caps are enabled and the container
// is over its limit, outbound packets may be either delayed or
// dropped completely either because it exceeds the maximum bandwidth
// allocation for a single container (the cap) or because the combined
// network traffic of multiple containers on the host exceeds the
// transmit capacity of the host (the share). We can report the
// following statistics for each of these conditions exported directly
// from the Linux Traffic Control Queueing Discipline.
//
// id         : name of the limiter, e.g. 'tx_bw_cap'
// backlog    : number of packets currently delayed
// bytes      : total bytes seen
// drops      : number of packets dropped in total
// overlimits : number of packets which exceeded allocation
// packets    : total packets seen
// qlen       : number of packets currently queued
// rate_bps   : throughput in bytes/sec
// rate_pps   : throughput in packets/sec
// requeues   : number of times a packet has been delayed due to
//              locking or device contention issues
//
// More information on the operation of Linux Traffic Control can be
// found at http://www.lartc.org/lartc.html.
type TrafficControlStatistics struct {
	ID         string  `protobuf:"bytes,1,req,name=id" json:"id"`
	Backlog    *uint64 `protobuf:"varint,2,opt,name=backlog" json:"backlog,omitempty"`
	Bytes      *uint64 `protobuf:"varint,3,opt,name=bytes" json:"bytes,omitempty"`
	Drops      *uint64 `protobuf:"varint,4,opt,name=drops" json:"drops,omitempty"`
	Overlimits *uint64 `protobuf:"varint,5,opt,name=overlimits" json:"overlimits,omitempty"`
	Packets    *uint64 `protobuf:"varint,6,opt,name=packets" json:"packets,omitempty"`
	Qlen       *uint64 `protobuf:"varint,7,opt,name=qlen" json:"qlen,omitempty"`
	RateBPS    *uint64 `protobuf:"varint,8,opt,name=ratebps" json:"ratebps,omitempty"`
	RatePPS    *uint64 `protobuf:"varint,9,opt,name=ratepps" json:"ratepps,omitempty"`
	Requeues   *uint64 `protobuf:"varint,10,opt,name=requeues" json:"requeues,omitempty"`
}

func (m *TrafficControlStatistics) Reset()                    { *m = TrafficControlStatistics{} }
func (*TrafficControlStatistics) ProtoMessage()               {}
func (*TrafficControlStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{30} }

func (m *TrafficControlStatistics) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *TrafficControlStatistics) GetBacklog() uint64 {
	if m != nil && m.Backlog != nil {
		return *m.Backlog
	}
	return 0
}

func (m *TrafficControlStatistics) GetBytes() uint64 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

func (m *TrafficControlStatistics) GetDrops() uint64 {
	if m != nil && m.Drops != nil {
		return *m.Drops
	}
	return 0
}

func (m *TrafficControlStatistics) GetOverlimits() uint64 {
	if m != nil && m.Overlimits != nil {
		return *m.Overlimits
	}
	return 0
}

func (m *TrafficControlStatistics) GetPackets() uint64 {
	if m != nil && m.Packets != nil {
		return *m.Packets
	}
	return 0
}

func (m *TrafficControlStatistics) GetQlen() uint64 {
	if m != nil && m.Qlen != nil {
		return *m.Qlen
	}
	return 0
}

func (m *TrafficControlStatistics) GetRateBPS() uint64 {
	if m != nil && m.RateBPS != nil {
		return *m.RateBPS
	}
	return 0
}

func (m *TrafficControlStatistics) GetRatePPS() uint64 {
	if m != nil && m.RatePPS != nil {
		return *m.RatePPS
	}
	return 0
}

func (m *TrafficControlStatistics) GetRequeues() uint64 {
	if m != nil && m.Requeues != nil {
		return *m.Requeues
	}
	return 0
}

type IpStatistics struct {
	Forwarding      *int64 `protobuf:"varint,1,opt,name=Forwarding" json:"Forwarding,omitempty"`
	DefaultTTL      *int64 `protobuf:"varint,2,opt,name=DefaultTTL" json:"DefaultTTL,omitempty"`
	InReceives      *int64 `protobuf:"varint,3,opt,name=InReceives" json:"InReceives,omitempty"`
	InHdrErrors     *int64 `protobuf:"varint,4,opt,name=InHdrErrors" json:"InHdrErrors,omitempty"`
	InAddrErrors    *int64 `protobuf:"varint,5,opt,name=InAddrErrors" json:"InAddrErrors,omitempty"`
	ForwDatagrams   *int64 `protobuf:"varint,6,opt,name=ForwDatagrams" json:"ForwDatagrams,omitempty"`
	InUnknownProtos *int64 `protobuf:"varint,7,opt,name=InUnknownProtos" json:"InUnknownProtos,omitempty"`
	InDiscards      *int64 `protobuf:"varint,8,opt,name=InDiscards" json:"InDiscards,omitempty"`
	InDelivers      *int64 `protobuf:"varint,9,opt,name=InDelivers" json:"InDelivers,omitempty"`
	OutRequests     *int64 `protobuf:"varint,10,opt,name=OutRequests" json:"OutRequests,omitempty"`
	OutDiscards     *int64 `protobuf:"varint,11,opt,name=OutDiscards" json:"OutDiscards,omitempty"`
	OutNoRoutes     *int64 `protobuf:"varint,12,opt,name=OutNoRoutes" json:"OutNoRoutes,omitempty"`
	ReasmTimeout    *int64 `protobuf:"varint,13,opt,name=ReasmTimeout" json:"ReasmTimeout,omitempty"`
	ReasmReqds      *int64 `protobuf:"varint,14,opt,name=ReasmReqds" json:"ReasmReqds,omitempty"`
	ReasmOKs        *int64 `protobuf:"varint,15,opt,name=ReasmOKs" json:"ReasmOKs,omitempty"`
	ReasmFails      *int64 `protobuf:"varint,16,opt,name=ReasmFails" json:"ReasmFails,omitempty"`
	FragOKs         *int64 `protobuf:"varint,17,opt,name=FragOKs" json:"FragOKs,omitempty"`
	FragFails       *int64 `protobuf:"varint,18,opt,name=FragFails" json:"FragFails,omitempty"`
	FragCreates     *int64 `protobuf:"varint,19,opt,name=FragCreates" json:"FragCreates,omitempty"`
}

func (m *IpStatistics) Reset()                    { *m = IpStatistics{} }
func (*IpStatistics) ProtoMessage()               {}
func (*IpStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{31} }

func (m *IpStatistics) GetForwarding() int64 {
	if m != nil && m.Forwarding != nil {
		return *m.Forwarding
	}
	return 0
}

func (m *IpStatistics) GetDefaultTTL() int64 {
	if m != nil && m.DefaultTTL != nil {
		return *m.DefaultTTL
	}
	return 0
}

func (m *IpStatistics) GetInReceives() int64 {
	if m != nil && m.InReceives != nil {
		return *m.InReceives
	}
	return 0
}

func (m *IpStatistics) GetInHdrErrors() int64 {
	if m != nil && m.InHdrErrors != nil {
		return *m.InHdrErrors
	}
	return 0
}

func (m *IpStatistics) GetInAddrErrors() int64 {
	if m != nil && m.InAddrErrors != nil {
		return *m.InAddrErrors
	}
	return 0
}

func (m *IpStatistics) GetForwDatagrams() int64 {
	if m != nil && m.ForwDatagrams != nil {
		return *m.ForwDatagrams
	}
	return 0
}

func (m *IpStatistics) GetInUnknownProtos() int64 {
	if m != nil && m.InUnknownProtos != nil {
		return *m.InUnknownProtos
	}
	return 0
}

func (m *IpStatistics) GetInDiscards() int64 {
	if m != nil && m.InDiscards != nil {
		return *m.InDiscards
	}
	return 0
}

func (m *IpStatistics) GetInDelivers() int64 {
	if m != nil && m.InDelivers != nil {
		return *m.InDelivers
	}
	return 0
}

func (m *IpStatistics) GetOutRequests() int64 {
	if m != nil && m.OutRequests != nil {
		return *m.OutRequests
	}
	return 0
}

func (m *IpStatistics) GetOutDiscards() int64 {
	if m != nil && m.OutDiscards != nil {
		return *m.OutDiscards
	}
	return 0
}

func (m *IpStatistics) GetOutNoRoutes() int64 {
	if m != nil && m.OutNoRoutes != nil {
		return *m.OutNoRoutes
	}
	return 0
}

func (m *IpStatistics) GetReasmTimeout() int64 {
	if m != nil && m.ReasmTimeout != nil {
		return *m.ReasmTimeout
	}
	return 0
}

func (m *IpStatistics) GetReasmReqds() int64 {
	if m != nil && m.ReasmReqds != nil {
		return *m.ReasmReqds
	}
	return 0
}

func (m *IpStatistics) GetReasmOKs() int64 {
	if m != nil && m.ReasmOKs != nil {
		return *m.ReasmOKs
	}
	return 0
}

func (m *IpStatistics) GetReasmFails() int64 {
	if m != nil && m.ReasmFails != nil {
		return *m.ReasmFails
	}
	return 0
}

func (m *IpStatistics) GetFragOKs() int64 {
	if m != nil && m.FragOKs != nil {
		return *m.FragOKs
	}
	return 0
}

func (m *IpStatistics) GetFragFails() int64 {
	if m != nil && m.FragFails != nil {
		return *m.FragFails
	}
	return 0
}

func (m *IpStatistics) GetFragCreates() int64 {
	if m != nil && m.FragCreates != nil {
		return *m.FragCreates
	}
	return 0
}

type IcmpStatistics struct {
	InMsgs           *int64 `protobuf:"varint,1,opt,name=InMsgs" json:"InMsgs,omitempty"`
	InErrors         *int64 `protobuf:"varint,2,opt,name=InErrors" json:"InErrors,omitempty"`
	InCsumErrors     *int64 `protobuf:"varint,3,opt,name=InCsumErrors" json:"InCsumErrors,omitempty"`
	InDestUnreachs   *int64 `protobuf:"varint,4,opt,name=InDestUnreachs" json:"InDestUnreachs,omitempty"`
	InTimeExcds      *int64 `protobuf:"varint,5,opt,name=InTimeExcds" json:"InTimeExcds,omitempty"`
	InParmProbs      *int64 `protobuf:"varint,6,opt,name=InParmProbs" json:"InParmProbs,omitempty"`
	InSrcQuenchs     *int64 `protobuf:"varint,7,opt,name=InSrcQuenchs" json:"InSrcQuenchs,omitempty"`
	InRedirects      *int64 `protobuf:"varint,8,opt,name=InRedirects" json:"InRedirects,omitempty"`
	InEchos          *int64 `protobuf:"varint,9,opt,name=InEchos" json:"InEchos,omitempty"`
	InEchoReps       *int64 `protobuf:"varint,10,opt,name=InEchoReps" json:"InEchoReps,omitempty"`
	InTimestamps     *int64 `protobuf:"varint,11,opt,name=InTimestamps" json:"InTimestamps,omitempty"`
	InTimestampReps  *int64 `protobuf:"varint,12,opt,name=InTimestampReps" json:"InTimestampReps,omitempty"`
	InAddrMasks      *int64 `protobuf:"varint,13,opt,name=InAddrMasks" json:"InAddrMasks,omitempty"`
	InAddrMaskReps   *int64 `protobuf:"varint,14,opt,name=InAddrMaskReps" json:"InAddrMaskReps,omitempty"`
	OutMsgs          *int64 `protobuf:"varint,15,opt,name=OutMsgs" json:"OutMsgs,omitempty"`
	OutErrors        *int64 `protobuf:"varint,16,opt,name=OutErrors" json:"OutErrors,omitempty"`
	OutDestUnreachs  *int64 `protobuf:"varint,17,opt,name=OutDestUnreachs" json:"OutDestUnreachs,omitempty"`
	OutTimeExcds     *int64 `protobuf:"varint,18,opt,name=OutTimeExcds" json:"OutTimeExcds,omitempty"`
	OutParmProbs     *int64 `protobuf:"varint,19,opt,name=OutParmProbs" json:"OutParmProbs,omitempty"`
	OutSrcQuenchs    *int64 `protobuf:"varint,20,opt,name=OutSrcQuenchs" json:"OutSrcQuenchs,omitempty"`
	OutRedirects     *int64 `protobuf:"varint,21,opt,name=OutRedirects" json:"OutRedirects,omitempty"`
	OutEchos         *int64 `protobuf:"varint,22,opt,name=OutEchos" json:"OutEchos,omitempty"`
	OutEchoReps      *int64 `protobuf:"varint,23,opt,name=OutEchoReps" json:"OutEchoReps,omitempty"`
	OutTimestamps    *int64 `protobuf:"varint,24,opt,name=OutTimestamps" json:"OutTimestamps,omitempty"`
	OutTimestampReps *int64 `protobuf:"varint,25,opt,name=OutTimestampReps" json:"OutTimestampReps,omitempty"`
	OutAddrMasks     *int64 `protobuf:"varint,26,opt,name=OutAddrMasks" json:"OutAddrMasks,omitempty"`
	OutAddrMaskReps  *int64 `protobuf:"varint,27,opt,name=OutAddrMaskReps" json:"OutAddrMaskReps,omitempty"`
}

func (m *IcmpStatistics) Reset()                    { *m = IcmpStatistics{} }
func (*IcmpStatistics) ProtoMessage()               {}
func (*IcmpStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{32} }

func (m *IcmpStatistics) GetInMsgs() int64 {
	if m != nil && m.InMsgs != nil {
		return *m.InMsgs
	}
	return 0
}

func (m *IcmpStatistics) GetInErrors() int64 {
	if m != nil && m.InErrors != nil {
		return *m.InErrors
	}
	return 0
}

func (m *IcmpStatistics) GetInCsumErrors() int64 {
	if m != nil && m.InCsumErrors != nil {
		return *m.InCsumErrors
	}
	return 0
}

func (m *IcmpStatistics) GetInDestUnreachs() int64 {
	if m != nil && m.InDestUnreachs != nil {
		return *m.InDestUnreachs
	}
	return 0
}

func (m *IcmpStatistics) GetInTimeExcds() int64 {
	if m != nil && m.InTimeExcds != nil {
		return *m.InTimeExcds
	}
	return 0
}

func (m *IcmpStatistics) GetInParmProbs() int64 {
	if m != nil && m.InParmProbs != nil {
		return *m.InParmProbs
	}
	return 0
}

func (m *IcmpStatistics) GetInSrcQuenchs() int64 {
	if m != nil && m.InSrcQuenchs != nil {
		return *m.InSrcQuenchs
	}
	return 0
}

func (m *IcmpStatistics) GetInRedirects() int64 {
	if m != nil && m.InRedirects != nil {
		return *m.InRedirects
	}
	return 0
}

func (m *IcmpStatistics) GetInEchos() int64 {
	if m != nil && m.InEchos != nil {
		return *m.InEchos
	}
	return 0
}

func (m *IcmpStatistics) GetInEchoReps() int64 {
	if m != nil && m.InEchoReps != nil {
		return *m.InEchoReps
	}
	return 0
}

func (m *IcmpStatistics) GetInTimestamps() int64 {
	if m != nil && m.InTimestamps != nil {
		return *m.InTimestamps
	}
	return 0
}

func (m *IcmpStatistics) GetInTimestampReps() int64 {
	if m != nil && m.InTimestampReps != nil {
		return *m.InTimestampReps
	}
	return 0
}

func (m *IcmpStatistics) GetInAddrMasks() int64 {
	if m != nil && m.InAddrMasks != nil {
		return *m.InAddrMasks
	}
	return 0
}

func (m *IcmpStatistics) GetInAddrMaskReps() int64 {
	if m != nil && m.InAddrMaskReps != nil {
		return *m.InAddrMaskReps
	}
	return 0
}

func (m *IcmpStatistics) GetOutMsgs() int64 {
	if m != nil && m.OutMsgs != nil {
		return *m.OutMsgs
	}
	return 0
}

func (m *IcmpStatistics) GetOutErrors() int64 {
	if m != nil && m.OutErrors != nil {
		return *m.OutErrors
	}
	return 0
}

func (m *IcmpStatistics) GetOutDestUnreachs() int64 {
	if m != nil && m.OutDestUnreachs != nil {
		return *m.OutDestUnreachs
	}
	return 0
}

func (m *IcmpStatistics) GetOutTimeExcds() int64 {
	if m != nil && m.OutTimeExcds != nil {
		return *m.OutTimeExcds
	}
	return 0
}

func (m *IcmpStatistics) GetOutParmProbs() int64 {
	if m != nil && m.OutParmProbs != nil {
		return *m.OutParmProbs
	}
	return 0
}

func (m *IcmpStatistics) GetOutSrcQuenchs() int64 {
	if m != nil && m.OutSrcQuenchs != nil {
		return *m.OutSrcQuenchs
	}
	return 0
}

func (m *IcmpStatistics) GetOutRedirects() int64 {
	if m != nil && m.OutRedirects != nil {
		return *m.OutRedirects
	}
	return 0
}

func (m *IcmpStatistics) GetOutEchos() int64 {
	if m != nil && m.OutEchos != nil {
		return *m.OutEchos
	}
	return 0
}

func (m *IcmpStatistics) GetOutEchoReps() int64 {
	if m != nil && m.OutEchoReps != nil {
		return *m.OutEchoReps
	}
	return 0
}

func (m *IcmpStatistics) GetOutTimestamps() int64 {
	if m != nil && m.OutTimestamps != nil {
		return *m.OutTimestamps
	}
	return 0
}

func (m *IcmpStatistics) GetOutTimestampReps() int64 {
	if m != nil && m.OutTimestampReps != nil {
		return *m.OutTimestampReps
	}
	return 0
}

func (m *IcmpStatistics) GetOutAddrMasks() int64 {
	if m != nil && m.OutAddrMasks != nil {
		return *m.OutAddrMasks
	}
	return 0
}

func (m *IcmpStatistics) GetOutAddrMaskReps() int64 {
	if m != nil && m.OutAddrMaskReps != nil {
		return *m.OutAddrMaskReps
	}
	return 0
}

type TcpStatistics struct {
	RtoAlgorithm *int64 `protobuf:"varint,1,opt,name=RtoAlgorithm" json:"RtoAlgorithm,omitempty"`
	RtoMin       *int64 `protobuf:"varint,2,opt,name=RtoMin" json:"RtoMin,omitempty"`
	RtoMax       *int64 `protobuf:"varint,3,opt,name=RtoMax" json:"RtoMax,omitempty"`
	MaxConn      *int64 `protobuf:"varint,4,opt,name=MaxConn" json:"MaxConn,omitempty"`
	ActiveOpens  *int64 `protobuf:"varint,5,opt,name=ActiveOpens" json:"ActiveOpens,omitempty"`
	PassiveOpens *int64 `protobuf:"varint,6,opt,name=PassiveOpens" json:"PassiveOpens,omitempty"`
	AttemptFails *int64 `protobuf:"varint,7,opt,name=AttemptFails" json:"AttemptFails,omitempty"`
	EstabResets  *int64 `protobuf:"varint,8,opt,name=EstabResets" json:"EstabResets,omitempty"`
	CurrEstab    *int64 `protobuf:"varint,9,opt,name=CurrEstab" json:"CurrEstab,omitempty"`
	InSegs       *int64 `protobuf:"varint,10,opt,name=InSegs" json:"InSegs,omitempty"`
	OutSegs      *int64 `protobuf:"varint,11,opt,name=OutSegs" json:"OutSegs,omitempty"`
	RetransSegs  *int64 `protobuf:"varint,12,opt,name=RetransSegs" json:"RetransSegs,omitempty"`
	InErrs       *int64 `protobuf:"varint,13,opt,name=InErrs" json:"InErrs,omitempty"`
	OutRsts      *int64 `protobuf:"varint,14,opt,name=OutRsts" json:"OutRsts,omitempty"`
	InCsumErrors *int64 `protobuf:"varint,15,opt,name=InCsumErrors" json:"InCsumErrors,omitempty"`
}

func (m *TcpStatistics) Reset()                    { *m = TcpStatistics{} }
func (*TcpStatistics) ProtoMessage()               {}
func (*TcpStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{33} }

func (m *TcpStatistics) GetRtoAlgorithm() int64 {
	if m != nil && m.RtoAlgorithm != nil {
		return *m.RtoAlgorithm
	}
	return 0
}

func (m *TcpStatistics) GetRtoMin() int64 {
	if m != nil && m.RtoMin != nil {
		return *m.RtoMin
	}
	return 0
}

func (m *TcpStatistics) GetRtoMax() int64 {
	if m != nil && m.RtoMax != nil {
		return *m.RtoMax
	}
	return 0
}

func (m *TcpStatistics) GetMaxConn() int64 {
	if m != nil && m.MaxConn != nil {
		return *m.MaxConn
	}
	return 0
}

func (m *TcpStatistics) GetActiveOpens() int64 {
	if m != nil && m.ActiveOpens != nil {
		return *m.ActiveOpens
	}
	return 0
}

func (m *TcpStatistics) GetPassiveOpens() int64 {
	if m != nil && m.PassiveOpens != nil {
		return *m.PassiveOpens
	}
	return 0
}

func (m *TcpStatistics) GetAttemptFails() int64 {
	if m != nil && m.AttemptFails != nil {
		return *m.AttemptFails
	}
	return 0
}

func (m *TcpStatistics) GetEstabResets() int64 {
	if m != nil && m.EstabResets != nil {
		return *m.EstabResets
	}
	return 0
}

func (m *TcpStatistics) GetCurrEstab() int64 {
	if m != nil && m.CurrEstab != nil {
		return *m.CurrEstab
	}
	return 0
}

func (m *TcpStatistics) GetInSegs() int64 {
	if m != nil && m.InSegs != nil {
		return *m.InSegs
	}
	return 0
}

func (m *TcpStatistics) GetOutSegs() int64 {
	if m != nil && m.OutSegs != nil {
		return *m.OutSegs
	}
	return 0
}

func (m *TcpStatistics) GetRetransSegs() int64 {
	if m != nil && m.RetransSegs != nil {
		return *m.RetransSegs
	}
	return 0
}

func (m *TcpStatistics) GetInErrs() int64 {
	if m != nil && m.InErrs != nil {
		return *m.InErrs
	}
	return 0
}

func (m *TcpStatistics) GetOutRsts() int64 {
	if m != nil && m.OutRsts != nil {
		return *m.OutRsts
	}
	return 0
}

func (m *TcpStatistics) GetInCsumErrors() int64 {
	if m != nil && m.InCsumErrors != nil {
		return *m.InCsumErrors
	}
	return 0
}

type UdpStatistics struct {
	InDatagrams  *int64 `protobuf:"varint,1,opt,name=InDatagrams" json:"InDatagrams,omitempty"`
	NoPorts      *int64 `protobuf:"varint,2,opt,name=NoPorts" json:"NoPorts,omitempty"`
	InErrors     *int64 `protobuf:"varint,3,opt,name=InErrors" json:"InErrors,omitempty"`
	OutDatagrams *int64 `protobuf:"varint,4,opt,name=OutDatagrams" json:"OutDatagrams,omitempty"`
	RcvbufErrors *int64 `protobuf:"varint,5,opt,name=RcvbufErrors" json:"RcvbufErrors,omitempty"`
	SndbufErrors *int64 `protobuf:"varint,6,opt,name=SndbufErrors" json:"SndbufErrors,omitempty"`
	InCsumErrors *int64 `protobuf:"varint,7,opt,name=InCsumErrors" json:"InCsumErrors,omitempty"`
	IgnoredMulti *int64 `protobuf:"varint,8,opt,name=IgnoredMulti" json:"IgnoredMulti,omitempty"`
}

func (m *UdpStatistics) Reset()                    { *m = UdpStatistics{} }
func (*UdpStatistics) ProtoMessage()               {}
func (*UdpStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{34} }

func (m *UdpStatistics) GetInDatagrams() int64 {
	if m != nil && m.InDatagrams != nil {
		return *m.InDatagrams
	}
	return 0
}

func (m *UdpStatistics) GetNoPorts() int64 {
	if m != nil && m.NoPorts != nil {
		return *m.NoPorts
	}
	return 0
}

func (m *UdpStatistics) GetInErrors() int64 {
	if m != nil && m.InErrors != nil {
		return *m.InErrors
	}
	return 0
}

func (m *UdpStatistics) GetOutDatagrams() int64 {
	if m != nil && m.OutDatagrams != nil {
		return *m.OutDatagrams
	}
	return 0
}

func (m *UdpStatistics) GetRcvbufErrors() int64 {
	if m != nil && m.RcvbufErrors != nil {
		return *m.RcvbufErrors
	}
	return 0
}

func (m *UdpStatistics) GetSndbufErrors() int64 {
	if m != nil && m.SndbufErrors != nil {
		return *m.SndbufErrors
	}
	return 0
}

func (m *UdpStatistics) GetInCsumErrors() int64 {
	if m != nil && m.InCsumErrors != nil {
		return *m.InCsumErrors
	}
	return 0
}

func (m *UdpStatistics) GetIgnoredMulti() int64 {
	if m != nil && m.IgnoredMulti != nil {
		return *m.IgnoredMulti
	}
	return 0
}

type SNMPStatistics struct {
	IPStats   *IpStatistics   `protobuf:"bytes,1,opt,name=ip_stats,json=ipStats" json:"ip_stats,omitempty"`
	ICMPStats *IcmpStatistics `protobuf:"bytes,2,opt,name=icmp_stats,json=icmpStats" json:"icmp_stats,omitempty"`
	TCPStats  *TcpStatistics  `protobuf:"bytes,3,opt,name=tcp_stats,json=tcpStats" json:"tcp_stats,omitempty"`
	UDPStats  *UdpStatistics  `protobuf:"bytes,4,opt,name=udp_stats,json=udpStats" json:"udp_stats,omitempty"`
}

func (m *SNMPStatistics) Reset()                    { *m = SNMPStatistics{} }
func (*SNMPStatistics) ProtoMessage()               {}
func (*SNMPStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{35} }

func (m *SNMPStatistics) GetIPStats() *IpStatistics {
	if m != nil {
		return m.IPStats
	}
	return nil
}

func (m *SNMPStatistics) GetICMPStats() *IcmpStatistics {
	if m != nil {
		return m.ICMPStats
	}
	return nil
}

func (m *SNMPStatistics) GetTCPStats() *TcpStatistics {
	if m != nil {
		return m.TCPStats
	}
	return nil
}

func (m *SNMPStatistics) GetUDPStats() *UdpStatistics {
	if m != nil {
		return m.UDPStats
	}
	return nil
}

type DiskStatistics struct {
	Source      *Resource_DiskInfo_Source      `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Persistence *Resource_DiskInfo_Persistence `protobuf:"bytes,2,opt,name=persistence" json:"persistence,omitempty"`
	LimitBytes  *uint64                        `protobuf:"varint,3,opt,name=limit_bytes,json=limitBytes" json:"limit_bytes,omitempty"`
	UsedBytes   *uint64                        `protobuf:"varint,4,opt,name=used_bytes,json=usedBytes" json:"used_bytes,omitempty"`
}

func (m *DiskStatistics) Reset()                    { *m = DiskStatistics{} }
func (*DiskStatistics) ProtoMessage()               {}
func (*DiskStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{36} }

func (m *DiskStatistics) GetSource() *Resource_DiskInfo_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *DiskStatistics) GetPersistence() *Resource_DiskInfo_Persistence {
	if m != nil {
		return m.Persistence
	}
	return nil
}

func (m *DiskStatistics) GetLimitBytes() uint64 {
	if m != nil && m.LimitBytes != nil {
		return *m.LimitBytes
	}
	return 0
}

func (m *DiskStatistics) GetUsedBytes() uint64 {
	if m != nil && m.UsedBytes != nil {
		return *m.UsedBytes
	}
	return 0
}

// *
// A snapshot of resource usage statistics.
type ResourceStatistics struct {
	Timestamp float64 `protobuf:"fixed64,1,req,name=timestamp" json:"timestamp"`
	Processes *uint32 `protobuf:"varint,30,opt,name=processes" json:"processes,omitempty"`
	Threads   *uint32 `protobuf:"varint,31,opt,name=threads" json:"threads,omitempty"`
	// CPU Usage Information:
	// Total CPU time spent in user mode, and kernel mode.
	CPUsUserTimeSecs   *float64 `protobuf:"fixed64,2,opt,name=cpus_user_time_secs,json=cpusUserTimeSecs" json:"cpus_user_time_secs,omitempty"`
	CPUsSystemTimeSecs *float64 `protobuf:"fixed64,3,opt,name=cpus_system_time_secs,json=cpusSystemTimeSecs" json:"cpus_system_time_secs,omitempty"`
	// Number of CPUs allocated.
	CPUsLimit *float64 `protobuf:"fixed64,4,opt,name=cpus_limit,json=cpusLimit" json:"cpus_limit,omitempty"`
	// cpu.stat on process throttling (for contention issues).
	CPUsNrPeriods         *uint32  `protobuf:"varint,7,opt,name=cpus_nr_periods,json=cpusNrPeriods" json:"cpus_nr_periods,omitempty"`
	CPUsNrThrottled       *uint32  `protobuf:"varint,8,opt,name=cpus_nr_throttled,json=cpusNrThrottled" json:"cpus_nr_throttled,omitempty"`
	CPUsThrottledTimeSecs *float64 `protobuf:"fixed64,9,opt,name=cpus_throttled_time_secs,json=cpusThrottledTimeSecs" json:"cpus_throttled_time_secs,omitempty"`
	// mem_total_bytes was added in 0.23.0 to represent the total memory
	// of a process in RAM (as opposed to in Swap). This was previously
	// reported as mem_rss_bytes, which was also changed in 0.23.0 to
	// represent only the anonymous memory usage, to keep in sync with
	// Linux kernel's (arguably erroneous) use of terminology.
	MemTotalBytes *uint64 `protobuf:"varint,36,opt,name=mem_total_bytes,json=memTotalBytes" json:"mem_total_bytes,omitempty"`
	// Total memory + swap usage. This is set if swap is enabled.
	MemTotalMemswBytes *uint64 `protobuf:"varint,37,opt,name=mem_total_memsw_bytes,json=memTotalMemswBytes" json:"mem_total_memsw_bytes,omitempty"`
	// Hard memory limit for a container.
	MemLimitBytes *uint64 `protobuf:"varint,6,opt,name=mem_limit_bytes,json=memLimitBytes" json:"mem_limit_bytes,omitempty"`
	// Soft memory limit for a container.
	MemSoftLimitBytes *uint64 `protobuf:"varint,38,opt,name=mem_soft_limit_bytes,json=memSoftLimitBytes" json:"mem_soft_limit_bytes,omitempty"`
	// TODO(chzhcn) mem_file_bytes and mem_anon_bytes are deprecated in
	// 0.23.0 and will be removed in 0.24.0.
	MemFileBytes *uint64 `protobuf:"varint,10,opt,name=mem_file_bytes,json=memFileBytes" json:"mem_file_bytes,omitempty"`
	MemAnonBytes *uint64 `protobuf:"varint,11,opt,name=mem_anon_bytes,json=memAnonBytes" json:"mem_anon_bytes,omitempty"`
	// mem_cache_bytes is added in 0.23.0 to represent page cache usage.
	MemCacheBytes *uint64 `protobuf:"varint,39,opt,name=mem_cache_bytes,json=memCacheBytes" json:"mem_cache_bytes,omitempty"`
	// Since 0.23.0, mem_rss_bytes is changed to represent only
	// anonymous memory usage. Note that neither its requiredness, type,
	// name nor numeric tag has been changed.
	MemRSSBytes        *uint64 `protobuf:"varint,5,opt,name=mem_rss_bytes,json=memRssBytes" json:"mem_rss_bytes,omitempty"`
	MemMappedFileBytes *uint64 `protobuf:"varint,12,opt,name=mem_mapped_file_bytes,json=memMappedFileBytes" json:"mem_mapped_file_bytes,omitempty"`
	// This is only set if swap is enabled.
	MemSwapBytes        *uint64 `protobuf:"varint,40,opt,name=mem_swap_bytes,json=memSwapBytes" json:"mem_swap_bytes,omitempty"`
	MemUnevictableBytes *uint64 `protobuf:"varint,41,opt,name=mem_unevictable_bytes,json=memUnevictableBytes" json:"mem_unevictable_bytes,omitempty"`
	// Number of occurrences of different levels of memory pressure
	// events reported by memory cgroup. Pressure listening (re)starts
	// with these values set to 0 when agent (re)starts. See
	// https://www.kernel.org/doc/Documentation/cgroups/memory.txt for
	// more details.
	MemLowPressureCounter      *uint64 `protobuf:"varint,32,opt,name=mem_low_pressure_counter,json=memLowPressureCounter" json:"mem_low_pressure_counter,omitempty"`
	MemMediumPressureCounter   *uint64 `protobuf:"varint,33,opt,name=mem_medium_pressure_counter,json=memMediumPressureCounter" json:"mem_medium_pressure_counter,omitempty"`
	MemCriticalPressureCounter *uint64 `protobuf:"varint,34,opt,name=mem_critical_pressure_counter,json=memCriticalPressureCounter" json:"mem_critical_pressure_counter,omitempty"`
	// Disk Usage Information for executor working directory.
	DiskLimitBytes *uint64 `protobuf:"varint,26,opt,name=disk_limit_bytes,json=diskLimitBytes" json:"disk_limit_bytes,omitempty"`
	DiskUsedBytes  *uint64 `protobuf:"varint,27,opt,name=disk_used_bytes,json=diskUsedBytes" json:"disk_used_bytes,omitempty"`
	// Per disk (resource) statistics.
	DiskStatistics []DiskStatistics `protobuf:"bytes,43,rep,name=disk_statistics,json=diskStatistics" json:"disk_statistics"`
	// Cgroups blkio statistics.
	BlkioStatistics *CgroupInfo_Blkio_Statistics `protobuf:"bytes,44,opt,name=blkio_statistics,json=blkioStatistics" json:"blkio_statistics,omitempty"`
	// Perf statistics.
	Perf *PerfStatistics `protobuf:"bytes,13,opt,name=perf" json:"perf,omitempty"`
	// Network Usage Information:
	NetRxPackets *uint64 `protobuf:"varint,14,opt,name=net_rx_packets,json=netRxPackets" json:"net_rx_packets,omitempty"`
	NetRxBytes   *uint64 `protobuf:"varint,15,opt,name=net_rx_bytes,json=netRxBytes" json:"net_rx_bytes,omitempty"`
	NetRxErrors  *uint64 `protobuf:"varint,16,opt,name=net_rx_errors,json=netRxErrors" json:"net_rx_errors,omitempty"`
	NetRxDropped *uint64 `protobuf:"varint,17,opt,name=net_rx_dropped,json=netRxDropped" json:"net_rx_dropped,omitempty"`
	NetTxPackets *uint64 `protobuf:"varint,18,opt,name=net_tx_packets,json=netTxPackets" json:"net_tx_packets,omitempty"`
	NetTxBytes   *uint64 `protobuf:"varint,19,opt,name=net_tx_bytes,json=netTxBytes" json:"net_tx_bytes,omitempty"`
	NetTxErrors  *uint64 `protobuf:"varint,20,opt,name=net_tx_errors,json=netTxErrors" json:"net_tx_errors,omitempty"`
	NetTxDropped *uint64 `protobuf:"varint,21,opt,name=net_tx_dropped,json=netTxDropped" json:"net_tx_dropped,omitempty"`
	// The kernel keeps track of RTT (round-trip time) for its TCP
	// sockets. RTT is a way to tell the latency of a container.
	NetTCPRttMicrosecsP50     *float64 `protobuf:"fixed64,22,opt,name=net_tcp_rtt_microsecs_p50,json=netTcpRttMicrosecsP50" json:"net_tcp_rtt_microsecs_p50,omitempty"`
	NetTCPRttMicrosecsP90     *float64 `protobuf:"fixed64,23,opt,name=net_tcp_rtt_microsecs_p90,json=netTcpRttMicrosecsP90" json:"net_tcp_rtt_microsecs_p90,omitempty"`
	NetTCPRttMicrosecsP95     *float64 `protobuf:"fixed64,24,opt,name=net_tcp_rtt_microsecs_p95,json=netTcpRttMicrosecsP95" json:"net_tcp_rtt_microsecs_p95,omitempty"`
	NetTCPRttMicrosecsP99     *float64 `protobuf:"fixed64,25,opt,name=net_tcp_rtt_microsecs_p99,json=netTcpRttMicrosecsP99" json:"net_tcp_rtt_microsecs_p99,omitempty"`
	NetTCPActiveConnections   *float64 `protobuf:"fixed64,28,opt,name=net_tcp_active_connections,json=netTcpActiveConnections" json:"net_tcp_active_connections,omitempty"`
	NetTCPTimeWaitConnections *float64 `protobuf:"fixed64,29,opt,name=net_tcp_time_wait_connections,json=netTcpTimeWaitConnections" json:"net_tcp_time_wait_connections,omitempty"`
	// Network traffic flowing into or out of a container can be delayed
	// or dropped due to congestion or policy inside and outside the
	// container.
	NetTrafficControlStatistics []TrafficControlStatistics `protobuf:"bytes,35,rep,name=net_traffic_control_statistics,json=netTrafficControlStatistics" json:"net_traffic_control_statistics"`
	// Network SNMP statistics for each container.
	NetSNMPStatistics *SNMPStatistics `protobuf:"bytes,42,opt,name=net_snmp_statistics,json=netSnmpStatistics" json:"net_snmp_statistics,omitempty"`
}

func (m *ResourceStatistics) Reset()                    { *m = ResourceStatistics{} }
func (*ResourceStatistics) ProtoMessage()               {}
func (*ResourceStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{37} }

func (m *ResourceStatistics) GetTimestamp() float64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ResourceStatistics) GetProcesses() uint32 {
	if m != nil && m.Processes != nil {
		return *m.Processes
	}
	return 0
}

func (m *ResourceStatistics) GetThreads() uint32 {
	if m != nil && m.Threads != nil {
		return *m.Threads
	}
	return 0
}

func (m *ResourceStatistics) GetCPUsUserTimeSecs() float64 {
	if m != nil && m.CPUsUserTimeSecs != nil {
		return *m.CPUsUserTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetCPUsSystemTimeSecs() float64 {
	if m != nil && m.CPUsSystemTimeSecs != nil {
		return *m.CPUsSystemTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetCPUsLimit() float64 {
	if m != nil && m.CPUsLimit != nil {
		return *m.CPUsLimit
	}
	return 0
}

func (m *ResourceStatistics) GetCPUsNrPeriods() uint32 {
	if m != nil && m.CPUsNrPeriods != nil {
		return *m.CPUsNrPeriods
	}
	return 0
}

func (m *ResourceStatistics) GetCPUsNrThrottled() uint32 {
	if m != nil && m.CPUsNrThrottled != nil {
		return *m.CPUsNrThrottled
	}
	return 0
}

func (m *ResourceStatistics) GetCPUsThrottledTimeSecs() float64 {
	if m != nil && m.CPUsThrottledTimeSecs != nil {
		return *m.CPUsThrottledTimeSecs
	}
	return 0
}

func (m *ResourceStatistics) GetMemTotalBytes() uint64 {
	if m != nil && m.MemTotalBytes != nil {
		return *m.MemTotalBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemTotalMemswBytes() uint64 {
	if m != nil && m.MemTotalMemswBytes != nil {
		return *m.MemTotalMemswBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemLimitBytes() uint64 {
	if m != nil && m.MemLimitBytes != nil {
		return *m.MemLimitBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemSoftLimitBytes() uint64 {
	if m != nil && m.MemSoftLimitBytes != nil {
		return *m.MemSoftLimitBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemFileBytes() uint64 {
	if m != nil && m.MemFileBytes != nil {
		return *m.MemFileBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemAnonBytes() uint64 {
	if m != nil && m.MemAnonBytes != nil {
		return *m.MemAnonBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemCacheBytes() uint64 {
	if m != nil && m.MemCacheBytes != nil {
		return *m.MemCacheBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemRSSBytes() uint64 {
	if m != nil && m.MemRSSBytes != nil {
		return *m.MemRSSBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemMappedFileBytes() uint64 {
	if m != nil && m.MemMappedFileBytes != nil {
		return *m.MemMappedFileBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemSwapBytes() uint64 {
	if m != nil && m.MemSwapBytes != nil {
		return *m.MemSwapBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemUnevictableBytes() uint64 {
	if m != nil && m.MemUnevictableBytes != nil {
		return *m.MemUnevictableBytes
	}
	return 0
}

func (m *ResourceStatistics) GetMemLowPressureCounter() uint64 {
	if m != nil && m.MemLowPressureCounter != nil {
		return *m.MemLowPressureCounter
	}
	return 0
}

func (m *ResourceStatistics) GetMemMediumPressureCounter() uint64 {
	if m != nil && m.MemMediumPressureCounter != nil {
		return *m.MemMediumPressureCounter
	}
	return 0
}

func (m *ResourceStatistics) GetMemCriticalPressureCounter() uint64 {
	if m != nil && m.MemCriticalPressureCounter != nil {
		return *m.MemCriticalPressureCounter
	}
	return 0
}

func (m *ResourceStatistics) GetDiskLimitBytes() uint64 {
	if m != nil && m.DiskLimitBytes != nil {
		return *m.DiskLimitBytes
	}
	return 0
}

func (m *ResourceStatistics) GetDiskUsedBytes() uint64 {
	if m != nil && m.DiskUsedBytes != nil {
		return *m.DiskUsedBytes
	}
	return 0
}

func (m *ResourceStatistics) GetDiskStatistics() []DiskStatistics {
	if m != nil {
		return m.DiskStatistics
	}
	return nil
}

func (m *ResourceStatistics) GetBlkioStatistics() *CgroupInfo_Blkio_Statistics {
	if m != nil {
		return m.BlkioStatistics
	}
	return nil
}

func (m *ResourceStatistics) GetPerf() *PerfStatistics {
	if m != nil {
		return m.Perf
	}
	return nil
}

func (m *ResourceStatistics) GetNetRxPackets() uint64 {
	if m != nil && m.NetRxPackets != nil {
		return *m.NetRxPackets
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxBytes() uint64 {
	if m != nil && m.NetRxBytes != nil {
		return *m.NetRxBytes
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxErrors() uint64 {
	if m != nil && m.NetRxErrors != nil {
		return *m.NetRxErrors
	}
	return 0
}

func (m *ResourceStatistics) GetNetRxDropped() uint64 {
	if m != nil && m.NetRxDropped != nil {
		return *m.NetRxDropped
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxPackets() uint64 {
	if m != nil && m.NetTxPackets != nil {
		return *m.NetTxPackets
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxBytes() uint64 {
	if m != nil && m.NetTxBytes != nil {
		return *m.NetTxBytes
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxErrors() uint64 {
	if m != nil && m.NetTxErrors != nil {
		return *m.NetTxErrors
	}
	return 0
}

func (m *ResourceStatistics) GetNetTxDropped() uint64 {
	if m != nil && m.NetTxDropped != nil {
		return *m.NetTxDropped
	}
	return 0
}

func (m *ResourceStatistics) GetNetTCPRttMicrosecsP50() float64 {
	if m != nil && m.NetTCPRttMicrosecsP50 != nil {
		return *m.NetTCPRttMicrosecsP50
	}
	return 0
}

func (m *ResourceStatistics) GetNetTCPRttMicrosecsP90() float64 {
	if m != nil && m.NetTCPRttMicrosecsP90 != nil {
		return *m.NetTCPRttMicrosecsP90
	}
	return 0
}

func (m *ResourceStatistics) GetNetTCPRttMicrosecsP95() float64 {
	if m != nil && m.NetTCPRttMicrosecsP95 != nil {
		return *m.NetTCPRttMicrosecsP95
	}
	return 0
}

func (m *ResourceStatistics) GetNetTCPRttMicrosecsP99() float64 {
	if m != nil && m.NetTCPRttMicrosecsP99 != nil {
		return *m.NetTCPRttMicrosecsP99
	}
	return 0
}

func (m *ResourceStatistics) GetNetTCPActiveConnections() float64 {
	if m != nil && m.NetTCPActiveConnections != nil {
		return *m.NetTCPActiveConnections
	}
	return 0
}

func (m *ResourceStatistics) GetNetTCPTimeWaitConnections() float64 {
	if m != nil && m.NetTCPTimeWaitConnections != nil {
		return *m.NetTCPTimeWaitConnections
	}
	return 0
}

func (m *ResourceStatistics) GetNetTrafficControlStatistics() []TrafficControlStatistics {
	if m != nil {
		return m.NetTrafficControlStatistics
	}
	return nil
}

func (m *ResourceStatistics) GetNetSNMPStatistics() *SNMPStatistics {
	if m != nil {
		return m.NetSNMPStatistics
	}
	return nil
}

// *
// Describes a snapshot of the resource usage for executors.
type ResourceUsage struct {
	Executors []ResourceUsage_Executor `protobuf:"bytes,1,rep,name=executors" json:"executors"`
	// Agent's total resources including checkpointed dynamic
	// reservations and persistent volumes.
	Total []Resource `protobuf:"bytes,2,rep,name=total" json:"total"`
}

func (m *ResourceUsage) Reset()                    { *m = ResourceUsage{} }
func (*ResourceUsage) ProtoMessage()               {}
func (*ResourceUsage) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{38} }

func (m *ResourceUsage) GetExecutors() []ResourceUsage_Executor {
	if m != nil {
		return m.Executors
	}
	return nil
}

func (m *ResourceUsage) GetTotal() []Resource {
	if m != nil {
		return m.Total
	}
	return nil
}

type ResourceUsage_Executor struct {
	ExecutorInfo ExecutorInfo `protobuf:"bytes,1,req,name=executor_info,json=executorInfo" json:"executor_info"`
	// This includes resources used by the executor itself
	// as well as its active tasks.
	Allocated []Resource `protobuf:"bytes,2,rep,name=allocated" json:"allocated"`
	// Current resource usage. If absent, the containerizer
	// cannot provide resource usage.
	Statistics *ResourceStatistics `protobuf:"bytes,3,opt,name=statistics" json:"statistics,omitempty"`
	// The container id for the executor specified in the executor_info field.
	ContainerID ContainerID `protobuf:"bytes,4,req,name=container_id,json=containerId" json:"container_id"`
	// Non-terminal tasks.
	Tasks []ResourceUsage_Executor_Task `protobuf:"bytes,5,rep,name=tasks" json:"tasks"`
}

func (m *ResourceUsage_Executor) Reset()                    { *m = ResourceUsage_Executor{} }
func (*ResourceUsage_Executor) ProtoMessage()               {}
func (*ResourceUsage_Executor) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{38, 0} }

func (m *ResourceUsage_Executor) GetExecutorInfo() ExecutorInfo {
	if m != nil {
		return m.ExecutorInfo
	}
	return ExecutorInfo{}
}

func (m *ResourceUsage_Executor) GetAllocated() []Resource {
	if m != nil {
		return m.Allocated
	}
	return nil
}

func (m *ResourceUsage_Executor) GetStatistics() *ResourceStatistics {
	if m != nil {
		return m.Statistics
	}
	return nil
}

func (m *ResourceUsage_Executor) GetContainerID() ContainerID {
	if m != nil {
		return m.ContainerID
	}
	return ContainerID{}
}

func (m *ResourceUsage_Executor) GetTasks() []ResourceUsage_Executor_Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

type ResourceUsage_Executor_Task struct {
	Name      string     `protobuf:"bytes,1,req,name=name" json:"name"`
	ID        TaskID     `protobuf:"bytes,2,req,name=id" json:"id"`
	Resources []Resource `protobuf:"bytes,3,rep,name=resources" json:"resources"`
	Labels    *Labels    `protobuf:"bytes,4,opt,name=labels" json:"labels,omitempty"`
}

func (m *ResourceUsage_Executor_Task) Reset()      { *m = ResourceUsage_Executor_Task{} }
func (*ResourceUsage_Executor_Task) ProtoMessage() {}
func (*ResourceUsage_Executor_Task) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{38, 0, 0}
}

func (m *ResourceUsage_Executor_Task) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResourceUsage_Executor_Task) GetID() TaskID {
	if m != nil {
		return m.ID
	}
	return TaskID{}
}

func (m *ResourceUsage_Executor_Task) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ResourceUsage_Executor_Task) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

// *
// Describes a sample of events from "perf stat". Only available on
// Linux.
//
// NOTE: Each optional field matches the name of a perf event (see
// "perf list") with the following changes:
// 1. Names are downcased.
// 2. Hyphens ('-') are replaced with underscores ('_').
// 3. Events with alternate names use the name "perf stat" returns,
//    e.g., for the event "cycles OR cpu-cycles" perf always returns
//    cycles.
type PerfStatistics struct {
	Timestamp float64 `protobuf:"fixed64,1,req,name=timestamp" json:"timestamp"`
	Duration  float64 `protobuf:"fixed64,2,req,name=duration" json:"duration"`
	// Hardware event.
	Cycles                *uint64 `protobuf:"varint,3,opt,name=cycles" json:"cycles,omitempty"`
	StalledCyclesFrontend *uint64 `protobuf:"varint,4,opt,name=stalled_cycles_frontend,json=stalledCyclesFrontend" json:"stalled_cycles_frontend,omitempty"`
	StalledCyclesBackend  *uint64 `protobuf:"varint,5,opt,name=stalled_cycles_backend,json=stalledCyclesBackend" json:"stalled_cycles_backend,omitempty"`
	Instructions          *uint64 `protobuf:"varint,6,opt,name=instructions" json:"instructions,omitempty"`
	CacheReferences       *uint64 `protobuf:"varint,7,opt,name=cache_references,json=cacheReferences" json:"cache_references,omitempty"`
	CacheMisses           *uint64 `protobuf:"varint,8,opt,name=cache_misses,json=cacheMisses" json:"cache_misses,omitempty"`
	Branches              *uint64 `protobuf:"varint,9,opt,name=branches" json:"branches,omitempty"`
	BranchMisses          *uint64 `protobuf:"varint,10,opt,name=branch_misses,json=branchMisses" json:"branch_misses,omitempty"`
	BusCycles             *uint64 `protobuf:"varint,11,opt,name=bus_cycles,json=busCycles" json:"bus_cycles,omitempty"`
	RefCycles             *uint64 `protobuf:"varint,12,opt,name=ref_cycles,json=refCycles" json:"ref_cycles,omitempty"`
	// Software event.
	CPUClock        *float64 `protobuf:"fixed64,13,opt,name=cpu_clock,json=cpuClock" json:"cpu_clock,omitempty"`
	TaskClock       *float64 `protobuf:"fixed64,14,opt,name=task_clock,json=taskClock" json:"task_clock,omitempty"`
	PageFaults      *uint64  `protobuf:"varint,15,opt,name=page_faults,json=pageFaults" json:"page_faults,omitempty"`
	MinorFaults     *uint64  `protobuf:"varint,16,opt,name=minor_faults,json=minorFaults" json:"minor_faults,omitempty"`
	MajorFaults     *uint64  `protobuf:"varint,17,opt,name=major_faults,json=majorFaults" json:"major_faults,omitempty"`
	ContextSwitches *uint64  `protobuf:"varint,18,opt,name=context_switches,json=contextSwitches" json:"context_switches,omitempty"`
	CPUMigrations   *uint64  `protobuf:"varint,19,opt,name=cpu_migrations,json=cpuMigrations" json:"cpu_migrations,omitempty"`
	AlignmentFaults *uint64  `protobuf:"varint,20,opt,name=alignment_faults,json=alignmentFaults" json:"alignment_faults,omitempty"`
	EmulationFaults *uint64  `protobuf:"varint,21,opt,name=emulation_faults,json=emulationFaults" json:"emulation_faults,omitempty"`
	// Hardware cache event.
	L1DcacheLoads          *uint64 `protobuf:"varint,22,opt,name=l1_dcache_loads,json=l1DcacheLoads" json:"l1_dcache_loads,omitempty"`
	L1DcacheLoadMisses     *uint64 `protobuf:"varint,23,opt,name=l1_dcache_load_misses,json=l1DcacheLoadMisses" json:"l1_dcache_load_misses,omitempty"`
	L1DcacheStores         *uint64 `protobuf:"varint,24,opt,name=l1_dcache_stores,json=l1DcacheStores" json:"l1_dcache_stores,omitempty"`
	L1DcacheStoreMisses    *uint64 `protobuf:"varint,25,opt,name=l1_dcache_store_misses,json=l1DcacheStoreMisses" json:"l1_dcache_store_misses,omitempty"`
	L1DcachePrefetches     *uint64 `protobuf:"varint,26,opt,name=l1_dcache_prefetches,json=l1DcachePrefetches" json:"l1_dcache_prefetches,omitempty"`
	L1DcachePrefetchMisses *uint64 `protobuf:"varint,27,opt,name=l1_dcache_prefetch_misses,json=l1DcachePrefetchMisses" json:"l1_dcache_prefetch_misses,omitempty"`
	L1IcacheLoads          *uint64 `protobuf:"varint,28,opt,name=l1_icache_loads,json=l1IcacheLoads" json:"l1_icache_loads,omitempty"`
	L1IcacheLoadMisses     *uint64 `protobuf:"varint,29,opt,name=l1_icache_load_misses,json=l1IcacheLoadMisses" json:"l1_icache_load_misses,omitempty"`
	L1IcachePrefetches     *uint64 `protobuf:"varint,30,opt,name=l1_icache_prefetches,json=l1IcachePrefetches" json:"l1_icache_prefetches,omitempty"`
	L1IcachePrefetchMisses *uint64 `protobuf:"varint,31,opt,name=l1_icache_prefetch_misses,json=l1IcachePrefetchMisses" json:"l1_icache_prefetch_misses,omitempty"`
	LLCLoads               *uint64 `protobuf:"varint,32,opt,name=llc_loads,json=llcLoads" json:"llc_loads,omitempty"`
	LLCLoadMisses          *uint64 `protobuf:"varint,33,opt,name=llc_load_misses,json=llcLoadMisses" json:"llc_load_misses,omitempty"`
	LLCStores              *uint64 `protobuf:"varint,34,opt,name=llc_stores,json=llcStores" json:"llc_stores,omitempty"`
	LLCStoreMisses         *uint64 `protobuf:"varint,35,opt,name=llc_store_misses,json=llcStoreMisses" json:"llc_store_misses,omitempty"`
	LLCPrefetches          *uint64 `protobuf:"varint,36,opt,name=llc_prefetches,json=llcPrefetches" json:"llc_prefetches,omitempty"`
	LLCPrefetchMisses      *uint64 `protobuf:"varint,37,opt,name=llc_prefetch_misses,json=llcPrefetchMisses" json:"llc_prefetch_misses,omitempty"`
	DTLBLoads              *uint64 `protobuf:"varint,38,opt,name=dtlb_loads,json=dtlbLoads" json:"dtlb_loads,omitempty"`
	DTLBLoadMisses         *uint64 `protobuf:"varint,39,opt,name=dtlb_load_misses,json=dtlbLoadMisses" json:"dtlb_load_misses,omitempty"`
	DTLBStores             *uint64 `protobuf:"varint,40,opt,name=dtlb_stores,json=dtlbStores" json:"dtlb_stores,omitempty"`
	DTLBStoreMisses        *uint64 `protobuf:"varint,41,opt,name=dtlb_store_misses,json=dtlbStoreMisses" json:"dtlb_store_misses,omitempty"`
	DTLBPrefetches         *uint64 `protobuf:"varint,42,opt,name=dtlb_prefetches,json=dtlbPrefetches" json:"dtlb_prefetches,omitempty"`
	DTLBPrefetchMisses     *uint64 `protobuf:"varint,43,opt,name=dtlb_prefetch_misses,json=dtlbPrefetchMisses" json:"dtlb_prefetch_misses,omitempty"`
	ITLBLoads              *uint64 `protobuf:"varint,44,opt,name=itlb_loads,json=itlbLoads" json:"itlb_loads,omitempty"`
	ITLBLoadMisses         *uint64 `protobuf:"varint,45,opt,name=itlb_load_misses,json=itlbLoadMisses" json:"itlb_load_misses,omitempty"`
	BranchLoads            *uint64 `protobuf:"varint,46,opt,name=branch_loads,json=branchLoads" json:"branch_loads,omitempty"`
	BranchLoadMisses       *uint64 `protobuf:"varint,47,opt,name=branch_load_misses,json=branchLoadMisses" json:"branch_load_misses,omitempty"`
	NodeLoads              *uint64 `protobuf:"varint,48,opt,name=node_loads,json=nodeLoads" json:"node_loads,omitempty"`
	NodeLoadMisses         *uint64 `protobuf:"varint,49,opt,name=node_load_misses,json=nodeLoadMisses" json:"node_load_misses,omitempty"`
	NodeStores             *uint64 `protobuf:"varint,50,opt,name=node_stores,json=nodeStores" json:"node_stores,omitempty"`
	NodeStoreMisses        *uint64 `protobuf:"varint,51,opt,name=node_store_misses,json=nodeStoreMisses" json:"node_store_misses,omitempty"`
	NodePrefetches         *uint64 `protobuf:"varint,52,opt,name=node_prefetches,json=nodePrefetches" json:"node_prefetches,omitempty"`
	NodePrefetchMisses     *uint64 `protobuf:"varint,53,opt,name=node_prefetch_misses,json=nodePrefetchMisses" json:"node_prefetch_misses,omitempty"`
}

func (m *PerfStatistics) Reset()                    { *m = PerfStatistics{} }
func (*PerfStatistics) ProtoMessage()               {}
func (*PerfStatistics) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{39} }

func (m *PerfStatistics) GetTimestamp() float64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *PerfStatistics) GetDuration() float64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *PerfStatistics) GetCycles() uint64 {
	if m != nil && m.Cycles != nil {
		return *m.Cycles
	}
	return 0
}

func (m *PerfStatistics) GetStalledCyclesFrontend() uint64 {
	if m != nil && m.StalledCyclesFrontend != nil {
		return *m.StalledCyclesFrontend
	}
	return 0
}

func (m *PerfStatistics) GetStalledCyclesBackend() uint64 {
	if m != nil && m.StalledCyclesBackend != nil {
		return *m.StalledCyclesBackend
	}
	return 0
}

func (m *PerfStatistics) GetInstructions() uint64 {
	if m != nil && m.Instructions != nil {
		return *m.Instructions
	}
	return 0
}

func (m *PerfStatistics) GetCacheReferences() uint64 {
	if m != nil && m.CacheReferences != nil {
		return *m.CacheReferences
	}
	return 0
}

func (m *PerfStatistics) GetCacheMisses() uint64 {
	if m != nil && m.CacheMisses != nil {
		return *m.CacheMisses
	}
	return 0
}

func (m *PerfStatistics) GetBranches() uint64 {
	if m != nil && m.Branches != nil {
		return *m.Branches
	}
	return 0
}

func (m *PerfStatistics) GetBranchMisses() uint64 {
	if m != nil && m.BranchMisses != nil {
		return *m.BranchMisses
	}
	return 0
}

func (m *PerfStatistics) GetBusCycles() uint64 {
	if m != nil && m.BusCycles != nil {
		return *m.BusCycles
	}
	return 0
}

func (m *PerfStatistics) GetRefCycles() uint64 {
	if m != nil && m.RefCycles != nil {
		return *m.RefCycles
	}
	return 0
}

func (m *PerfStatistics) GetCPUClock() float64 {
	if m != nil && m.CPUClock != nil {
		return *m.CPUClock
	}
	return 0
}

func (m *PerfStatistics) GetTaskClock() float64 {
	if m != nil && m.TaskClock != nil {
		return *m.TaskClock
	}
	return 0
}

func (m *PerfStatistics) GetPageFaults() uint64 {
	if m != nil && m.PageFaults != nil {
		return *m.PageFaults
	}
	return 0
}

func (m *PerfStatistics) GetMinorFaults() uint64 {
	if m != nil && m.MinorFaults != nil {
		return *m.MinorFaults
	}
	return 0
}

func (m *PerfStatistics) GetMajorFaults() uint64 {
	if m != nil && m.MajorFaults != nil {
		return *m.MajorFaults
	}
	return 0
}

func (m *PerfStatistics) GetContextSwitches() uint64 {
	if m != nil && m.ContextSwitches != nil {
		return *m.ContextSwitches
	}
	return 0
}

func (m *PerfStatistics) GetCPUMigrations() uint64 {
	if m != nil && m.CPUMigrations != nil {
		return *m.CPUMigrations
	}
	return 0
}

func (m *PerfStatistics) GetAlignmentFaults() uint64 {
	if m != nil && m.AlignmentFaults != nil {
		return *m.AlignmentFaults
	}
	return 0
}

func (m *PerfStatistics) GetEmulationFaults() uint64 {
	if m != nil && m.EmulationFaults != nil {
		return *m.EmulationFaults
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheLoads() uint64 {
	if m != nil && m.L1DcacheLoads != nil {
		return *m.L1DcacheLoads
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheLoadMisses() uint64 {
	if m != nil && m.L1DcacheLoadMisses != nil {
		return *m.L1DcacheLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheStores() uint64 {
	if m != nil && m.L1DcacheStores != nil {
		return *m.L1DcacheStores
	}
	return 0
}

func (m *PerfStatistics) GetL1DcacheStoreMisses() uint64 {
	if m != nil && m.L1DcacheStoreMisses != nil {
		return *m.L1DcacheStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1DcachePrefetches() uint64 {
	if m != nil && m.L1DcachePrefetches != nil {
		return *m.L1DcachePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetL1DcachePrefetchMisses() uint64 {
	if m != nil && m.L1DcachePrefetchMisses != nil {
		return *m.L1DcachePrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1IcacheLoads() uint64 {
	if m != nil && m.L1IcacheLoads != nil {
		return *m.L1IcacheLoads
	}
	return 0
}

func (m *PerfStatistics) GetL1IcacheLoadMisses() uint64 {
	if m != nil && m.L1IcacheLoadMisses != nil {
		return *m.L1IcacheLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetL1IcachePrefetches() uint64 {
	if m != nil && m.L1IcachePrefetches != nil {
		return *m.L1IcachePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetL1IcachePrefetchMisses() uint64 {
	if m != nil && m.L1IcachePrefetchMisses != nil {
		return *m.L1IcachePrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetLLCLoads() uint64 {
	if m != nil && m.LLCLoads != nil {
		return *m.LLCLoads
	}
	return 0
}

func (m *PerfStatistics) GetLLCLoadMisses() uint64 {
	if m != nil && m.LLCLoadMisses != nil {
		return *m.LLCLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetLLCStores() uint64 {
	if m != nil && m.LLCStores != nil {
		return *m.LLCStores
	}
	return 0
}

func (m *PerfStatistics) GetLLCStoreMisses() uint64 {
	if m != nil && m.LLCStoreMisses != nil {
		return *m.LLCStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetLLCPrefetches() uint64 {
	if m != nil && m.LLCPrefetches != nil {
		return *m.LLCPrefetches
	}
	return 0
}

func (m *PerfStatistics) GetLLCPrefetchMisses() uint64 {
	if m != nil && m.LLCPrefetchMisses != nil {
		return *m.LLCPrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetDTLBLoads() uint64 {
	if m != nil && m.DTLBLoads != nil {
		return *m.DTLBLoads
	}
	return 0
}

func (m *PerfStatistics) GetDTLBLoadMisses() uint64 {
	if m != nil && m.DTLBLoadMisses != nil {
		return *m.DTLBLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetDTLBStores() uint64 {
	if m != nil && m.DTLBStores != nil {
		return *m.DTLBStores
	}
	return 0
}

func (m *PerfStatistics) GetDTLBStoreMisses() uint64 {
	if m != nil && m.DTLBStoreMisses != nil {
		return *m.DTLBStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetDTLBPrefetches() uint64 {
	if m != nil && m.DTLBPrefetches != nil {
		return *m.DTLBPrefetches
	}
	return 0
}

func (m *PerfStatistics) GetDTLBPrefetchMisses() uint64 {
	if m != nil && m.DTLBPrefetchMisses != nil {
		return *m.DTLBPrefetchMisses
	}
	return 0
}

func (m *PerfStatistics) GetITLBLoads() uint64 {
	if m != nil && m.ITLBLoads != nil {
		return *m.ITLBLoads
	}
	return 0
}

func (m *PerfStatistics) GetITLBLoadMisses() uint64 {
	if m != nil && m.ITLBLoadMisses != nil {
		return *m.ITLBLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetBranchLoads() uint64 {
	if m != nil && m.BranchLoads != nil {
		return *m.BranchLoads
	}
	return 0
}

func (m *PerfStatistics) GetBranchLoadMisses() uint64 {
	if m != nil && m.BranchLoadMisses != nil {
		return *m.BranchLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodeLoads() uint64 {
	if m != nil && m.NodeLoads != nil {
		return *m.NodeLoads
	}
	return 0
}

func (m *PerfStatistics) GetNodeLoadMisses() uint64 {
	if m != nil && m.NodeLoadMisses != nil {
		return *m.NodeLoadMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodeStores() uint64 {
	if m != nil && m.NodeStores != nil {
		return *m.NodeStores
	}
	return 0
}

func (m *PerfStatistics) GetNodeStoreMisses() uint64 {
	if m != nil && m.NodeStoreMisses != nil {
		return *m.NodeStoreMisses
	}
	return 0
}

func (m *PerfStatistics) GetNodePrefetches() uint64 {
	if m != nil && m.NodePrefetches != nil {
		return *m.NodePrefetches
	}
	return 0
}

func (m *PerfStatistics) GetNodePrefetchMisses() uint64 {
	if m != nil && m.NodePrefetchMisses != nil {
		return *m.NodePrefetchMisses
	}
	return 0
}

// *
// Describes a request for resources that can be used by a framework
// to proactively influence the allocator.  If 'agent_id' is provided
// then this request is assumed to only apply to resources on that
// agent.
type Request struct {
	AgentID   *AgentID   `protobuf:"bytes,1,opt,name=agent_id,json=agentId" json:"agent_id,omitempty"`
	Resources []Resource `protobuf:"bytes,2,rep,name=resources" json:"resources"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{40} }

func (m *Request) GetAgentID() *AgentID {
	if m != nil {
		return m.AgentID
	}
	return nil
}

func (m *Request) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// *
// Describes some resources available on an agent. An offer only
// contains resources from a single agent.
type Offer struct {
	ID          OfferID     `protobuf:"bytes,1,req,name=id" json:"id"`
	FrameworkID FrameworkID `protobuf:"bytes,2,req,name=framework_id,json=frameworkId" json:"framework_id"`
	AgentID     AgentID     `protobuf:"bytes,3,req,name=agent_id,json=agentId" json:"agent_id"`
	Hostname    string      `protobuf:"bytes,4,req,name=hostname" json:"hostname"`
	// URL for reaching the agent running on the host.
	URL *URL `protobuf:"bytes,8,opt,name=url" json:"url,omitempty"`
	// The domain of the agent.
	Domain     *DomainInfo `protobuf:"bytes,11,opt,name=domain" json:"domain,omitempty"`
	Resources  []Resource  `protobuf:"bytes,5,rep,name=resources" json:"resources"`
	Attributes []Attribute `protobuf:"bytes,7,rep,name=attributes" json:"attributes"`
	// Executors of the same framework running on this agent.
	ExecutorIDs []ExecutorID `protobuf:"bytes,6,rep,name=executor_ids,json=executorIds" json:"executor_ids"`
	// Signifies that the resources in this Offer may be unavailable during
	// the given interval.  Any tasks launched using these resources may be
	// killed when the interval arrives.  For example, these resources may be
	// part of a planned maintenance schedule.
	//
	// This field only provides information about a planned unavailability.
	// The unavailability interval may not necessarily start at exactly this
	// interval, nor last for exactly the duration of this interval.
	// The unavailability may also be forever!  See comments in
	// `Unavailability` for more details.
	Unavailability *Unavailability `protobuf:"bytes,9,opt,name=unavailability" json:"unavailability,omitempty"`
	// An offer represents resources allocated to *one* of the
	// roles managed by the scheduler. (Therefore, each
	// `Offer.resources[i].allocation_info` will match the
	// top level `Offer.allocation_info`).
	AllocationInfo *Resource_AllocationInfo `protobuf:"bytes,10,opt,name=allocation_info,json=allocationInfo" json:"allocation_info,omitempty"`
}

func (m *Offer) Reset()                    { *m = Offer{} }
func (*Offer) ProtoMessage()               {}
func (*Offer) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{41} }

func (m *Offer) GetID() OfferID {
	if m != nil {
		return m.ID
	}
	return OfferID{}
}

func (m *Offer) GetFrameworkID() FrameworkID {
	if m != nil {
		return m.FrameworkID
	}
	return FrameworkID{}
}

func (m *Offer) GetAgentID() AgentID {
	if m != nil {
		return m.AgentID
	}
	return AgentID{}
}

func (m *Offer) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Offer) GetURL() *URL {
	if m != nil {
		return m.URL
	}
	return nil
}

func (m *Offer) GetDomain() *DomainInfo {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *Offer) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Offer) GetAttributes() []Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Offer) GetExecutorIDs() []ExecutorID {
	if m != nil {
		return m.ExecutorIDs
	}
	return nil
}

func (m *Offer) GetUnavailability() *Unavailability {
	if m != nil {
		return m.Unavailability
	}
	return nil
}

func (m *Offer) GetAllocationInfo() *Resource_AllocationInfo {
	if m != nil {
		return m.AllocationInfo
	}
	return nil
}

// Defines an operation that can be performed against offers.
type Offer_Operation struct {
	Type Offer_Operation_Type `protobuf:"varint,1,opt,name=type,enum=mesos.Offer_Operation_Type" json:"type"`
	// NOTE: The `id` field will allow frameworks to indicate that they wish to
	// receive feedback about an operation. Since this feature is not yet
	// implemented, the `id` field should NOT be set at present. See MESOS-8054.
	ID           *OperationID                  `protobuf:"bytes,12,opt,name=id" json:"id,omitempty"`
	Launch       *Offer_Operation_Launch       `protobuf:"bytes,2,opt,name=launch" json:"launch,omitempty"`
	LaunchGroup  *Offer_Operation_LaunchGroup  `protobuf:"bytes,7,opt,name=launch_group,json=launchGroup" json:"launch_group,omitempty"`
	Reserve      *Offer_Operation_Reserve      `protobuf:"bytes,3,opt,name=reserve" json:"reserve,omitempty"`
	Unreserve    *Offer_Operation_Unreserve    `protobuf:"bytes,4,opt,name=unreserve" json:"unreserve,omitempty"`
	Create       *Offer_Operation_Create       `protobuf:"bytes,5,opt,name=create" json:"create,omitempty"`
	Destroy      *Offer_Operation_Destroy      `protobuf:"bytes,6,opt,name=destroy" json:"destroy,omitempty"`
	GrowVolume   *Offer_Operation_GrowVolume   `protobuf:"bytes,13,opt,name=grow_volume,json=growVolume" json:"grow_volume,omitempty"`
	ShrinkVolume *Offer_Operation_ShrinkVolume `protobuf:"bytes,14,opt,name=shrink_volume,json=shrinkVolume" json:"shrink_volume,omitempty"`
	CreateDisk   *Offer_Operation_CreateDisk   `protobuf:"bytes,15,opt,name=create_disk,json=createDisk" json:"create_disk,omitempty"`
	DestroyDisk  *Offer_Operation_DestroyDisk  `protobuf:"bytes,16,opt,name=destroy_disk,json=destroyDisk" json:"destroy_disk,omitempty"`
}

func (m *Offer_Operation) Reset()                    { *m = Offer_Operation{} }
func (*Offer_Operation) ProtoMessage()               {}
func (*Offer_Operation) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{41, 0} }

func (m *Offer_Operation) GetType() Offer_Operation_Type {
	if m != nil {
		return m.Type
	}
	return Offer_Operation_UNKNOWN
}

func (m *Offer_Operation) GetID() *OperationID {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Offer_Operation) GetLaunch() *Offer_Operation_Launch {
	if m != nil {
		return m.Launch
	}
	return nil
}

func (m *Offer_Operation) GetLaunchGroup() *Offer_Operation_LaunchGroup {
	if m != nil {
		return m.LaunchGroup
	}
	return nil
}

func (m *Offer_Operation) GetReserve() *Offer_Operation_Reserve {
	if m != nil {
		return m.Reserve
	}
	return nil
}

func (m *Offer_Operation) GetUnreserve() *Offer_Operation_Unreserve {
	if m != nil {
		return m.Unreserve
	}
	return nil
}

func (m *Offer_Operation) GetCreate() *Offer_Operation_Create {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *Offer_Operation) GetDestroy() *Offer_Operation_Destroy {
	if m != nil {
		return m.Destroy
	}
	return nil
}

func (m *Offer_Operation) GetGrowVolume() *Offer_Operation_GrowVolume {
	if m != nil {
		return m.GrowVolume
	}
	return nil
}

func (m *Offer_Operation) GetShrinkVolume() *Offer_Operation_ShrinkVolume {
	if m != nil {
		return m.ShrinkVolume
	}
	return nil
}

func (m *Offer_Operation) GetCreateDisk() *Offer_Operation_CreateDisk {
	if m != nil {
		return m.CreateDisk
	}
	return nil
}

func (m *Offer_Operation) GetDestroyDisk() *Offer_Operation_DestroyDisk {
	if m != nil {
		return m.DestroyDisk
	}
	return nil
}

// TODO(vinod): Deprecate this in favor of `LaunchGroup` below.
type Offer_Operation_Launch struct {
	TaskInfos []TaskInfo `protobuf:"bytes,1,rep,name=task_infos,json=taskInfos" json:"task_infos"`
}

func (m *Offer_Operation_Launch) Reset()      { *m = Offer_Operation_Launch{} }
func (*Offer_Operation_Launch) ProtoMessage() {}
func (*Offer_Operation_Launch) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 0}
}

func (m *Offer_Operation_Launch) GetTaskInfos() []TaskInfo {
	if m != nil {
		return m.TaskInfos
	}
	return nil
}

// Unlike `Launch` above, all the tasks in a `task_group` are
// atomically delivered to an executor.
//
// `NetworkInfo` set on executor will be shared by all tasks in
// the task group.
//
// TODO(vinod): Any volumes set on executor could be used by a
// task by explicitly setting `Volume.source` in its resources.
type Offer_Operation_LaunchGroup struct {
	Executor  ExecutorInfo  `protobuf:"bytes,1,req,name=executor" json:"executor"`
	TaskGroup TaskGroupInfo `protobuf:"bytes,2,req,name=task_group,json=taskGroup" json:"task_group"`
}

func (m *Offer_Operation_LaunchGroup) Reset()      { *m = Offer_Operation_LaunchGroup{} }
func (*Offer_Operation_LaunchGroup) ProtoMessage() {}
func (*Offer_Operation_LaunchGroup) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 1}
}

func (m *Offer_Operation_LaunchGroup) GetExecutor() ExecutorInfo {
	if m != nil {
		return m.Executor
	}
	return ExecutorInfo{}
}

func (m *Offer_Operation_LaunchGroup) GetTaskGroup() TaskGroupInfo {
	if m != nil {
		return m.TaskGroup
	}
	return TaskGroupInfo{}
}

type Offer_Operation_Reserve struct {
	Resources []Resource `protobuf:"bytes,1,rep,name=resources" json:"resources"`
}

func (m *Offer_Operation_Reserve) Reset()      { *m = Offer_Operation_Reserve{} }
func (*Offer_Operation_Reserve) ProtoMessage() {}
func (*Offer_Operation_Reserve) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 2}
}

func (m *Offer_Operation_Reserve) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

type Offer_Operation_Unreserve struct {
	Resources []Resource `protobuf:"bytes,1,rep,name=resources" json:"resources"`
}

func (m *Offer_Operation_Unreserve) Reset()      { *m = Offer_Operation_Unreserve{} }
func (*Offer_Operation_Unreserve) ProtoMessage() {}
func (*Offer_Operation_Unreserve) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 3}
}

func (m *Offer_Operation_Unreserve) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

type Offer_Operation_Create struct {
	Volumes []Resource `protobuf:"bytes,1,rep,name=volumes" json:"volumes"`
}

func (m *Offer_Operation_Create) Reset()      { *m = Offer_Operation_Create{} }
func (*Offer_Operation_Create) ProtoMessage() {}
func (*Offer_Operation_Create) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 4}
}

func (m *Offer_Operation_Create) GetVolumes() []Resource {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type Offer_Operation_Destroy struct {
	Volumes []Resource `protobuf:"bytes,1,rep,name=volumes" json:"volumes"`
}

func (m *Offer_Operation_Destroy) Reset()      { *m = Offer_Operation_Destroy{} }
func (*Offer_Operation_Destroy) ProtoMessage() {}
func (*Offer_Operation_Destroy) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 5}
}

func (m *Offer_Operation_Destroy) GetVolumes() []Resource {
	if m != nil {
		return m.Volumes
	}
	return nil
}

// Grow a volume by an additional disk resource.
// NOTE: This is currently experimental and only for persistent volumes
// created on ROOT/PATH disk.
type Offer_Operation_GrowVolume struct {
	Volume   Resource `protobuf:"bytes,1,req,name=volume" json:"volume"`
	Addition Resource `protobuf:"bytes,2,req,name=addition" json:"addition"`
}

func (m *Offer_Operation_GrowVolume) Reset()      { *m = Offer_Operation_GrowVolume{} }
func (*Offer_Operation_GrowVolume) ProtoMessage() {}
func (*Offer_Operation_GrowVolume) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 6}
}

func (m *Offer_Operation_GrowVolume) GetVolume() Resource {
	if m != nil {
		return m.Volume
	}
	return Resource{}
}

func (m *Offer_Operation_GrowVolume) GetAddition() Resource {
	if m != nil {
		return m.Addition
	}
	return Resource{}
}

// Shrink a volume by the size specified in the `subtract` field.
// NOTE: This is currently experimental and only for persistent volumes
// created on ROOT/PATH disk.
type Offer_Operation_ShrinkVolume struct {
	Volume Resource `protobuf:"bytes,1,req,name=volume" json:"volume"`
	// See comments in `Value.Scalar` for maximum precision supported.
	Subtract Value_Scalar `protobuf:"bytes,2,req,name=subtract" json:"subtract"`
}

func (m *Offer_Operation_ShrinkVolume) Reset()      { *m = Offer_Operation_ShrinkVolume{} }
func (*Offer_Operation_ShrinkVolume) ProtoMessage() {}
func (*Offer_Operation_ShrinkVolume) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 7}
}

func (m *Offer_Operation_ShrinkVolume) GetVolume() Resource {
	if m != nil {
		return m.Volume
	}
	return Resource{}
}

func (m *Offer_Operation_ShrinkVolume) GetSubtract() Value_Scalar {
	if m != nil {
		return m.Subtract
	}
	return Value_Scalar{}
}

// Create a `MOUNT` or `BLOCK` disk resource from a `RAW` disk resource.
// NOTE: For the time being, this API is subject to change and the related
// feature is experimental.
type Offer_Operation_CreateDisk struct {
	Source Resource `protobuf:"bytes,1,req,name=source" json:"source"`
	// NOTE: Only `MOUNT` or `BLOCK` is allowed in the `target_type` field.
	TargetType Resource_DiskInfo_Source_Type `protobuf:"varint,2,req,name=target_type,json=targetType,enum=mesos.Resource_DiskInfo_Source_Type" json:"target_type"`
}

func (m *Offer_Operation_CreateDisk) Reset()      { *m = Offer_Operation_CreateDisk{} }
func (*Offer_Operation_CreateDisk) ProtoMessage() {}
func (*Offer_Operation_CreateDisk) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 8}
}

func (m *Offer_Operation_CreateDisk) GetSource() Resource {
	if m != nil {
		return m.Source
	}
	return Resource{}
}

func (m *Offer_Operation_CreateDisk) GetTargetType() Resource_DiskInfo_Source_Type {
	if m != nil {
		return m.TargetType
	}
	return Resource_DiskInfo_Source_UNKNOWN
}

// Destroy a `MOUNT` or `BLOCK` disk resource. This will result in a `RAW`
// disk resource.
// NOTE: For the time being, this API is subject to change and the related
// feature is experimental.
type Offer_Operation_DestroyDisk struct {
	// NOTE: Only a `MOUNT` or `BLOCK` disk is allowed in the `source` field.
	Source Resource `protobuf:"bytes,1,req,name=source" json:"source"`
}

func (m *Offer_Operation_DestroyDisk) Reset()      { *m = Offer_Operation_DestroyDisk{} }
func (*Offer_Operation_DestroyDisk) ProtoMessage() {}
func (*Offer_Operation_DestroyDisk) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{41, 0, 9}
}

func (m *Offer_Operation_DestroyDisk) GetSource() Resource {
	if m != nil {
		return m.Source
	}
	return Resource{}
}

// *
// A request to return some resources occupied by a framework.
type InverseOffer struct {
	// This is the same OfferID as found in normal offers, which allows
	// re-use of some of the OfferID-only messages.
	OfferID OfferID `protobuf:"bytes,1,req,name=id" json:"id"`
	// URL for reaching the agent running on the host.  This enables some
	// optimizations as described in MESOS-3012, such as allowing the
	// scheduler driver to bypass the master and talk directly with an agent.
	URL *URL `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
	// The framework that should release its resources.
	// If no specifics are provided (i.e. which agent), all the framework's
	// resources are requested back.
	FrameworkID FrameworkID `protobuf:"bytes,3,req,name=framework_id,json=frameworkId" json:"framework_id"`
	// Specified if the resources need to be released from a particular agent.
	// All the framework's resources on this agent are requested back,
	// unless further qualified by the `resources` field.
	AgentID *AgentID `protobuf:"bytes,4,opt,name=agent_id,json=agentId" json:"agent_id,omitempty"`
	// This InverseOffer represents a planned unavailability event in the
	// specified interval.  Any tasks running on the given framework or agent
	// may be killed when the interval arrives.  Therefore, frameworks should
	// aim to gracefully terminate tasks prior to the arrival of the interval.
	//
	// For reserved resources, the resources are expected to be returned to the
	// framework after the unavailability interval.  This is an expectation,
	// not a guarantee.  For example, if the unavailability duration is not set,
	// the resources may be removed permanently.
	//
	// For other resources, there is no guarantee that requested resources will
	// be returned after the unavailability interval.  The allocator has no
	// obligation to re-offer these resources to the prior framework after
	// the unavailability.
	Unavailability Unavailability `protobuf:"bytes,5,req,name=unavailability" json:"unavailability"`
	// A list of resources being requested back from the framework,
	// on the agent identified by `agent_id`.  If no resources are specified
	// then all resources are being requested back.  For the purpose of
	// maintenance, this field is always empty (maintenance always requests
	// all resources back).
	Resources []Resource `protobuf:"bytes,6,rep,name=resources" json:"resources"`
}

func (m *InverseOffer) Reset()                    { *m = InverseOffer{} }
func (*InverseOffer) ProtoMessage()               {}
func (*InverseOffer) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{42} }

func (m *InverseOffer) GetOfferID() OfferID {
	if m != nil {
		return m.OfferID
	}
	return OfferID{}
}

func (m *InverseOffer) GetURL() *URL {
	if m != nil {
		return m.URL
	}
	return nil
}

func (m *InverseOffer) GetFrameworkID() FrameworkID {
	if m != nil {
		return m.FrameworkID
	}
	return FrameworkID{}
}

func (m *InverseOffer) GetAgentID() *AgentID {
	if m != nil {
		return m.AgentID
	}
	return nil
}

func (m *InverseOffer) GetUnavailability() Unavailability {
	if m != nil {
		return m.Unavailability
	}
	return Unavailability{}
}

func (m *InverseOffer) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// *
// Describes a task. Passed from the scheduler all the way to an
// executor (see SchedulerDriver::launchTasks and
// Executor::launchTask). Either ExecutorInfo or CommandInfo should be set.
// A different executor can be used to launch this task, and subsequent tasks
// meant for the same executor can reuse the same ExecutorInfo struct.
type TaskInfo struct {
	Name      string        `protobuf:"bytes,1,req,name=name" json:"name"`
	TaskID    TaskID        `protobuf:"bytes,2,req,name=task_id,json=taskId" json:"task_id"`
	AgentID   AgentID       `protobuf:"bytes,3,req,name=agent_id,json=agentId" json:"agent_id"`
	Resources []Resource    `protobuf:"bytes,4,rep,name=resources" json:"resources"`
	Executor  *ExecutorInfo `protobuf:"bytes,5,opt,name=executor" json:"executor,omitempty"`
	Command   *CommandInfo  `protobuf:"bytes,7,opt,name=command" json:"command,omitempty"`
	// Task provided with a container will launch the container as part
	// of this task paired with the task's CommandInfo.
	Container *ContainerInfo `protobuf:"bytes,9,opt,name=container" json:"container,omitempty"`
	// A health check for the task. Implemented for executor-less
	// command-based tasks. For tasks that specify an executor, it is
	// the executor's responsibility to implement the health checking.
	HealthCheck *HealthCheck `protobuf:"bytes,8,opt,name=health_check,json=healthCheck" json:"health_check,omitempty"`
	// A general check for the task. Implemented for all built-in executors.
	// For tasks that specify an executor, it is the executor's responsibility
	// to implement checking support. Executors should (all built-in executors
	// will) neither interpret nor act on the check's result.
	//
	// NOTE: Check support in built-in executors is experimental.
	//
	// TODO(alexr): Consider supporting multiple checks per task.
	Check *CheckInfo `protobuf:"bytes,13,opt,name=check" json:"check,omitempty"`
	// A kill policy for the task. Implemented for executor-less
	// command-based and docker tasks. For tasks that specify an
	// executor, it is the executor's responsibility to implement
	// the kill policy.
	KillPolicy *KillPolicy `protobuf:"bytes,12,opt,name=kill_policy,json=killPolicy" json:"kill_policy,omitempty"`
	Data       []byte      `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	// Labels are free-form key value pairs which are exposed through
	// master and agent endpoints. Labels will not be interpreted or
	// acted upon by Mesos itself. As opposed to the data field, labels
	// will be kept in memory on master and agent processes. Therefore,
	// labels should be used to tag tasks with light-weight meta-data.
	// Labels should not contain duplicate key-value pairs.
	Labels *Labels `protobuf:"bytes,10,opt,name=labels" json:"labels,omitempty"`
	// Service discovery information for the task. It is not interpreted
	// or acted upon by Mesos. It is up to a service discovery system
	// to use this information as needed and to handle tasks without
	// service discovery information.
	Discovery *DiscoveryInfo `protobuf:"bytes,11,opt,name=discovery" json:"discovery,omitempty"`
	// Maximum duration for task completion. If the task is non-terminal at the
	// end of this duration, it will fail with the reason
	// `REASON_MAX_COMPLETION_TIME_REACHED`. Mesos supports this field for
	// executor-less tasks, and tasks that use Docker or default executors.
	// It is the executor's responsibility to implement this, so it might not be
	// supported by all custom executors.
	MaxCompletionTime *DurationInfo `protobuf:"bytes,14,opt,name=max_completion_time,json=maxCompletionTime" json:"max_completion_time,omitempty"`
}

func (m *TaskInfo) Reset()                    { *m = TaskInfo{} }
func (*TaskInfo) ProtoMessage()               {}
func (*TaskInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{43} }

func (m *TaskInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TaskInfo) GetTaskID() TaskID {
	if m != nil {
		return m.TaskID
	}
	return TaskID{}
}

func (m *TaskInfo) GetAgentID() AgentID {
	if m != nil {
		return m.AgentID
	}
	return AgentID{}
}

func (m *TaskInfo) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *TaskInfo) GetExecutor() *ExecutorInfo {
	if m != nil {
		return m.Executor
	}
	return nil
}

func (m *TaskInfo) GetCommand() *CommandInfo {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *TaskInfo) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *TaskInfo) GetHealthCheck() *HealthCheck {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

func (m *TaskInfo) GetCheck() *CheckInfo {
	if m != nil {
		return m.Check
	}
	return nil
}

func (m *TaskInfo) GetKillPolicy() *KillPolicy {
	if m != nil {
		return m.KillPolicy
	}
	return nil
}

func (m *TaskInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TaskInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TaskInfo) GetDiscovery() *DiscoveryInfo {
	if m != nil {
		return m.Discovery
	}
	return nil
}

func (m *TaskInfo) GetMaxCompletionTime() *DurationInfo {
	if m != nil {
		return m.MaxCompletionTime
	}
	return nil
}

// *
// Describes a group of tasks that belong to an executor. The
// executor will receive the task group in a single message to
// allow the group to be launched "atomically".
//
// NOTES:
// 1) `NetworkInfo` must not be set inside task's `ContainerInfo`.
// 2) `TaskInfo.executor` doesn't need to set. If set, it should match
//    `LaunchGroup.executor`.
type TaskGroupInfo struct {
	Tasks []TaskInfo `protobuf:"bytes,1,rep,name=tasks" json:"tasks"`
}

func (m *TaskGroupInfo) Reset()                    { *m = TaskGroupInfo{} }
func (*TaskGroupInfo) ProtoMessage()               {}
func (*TaskGroupInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{44} }

func (m *TaskGroupInfo) GetTasks() []TaskInfo {
	if m != nil {
		return m.Tasks
	}
	return nil
}

// *
// Describes a task, similar to `TaskInfo`.
//
// `Task` is used in some of the Mesos messages found below.
// `Task` is used instead of `TaskInfo` if:
//   1) we need additional IDs, such as a specific
//      framework, executor, or agent; or
//   2) we do not need the additional data, such as the command run by the
//      task or the health checks.  These additional fields may be large and
//      unnecessary for some Mesos messages.
//
// `Task` is generally constructed from a `TaskInfo`.  See protobuf::createTask.
type Task struct {
	Name        string       `protobuf:"bytes,1,req,name=name" json:"name"`
	TaskID      TaskID       `protobuf:"bytes,2,req,name=task_id,json=taskId" json:"task_id"`
	FrameworkID FrameworkID  `protobuf:"bytes,3,req,name=framework_id,json=frameworkId" json:"framework_id"`
	ExecutorID  *ExecutorID  `protobuf:"bytes,4,opt,name=executor_id,json=executorId" json:"executor_id,omitempty"`
	AgentID     AgentID      `protobuf:"bytes,5,req,name=agent_id,json=agentId" json:"agent_id"`
	State       *TaskState   `protobuf:"varint,6,req,name=state,enum=mesos.TaskState" json:"state,omitempty"`
	Resources   []Resource   `protobuf:"bytes,7,rep,name=resources" json:"resources"`
	Statuses    []TaskStatus `protobuf:"bytes,8,rep,name=statuses" json:"statuses"`
	// These fields correspond to the state and uuid of the latest
	// status update forwarded to the master.
	// NOTE: Either both the fields must be set or both must be unset.
	StatusUpdateState *TaskState `protobuf:"varint,9,opt,name=status_update_state,json=statusUpdateState,enum=mesos.TaskState" json:"status_update_state,omitempty"`
	StatusUpdateUUID  []byte     `protobuf:"bytes,10,opt,name=status_update_uuid,json=statusUpdateUuid" json:"status_update_uuid,omitempty"`
	Labels            *Labels    `protobuf:"bytes,11,opt,name=labels" json:"labels,omitempty"`
	// Service discovery information for the task. It is not interpreted
	// or acted upon by Mesos. It is up to a service discovery system
	// to use this information as needed and to handle tasks without
	// service discovery information.
	Discovery *DiscoveryInfo `protobuf:"bytes,12,opt,name=discovery" json:"discovery,omitempty"`
	// Container information for the task.
	Container *ContainerInfo `protobuf:"bytes,13,opt,name=container" json:"container,omitempty"`
	// Specific user under which task is running.
	User *string `protobuf:"bytes,14,opt,name=user" json:"user,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{45} }

func (m *Task) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Task) GetTaskID() TaskID {
	if m != nil {
		return m.TaskID
	}
	return TaskID{}
}

func (m *Task) GetFrameworkID() FrameworkID {
	if m != nil {
		return m.FrameworkID
	}
	return FrameworkID{}
}

func (m *Task) GetExecutorID() *ExecutorID {
	if m != nil {
		return m.ExecutorID
	}
	return nil
}

func (m *Task) GetAgentID() AgentID {
	if m != nil {
		return m.AgentID
	}
	return AgentID{}
}

func (m *Task) GetState() TaskState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return TASK_STAGING
}

func (m *Task) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Task) GetStatuses() []TaskStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

func (m *Task) GetStatusUpdateState() TaskState {
	if m != nil && m.StatusUpdateState != nil {
		return *m.StatusUpdateState
	}
	return TASK_STAGING
}

func (m *Task) GetStatusUpdateUUID() []byte {
	if m != nil {
		return m.StatusUpdateUUID
	}
	return nil
}

func (m *Task) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Task) GetDiscovery() *DiscoveryInfo {
	if m != nil {
		return m.Discovery
	}
	return nil
}

func (m *Task) GetContainer() *ContainerInfo {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Task) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

// *
// Describes a resource limitation that caused a task failure.
type TaskResourceLimitation struct {
	// This field contains the resource whose limits were violated.
	//
	// NOTE: 'Resources' is used here because the resource may span
	// multiple roles (e.g. `"mem(*):1;mem(role):2"`).
	Resources []Resource `protobuf:"bytes,1,rep,name=resources" json:"resources"`
}

func (m *TaskResourceLimitation) Reset()                    { *m = TaskResourceLimitation{} }
func (*TaskResourceLimitation) ProtoMessage()               {}
func (*TaskResourceLimitation) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{46} }

func (m *TaskResourceLimitation) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// *
// Describes a UUID.
type UUID struct {
	Value []byte `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
}

func (m *UUID) Reset()                    { *m = UUID{} }
func (*UUID) ProtoMessage()               {}
func (*UUID) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{47} }

func (m *UUID) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// *
// Describes an operation, similar to `Offer.Operation`, with
// some additional information.
type Operation struct {
	FrameworkID  *FrameworkID    `protobuf:"bytes,1,opt,name=framework_id,json=frameworkId" json:"framework_id,omitempty"`
	AgentID      *AgentID        `protobuf:"bytes,2,opt,name=agent_id,json=agentId" json:"agent_id,omitempty"`
	Info         Offer_Operation `protobuf:"bytes,3,req,name=info" json:"info"`
	LatestStatus OperationStatus `protobuf:"bytes,4,req,name=latest_status,json=latestStatus" json:"latest_status"`
	// All the statuses known to this operation. Some of the statuses in this
	// list might not have been acknowledged yet. The statuses are ordered.
	Statuses []OperationStatus `protobuf:"bytes,5,rep,name=statuses" json:"statuses"`
	// This is the internal UUID for the operation, which is kept independently
	// from the framework-specified operation ID, which is optional.
	UUID UUID `protobuf:"bytes,6,req,name=uuid" json:"uuid"`
}

func (m *Operation) Reset()                    { *m = Operation{} }
func (*Operation) ProtoMessage()               {}
func (*Operation) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{48} }

func (m *Operation) GetFrameworkID() *FrameworkID {
	if m != nil {
		return m.FrameworkID
	}
	return nil
}

func (m *Operation) GetAgentID() *AgentID {
	if m != nil {
		return m.AgentID
	}
	return nil
}

func (m *Operation) GetInfo() Offer_Operation {
	if m != nil {
		return m.Info
	}
	return Offer_Operation{}
}

func (m *Operation) GetLatestStatus() OperationStatus {
	if m != nil {
		return m.LatestStatus
	}
	return OperationStatus{}
}

func (m *Operation) GetStatuses() []OperationStatus {
	if m != nil {
		return m.Statuses
	}
	return nil
}

func (m *Operation) GetUUID() UUID {
	if m != nil {
		return m.UUID
	}
	return UUID{}
}

// *
// Describes the current status of an operation.
type OperationStatus struct {
	// While frameworks will only receive status updates for operations on which
	// they have set an ID, this field is optional because this message is also
	// used internally by Mesos components when the operation's ID has not been
	// set.
	OperationID *OperationID   `protobuf:"bytes,1,opt,name=operation_id,json=operationId" json:"operation_id,omitempty"`
	State       OperationState `protobuf:"varint,2,req,name=state,enum=mesos.OperationState" json:"state"`
	Message     *string        `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	// Converted resources after applying the operation. This only
	// applies if the `state` is `OPERATION_FINISHED`.
	ConvertedResources []Resource `protobuf:"bytes,4,rep,name=converted_resources,json=convertedResources" json:"converted_resources"`
	// Statuses that are delivered reliably to the scheduler will
	// include a `uuid`. The status is considered delivered once
	// it is acknowledged by the scheduler.
	UUID *UUID `protobuf:"bytes,5,opt,name=uuid" json:"uuid,omitempty"`
}

func (m *OperationStatus) Reset()                    { *m = OperationStatus{} }
func (*OperationStatus) ProtoMessage()               {}
func (*OperationStatus) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{49} }

func (m *OperationStatus) GetOperationID() *OperationID {
	if m != nil {
		return m.OperationID
	}
	return nil
}

func (m *OperationStatus) GetState() OperationState {
	if m != nil {
		return m.State
	}
	return OPERATION_UNSUPPORTED
}

func (m *OperationStatus) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *OperationStatus) GetConvertedResources() []Resource {
	if m != nil {
		return m.ConvertedResources
	}
	return nil
}

func (m *OperationStatus) GetUUID() *UUID {
	if m != nil {
		return m.UUID
	}
	return nil
}

// *
// Describes the status of a check. Type and the corresponding field, i.e.,
// `command` or `http` must be set. If the result of the check is not available
// (e.g., the check timed out), these fields must contain empty messages, i.e.,
// `exit_code` or `status_code` will be unset.
//
// NOTE: This API is subject to change and the related feature is experimental.
type CheckStatusInfo struct {
	// The type of the check this status corresponds to.
	Type *CheckInfo_Type `protobuf:"varint,1,opt,name=type,enum=mesos.CheckInfo_Type" json:"type,omitempty"`
	// Status of a command check.
	Command *CheckStatusInfo_Command `protobuf:"bytes,2,opt,name=command" json:"command,omitempty"`
	// Status of an HTTP check.
	HTTP *CheckStatusInfo_Http `protobuf:"bytes,3,opt,name=http" json:"http,omitempty"`
	// Status of a TCP check.
	TCP *CheckStatusInfo_Tcp `protobuf:"bytes,4,opt,name=tcp" json:"tcp,omitempty"`
}

func (m *CheckStatusInfo) Reset()                    { *m = CheckStatusInfo{} }
func (*CheckStatusInfo) ProtoMessage()               {}
func (*CheckStatusInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{50} }

func (m *CheckStatusInfo) GetType() CheckInfo_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return CheckInfo_UNKNOWN
}

func (m *CheckStatusInfo) GetCommand() *CheckStatusInfo_Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *CheckStatusInfo) GetHTTP() *CheckStatusInfo_Http {
	if m != nil {
		return m.HTTP
	}
	return nil
}

func (m *CheckStatusInfo) GetTCP() *CheckStatusInfo_Tcp {
	if m != nil {
		return m.TCP
	}
	return nil
}

type CheckStatusInfo_Command struct {
	// Exit code of a command check. It is the result of calling
	// `WEXITSTATUS()` on `waitpid()` termination information on
	// Posix and calling `GetExitCodeProcess()` on Windows.
	ExitCode *int32 `protobuf:"varint,1,opt,name=exit_code,json=exitCode" json:"exit_code,omitempty"`
}

func (m *CheckStatusInfo_Command) Reset()                    { *m = CheckStatusInfo_Command{} }
func (*CheckStatusInfo_Command) ProtoMessage()               {}
func (*CheckStatusInfo_Command) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{50, 0} }

func (m *CheckStatusInfo_Command) GetExitCode() int32 {
	if m != nil && m.ExitCode != nil {
		return *m.ExitCode
	}
	return 0
}

type CheckStatusInfo_Http struct {
	// HTTP status code of an HTTP check.
	StatusCode *uint32 `protobuf:"varint,1,opt,name=status_code,json=statusCode" json:"status_code,omitempty"`
}

func (m *CheckStatusInfo_Http) Reset()                    { *m = CheckStatusInfo_Http{} }
func (*CheckStatusInfo_Http) ProtoMessage()               {}
func (*CheckStatusInfo_Http) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{50, 1} }

func (m *CheckStatusInfo_Http) GetStatusCode() uint32 {
	if m != nil && m.StatusCode != nil {
		return *m.StatusCode
	}
	return 0
}

type CheckStatusInfo_Tcp struct {
	// Whether a TCP connection succeeded.
	Succeeded *bool `protobuf:"varint,1,opt,name=succeeded" json:"succeeded,omitempty"`
}

func (m *CheckStatusInfo_Tcp) Reset()                    { *m = CheckStatusInfo_Tcp{} }
func (*CheckStatusInfo_Tcp) ProtoMessage()               {}
func (*CheckStatusInfo_Tcp) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{50, 2} }

func (m *CheckStatusInfo_Tcp) GetSucceeded() bool {
	if m != nil && m.Succeeded != nil {
		return *m.Succeeded
	}
	return false
}

// *
// Describes the current status of a task.
type TaskStatus struct {
	TaskID     TaskID             `protobuf:"bytes,1,req,name=task_id,json=taskId" json:"task_id"`
	State      *TaskState         `protobuf:"varint,2,req,name=state,enum=mesos.TaskState" json:"state,omitempty"`
	Message    *string            `protobuf:"bytes,4,opt,name=message" json:"message,omitempty"`
	Source     *TaskStatus_Source `protobuf:"varint,9,opt,name=source,enum=mesos.TaskStatus_Source" json:"source,omitempty"`
	Reason     *TaskStatus_Reason `protobuf:"varint,10,opt,name=reason,enum=mesos.TaskStatus_Reason" json:"reason,omitempty"`
	Data       []byte             `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	AgentID    *AgentID           `protobuf:"bytes,5,opt,name=agent_id,json=agentId" json:"agent_id,omitempty"`
	ExecutorID *ExecutorID        `protobuf:"bytes,7,opt,name=executor_id,json=executorId" json:"executor_id,omitempty"`
	Timestamp  *float64           `protobuf:"fixed64,6,opt,name=timestamp" json:"timestamp,omitempty"`
	// Statuses that are delivered reliably to the scheduler will
	// include a 'uuid'. The status is considered delivered once
	// it is acknowledged by the scheduler. Schedulers can choose
	// to either explicitly acknowledge statuses or let the scheduler
	// driver implicitly acknowledge (default).
	//
	// TODO(bmahler): This is currently overwritten in the scheduler
	// driver and executor driver, but executors will need to set this
	// to a valid RFC-4122 UUID if using the HTTP API.
	UUID []byte `protobuf:"bytes,11,opt,name=uuid" json:"uuid,omitempty"`
	// Describes whether the task has been determined to be healthy (true) or
	// unhealthy (false) according to the `health_check` field in `TaskInfo`.
	Healthy *bool `protobuf:"varint,8,opt,name=healthy" json:"healthy,omitempty"`
	// Contains check status for the check specified in the corresponding
	// `TaskInfo`. If no check has been specified, this field must be
	// absent, otherwise it must be present even if the check status is
	// not available yet. If the status update is triggered for a different
	// reason than `REASON_TASK_CHECK_STATUS_UPDATED`, this field will contain
	// the last known value.
	//
	// NOTE: A check-related task status update is triggered if and only if
	// the value or presence of any field in `CheckStatusInfo` changes.
	//
	// NOTE: Check support in built-in executors is experimental.
	CheckStatus *CheckStatusInfo `protobuf:"bytes,15,opt,name=check_status,json=checkStatus" json:"check_status,omitempty"`
	// Labels are free-form key value pairs which are exposed through
	// master and agent endpoints. Labels will not be interpreted or
	// acted upon by Mesos itself. As opposed to the data field, labels
	// will be kept in memory on master and agent processes. Therefore,
	// labels should be used to tag TaskStatus message with light-weight
	// meta-data. Labels should not contain duplicate key-value pairs.
	Labels *Labels `protobuf:"bytes,12,opt,name=labels" json:"labels,omitempty"`
	// Container related information that is resolved dynamically such as
	// network address.
	ContainerStatus *ContainerStatus `protobuf:"bytes,13,opt,name=container_status,json=containerStatus" json:"container_status,omitempty"`
	// The time (according to the master's clock) when the agent where
	// this task was running became unreachable. This is only set on
	// status updates for tasks running on agents that are unreachable
	// (e.g., partitioned away from the master).
	UnreachableTime *TimeInfo `protobuf:"bytes,14,opt,name=unreachable_time,json=unreachableTime" json:"unreachable_time,omitempty"`
	// If the reason field indicates a container resource limitation,
	// this field optionally contains additional information.
	Limitation *TaskResourceLimitation `protobuf:"bytes,16,opt,name=limitation" json:"limitation,omitempty"`
}

func (m *TaskStatus) Reset()                    { *m = TaskStatus{} }
func (*TaskStatus) ProtoMessage()               {}
func (*TaskStatus) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{51} }

func (m *TaskStatus) GetTaskID() TaskID {
	if m != nil {
		return m.TaskID
	}
	return TaskID{}
}

func (m *TaskStatus) GetState() TaskState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return TASK_STAGING
}

func (m *TaskStatus) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *TaskStatus) GetSource() TaskStatus_Source {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return SOURCE_MASTER
}

func (m *TaskStatus) GetReason() TaskStatus_Reason {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return REASON_COMMAND_EXECUTOR_FAILED
}

func (m *TaskStatus) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TaskStatus) GetAgentID() *AgentID {
	if m != nil {
		return m.AgentID
	}
	return nil
}

func (m *TaskStatus) GetExecutorID() *ExecutorID {
	if m != nil {
		return m.ExecutorID
	}
	return nil
}

func (m *TaskStatus) GetTimestamp() float64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *TaskStatus) GetUUID() []byte {
	if m != nil {
		return m.UUID
	}
	return nil
}

func (m *TaskStatus) GetHealthy() bool {
	if m != nil && m.Healthy != nil {
		return *m.Healthy
	}
	return false
}

func (m *TaskStatus) GetCheckStatus() *CheckStatusInfo {
	if m != nil {
		return m.CheckStatus
	}
	return nil
}

func (m *TaskStatus) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TaskStatus) GetContainerStatus() *ContainerStatus {
	if m != nil {
		return m.ContainerStatus
	}
	return nil
}

func (m *TaskStatus) GetUnreachableTime() *TimeInfo {
	if m != nil {
		return m.UnreachableTime
	}
	return nil
}

func (m *TaskStatus) GetLimitation() *TaskResourceLimitation {
	if m != nil {
		return m.Limitation
	}
	return nil
}

// *
// Describes possible filters that can be applied to unused resources
// (see SchedulerDriver::launchTasks) to influence the allocator.
type Filters struct {
	// Time to consider unused resources refused. Note that all unused
	// resources will be considered refused and use the default value
	// (below) regardless of whether Filters was passed to
	// SchedulerDriver::launchTasks. You MUST pass Filters with this
	// field set to change this behavior (i.e., get another offer which
	// includes unused resources sooner or later than the default).
	//
	// If this field is set to a number of seconds greater than 31536000
	// (365 days), then the resources will be considered refused for 365
	// days. If it is set to a negative number, then the default value
	// will be used.
	RefuseSeconds *float64 `protobuf:"fixed64,1,opt,name=refuse_seconds,json=refuseSeconds,def=5" json:"refuse_seconds,omitempty"`
}

func (m *Filters) Reset()                    { *m = Filters{} }
func (*Filters) ProtoMessage()               {}
func (*Filters) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{52} }

const Default_Filters_RefuseSeconds float64 = 5

func (m *Filters) GetRefuseSeconds() float64 {
	if m != nil && m.RefuseSeconds != nil {
		return *m.RefuseSeconds
	}
	return Default_Filters_RefuseSeconds
}

// *
// Describes a collection of environment variables. This is used with
// CommandInfo in order to set environment variables before running a
// command. The contents of each variable may be specified as a string
// or a Secret; only one of `value` and `secret` must be set.
type Environment struct {
	Variables []Environment_Variable `protobuf:"bytes,1,rep,name=variables" json:"variables"`
}

func (m *Environment) Reset()                    { *m = Environment{} }
func (*Environment) ProtoMessage()               {}
func (*Environment) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{53} }

func (m *Environment) GetVariables() []Environment_Variable {
	if m != nil {
		return m.Variables
	}
	return nil
}

type Environment_Variable struct {
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
	// In Mesos 1.2, the `Environment.variables.value` message was made
	// optional. The default type for `Environment.variables.type` is now VALUE,
	// which requires `value` to be set, maintaining backward compatibility.
	//
	// TODO(greggomann): The default can be removed in Mesos 2.1 (MESOS-7134).
	Type *Environment_Variable_Type `protobuf:"varint,3,opt,name=type,enum=mesos.Environment_Variable_Type,def=1" json:"type,omitempty"`
	// Only one of `value` and `secret` must be set.
	Value  *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Secret *Secret `protobuf:"bytes,4,opt,name=secret" json:"secret,omitempty"`
}

func (m *Environment_Variable) Reset()                    { *m = Environment_Variable{} }
func (*Environment_Variable) ProtoMessage()               {}
func (*Environment_Variable) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{53, 0} }

const Default_Environment_Variable_Type Environment_Variable_Type = Environment_Variable_VALUE

func (m *Environment_Variable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Environment_Variable) GetType() Environment_Variable_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_Environment_Variable_Type
}

func (m *Environment_Variable) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *Environment_Variable) GetSecret() *Secret {
	if m != nil {
		return m.Secret
	}
	return nil
}

// *
// A generic (key, value) pair used in various places for parameters.
type Parameter struct {
	Key   string `protobuf:"bytes,1,req,name=key" json:"key"`
	Value string `protobuf:"bytes,2,req,name=value" json:"value"`
}

func (m *Parameter) Reset()                    { *m = Parameter{} }
func (*Parameter) ProtoMessage()               {}
func (*Parameter) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{54} }

func (m *Parameter) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Parameter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// *
// Collection of Parameter.
type Parameters struct {
	Parameter []Parameter `protobuf:"bytes,1,rep,name=parameter" json:"parameter"`
}

func (m *Parameters) Reset()                    { *m = Parameters{} }
func (*Parameters) ProtoMessage()               {}
func (*Parameters) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{55} }

func (m *Parameters) GetParameter() []Parameter {
	if m != nil {
		return m.Parameter
	}
	return nil
}

// *
// Credential used in various places for authentication and
// authorization.
//
// NOTE: A 'principal' is different from 'FrameworkInfo.user'. The
// former is used for authentication and authorization while the
// latter is used to determine the default user under which the
// framework's executors/tasks are run.
type Credential struct {
	Principal string  `protobuf:"bytes,1,req,name=principal" json:"principal"`
	Secret    *string `protobuf:"bytes,2,opt,name=secret" json:"secret,omitempty"`
}

func (m *Credential) Reset()                    { *m = Credential{} }
func (*Credential) ProtoMessage()               {}
func (*Credential) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{56} }

func (m *Credential) GetPrincipal() string {
	if m != nil {
		return m.Principal
	}
	return ""
}

func (m *Credential) GetSecret() string {
	if m != nil && m.Secret != nil {
		return *m.Secret
	}
	return ""
}

// *
// Credentials used for framework authentication, HTTP authentication
// (where the common 'username' and 'password' are captured as
// 'principal' and 'secret' respectively), etc.
type Credentials struct {
	Credentials []Credential `protobuf:"bytes,1,rep,name=credentials" json:"credentials"`
}

func (m *Credentials) Reset()                    { *m = Credentials{} }
func (*Credentials) ProtoMessage()               {}
func (*Credentials) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{57} }

func (m *Credentials) GetCredentials() []Credential {
	if m != nil {
		return m.Credentials
	}
	return nil
}

// *
// Secret used to pass privileged information. It is designed to provide
// pass-by-value or pass-by-reference semantics, where the REFERENCE type can be
// used by custom modules which interact with a secure back-end.
type Secret struct {
	Type Secret_Type `protobuf:"varint,1,opt,name=type,enum=mesos.Secret_Type" json:"type"`
	// Only one of `reference` and `value` must be set.
	Reference *Secret_Reference `protobuf:"bytes,2,opt,name=reference" json:"reference,omitempty"`
	Value     *Secret_Value     `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *Secret) Reset()                    { *m = Secret{} }
func (*Secret) ProtoMessage()               {}
func (*Secret) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{58} }

func (m *Secret) GetType() Secret_Type {
	if m != nil {
		return m.Type
	}
	return Secret_UNKNOWN
}

func (m *Secret) GetReference() *Secret_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *Secret) GetValue() *Secret_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Can be used by modules to refer to a secret stored in a secure back-end.
// The `key` field is provided to permit reference to a single value within a
// secret containing arbitrary key-value pairs.
//
// For example, given a back-end secret store with a secret named
// "my-secret" containing the following key-value pairs:
//
//   {
//     "username": "my-user",
//     "password": "my-password
//   }
//
// the username could be referred to in a `Secret` by specifying
// "my-secret" for the `name` and "username" for the `key`.
type Secret_Reference struct {
	Name string  `protobuf:"bytes,1,req,name=name" json:"name"`
	Key  *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
}

func (m *Secret_Reference) Reset()                    { *m = Secret_Reference{} }
func (*Secret_Reference) ProtoMessage()               {}
func (*Secret_Reference) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{58, 0} }

func (m *Secret_Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Secret_Reference) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

// Used to pass the value of a secret.
type Secret_Value struct {
	Data []byte `protobuf:"bytes,1,req,name=data" json:"data,omitempty"`
}

func (m *Secret_Value) Reset()                    { *m = Secret_Value{} }
func (*Secret_Value) ProtoMessage()               {}
func (*Secret_Value) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{58, 1} }

func (m *Secret_Value) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Rate (queries per second, QPS) limit for messages from a framework to master.
// Strictly speaking they are the combined rate from all frameworks of the same
// principal.
type RateLimit struct {
	// Leaving QPS unset gives it unlimited rate (i.e., not throttled),
	// which also implies unlimited capacity.
	QPS *float64 `protobuf:"fixed64,1,opt,name=qps" json:"qps,omitempty"`
	// Principal of framework(s) to be throttled. Should match
	// FrameworkInfo.principal and Credential.principal (if using authentication).
	Principal string `protobuf:"bytes,2,req,name=principal" json:"principal"`
	// Max number of outstanding messages from frameworks of this principal
	// allowed by master before the next message is dropped and an error is sent
	// back to the sender. Messages received before the capacity is reached are
	// still going to be processed after the error is sent.
	// If unspecified, this principal is assigned unlimited capacity.
	// NOTE: This value is ignored if 'qps' is not set.
	Capacity *uint64 `protobuf:"varint,3,opt,name=capacity" json:"capacity,omitempty"`
}

func (m *RateLimit) Reset()                    { *m = RateLimit{} }
func (*RateLimit) ProtoMessage()               {}
func (*RateLimit) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{59} }

func (m *RateLimit) GetQPS() float64 {
	if m != nil && m.QPS != nil {
		return *m.QPS
	}
	return 0
}

func (m *RateLimit) GetPrincipal() string {
	if m != nil {
		return m.Principal
	}
	return ""
}

func (m *RateLimit) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

// *
// Collection of RateLimit.
// Frameworks without rate limits defined here are not throttled unless
// 'aggregate_default_qps' is specified.
type RateLimits struct {
	// Items should have unique principals.
	Limits []RateLimit `protobuf:"bytes,1,rep,name=limits" json:"limits"`
	// All the frameworks not specified in 'limits' get this default rate.
	// This rate is an aggregate rate for all of them, i.e., their combined
	// traffic is throttled together at this rate.
	AggregateDefaultQPS *float64 `protobuf:"fixed64,2,opt,name=aggregate_default_qps,json=aggregateDefaultQps" json:"aggregate_default_qps,omitempty"`
	// All the frameworks not specified in 'limits' get this default capacity.
	// This is an aggregate value similar to 'aggregate_default_qps'.
	AggregateDefaultCapacity *uint64 `protobuf:"varint,3,opt,name=aggregate_default_capacity,json=aggregateDefaultCapacity" json:"aggregate_default_capacity,omitempty"`
}

func (m *RateLimits) Reset()                    { *m = RateLimits{} }
func (*RateLimits) ProtoMessage()               {}
func (*RateLimits) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{60} }

func (m *RateLimits) GetLimits() []RateLimit {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *RateLimits) GetAggregateDefaultQPS() float64 {
	if m != nil && m.AggregateDefaultQPS != nil {
		return *m.AggregateDefaultQPS
	}
	return 0
}

func (m *RateLimits) GetAggregateDefaultCapacity() uint64 {
	if m != nil && m.AggregateDefaultCapacity != nil {
		return *m.AggregateDefaultCapacity
	}
	return 0
}

// *
// Describe an image used by tasks or executors. Note that it's only
// for tasks or executors launched by MesosContainerizer currently.
type Image struct {
	Type *Image_Type `protobuf:"varint,1,req,name=type,enum=mesos.Image_Type" json:"type,omitempty"`
	// Only one of the following image messages should be set to match
	// the type.
	Appc   *Image_Appc   `protobuf:"bytes,2,opt,name=appc" json:"appc,omitempty"`
	Docker *Image_Docker `protobuf:"bytes,3,opt,name=docker" json:"docker,omitempty"`
	// With this flag set to false, the mesos containerizer will pull
	// the docker/appc image from the registry even if the image is
	// already downloaded on the agent.
	Cached *bool `protobuf:"varint,4,opt,name=cached,def=1" json:"cached,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{61} }

const Default_Image_Cached bool = true

func (m *Image) GetType() Image_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Image_APPC
}

func (m *Image) GetAppc() *Image_Appc {
	if m != nil {
		return m.Appc
	}
	return nil
}

func (m *Image) GetDocker() *Image_Docker {
	if m != nil {
		return m.Docker
	}
	return nil
}

func (m *Image) GetCached() bool {
	if m != nil && m.Cached != nil {
		return *m.Cached
	}
	return Default_Image_Cached
}

// Protobuf for specifying an Appc container image. See:
// https://github.com/appc/spec/blob/master/spec/aci.md
type Image_Appc struct {
	// The name of the image.
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
	// An image ID is a string of the format "hash-value", where
	// "hash" is the hash algorithm used and "value" is the hex
	// encoded string of the digest. Currently the only permitted
	// hash algorithm is sha512.
	ID *string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Optional labels. Suggested labels: "version", "os", and "arch".
	Labels *Labels `protobuf:"bytes,3,opt,name=labels" json:"labels,omitempty"`
}

func (m *Image_Appc) Reset()                    { *m = Image_Appc{} }
func (*Image_Appc) ProtoMessage()               {}
func (*Image_Appc) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{61, 0} }

func (m *Image_Appc) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Image_Appc) GetID() string {
	if m != nil && m.ID != nil {
		return *m.ID
	}
	return ""
}

func (m *Image_Appc) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Image_Docker struct {
	// The name of the image. Expected format:
	//   [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG|@TYPE:DIGEST]
	//
	// See: https://docs.docker.com/reference/commandline/pull/
	Name string `protobuf:"bytes,1,req,name=name" json:"name"`
	// Credential to authenticate with docker registry.
	// NOTE: This is not encrypted, therefore framework and operators
	// should enable SSL when passing this information.
	//
	// This field has never been used in Mesos before and is
	// deprecated since Mesos 1.3. Please use `config` below
	// (see MESOS-7088 for details).
	Credential *Credential `protobuf:"bytes,2,opt,name=credential" json:"credential,omitempty"`
	// Docker config containing credentials to authenticate with
	// docker registry. The secret is expected to be a docker
	// config file in JSON format with UTF-8 character encoding.
	Config *Secret `protobuf:"bytes,3,opt,name=config" json:"config,omitempty"`
}

func (m *Image_Docker) Reset()                    { *m = Image_Docker{} }
func (*Image_Docker) ProtoMessage()               {}
func (*Image_Docker) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{61, 1} }

func (m *Image_Docker) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Image_Docker) GetCredential() *Credential {
	if m != nil {
		return m.Credential
	}
	return nil
}

func (m *Image_Docker) GetConfig() *Secret {
	if m != nil {
		return m.Config
	}
	return nil
}

// *
// Describes how the mount will be propagated for a volume. See the
// following doc for more details about mount propagation:
// https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
type MountPropagation struct {
	Mode *MountPropagation_Mode `protobuf:"varint,1,opt,name=mode,enum=mesos.MountPropagation_Mode" json:"mode,omitempty"`
}

func (m *MountPropagation) Reset()                    { *m = MountPropagation{} }
func (*MountPropagation) ProtoMessage()               {}
func (*MountPropagation) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{62} }

func (m *MountPropagation) GetMode() MountPropagation_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return MountPropagation_UNKNOWN
}

// *
// Describes a volume mapping either from host to container or vice
// versa. Both paths can either refer to a directory or a file.
type Volume struct {
	// TODO(gyliu513): Make this as `optional` after deprecation cycle of 1.0.
	Mode *Volume_Mode `protobuf:"varint,3,req,name=mode,enum=mesos.Volume_Mode" json:"mode,omitempty"`
	// Path pointing to a directory or file in the container. If the
	// path is a relative path, it is relative to the container work
	// directory. If the path is an absolute path, that path must
	// already exist.
	ContainerPath string `protobuf:"bytes,1,req,name=container_path,json=containerPath" json:"container_path"`
	// Absolute path pointing to a directory or file on the host or a
	// path relative to the container work directory.
	HostPath *string `protobuf:"bytes,2,opt,name=host_path,json=hostPath" json:"host_path,omitempty"`
	// The source of the volume is an Image which describes a root
	// filesystem which will be provisioned by Mesos.
	Image  *Image         `protobuf:"bytes,4,opt,name=image" json:"image,omitempty"`
	Source *Volume_Source `protobuf:"bytes,5,opt,name=source" json:"source,omitempty"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{63} }

func (m *Volume) GetMode() Volume_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return RW
}

func (m *Volume) GetContainerPath() string {
	if m != nil {
		return m.ContainerPath
	}
	return ""
}

func (m *Volume) GetHostPath() string {
	if m != nil && m.HostPath != nil {
		return *m.HostPath
	}
	return ""
}

func (m *Volume) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *Volume) GetSource() *Volume_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

// Describes where a volume originates from.
type Volume_Source struct {
	// Enum fields should be optional, see: MESOS-4997.
	Type Volume_Source_Type `protobuf:"varint,1,opt,name=type,enum=mesos.Volume_Source_Type" json:"type"`
	// The source of the volume created by docker volume driver.
	DockerVolume *Volume_Source_DockerVolume `protobuf:"bytes,2,opt,name=docker_volume,json=dockerVolume" json:"docker_volume,omitempty"`
	HostPath     *Volume_Source_HostPath     `protobuf:"bytes,5,opt,name=host_path,json=hostPath" json:"host_path,omitempty"`
	SandboxPath  *Volume_Source_SandboxPath  `protobuf:"bytes,3,opt,name=sandbox_path,json=sandboxPath" json:"sandbox_path,omitempty"`
	// The volume/secret isolator uses the secret-fetcher module (third-party or
	// internal) downloads the secret and makes it available at container_path.
	Secret *Secret `protobuf:"bytes,4,opt,name=secret" json:"secret,omitempty"`
}

func (m *Volume_Source) Reset()                    { *m = Volume_Source{} }
func (*Volume_Source) ProtoMessage()               {}
func (*Volume_Source) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{63, 0} }

func (m *Volume_Source) GetType() Volume_Source_Type {
	if m != nil {
		return m.Type
	}
	return Volume_Source_UNKNOWN
}

func (m *Volume_Source) GetDockerVolume() *Volume_Source_DockerVolume {
	if m != nil {
		return m.DockerVolume
	}
	return nil
}

func (m *Volume_Source) GetHostPath() *Volume_Source_HostPath {
	if m != nil {
		return m.HostPath
	}
	return nil
}

func (m *Volume_Source) GetSandboxPath() *Volume_Source_SandboxPath {
	if m != nil {
		return m.SandboxPath
	}
	return nil
}

func (m *Volume_Source) GetSecret() *Secret {
	if m != nil {
		return m.Secret
	}
	return nil
}

type Volume_Source_DockerVolume struct {
	// Driver of the volume, it can be flocker, convoy, raxrey etc.
	Driver *string `protobuf:"bytes,1,opt,name=driver" json:"driver,omitempty"`
	// Name of the volume.
	Name string `protobuf:"bytes,2,req,name=name" json:"name"`
	// Volume driver specific options.
	DriverOptions *Parameters `protobuf:"bytes,3,opt,name=driver_options,json=driverOptions" json:"driver_options,omitempty"`
}

func (m *Volume_Source_DockerVolume) Reset()      { *m = Volume_Source_DockerVolume{} }
func (*Volume_Source_DockerVolume) ProtoMessage() {}
func (*Volume_Source_DockerVolume) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{63, 0, 0}
}

func (m *Volume_Source_DockerVolume) GetDriver() string {
	if m != nil && m.Driver != nil {
		return *m.Driver
	}
	return ""
}

func (m *Volume_Source_DockerVolume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Volume_Source_DockerVolume) GetDriverOptions() *Parameters {
	if m != nil {
		return m.DriverOptions
	}
	return nil
}

// Absolute path pointing to a directory or file on the host.
type Volume_Source_HostPath struct {
	Path             string            `protobuf:"bytes,1,req,name=path" json:"path"`
	MountPropagation *MountPropagation `protobuf:"bytes,2,opt,name=mount_propagation,json=mountPropagation" json:"mount_propagation,omitempty"`
}

func (m *Volume_Source_HostPath) Reset()      { *m = Volume_Source_HostPath{} }
func (*Volume_Source_HostPath) ProtoMessage() {}
func (*Volume_Source_HostPath) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{63, 0, 1}
}

func (m *Volume_Source_HostPath) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Volume_Source_HostPath) GetMountPropagation() *MountPropagation {
	if m != nil {
		return m.MountPropagation
	}
	return nil
}

// Describe a path from a container's sandbox. The container can
// be the current container (SELF), or its parent container
// (PARENT). PARENT allows all child containers to share a volume
// from their parent container's sandbox. It'll be an error if
// the current container is a top level container.
type Volume_Source_SandboxPath struct {
	Type Volume_Source_SandboxPath_Type `protobuf:"varint,1,opt,name=type,enum=mesos.Volume_Source_SandboxPath_Type" json:"type"`
	// A path relative to the corresponding container's sandbox.
	// Note that upwards traversal (i.e. ../../abc) is not allowed.
	Path string `protobuf:"bytes,2,req,name=path" json:"path"`
}

func (m *Volume_Source_SandboxPath) Reset()      { *m = Volume_Source_SandboxPath{} }
func (*Volume_Source_SandboxPath) ProtoMessage() {}
func (*Volume_Source_SandboxPath) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{63, 0, 2}
}

func (m *Volume_Source_SandboxPath) GetType() Volume_Source_SandboxPath_Type {
	if m != nil {
		return m.Type
	}
	return Volume_Source_SandboxPath_UNKNOWN
}

func (m *Volume_Source_SandboxPath) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// *
// Describes a network request from a framework as well as network resolution
// provided by Mesos.
//
// A framework may request the network isolator on the Agent to isolate the
// container in a network namespace and create a virtual network interface.
// The `NetworkInfo` message describes the properties of that virtual
// interface, including the IP addresses and network isolation policy
// (network group membership).
//
// The NetworkInfo message is not interpreted by the Master or Agent and is
// intended to be used by Agent and Master modules implementing network
// isolation. If the modules are missing, the message is simply ignored. In
// future, the task launch will fail if there is no module providing the
// network isolation capabilities (MESOS-3390).
//
// An executor, Agent, or an Agent module may append NetworkInfos inside
// TaskStatus::container_status to provide information such as the container IP
// address and isolation groups.
type NetworkInfo struct {
	// When included in a ContainerInfo, each of these represent a
	// request for an IP address. Each request can specify an explicit address
	// or the IP protocol to use.
	//
	// When included in a TaskStatus message, these inform the framework
	// scheduler about the IP addresses that are bound to the container
	// interface. When there are no custom network isolator modules installed,
	// this field is filled in automatically with the Agent IP address.
	IPAddresses []NetworkInfo_IPAddress `protobuf:"bytes,5,rep,name=ip_addresses,json=ipAddresses" json:"ip_addresses"`
	// Name of the network which will be used by network isolator to determine
	// the network that the container joins. It's up to the network isolator
	// to decide how to interpret this field.
	Name *string `protobuf:"bytes,6,opt,name=name" json:"name,omitempty"`
	// A group is the name given to a set of logically-related interfaces that
	// are allowed to communicate among themselves. Network traffic is allowed
	// between two container interfaces that share at least one network group.
	// For example, one might want to create separate groups for isolating dev,
	// testing, qa and prod deployment environments.
	Groups []string `protobuf:"bytes,3,rep,name=groups" json:"groups,omitempty"`
	// To tag certain metadata to be used by Isolator/IPAM, e.g., rack, etc.
	Labels       *Labels                   `protobuf:"bytes,4,opt,name=labels" json:"labels,omitempty"`
	PortMappings []NetworkInfo_PortMapping `protobuf:"bytes,7,rep,name=port_mappings,json=portMappings" json:"port_mappings"`
}

func (m *NetworkInfo) Reset()                    { *m = NetworkInfo{} }
func (*NetworkInfo) ProtoMessage()               {}
func (*NetworkInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{64} }

func (m *NetworkInfo) GetIPAddresses() []NetworkInfo_IPAddress {
	if m != nil {
		return m.IPAddresses
	}
	return nil
}

func (m *NetworkInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetworkInfo) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *NetworkInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *NetworkInfo) GetPortMappings() []NetworkInfo_PortMapping {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

// Specifies a request for an IP address, or reports the assigned container
// IP address.
//
// Users can request an automatically assigned IP (for example, via an
// IPAM service) or a specific IP by adding a NetworkInfo to the
// ContainerInfo for a task.  On a request, specifying neither `protocol`
// nor `ip_address` means that any available address may be assigned.
type NetworkInfo_IPAddress struct {
	// Specify IP address requirement. Set protocol to the desired value to
	// request the network isolator on the Agent to assign an IP address to the
	// container being launched. If a specific IP address is specified in
	// ip_address, this field should not be set.
	Protocol *NetworkInfo_Protocol `protobuf:"varint,1,opt,name=protocol,enum=mesos.NetworkInfo_Protocol,def=1" json:"protocol,omitempty"`
	// Statically assigned IP provided by the Framework. This IP will be
	// assigned to the container by the network isolator module on the Agent.
	// This field should not be used with the protocol field above.
	//
	// If an explicit address is requested but is unavailable, the network
	// isolator should fail the task.
	IPAddress *string `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
}

func (m *NetworkInfo_IPAddress) Reset()                    { *m = NetworkInfo_IPAddress{} }
func (*NetworkInfo_IPAddress) ProtoMessage()               {}
func (*NetworkInfo_IPAddress) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{64, 0} }

const Default_NetworkInfo_IPAddress_Protocol NetworkInfo_Protocol = IPv4

func (m *NetworkInfo_IPAddress) GetProtocol() NetworkInfo_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return Default_NetworkInfo_IPAddress_Protocol
}

func (m *NetworkInfo_IPAddress) GetIPAddress() string {
	if m != nil && m.IPAddress != nil {
		return *m.IPAddress
	}
	return ""
}

// Specifies a port mapping request for the task on this network.
type NetworkInfo_PortMapping struct {
	HostPort      uint32 `protobuf:"varint,1,req,name=host_port,json=hostPort" json:"host_port"`
	ContainerPort uint32 `protobuf:"varint,2,req,name=container_port,json=containerPort" json:"container_port"`
	// Protocol to expose as (ie: tcp, udp).
	Protocol *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
}

func (m *NetworkInfo_PortMapping) Reset()                    { *m = NetworkInfo_PortMapping{} }
func (*NetworkInfo_PortMapping) ProtoMessage()               {}
func (*NetworkInfo_PortMapping) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{64, 1} }

func (m *NetworkInfo_PortMapping) GetHostPort() uint32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *NetworkInfo_PortMapping) GetContainerPort() uint32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *NetworkInfo_PortMapping) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

// *
// Encapsulation of `Capabilities` supported by Linux.
// Reference: http://linux.die.net/man/7/capabilities.
type CapabilityInfo struct {
	Capabilities []CapabilityInfo_Capability `protobuf:"varint,1,rep,name=capabilities,enum=mesos.CapabilityInfo_Capability" json:"capabilities,omitempty"`
}

func (m *CapabilityInfo) Reset()                    { *m = CapabilityInfo{} }
func (*CapabilityInfo) ProtoMessage()               {}
func (*CapabilityInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{65} }

func (m *CapabilityInfo) GetCapabilities() []CapabilityInfo_Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// *
// Encapsulation for Linux specific configuration.
// E.g, capabilities, limits etc.
type LinuxInfo struct {
	// Since 1.4.0, deprecated in favor of `effective_capabilities`.
	CapabilityInfo *CapabilityInfo `protobuf:"bytes,1,opt,name=capability_info,json=capabilityInfo" json:"capability_info,omitempty"`
	// The set of capabilities that are allowed but not initially
	// granted to tasks.
	BoundingCapabilities *CapabilityInfo `protobuf:"bytes,2,opt,name=bounding_capabilities,json=boundingCapabilities" json:"bounding_capabilities,omitempty"`
	// Represents the set of capabilities that the task will
	// be executed with.
	EffectiveCapabilities *CapabilityInfo `protobuf:"bytes,3,opt,name=effective_capabilities,json=effectiveCapabilities" json:"effective_capabilities,omitempty"`
	// If set as 'true', the container shares the pid namespace with
	// its parent. If the container is a top level container, it will
	// share the pid namespace with the agent. If the container is a
	// nested container, it will share the pid namespace with its
	// parent container. This field will be ignored if 'namespaces/pid'
	// isolator is not enabled.
	SharePIDNamespace *bool `protobuf:"varint,4,opt,name=share_pid_namespace,json=sharePidNamespace" json:"share_pid_namespace,omitempty"`
}

func (m *LinuxInfo) Reset()                    { *m = LinuxInfo{} }
func (*LinuxInfo) ProtoMessage()               {}
func (*LinuxInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{66} }

func (m *LinuxInfo) GetCapabilityInfo() *CapabilityInfo {
	if m != nil {
		return m.CapabilityInfo
	}
	return nil
}

func (m *LinuxInfo) GetBoundingCapabilities() *CapabilityInfo {
	if m != nil {
		return m.BoundingCapabilities
	}
	return nil
}

func (m *LinuxInfo) GetEffectiveCapabilities() *CapabilityInfo {
	if m != nil {
		return m.EffectiveCapabilities
	}
	return nil
}

func (m *LinuxInfo) GetSharePIDNamespace() bool {
	if m != nil && m.SharePIDNamespace != nil {
		return *m.SharePIDNamespace
	}
	return false
}

// *
// Encapsulation for POSIX rlimits, see
// http://pubs.opengroup.org/onlinepubs/009695399/functions/getrlimit.html.
// Note that some types might only be defined for Linux.
// We use a custom prefix to avoid conflict with existing system macros
// (e.g., `RLIMIT_CPU` or `NOFILE`).
type RLimitInfo struct {
	Rlimits []RLimitInfo_RLimit `protobuf:"bytes,1,rep,name=rlimits" json:"rlimits"`
}

func (m *RLimitInfo) Reset()                    { *m = RLimitInfo{} }
func (*RLimitInfo) ProtoMessage()               {}
func (*RLimitInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{67} }

func (m *RLimitInfo) GetRlimits() []RLimitInfo_RLimit {
	if m != nil {
		return m.Rlimits
	}
	return nil
}

type RLimitInfo_RLimit struct {
	Type RLimitInfo_RLimit_Type `protobuf:"varint,1,opt,name=type,enum=mesos.RLimitInfo_RLimit_Type" json:"type"`
	// Either both are set or both are not set.
	// If both are not set, it represents unlimited.
	// If both are set, we require `soft` <= `hard`.
	Hard *uint64 `protobuf:"varint,2,opt,name=hard" json:"hard,omitempty"`
	Soft *uint64 `protobuf:"varint,3,opt,name=soft" json:"soft,omitempty"`
}

func (m *RLimitInfo_RLimit) Reset()                    { *m = RLimitInfo_RLimit{} }
func (*RLimitInfo_RLimit) ProtoMessage()               {}
func (*RLimitInfo_RLimit) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{67, 0} }

func (m *RLimitInfo_RLimit) GetType() RLimitInfo_RLimit_Type {
	if m != nil {
		return m.Type
	}
	return RLimitInfo_RLimit_UNKNOWN
}

func (m *RLimitInfo_RLimit) GetHard() uint64 {
	if m != nil && m.Hard != nil {
		return *m.Hard
	}
	return 0
}

func (m *RLimitInfo_RLimit) GetSoft() uint64 {
	if m != nil && m.Soft != nil {
		return *m.Soft
	}
	return 0
}

// *
// Describes the information about (pseudo) TTY that can
// be attached to a process running in a container.
type TTYInfo struct {
	WindowSize *TTYInfo_WindowSize `protobuf:"bytes,1,opt,name=window_size,json=windowSize" json:"window_size,omitempty"`
}

func (m *TTYInfo) Reset()                    { *m = TTYInfo{} }
func (*TTYInfo) ProtoMessage()               {}
func (*TTYInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{68} }

func (m *TTYInfo) GetWindowSize() *TTYInfo_WindowSize {
	if m != nil {
		return m.WindowSize
	}
	return nil
}

type TTYInfo_WindowSize struct {
	Rows    uint32 `protobuf:"varint,1,req,name=rows" json:"rows"`
	Columns uint32 `protobuf:"varint,2,req,name=columns" json:"columns"`
}

func (m *TTYInfo_WindowSize) Reset()                    { *m = TTYInfo_WindowSize{} }
func (*TTYInfo_WindowSize) ProtoMessage()               {}
func (*TTYInfo_WindowSize) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{68, 0} }

func (m *TTYInfo_WindowSize) GetRows() uint32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

func (m *TTYInfo_WindowSize) GetColumns() uint32 {
	if m != nil {
		return m.Columns
	}
	return 0
}

// *
// Describes a container configuration and allows extensible
// configurations for different container implementations.
//
// NOTE: `ContainerInfo` may be specified, e.g., by a task, even if no
// container image is provided. In this case neither `MesosInfo` nor
// `DockerInfo` is set, the required `type` must be `MESOS`. This is to
// address a case when a task without an image, e.g., a shell script
// with URIs, wants to use features originally designed for containers,
// for example custom network isolation via `NetworkInfo`.
type ContainerInfo struct {
	Type     *ContainerInfo_Type `protobuf:"varint,1,req,name=type,enum=mesos.ContainerInfo_Type" json:"type,omitempty"`
	Volumes  []Volume            `protobuf:"bytes,2,rep,name=volumes" json:"volumes"`
	Hostname *string             `protobuf:"bytes,4,opt,name=hostname" json:"hostname,omitempty"`
	// Only one of the following *Info messages should be set to match
	// the type.
	Docker *ContainerInfo_DockerInfo `protobuf:"bytes,3,opt,name=docker" json:"docker,omitempty"`
	Mesos  *ContainerInfo_MesosInfo  `protobuf:"bytes,5,opt,name=mesos" json:"mesos,omitempty"`
	// A list of network requests. A framework can request multiple IP addresses
	// for the container.
	NetworkInfos []NetworkInfo `protobuf:"bytes,7,rep,name=network_infos,json=networkInfos" json:"network_infos"`
	// Linux specific information for the container.
	LinuxInfo *LinuxInfo `protobuf:"bytes,8,opt,name=linux_info,json=linuxInfo" json:"linux_info,omitempty"`
	// (POSIX only) rlimits of the container.
	RlimitInfo *RLimitInfo `protobuf:"bytes,9,opt,name=rlimit_info,json=rlimitInfo" json:"rlimit_info,omitempty"`
	// If specified a tty will be attached to the container entrypoint.
	TTYInfo *TTYInfo `protobuf:"bytes,10,opt,name=tty_info,json=ttyInfo" json:"tty_info,omitempty"`
}

func (m *ContainerInfo) Reset()                    { *m = ContainerInfo{} }
func (*ContainerInfo) ProtoMessage()               {}
func (*ContainerInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{69} }

func (m *ContainerInfo) GetType() ContainerInfo_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ContainerInfo_DOCKER
}

func (m *ContainerInfo) GetVolumes() []Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *ContainerInfo) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *ContainerInfo) GetDocker() *ContainerInfo_DockerInfo {
	if m != nil {
		return m.Docker
	}
	return nil
}

func (m *ContainerInfo) GetMesos() *ContainerInfo_MesosInfo {
	if m != nil {
		return m.Mesos
	}
	return nil
}

func (m *ContainerInfo) GetNetworkInfos() []NetworkInfo {
	if m != nil {
		return m.NetworkInfos
	}
	return nil
}

func (m *ContainerInfo) GetLinuxInfo() *LinuxInfo {
	if m != nil {
		return m.LinuxInfo
	}
	return nil
}

func (m *ContainerInfo) GetRlimitInfo() *RLimitInfo {
	if m != nil {
		return m.RlimitInfo
	}
	return nil
}

func (m *ContainerInfo) GetTTYInfo() *TTYInfo {
	if m != nil {
		return m.TTYInfo
	}
	return nil
}

type ContainerInfo_DockerInfo struct {
	// The docker image that is going to be passed to the registry.
	Image        string                                 `protobuf:"bytes,1,req,name=image" json:"image"`
	Network      *ContainerInfo_DockerInfo_Network      `protobuf:"varint,2,opt,name=network,enum=mesos.ContainerInfo_DockerInfo_Network,def=1" json:"network,omitempty"`
	PortMappings []ContainerInfo_DockerInfo_PortMapping `protobuf:"bytes,3,rep,name=port_mappings,json=portMappings" json:"port_mappings"`
	Privileged   *bool                                  `protobuf:"varint,4,opt,name=privileged,def=0" json:"privileged,omitempty"`
	// Allowing arbitrary parameters to be passed to docker CLI.
	// Note that anything passed to this field is not guaranteed
	// to be supported moving forward, as we might move away from
	// the docker CLI.
	Parameters []Parameter `protobuf:"bytes,5,rep,name=parameters" json:"parameters"`
	// With this flag set to true, the docker containerizer will
	// pull the docker image from the registry even if the image
	// is already downloaded on the agent.
	ForcePullImage *bool `protobuf:"varint,6,opt,name=force_pull_image,json=forcePullImage" json:"force_pull_image,omitempty"`
	// The name of volume driver plugin.
	VolumeDriver *string `protobuf:"bytes,7,opt,name=volume_driver,json=volumeDriver" json:"volume_driver,omitempty"`
}

func (m *ContainerInfo_DockerInfo) Reset()      { *m = ContainerInfo_DockerInfo{} }
func (*ContainerInfo_DockerInfo) ProtoMessage() {}
func (*ContainerInfo_DockerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{69, 0}
}

const Default_ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo_Network = ContainerInfo_DockerInfo_HOST
const Default_ContainerInfo_DockerInfo_Privileged bool = false

func (m *ContainerInfo_DockerInfo) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ContainerInfo_DockerInfo) GetNetwork() ContainerInfo_DockerInfo_Network {
	if m != nil && m.Network != nil {
		return *m.Network
	}
	return Default_ContainerInfo_DockerInfo_Network
}

func (m *ContainerInfo_DockerInfo) GetPortMappings() []ContainerInfo_DockerInfo_PortMapping {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

func (m *ContainerInfo_DockerInfo) GetPrivileged() bool {
	if m != nil && m.Privileged != nil {
		return *m.Privileged
	}
	return Default_ContainerInfo_DockerInfo_Privileged
}

func (m *ContainerInfo_DockerInfo) GetParameters() []Parameter {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ContainerInfo_DockerInfo) GetForcePullImage() bool {
	if m != nil && m.ForcePullImage != nil {
		return *m.ForcePullImage
	}
	return false
}

func (m *ContainerInfo_DockerInfo) GetVolumeDriver() string {
	if m != nil && m.VolumeDriver != nil {
		return *m.VolumeDriver
	}
	return ""
}

type ContainerInfo_DockerInfo_PortMapping struct {
	HostPort      uint32 `protobuf:"varint,1,req,name=host_port,json=hostPort" json:"host_port"`
	ContainerPort uint32 `protobuf:"varint,2,req,name=container_port,json=containerPort" json:"container_port"`
	// Protocol to expose as (ie: tcp, udp).
	Protocol *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
}

func (m *ContainerInfo_DockerInfo_PortMapping) Reset()      { *m = ContainerInfo_DockerInfo_PortMapping{} }
func (*ContainerInfo_DockerInfo_PortMapping) ProtoMessage() {}
func (*ContainerInfo_DockerInfo_PortMapping) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{69, 0, 0}
}

func (m *ContainerInfo_DockerInfo_PortMapping) GetHostPort() uint32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *ContainerInfo_DockerInfo_PortMapping) GetContainerPort() uint32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *ContainerInfo_DockerInfo_PortMapping) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

type ContainerInfo_MesosInfo struct {
	Image *Image `protobuf:"bytes,1,opt,name=image" json:"image,omitempty"`
}

func (m *ContainerInfo_MesosInfo) Reset()                    { *m = ContainerInfo_MesosInfo{} }
func (*ContainerInfo_MesosInfo) ProtoMessage()               {}
func (*ContainerInfo_MesosInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{69, 1} }

func (m *ContainerInfo_MesosInfo) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

// *
// Container related information that is resolved during container
// setup. The information is sent back to the framework as part of the
// TaskStatus message.
type ContainerStatus struct {
	ContainerID *ContainerID `protobuf:"bytes,4,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// This field can be reliably used to identify the container IP address.
	NetworkInfos []NetworkInfo `protobuf:"bytes,1,rep,name=network_infos,json=networkInfos" json:"network_infos"`
	// Information about Linux control group (cgroup).
	CgroupInfo *CgroupInfo `protobuf:"bytes,2,opt,name=cgroup_info,json=cgroupInfo" json:"cgroup_info,omitempty"`
	// Information about Executor PID.
	ExecutorPID *uint32 `protobuf:"varint,3,opt,name=executor_pid,json=executorPid" json:"executor_pid,omitempty"`
}

func (m *ContainerStatus) Reset()                    { *m = ContainerStatus{} }
func (*ContainerStatus) ProtoMessage()               {}
func (*ContainerStatus) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{70} }

func (m *ContainerStatus) GetContainerID() *ContainerID {
	if m != nil {
		return m.ContainerID
	}
	return nil
}

func (m *ContainerStatus) GetNetworkInfos() []NetworkInfo {
	if m != nil {
		return m.NetworkInfos
	}
	return nil
}

func (m *ContainerStatus) GetCgroupInfo() *CgroupInfo {
	if m != nil {
		return m.CgroupInfo
	}
	return nil
}

func (m *ContainerStatus) GetExecutorPID() uint32 {
	if m != nil && m.ExecutorPID != nil {
		return *m.ExecutorPID
	}
	return 0
}

// *
// Linux control group (cgroup) information.
type CgroupInfo struct {
	NetCLS *CgroupInfo_NetCls `protobuf:"bytes,1,opt,name=net_cls,json=netCls" json:"net_cls,omitempty"`
}

func (m *CgroupInfo) Reset()                    { *m = CgroupInfo{} }
func (*CgroupInfo) ProtoMessage()               {}
func (*CgroupInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{71} }

func (m *CgroupInfo) GetNetCLS() *CgroupInfo_NetCls {
	if m != nil {
		return m.NetCLS
	}
	return nil
}

// Configuration of a blkio cgroup subsystem.
type CgroupInfo_Blkio struct {
}

func (m *CgroupInfo_Blkio) Reset()                    { *m = CgroupInfo_Blkio{} }
func (*CgroupInfo_Blkio) ProtoMessage()               {}
func (*CgroupInfo_Blkio) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{71, 0} }

// Describes a stat value without the device descriptor part.
type CgroupInfo_Blkio_Value struct {
	Op    *CgroupInfo_Blkio_Operation `protobuf:"varint,1,opt,name=op,enum=mesos.CgroupInfo_Blkio_Operation" json:"op,omitempty"`
	Value *uint64                     `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *CgroupInfo_Blkio_Value) Reset()      { *m = CgroupInfo_Blkio_Value{} }
func (*CgroupInfo_Blkio_Value) ProtoMessage() {}
func (*CgroupInfo_Blkio_Value) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{71, 0, 0}
}

func (m *CgroupInfo_Blkio_Value) GetOp() CgroupInfo_Blkio_Operation {
	if m != nil && m.Op != nil {
		return *m.Op
	}
	return CgroupInfo_Blkio_UNKNOWN
}

func (m *CgroupInfo_Blkio_Value) GetValue() uint64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type CgroupInfo_Blkio_CFQ struct {
}

func (m *CgroupInfo_Blkio_CFQ) Reset()                    { *m = CgroupInfo_Blkio_CFQ{} }
func (*CgroupInfo_Blkio_CFQ) ProtoMessage()               {}
func (*CgroupInfo_Blkio_CFQ) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{71, 0, 1} }

type CgroupInfo_Blkio_CFQ_Statistics struct {
	// Stats are grouped by block devices. If `device` is not
	// set, it represents `Total`.
	Device *Device_Number `protobuf:"bytes,1,opt,name=device" json:"device,omitempty"`
	// blkio.sectors
	Sectors *uint64 `protobuf:"varint,2,opt,name=sectors" json:"sectors,omitempty"`
	// blkio.time
	Time *uint64 `protobuf:"varint,3,opt,name=time" json:"time,omitempty"`
	// blkio.io_serviced
	IOServiced []CgroupInfo_Blkio_Value `protobuf:"bytes,4,rep,name=io_serviced,json=ioServiced" json:"io_serviced"`
	// blkio.io_service_bytes
	IOServiceBytes []CgroupInfo_Blkio_Value `protobuf:"bytes,5,rep,name=io_service_bytes,json=ioServiceBytes" json:"io_service_bytes"`
	// blkio.io_service_time
	IOServiceTime []CgroupInfo_Blkio_Value `protobuf:"bytes,6,rep,name=io_service_time,json=ioServiceTime" json:"io_service_time"`
	// blkio.io_wait_time
	IOWaitTime []CgroupInfo_Blkio_Value `protobuf:"bytes,7,rep,name=io_wait_time,json=ioWaitTime" json:"io_wait_time"`
	// blkio.io_merged
	IOMerged []CgroupInfo_Blkio_Value `protobuf:"bytes,8,rep,name=io_merged,json=ioMerged" json:"io_merged"`
	// blkio.io_queued
	IOQueued []CgroupInfo_Blkio_Value `protobuf:"bytes,9,rep,name=io_queued,json=ioQueued" json:"io_queued"`
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) Reset()      { *m = CgroupInfo_Blkio_CFQ_Statistics{} }
func (*CgroupInfo_Blkio_CFQ_Statistics) ProtoMessage() {}
func (*CgroupInfo_Blkio_CFQ_Statistics) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{71, 0, 1, 0}
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetDevice() *Device_Number {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetSectors() uint64 {
	if m != nil && m.Sectors != nil {
		return *m.Sectors
	}
	return 0
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetTime() uint64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetIOServiced() []CgroupInfo_Blkio_Value {
	if m != nil {
		return m.IOServiced
	}
	return nil
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetIOServiceBytes() []CgroupInfo_Blkio_Value {
	if m != nil {
		return m.IOServiceBytes
	}
	return nil
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetIOServiceTime() []CgroupInfo_Blkio_Value {
	if m != nil {
		return m.IOServiceTime
	}
	return nil
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetIOWaitTime() []CgroupInfo_Blkio_Value {
	if m != nil {
		return m.IOWaitTime
	}
	return nil
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetIOMerged() []CgroupInfo_Blkio_Value {
	if m != nil {
		return m.IOMerged
	}
	return nil
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) GetIOQueued() []CgroupInfo_Blkio_Value {
	if m != nil {
		return m.IOQueued
	}
	return nil
}

type CgroupInfo_Blkio_Throttling struct {
}

func (m *CgroupInfo_Blkio_Throttling) Reset()      { *m = CgroupInfo_Blkio_Throttling{} }
func (*CgroupInfo_Blkio_Throttling) ProtoMessage() {}
func (*CgroupInfo_Blkio_Throttling) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{71, 0, 2}
}

type CgroupInfo_Blkio_Throttling_Statistics struct {
	// Stats are grouped by block devices. If `device` is not
	// set, it represents `Total`.
	Device *Device_Number `protobuf:"bytes,1,opt,name=device" json:"device,omitempty"`
	// blkio.throttle.io_serviced
	IOServiced []CgroupInfo_Blkio_Value `protobuf:"bytes,2,rep,name=io_serviced,json=ioServiced" json:"io_serviced"`
	// blkio.throttle.io_service_bytes
	IOServiceBytes []CgroupInfo_Blkio_Value `protobuf:"bytes,3,rep,name=io_service_bytes,json=ioServiceBytes" json:"io_service_bytes"`
}

func (m *CgroupInfo_Blkio_Throttling_Statistics) Reset() {
	*m = CgroupInfo_Blkio_Throttling_Statistics{}
}
func (*CgroupInfo_Blkio_Throttling_Statistics) ProtoMessage() {}
func (*CgroupInfo_Blkio_Throttling_Statistics) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{71, 0, 2, 0}
}

func (m *CgroupInfo_Blkio_Throttling_Statistics) GetDevice() *Device_Number {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *CgroupInfo_Blkio_Throttling_Statistics) GetIOServiced() []CgroupInfo_Blkio_Value {
	if m != nil {
		return m.IOServiced
	}
	return nil
}

func (m *CgroupInfo_Blkio_Throttling_Statistics) GetIOServiceBytes() []CgroupInfo_Blkio_Value {
	if m != nil {
		return m.IOServiceBytes
	}
	return nil
}

type CgroupInfo_Blkio_Statistics struct {
	CFQ          []CgroupInfo_Blkio_CFQ_Statistics         `protobuf:"bytes,1,rep,name=cfq" json:"cfq"`
	CFQRecursive []CgroupInfo_Blkio_CFQ_Statistics         `protobuf:"bytes,2,rep,name=cfq_recursive,json=cfqRecursive" json:"cfq_recursive"`
	Throttling   []*CgroupInfo_Blkio_Throttling_Statistics `protobuf:"bytes,3,rep,name=throttling" json:"throttling,omitempty"`
}

func (m *CgroupInfo_Blkio_Statistics) Reset()      { *m = CgroupInfo_Blkio_Statistics{} }
func (*CgroupInfo_Blkio_Statistics) ProtoMessage() {}
func (*CgroupInfo_Blkio_Statistics) Descriptor() ([]byte, []int) {
	return fileDescriptorMesos, []int{71, 0, 3}
}

func (m *CgroupInfo_Blkio_Statistics) GetCFQ() []CgroupInfo_Blkio_CFQ_Statistics {
	if m != nil {
		return m.CFQ
	}
	return nil
}

func (m *CgroupInfo_Blkio_Statistics) GetCFQRecursive() []CgroupInfo_Blkio_CFQ_Statistics {
	if m != nil {
		return m.CFQRecursive
	}
	return nil
}

func (m *CgroupInfo_Blkio_Statistics) GetThrottling() []*CgroupInfo_Blkio_Throttling_Statistics {
	if m != nil {
		return m.Throttling
	}
	return nil
}

// Configuration of a net_cls cgroup subsystem.
type CgroupInfo_NetCls struct {
	// The 32-bit classid consists of two parts, a 16 bit major handle
	// and a 16-bit minor handle. The major and minor handle are
	// represented using the format 0xAAAABBBB, where 0xAAAA is the
	// 16-bit major handle and 0xBBBB is the 16-bit minor handle.
	ClassID *uint32 `protobuf:"varint,1,opt,name=classid" json:"classid,omitempty"`
}

func (m *CgroupInfo_NetCls) Reset()                    { *m = CgroupInfo_NetCls{} }
func (*CgroupInfo_NetCls) ProtoMessage()               {}
func (*CgroupInfo_NetCls) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{71, 1} }

func (m *CgroupInfo_NetCls) GetClassID() uint32 {
	if m != nil && m.ClassID != nil {
		return *m.ClassID
	}
	return 0
}

// *
// Collection of labels. Labels should not contain duplicate key-value
// pairs.
type Labels struct {
	Labels []Label `protobuf:"bytes,1,rep,name=labels" json:"labels"`
}

func (m *Labels) Reset()                    { *m = Labels{} }
func (*Labels) ProtoMessage()               {}
func (*Labels) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{72} }

func (m *Labels) GetLabels() []Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// *
// Key, value pair used to store free form user-data.
type Label struct {
	Key   string  `protobuf:"bytes,1,req,name=key" json:"key"`
	Value *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Label) Reset()                    { *m = Label{} }
func (*Label) ProtoMessage()               {}
func (*Label) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{73} }

func (m *Label) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Label) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Named port used for service discovery.
type Port struct {
	// Port number on which the framework exposes a service.
	Number uint32 `protobuf:"varint,1,req,name=number" json:"number"`
	// Name of the service hosted on this port.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Layer 4-7 protocol on which the framework exposes its services.
	Protocol *string `protobuf:"bytes,3,opt,name=protocol" json:"protocol,omitempty"`
	// This field restricts discovery within a framework (FRAMEWORK),
	// within a Mesos cluster (CLUSTER), or places no restrictions (EXTERNAL).
	// The visibility setting for a Port overrides the general visibility setting
	// in the DiscoveryInfo.
	Visibility *DiscoveryInfo_Visibility `protobuf:"varint,4,opt,name=visibility,enum=mesos.DiscoveryInfo_Visibility" json:"visibility,omitempty"`
	// This can be used to decorate the message with metadata to be
	// interpreted by external applications such as firewalls.
	Labels *Labels `protobuf:"bytes,5,opt,name=labels" json:"labels,omitempty"`
}

func (m *Port) Reset()                    { *m = Port{} }
func (*Port) ProtoMessage()               {}
func (*Port) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{74} }

func (m *Port) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Port) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Port) GetProtocol() string {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ""
}

func (m *Port) GetVisibility() DiscoveryInfo_Visibility {
	if m != nil && m.Visibility != nil {
		return *m.Visibility
	}
	return FRAMEWORK
}

func (m *Port) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

// *
// Collection of ports.
type Ports struct {
	Ports []Port `protobuf:"bytes,1,rep,name=ports" json:"ports"`
}

func (m *Ports) Reset()                    { *m = Ports{} }
func (*Ports) ProtoMessage()               {}
func (*Ports) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{75} }

func (m *Ports) GetPorts() []Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

// *
// Service discovery information.
// The visibility field restricts discovery within a framework (FRAMEWORK),
// within a Mesos cluster (CLUSTER), or places no restrictions (EXTERNAL).
// Each port in the ports field also has an optional visibility field.
// If visibility is specified for a port, it overrides the default service-wide
// DiscoveryInfo.visibility for that port.
// The environment, location, and version fields provide first class support for
// common attributes used to differentiate between similar services. The
// environment may receive values such as PROD/QA/DEV, the location field may
// receive values like EAST-US/WEST-US/EUROPE/AMEA, and the version field may
// receive values like v2.0/v0.9. The exact use of these fields is up to each
// service discovery system.
type DiscoveryInfo struct {
	Visibility  DiscoveryInfo_Visibility `protobuf:"varint,1,req,name=visibility,enum=mesos.DiscoveryInfo_Visibility" json:"visibility"`
	Name        *string                  `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Environment *string                  `protobuf:"bytes,3,opt,name=environment" json:"environment,omitempty"`
	Location    *string                  `protobuf:"bytes,4,opt,name=location" json:"location,omitempty"`
	Version     *string                  `protobuf:"bytes,5,opt,name=version" json:"version,omitempty"`
	Ports       *Ports                   `protobuf:"bytes,6,opt,name=ports" json:"ports,omitempty"`
	Labels      *Labels                  `protobuf:"bytes,7,opt,name=labels" json:"labels,omitempty"`
}

func (m *DiscoveryInfo) Reset()                    { *m = DiscoveryInfo{} }
func (*DiscoveryInfo) ProtoMessage()               {}
func (*DiscoveryInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{76} }

func (m *DiscoveryInfo) GetVisibility() DiscoveryInfo_Visibility {
	if m != nil {
		return m.Visibility
	}
	return FRAMEWORK
}

func (m *DiscoveryInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DiscoveryInfo) GetEnvironment() string {
	if m != nil && m.Environment != nil {
		return *m.Environment
	}
	return ""
}

func (m *DiscoveryInfo) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

func (m *DiscoveryInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *DiscoveryInfo) GetPorts() *Ports {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DiscoveryInfo) GetLabels() *Labels {
	if m != nil {
		return m.Labels
	}
	return nil
}

// *
// Named WeightInfo to indicate resource allocation
// priority between the different roles.
type WeightInfo struct {
	Weight float64 `protobuf:"fixed64,1,req,name=weight" json:"weight"`
	// Related role name.
	Role *string `protobuf:"bytes,2,opt,name=role" json:"role,omitempty"`
}

func (m *WeightInfo) Reset()                    { *m = WeightInfo{} }
func (*WeightInfo) ProtoMessage()               {}
func (*WeightInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{77} }

func (m *WeightInfo) GetWeight() float64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *WeightInfo) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return ""
}

// *
// Version information of a component.
type VersionInfo struct {
	Version   string   `protobuf:"bytes,1,req,name=version" json:"version"`
	BuildDate *string  `protobuf:"bytes,2,opt,name=build_date,json=buildDate" json:"build_date,omitempty"`
	BuildTime *float64 `protobuf:"fixed64,3,opt,name=build_time,json=buildTime" json:"build_time,omitempty"`
	BuildUser *string  `protobuf:"bytes,4,opt,name=build_user,json=buildUser" json:"build_user,omitempty"`
	GitSHA    *string  `protobuf:"bytes,5,opt,name=git_sha,json=gitSha" json:"git_sha,omitempty"`
	GitBranch *string  `protobuf:"bytes,6,opt,name=git_branch,json=gitBranch" json:"git_branch,omitempty"`
	GitTag    *string  `protobuf:"bytes,7,opt,name=git_tag,json=gitTag" json:"git_tag,omitempty"`
}

func (m *VersionInfo) Reset()                    { *m = VersionInfo{} }
func (*VersionInfo) ProtoMessage()               {}
func (*VersionInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{78} }

func (m *VersionInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *VersionInfo) GetBuildDate() string {
	if m != nil && m.BuildDate != nil {
		return *m.BuildDate
	}
	return ""
}

func (m *VersionInfo) GetBuildTime() float64 {
	if m != nil && m.BuildTime != nil {
		return *m.BuildTime
	}
	return 0
}

func (m *VersionInfo) GetBuildUser() string {
	if m != nil && m.BuildUser != nil {
		return *m.BuildUser
	}
	return ""
}

func (m *VersionInfo) GetGitSHA() string {
	if m != nil && m.GitSHA != nil {
		return *m.GitSHA
	}
	return ""
}

func (m *VersionInfo) GetGitBranch() string {
	if m != nil && m.GitBranch != nil {
		return *m.GitBranch
	}
	return ""
}

func (m *VersionInfo) GetGitTag() string {
	if m != nil && m.GitTag != nil {
		return *m.GitTag
	}
	return ""
}

// *
// Flag consists of a name and optionally its value.
type Flag struct {
	Name  string  `protobuf:"bytes,1,req,name=name" json:"name"`
	Value *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Flag) Reset()                    { *m = Flag{} }
func (*Flag) ProtoMessage()               {}
func (*Flag) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{79} }

func (m *Flag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Flag) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// Describes a Role. Roles can be used to specify that certain resources are
// reserved for the use of one or more frameworks.
type Role struct {
	Name       string        `protobuf:"bytes,1,req,name=name" json:"name"`
	Weight     float64       `protobuf:"fixed64,2,req,name=weight" json:"weight"`
	Frameworks []FrameworkID `protobuf:"bytes,3,rep,name=frameworks" json:"frameworks"`
	Resources  []Resource    `protobuf:"bytes,4,rep,name=resources" json:"resources"`
}

func (m *Role) Reset()                    { *m = Role{} }
func (*Role) ProtoMessage()               {}
func (*Role) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{80} }

func (m *Role) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Role) GetWeight() float64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Role) GetFrameworks() []FrameworkID {
	if m != nil {
		return m.Frameworks
	}
	return nil
}

func (m *Role) GetResources() []Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// *
// Metric consists of a name and optionally its value.
type Metric struct {
	Name  string   `protobuf:"bytes,1,req,name=name" json:"name"`
	Value *float64 `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
}

func (m *Metric) Reset()                    { *m = Metric{} }
func (*Metric) ProtoMessage()               {}
func (*Metric) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{81} }

func (m *Metric) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Metric) GetValue() float64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

// *
// Describes a File.
type FileInfo struct {
	// Absolute path to the file.
	Path string `protobuf:"bytes,1,req,name=path" json:"path"`
	// Number of hard links.
	Nlink *int32 `protobuf:"varint,2,opt,name=nlink" json:"nlink,omitempty"`
	// Total size in bytes.
	Size *uint64 `protobuf:"varint,3,opt,name=size" json:"size,omitempty"`
	// Last modification time.
	Mtime *TimeInfo `protobuf:"bytes,4,opt,name=mtime" json:"mtime,omitempty"`
	// Represents a file's mode and permission bits. The bits have the same
	// definition on all systems and is portable.
	Mode *uint32 `protobuf:"varint,5,opt,name=mode" json:"mode,omitempty"`
	// User ID of owner.
	UID *string `protobuf:"bytes,6,opt,name=uid" json:"uid,omitempty"`
	// Group ID of owner.
	GID *string `protobuf:"bytes,7,opt,name=gid" json:"gid,omitempty"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{82} }

func (m *FileInfo) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileInfo) GetNlink() int32 {
	if m != nil && m.Nlink != nil {
		return *m.Nlink
	}
	return 0
}

func (m *FileInfo) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *FileInfo) GetMtime() *TimeInfo {
	if m != nil {
		return m.Mtime
	}
	return nil
}

func (m *FileInfo) GetMode() uint32 {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return 0
}

func (m *FileInfo) GetUID() string {
	if m != nil && m.UID != nil {
		return *m.UID
	}
	return ""
}

func (m *FileInfo) GetGID() string {
	if m != nil && m.GID != nil {
		return *m.GID
	}
	return ""
}

// *
// Describes information abount a device.
type Device struct {
	Path   *string        `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Number *Device_Number `protobuf:"bytes,2,opt,name=number" json:"number,omitempty"`
}

func (m *Device) Reset()                    { *m = Device{} }
func (*Device) ProtoMessage()               {}
func (*Device) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{83} }

func (m *Device) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *Device) GetNumber() *Device_Number {
	if m != nil {
		return m.Number
	}
	return nil
}

type Device_Number struct {
	MajorNumber *uint64 `protobuf:"varint,1,req,name=major_number,json=majorNumber" json:"major_number,omitempty"`
	MinorNumber *uint64 `protobuf:"varint,2,req,name=minor_number,json=minorNumber" json:"minor_number,omitempty"`
}

func (m *Device_Number) Reset()                    { *m = Device_Number{} }
func (*Device_Number) ProtoMessage()               {}
func (*Device_Number) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{83, 0} }

func (m *Device_Number) GetMajorNumber() uint64 {
	if m != nil && m.MajorNumber != nil {
		return *m.MajorNumber
	}
	return 0
}

func (m *Device_Number) GetMinorNumber() uint64 {
	if m != nil && m.MinorNumber != nil {
		return *m.MinorNumber
	}
	return 0
}

// *
// Describes a device whitelist entry that expose from host to container.
type DeviceAccess struct {
	Device Device              `protobuf:"bytes,1,req,name=device" json:"device"`
	Access DeviceAccess_Access `protobuf:"bytes,2,req,name=access" json:"access"`
}

func (m *DeviceAccess) Reset()                    { *m = DeviceAccess{} }
func (*DeviceAccess) ProtoMessage()               {}
func (*DeviceAccess) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{84} }

func (m *DeviceAccess) GetDevice() Device {
	if m != nil {
		return m.Device
	}
	return Device{}
}

func (m *DeviceAccess) GetAccess() DeviceAccess_Access {
	if m != nil {
		return m.Access
	}
	return DeviceAccess_Access{}
}

type DeviceAccess_Access struct {
	Read  *bool `protobuf:"varint,1,opt,name=read" json:"read,omitempty"`
	Write *bool `protobuf:"varint,2,opt,name=write" json:"write,omitempty"`
	Mknod *bool `protobuf:"varint,3,opt,name=mknod" json:"mknod,omitempty"`
}

func (m *DeviceAccess_Access) Reset()                    { *m = DeviceAccess_Access{} }
func (*DeviceAccess_Access) ProtoMessage()               {}
func (*DeviceAccess_Access) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{84, 0} }

func (m *DeviceAccess_Access) GetRead() bool {
	if m != nil && m.Read != nil {
		return *m.Read
	}
	return false
}

func (m *DeviceAccess_Access) GetWrite() bool {
	if m != nil && m.Write != nil {
		return *m.Write
	}
	return false
}

func (m *DeviceAccess_Access) GetMknod() bool {
	if m != nil && m.Mknod != nil {
		return *m.Mknod
	}
	return false
}

type DeviceWhitelist struct {
	AllowedDevices []DeviceAccess `protobuf:"bytes,1,rep,name=allowed_devices,json=allowedDevices" json:"allowed_devices"`
}

func (m *DeviceWhitelist) Reset()                    { *m = DeviceWhitelist{} }
func (*DeviceWhitelist) ProtoMessage()               {}
func (*DeviceWhitelist) Descriptor() ([]byte, []int) { return fileDescriptorMesos, []int{85} }

func (m *DeviceWhitelist) GetAllowedDevices() []DeviceAccess {
	if m != nil {
		return m.AllowedDevices
	}
	return nil
}

func init() {
	proto.RegisterType((*FrameworkID)(nil), "mesos.FrameworkID")
	proto.RegisterType((*OfferID)(nil), "mesos.OfferID")
	proto.RegisterType((*AgentID)(nil), "mesos.AgentID")
	proto.RegisterType((*TaskID)(nil), "mesos.TaskID")
	proto.RegisterType((*ExecutorID)(nil), "mesos.ExecutorID")
	proto.RegisterType((*ContainerID)(nil), "mesos.ContainerID")
	proto.RegisterType((*ResourceProviderID)(nil), "mesos.ResourceProviderID")
	proto.RegisterType((*OperationID)(nil), "mesos.OperationID")
	proto.RegisterType((*TimeInfo)(nil), "mesos.TimeInfo")
	proto.RegisterType((*DurationInfo)(nil), "mesos.DurationInfo")
	proto.RegisterType((*Address)(nil), "mesos.Address")
	proto.RegisterType((*URL)(nil), "mesos.URL")
	proto.RegisterType((*Unavailability)(nil), "mesos.Unavailability")
	proto.RegisterType((*MachineID)(nil), "mesos.MachineID")
	proto.RegisterType((*MachineInfo)(nil), "mesos.MachineInfo")
	proto.RegisterType((*FrameworkInfo)(nil), "mesos.FrameworkInfo")
	proto.RegisterType((*FrameworkInfo_Capability)(nil), "mesos.FrameworkInfo.Capability")
	proto.RegisterType((*CheckInfo)(nil), "mesos.CheckInfo")
	proto.RegisterType((*CheckInfo_Command)(nil), "mesos.CheckInfo.Command")
	proto.RegisterType((*CheckInfo_Http)(nil), "mesos.CheckInfo.Http")
	proto.RegisterType((*CheckInfo_Tcp)(nil), "mesos.CheckInfo.Tcp")
	proto.RegisterType((*HealthCheck)(nil), "mesos.HealthCheck")
	proto.RegisterType((*HealthCheck_HTTPCheckInfo)(nil), "mesos.HealthCheck.HTTPCheckInfo")
	proto.RegisterType((*HealthCheck_TCPCheckInfo)(nil), "mesos.HealthCheck.TCPCheckInfo")
	proto.RegisterType((*KillPolicy)(nil), "mesos.KillPolicy")
	proto.RegisterType((*CommandInfo)(nil), "mesos.CommandInfo")
	proto.RegisterType((*CommandInfo_URI)(nil), "mesos.CommandInfo.URI")
	proto.RegisterType((*ExecutorInfo)(nil), "mesos.ExecutorInfo")
	proto.RegisterType((*DomainInfo)(nil), "mesos.DomainInfo")
	proto.RegisterType((*DomainInfo_FaultDomain)(nil), "mesos.DomainInfo.FaultDomain")
	proto.RegisterType((*DomainInfo_FaultDomain_RegionInfo)(nil), "mesos.DomainInfo.FaultDomain.RegionInfo")
	proto.RegisterType((*DomainInfo_FaultDomain_ZoneInfo)(nil), "mesos.DomainInfo.FaultDomain.ZoneInfo")
	proto.RegisterType((*MasterInfo)(nil), "mesos.MasterInfo")
	proto.RegisterType((*MasterInfo_Capability)(nil), "mesos.MasterInfo.Capability")
	proto.RegisterType((*AgentInfo)(nil), "mesos.AgentInfo")
	proto.RegisterType((*AgentInfo_Capability)(nil), "mesos.AgentInfo.Capability")
	proto.RegisterType((*CSIPluginContainerInfo)(nil), "mesos.CSIPluginContainerInfo")
	proto.RegisterType((*CSIPluginInfo)(nil), "mesos.CSIPluginInfo")
	proto.RegisterType((*ResourceProviderInfo)(nil), "mesos.ResourceProviderInfo")
	proto.RegisterType((*ResourceProviderInfo_Storage)(nil), "mesos.ResourceProviderInfo.Storage")
	proto.RegisterType((*Value)(nil), "mesos.Value")
	proto.RegisterType((*Value_Scalar)(nil), "mesos.Value.Scalar")
	proto.RegisterType((*Value_Range)(nil), "mesos.Value.Range")
	proto.RegisterType((*Value_Ranges)(nil), "mesos.Value.Ranges")
	proto.RegisterType((*Value_Set)(nil), "mesos.Value.Set")
	proto.RegisterType((*Value_Text)(nil), "mesos.Value.Text")
	proto.RegisterType((*Attribute)(nil), "mesos.Attribute")
	proto.RegisterType((*Resource)(nil), "mesos.Resource")
	proto.RegisterType((*Resource_AllocationInfo)(nil), "mesos.Resource.AllocationInfo")
	proto.RegisterType((*Resource_ReservationInfo)(nil), "mesos.Resource.ReservationInfo")
	proto.RegisterType((*Resource_DiskInfo)(nil), "mesos.Resource.DiskInfo")
	proto.RegisterType((*Resource_DiskInfo_Persistence)(nil), "mesos.Resource.DiskInfo.Persistence")
	proto.RegisterType((*Resource_DiskInfo_Source)(nil), "mesos.Resource.DiskInfo.Source")
	proto.RegisterType((*Resource_DiskInfo_Source_Path)(nil), "mesos.Resource.DiskInfo.Source.Path")
	proto.RegisterType((*Resource_DiskInfo_Source_Mount)(nil), "mesos.Resource.DiskInfo.Source.Mount")
	proto.RegisterType((*Resource_RevocableInfo)(nil), "mesos.Resource.RevocableInfo")
	proto.RegisterType((*Resource_SharedInfo)(nil), "mesos.Resource.SharedInfo")
	proto.RegisterType((*TrafficControlStatistics)(nil), "mesos.TrafficControlStatistics")
	proto.RegisterType((*IpStatistics)(nil), "mesos.IpStatistics")
	proto.RegisterType((*IcmpStatistics)(nil), "mesos.IcmpStatistics")
	proto.RegisterType((*TcpStatistics)(nil), "mesos.TcpStatistics")
	proto.RegisterType((*UdpStatistics)(nil), "mesos.UdpStatistics")
	proto.RegisterType((*SNMPStatistics)(nil), "mesos.SNMPStatistics")
	proto.RegisterType((*DiskStatistics)(nil), "mesos.DiskStatistics")
	proto.RegisterType((*ResourceStatistics)(nil), "mesos.ResourceStatistics")
	proto.RegisterType((*ResourceUsage)(nil), "mesos.ResourceUsage")
	proto.RegisterType((*ResourceUsage_Executor)(nil), "mesos.ResourceUsage.Executor")
	proto.RegisterType((*ResourceUsage_Executor_Task)(nil), "mesos.ResourceUsage.Executor.Task")
	proto.RegisterType((*PerfStatistics)(nil), "mesos.PerfStatistics")
	proto.RegisterType((*Request)(nil), "mesos.Request")
	proto.RegisterType((*Offer)(nil), "mesos.Offer")
	proto.RegisterType((*Offer_Operation)(nil), "mesos.Offer.Operation")
	proto.RegisterType((*Offer_Operation_Launch)(nil), "mesos.Offer.Operation.Launch")
	proto.RegisterType((*Offer_Operation_LaunchGroup)(nil), "mesos.Offer.Operation.LaunchGroup")
	proto.RegisterType((*Offer_Operation_Reserve)(nil), "mesos.Offer.Operation.Reserve")
	proto.RegisterType((*Offer_Operation_Unreserve)(nil), "mesos.Offer.Operation.Unreserve")
	proto.RegisterType((*Offer_Operation_Create)(nil), "mesos.Offer.Operation.Create")
	proto.RegisterType((*Offer_Operation_Destroy)(nil), "mesos.Offer.Operation.Destroy")
	proto.RegisterType((*Offer_Operation_GrowVolume)(nil), "mesos.Offer.Operation.GrowVolume")
	proto.RegisterType((*Offer_Operation_ShrinkVolume)(nil), "mesos.Offer.Operation.ShrinkVolume")
	proto.RegisterType((*Offer_Operation_CreateDisk)(nil), "mesos.Offer.Operation.CreateDisk")
	proto.RegisterType((*Offer_Operation_DestroyDisk)(nil), "mesos.Offer.Operation.DestroyDisk")
	proto.RegisterType((*InverseOffer)(nil), "mesos.InverseOffer")
	proto.RegisterType((*TaskInfo)(nil), "mesos.TaskInfo")
	proto.RegisterType((*TaskGroupInfo)(nil), "mesos.TaskGroupInfo")
	proto.RegisterType((*Task)(nil), "mesos.Task")
	proto.RegisterType((*TaskResourceLimitation)(nil), "mesos.TaskResourceLimitation")
	proto.RegisterType((*UUID)(nil), "mesos.UUID")
	proto.RegisterType((*Operation)(nil), "mesos.Operation")
	proto.RegisterType((*OperationStatus)(nil), "mesos.OperationStatus")
	proto.RegisterType((*CheckStatusInfo)(nil), "mesos.CheckStatusInfo")
	proto.RegisterType((*CheckStatusInfo_Command)(nil), "mesos.CheckStatusInfo.Command")
	proto.RegisterType((*CheckStatusInfo_Http)(nil), "mesos.CheckStatusInfo.Http")
	proto.RegisterType((*CheckStatusInfo_Tcp)(nil), "mesos.CheckStatusInfo.Tcp")
	proto.RegisterType((*TaskStatus)(nil), "mesos.TaskStatus")
	proto.RegisterType((*Filters)(nil), "mesos.Filters")
	proto.RegisterType((*Environment)(nil), "mesos.Environment")
	proto.RegisterType((*Environment_Variable)(nil), "mesos.Environment.Variable")
	proto.RegisterType((*Parameter)(nil), "mesos.Parameter")
	proto.RegisterType((*Parameters)(nil), "mesos.Parameters")
	proto.RegisterType((*Credential)(nil), "mesos.Credential")
	proto.RegisterType((*Credentials)(nil), "mesos.Credentials")
	proto.RegisterType((*Secret)(nil), "mesos.Secret")
	proto.RegisterType((*Secret_Reference)(nil), "mesos.Secret.Reference")
	proto.RegisterType((*Secret_Value)(nil), "mesos.Secret.Value")
	proto.RegisterType((*RateLimit)(nil), "mesos.RateLimit")
	proto.RegisterType((*RateLimits)(nil), "mesos.RateLimits")
	proto.RegisterType((*Image)(nil), "mesos.Image")
	proto.RegisterType((*Image_Appc)(nil), "mesos.Image.Appc")
	proto.RegisterType((*Image_Docker)(nil), "mesos.Image.Docker")
	proto.RegisterType((*MountPropagation)(nil), "mesos.MountPropagation")
	proto.RegisterType((*Volume)(nil), "mesos.Volume")
	proto.RegisterType((*Volume_Source)(nil), "mesos.Volume.Source")
	proto.RegisterType((*Volume_Source_DockerVolume)(nil), "mesos.Volume.Source.DockerVolume")
	proto.RegisterType((*Volume_Source_HostPath)(nil), "mesos.Volume.Source.HostPath")
	proto.RegisterType((*Volume_Source_SandboxPath)(nil), "mesos.Volume.Source.SandboxPath")
	proto.RegisterType((*NetworkInfo)(nil), "mesos.NetworkInfo")
	proto.RegisterType((*NetworkInfo_IPAddress)(nil), "mesos.NetworkInfo.IPAddress")
	proto.RegisterType((*NetworkInfo_PortMapping)(nil), "mesos.NetworkInfo.PortMapping")
	proto.RegisterType((*CapabilityInfo)(nil), "mesos.CapabilityInfo")
	proto.RegisterType((*LinuxInfo)(nil), "mesos.LinuxInfo")
	proto.RegisterType((*RLimitInfo)(nil), "mesos.RLimitInfo")
	proto.RegisterType((*RLimitInfo_RLimit)(nil), "mesos.RLimitInfo.RLimit")
	proto.RegisterType((*TTYInfo)(nil), "mesos.TTYInfo")
	proto.RegisterType((*TTYInfo_WindowSize)(nil), "mesos.TTYInfo.WindowSize")
	proto.RegisterType((*ContainerInfo)(nil), "mesos.ContainerInfo")
	proto.RegisterType((*ContainerInfo_DockerInfo)(nil), "mesos.ContainerInfo.DockerInfo")
	proto.RegisterType((*ContainerInfo_DockerInfo_PortMapping)(nil), "mesos.ContainerInfo.DockerInfo.PortMapping")
	proto.RegisterType((*ContainerInfo_MesosInfo)(nil), "mesos.ContainerInfo.MesosInfo")
	proto.RegisterType((*ContainerStatus)(nil), "mesos.ContainerStatus")
	proto.RegisterType((*CgroupInfo)(nil), "mesos.CgroupInfo")
	proto.RegisterType((*CgroupInfo_Blkio)(nil), "mesos.CgroupInfo.Blkio")
	proto.RegisterType((*CgroupInfo_Blkio_Value)(nil), "mesos.CgroupInfo.Blkio.Value")
	proto.RegisterType((*CgroupInfo_Blkio_CFQ)(nil), "mesos.CgroupInfo.Blkio.CFQ")
	proto.RegisterType((*CgroupInfo_Blkio_CFQ_Statistics)(nil), "mesos.CgroupInfo.Blkio.CFQ.Statistics")
	proto.RegisterType((*CgroupInfo_Blkio_Throttling)(nil), "mesos.CgroupInfo.Blkio.Throttling")
	proto.RegisterType((*CgroupInfo_Blkio_Throttling_Statistics)(nil), "mesos.CgroupInfo.Blkio.Throttling.Statistics")
	proto.RegisterType((*CgroupInfo_Blkio_Statistics)(nil), "mesos.CgroupInfo.Blkio.Statistics")
	proto.RegisterType((*CgroupInfo_NetCls)(nil), "mesos.CgroupInfo.NetCls")
	proto.RegisterType((*Labels)(nil), "mesos.Labels")
	proto.RegisterType((*Label)(nil), "mesos.Label")
	proto.RegisterType((*Port)(nil), "mesos.Port")
	proto.RegisterType((*Ports)(nil), "mesos.Ports")
	proto.RegisterType((*DiscoveryInfo)(nil), "mesos.DiscoveryInfo")
	proto.RegisterType((*WeightInfo)(nil), "mesos.WeightInfo")
	proto.RegisterType((*VersionInfo)(nil), "mesos.VersionInfo")
	proto.RegisterType((*Flag)(nil), "mesos.Flag")
	proto.RegisterType((*Role)(nil), "mesos.Role")
	proto.RegisterType((*Metric)(nil), "mesos.Metric")
	proto.RegisterType((*FileInfo)(nil), "mesos.FileInfo")
	proto.RegisterType((*Device)(nil), "mesos.Device")
	proto.RegisterType((*Device_Number)(nil), "mesos.Device.Number")
	proto.RegisterType((*DeviceAccess)(nil), "mesos.DeviceAccess")
	proto.RegisterType((*DeviceAccess_Access)(nil), "mesos.DeviceAccess.Access")
	proto.RegisterType((*DeviceWhitelist)(nil), "mesos.DeviceWhitelist")
	proto.RegisterEnum("mesos.Status", Status_name, Status_value)
	proto.RegisterEnum("mesos.TaskState", TaskState_name, TaskState_value)
	proto.RegisterEnum("mesos.OperationState", OperationState_name, OperationState_value)
	proto.RegisterEnum("mesos.MachineInfo_Mode", MachineInfo_Mode_name, MachineInfo_Mode_value)
	proto.RegisterEnum("mesos.FrameworkInfo_Capability_Type", FrameworkInfo_Capability_Type_name, FrameworkInfo_Capability_Type_value)
	proto.RegisterEnum("mesos.CheckInfo_Type", CheckInfo_Type_name, CheckInfo_Type_value)
	proto.RegisterEnum("mesos.HealthCheck_Type", HealthCheck_Type_name, HealthCheck_Type_value)
	proto.RegisterEnum("mesos.ExecutorInfo_Type", ExecutorInfo_Type_name, ExecutorInfo_Type_value)
	proto.RegisterEnum("mesos.MasterInfo_Capability_Type", MasterInfo_Capability_Type_name, MasterInfo_Capability_Type_value)
	proto.RegisterEnum("mesos.AgentInfo_Capability_Type", AgentInfo_Capability_Type_name, AgentInfo_Capability_Type_value)
	proto.RegisterEnum("mesos.CSIPluginContainerInfo_Service", CSIPluginContainerInfo_Service_name, CSIPluginContainerInfo_Service_value)
	proto.RegisterEnum("mesos.Value_Type", Value_Type_name, Value_Type_value)
	proto.RegisterEnum("mesos.Resource_ReservationInfo_Type", Resource_ReservationInfo_Type_name, Resource_ReservationInfo_Type_value)
	proto.RegisterEnum("mesos.Resource_DiskInfo_Source_Type", Resource_DiskInfo_Source_Type_name, Resource_DiskInfo_Source_Type_value)
	proto.RegisterEnum("mesos.Offer_Operation_Type", Offer_Operation_Type_name, Offer_Operation_Type_value)
	proto.RegisterEnum("mesos.TaskStatus_Source", TaskStatus_Source_name, TaskStatus_Source_value)
	proto.RegisterEnum("mesos.TaskStatus_Reason", TaskStatus_Reason_name, TaskStatus_Reason_value)
	proto.RegisterEnum("mesos.Environment_Variable_Type", Environment_Variable_Type_name, Environment_Variable_Type_value)
	proto.RegisterEnum("mesos.Secret_Type", Secret_Type_name, Secret_Type_value)
	proto.RegisterEnum("mesos.Image_Type", Image_Type_name, Image_Type_value)
	proto.RegisterEnum("mesos.MountPropagation_Mode", MountPropagation_Mode_name, MountPropagation_Mode_value)
	proto.RegisterEnum("mesos.Volume_Mode", Volume_Mode_name, Volume_Mode_value)
	proto.RegisterEnum("mesos.Volume_Source_Type", Volume_Source_Type_name, Volume_Source_Type_value)
	proto.RegisterEnum("mesos.Volume_Source_SandboxPath_Type", Volume_Source_SandboxPath_Type_name, Volume_Source_SandboxPath_Type_value)
	proto.RegisterEnum("mesos.NetworkInfo_Protocol", NetworkInfo_Protocol_name, NetworkInfo_Protocol_value)
	proto.RegisterEnum("mesos.CapabilityInfo_Capability", CapabilityInfo_Capability_name, CapabilityInfo_Capability_value)
	proto.RegisterEnum("mesos.RLimitInfo_RLimit_Type", RLimitInfo_RLimit_Type_name, RLimitInfo_RLimit_Type_value)
	proto.RegisterEnum("mesos.ContainerInfo_Type", ContainerInfo_Type_name, ContainerInfo_Type_value)
	proto.RegisterEnum("mesos.ContainerInfo_DockerInfo_Network", ContainerInfo_DockerInfo_Network_name, ContainerInfo_DockerInfo_Network_value)
	proto.RegisterEnum("mesos.CgroupInfo_Blkio_Operation", CgroupInfo_Blkio_Operation_name, CgroupInfo_Blkio_Operation_value)
	proto.RegisterEnum("mesos.DiscoveryInfo_Visibility", DiscoveryInfo_Visibility_name, DiscoveryInfo_Visibility_value)
}
func (x Status) String() string {
	s, ok := Status_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TaskState) String() string {
	s, ok := TaskState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OperationState) String() string {
	s, ok := OperationState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MachineInfo_Mode) String() string {
	s, ok := MachineInfo_Mode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FrameworkInfo_Capability_Type) String() string {
	s, ok := FrameworkInfo_Capability_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CheckInfo_Type) String() string {
	s, ok := CheckInfo_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HealthCheck_Type) String() string {
	s, ok := HealthCheck_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ExecutorInfo_Type) String() string {
	s, ok := ExecutorInfo_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MasterInfo_Capability_Type) String() string {
	s, ok := MasterInfo_Capability_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AgentInfo_Capability_Type) String() string {
	s, ok := AgentInfo_Capability_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CSIPluginContainerInfo_Service) String() string {
	s, ok := CSIPluginContainerInfo_Service_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Value_Type) String() string {
	s, ok := Value_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Resource_ReservationInfo_Type) String() string {
	s, ok := Resource_ReservationInfo_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Resource_DiskInfo_Source_Type) String() string {
	s, ok := Resource_DiskInfo_Source_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Offer_Operation_Type) String() string {
	s, ok := Offer_Operation_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TaskStatus_Source) String() string {
	s, ok := TaskStatus_Source_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TaskStatus_Reason) String() string {
	s, ok := TaskStatus_Reason_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Environment_Variable_Type) String() string {
	s, ok := Environment_Variable_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Secret_Type) String() string {
	s, ok := Secret_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Image_Type) String() string {
	s, ok := Image_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MountPropagation_Mode) String() string {
	s, ok := MountPropagation_Mode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Volume_Mode) String() string {
	s, ok := Volume_Mode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Volume_Source_Type) String() string {
	s, ok := Volume_Source_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Volume_Source_SandboxPath_Type) String() string {
	s, ok := Volume_Source_SandboxPath_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInfo_Protocol) String() string {
	s, ok := NetworkInfo_Protocol_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CapabilityInfo_Capability) String() string {
	s, ok := CapabilityInfo_Capability_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RLimitInfo_RLimit_Type) String() string {
	s, ok := RLimitInfo_RLimit_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ContainerInfo_Type) String() string {
	s, ok := ContainerInfo_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ContainerInfo_DockerInfo_Network) String() string {
	s, ok := ContainerInfo_DockerInfo_Network_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CgroupInfo_Blkio_Operation) String() string {
	s, ok := CgroupInfo_Blkio_Operation_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DiscoveryInfo_Visibility) String() string {
	s, ok := DiscoveryInfo_Visibility_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *FrameworkID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FrameworkID)
	if !ok {
		that2, ok := that.(FrameworkID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FrameworkID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FrameworkID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FrameworkID but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *FrameworkID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FrameworkID)
	if !ok {
		that2, ok := that.(FrameworkID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *OfferID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OfferID)
	if !ok {
		that2, ok := that.(OfferID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OfferID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OfferID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OfferID but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *OfferID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OfferID)
	if !ok {
		that2, ok := that.(OfferID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *AgentID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AgentID)
	if !ok {
		that2, ok := that.(AgentID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AgentID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AgentID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AgentID but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *AgentID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AgentID)
	if !ok {
		that2, ok := that.(AgentID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *TaskID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TaskID)
	if !ok {
		that2, ok := that.(TaskID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TaskID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TaskID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TaskID but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *TaskID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TaskID)
	if !ok {
		that2, ok := that.(TaskID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ExecutorID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ExecutorID)
	if !ok {
		that2, ok := that.(ExecutorID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ExecutorID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ExecutorID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ExecutorID but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *ExecutorID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ExecutorID)
	if !ok {
		that2, ok := that.(ExecutorID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *ContainerID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainerID)
	if !ok {
		that2, ok := that.(ContainerID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainerID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainerID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainerID but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if !this.Parent.Equal(that1.Parent) {
		return fmt.Errorf("Parent this(%v) Not Equal that(%v)", this.Parent, that1.Parent)
	}
	return nil
}
func (this *ContainerID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerID)
	if !ok {
		that2, ok := that.(ContainerID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !this.Parent.Equal(that1.Parent) {
		return false
	}
	return true
}
func (this *ResourceProviderID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResourceProviderID)
	if !ok {
		that2, ok := that.(ResourceProviderID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResourceProviderID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResourceProviderID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResourceProviderID but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *ResourceProviderID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceProviderID)
	if !ok {
		that2, ok := that.(ResourceProviderID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *OperationID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OperationID)
	if !ok {
		that2, ok := that.(OperationID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OperationID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OperationID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OperationID but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *OperationID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OperationID)
	if !ok {
		that2, ok := that.(OperationID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *TimeInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TimeInfo)
	if !ok {
		that2, ok := that.(TimeInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TimeInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TimeInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TimeInfo but is not nil && this == nil")
	}
	if this.Nanoseconds != that1.Nanoseconds {
		return fmt.Errorf("Nanoseconds this(%v) Not Equal that(%v)", this.Nanoseconds, that1.Nanoseconds)
	}
	return nil
}
func (this *TimeInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TimeInfo)
	if !ok {
		that2, ok := that.(TimeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Nanoseconds != that1.Nanoseconds {
		return false
	}
	return true
}
func (this *DurationInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DurationInfo)
	if !ok {
		that2, ok := that.(DurationInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DurationInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DurationInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DurationInfo but is not nil && this == nil")
	}
	if this.Nanoseconds != that1.Nanoseconds {
		return fmt.Errorf("Nanoseconds this(%v) Not Equal that(%v)", this.Nanoseconds, that1.Nanoseconds)
	}
	return nil
}
func (this *DurationInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DurationInfo)
	if !ok {
		that2, ok := that.(DurationInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Nanoseconds != that1.Nanoseconds {
		return false
	}
	return true
}
func (this *Address) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Address)
	if !ok {
		that2, ok := that.(Address)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Address")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Address but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Address but is not nil && this == nil")
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", *this.Hostname, *that1.Hostname)
		}
	} else if this.Hostname != nil {
		return fmt.Errorf("this.Hostname == nil && that.Hostname != nil")
	} else if that1.Hostname != nil {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.IP != nil && that1.IP != nil {
		if *this.IP != *that1.IP {
			return fmt.Errorf("IP this(%v) Not Equal that(%v)", *this.IP, *that1.IP)
		}
	} else if this.IP != nil {
		return fmt.Errorf("this.IP == nil && that.IP != nil")
	} else if that1.IP != nil {
		return fmt.Errorf("IP this(%v) Not Equal that(%v)", this.IP, that1.IP)
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	return nil
}
func (this *Address) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Address)
	if !ok {
		that2, ok := that.(Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return false
		}
	} else if this.Hostname != nil {
		return false
	} else if that1.Hostname != nil {
		return false
	}
	if this.IP != nil && that1.IP != nil {
		if *this.IP != *that1.IP {
			return false
		}
	} else if this.IP != nil {
		return false
	} else if that1.IP != nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *URL) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*URL)
	if !ok {
		that2, ok := that.(URL)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *URL")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *URL but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *URL but is not nil && this == nil")
	}
	if this.Scheme != that1.Scheme {
		return fmt.Errorf("Scheme this(%v) Not Equal that(%v)", this.Scheme, that1.Scheme)
	}
	if !this.Address.Equal(&that1.Address) {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return fmt.Errorf("Path this(%v) Not Equal that(%v)", *this.Path, *that1.Path)
		}
	} else if this.Path != nil {
		return fmt.Errorf("this.Path == nil && that.Path != nil")
	} else if that1.Path != nil {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	if len(this.Query) != len(that1.Query) {
		return fmt.Errorf("Query this(%v) Not Equal that(%v)", len(this.Query), len(that1.Query))
	}
	for i := range this.Query {
		if !this.Query[i].Equal(&that1.Query[i]) {
			return fmt.Errorf("Query this[%v](%v) Not Equal that[%v](%v)", i, this.Query[i], i, that1.Query[i])
		}
	}
	if this.Fragment != nil && that1.Fragment != nil {
		if *this.Fragment != *that1.Fragment {
			return fmt.Errorf("Fragment this(%v) Not Equal that(%v)", *this.Fragment, *that1.Fragment)
		}
	} else if this.Fragment != nil {
		return fmt.Errorf("this.Fragment == nil && that.Fragment != nil")
	} else if that1.Fragment != nil {
		return fmt.Errorf("Fragment this(%v) Not Equal that(%v)", this.Fragment, that1.Fragment)
	}
	return nil
}
func (this *URL) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*URL)
	if !ok {
		that2, ok := that.(URL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if !this.Address.Equal(&that1.Address) {
		return false
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return false
		}
	} else if this.Path != nil {
		return false
	} else if that1.Path != nil {
		return false
	}
	if len(this.Query) != len(that1.Query) {
		return false
	}
	for i := range this.Query {
		if !this.Query[i].Equal(&that1.Query[i]) {
			return false
		}
	}
	if this.Fragment != nil && that1.Fragment != nil {
		if *this.Fragment != *that1.Fragment {
			return false
		}
	} else if this.Fragment != nil {
		return false
	} else if that1.Fragment != nil {
		return false
	}
	return true
}
func (this *Unavailability) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Unavailability)
	if !ok {
		that2, ok := that.(Unavailability)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Unavailability")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Unavailability but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Unavailability but is not nil && this == nil")
	}
	if !this.Start.Equal(&that1.Start) {
		return fmt.Errorf("Start this(%v) Not Equal that(%v)", this.Start, that1.Start)
	}
	if !this.Duration.Equal(that1.Duration) {
		return fmt.Errorf("Duration this(%v) Not Equal that(%v)", this.Duration, that1.Duration)
	}
	return nil
}
func (this *Unavailability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Unavailability)
	if !ok {
		that2, ok := that.(Unavailability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Start.Equal(&that1.Start) {
		return false
	}
	if !this.Duration.Equal(that1.Duration) {
		return false
	}
	return true
}
func (this *MachineID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MachineID)
	if !ok {
		that2, ok := that.(MachineID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MachineID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MachineID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MachineID but is not nil && this == nil")
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", *this.Hostname, *that1.Hostname)
		}
	} else if this.Hostname != nil {
		return fmt.Errorf("this.Hostname == nil && that.Hostname != nil")
	} else if that1.Hostname != nil {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.IP != nil && that1.IP != nil {
		if *this.IP != *that1.IP {
			return fmt.Errorf("IP this(%v) Not Equal that(%v)", *this.IP, *that1.IP)
		}
	} else if this.IP != nil {
		return fmt.Errorf("this.IP == nil && that.IP != nil")
	} else if that1.IP != nil {
		return fmt.Errorf("IP this(%v) Not Equal that(%v)", this.IP, that1.IP)
	}
	return nil
}
func (this *MachineID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MachineID)
	if !ok {
		that2, ok := that.(MachineID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return false
		}
	} else if this.Hostname != nil {
		return false
	} else if that1.Hostname != nil {
		return false
	}
	if this.IP != nil && that1.IP != nil {
		if *this.IP != *that1.IP {
			return false
		}
	} else if this.IP != nil {
		return false
	} else if that1.IP != nil {
		return false
	}
	return true
}
func (this *MachineInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MachineInfo)
	if !ok {
		that2, ok := that.(MachineInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MachineInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MachineInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MachineInfo but is not nil && this == nil")
	}
	if !this.ID.Equal(&that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.Mode != nil && that1.Mode != nil {
		if *this.Mode != *that1.Mode {
			return fmt.Errorf("Mode this(%v) Not Equal that(%v)", *this.Mode, *that1.Mode)
		}
	} else if this.Mode != nil {
		return fmt.Errorf("this.Mode == nil && that.Mode != nil")
	} else if that1.Mode != nil {
		return fmt.Errorf("Mode this(%v) Not Equal that(%v)", this.Mode, that1.Mode)
	}
	if !this.Unavailability.Equal(that1.Unavailability) {
		return fmt.Errorf("Unavailability this(%v) Not Equal that(%v)", this.Unavailability, that1.Unavailability)
	}
	return nil
}
func (this *MachineInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MachineInfo)
	if !ok {
		that2, ok := that.(MachineInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(&that1.ID) {
		return false
	}
	if this.Mode != nil && that1.Mode != nil {
		if *this.Mode != *that1.Mode {
			return false
		}
	} else if this.Mode != nil {
		return false
	} else if that1.Mode != nil {
		return false
	}
	if !this.Unavailability.Equal(that1.Unavailability) {
		return false
	}
	return true
}
func (this *FrameworkInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FrameworkInfo)
	if !ok {
		that2, ok := that.(FrameworkInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FrameworkInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FrameworkInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FrameworkInfo but is not nil && this == nil")
	}
	if this.User != that1.User {
		return fmt.Errorf("User this(%v) Not Equal that(%v)", this.User, that1.User)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if !this.ID.Equal(that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.FailoverTimeout != nil && that1.FailoverTimeout != nil {
		if *this.FailoverTimeout != *that1.FailoverTimeout {
			return fmt.Errorf("FailoverTimeout this(%v) Not Equal that(%v)", *this.FailoverTimeout, *that1.FailoverTimeout)
		}
	} else if this.FailoverTimeout != nil {
		return fmt.Errorf("this.FailoverTimeout == nil && that.FailoverTimeout != nil")
	} else if that1.FailoverTimeout != nil {
		return fmt.Errorf("FailoverTimeout this(%v) Not Equal that(%v)", this.FailoverTimeout, that1.FailoverTimeout)
	}
	if this.Checkpoint != nil && that1.Checkpoint != nil {
		if *this.Checkpoint != *that1.Checkpoint {
			return fmt.Errorf("Checkpoint this(%v) Not Equal that(%v)", *this.Checkpoint, *that1.Checkpoint)
		}
	} else if this.Checkpoint != nil {
		return fmt.Errorf("this.Checkpoint == nil && that.Checkpoint != nil")
	} else if that1.Checkpoint != nil {
		return fmt.Errorf("Checkpoint this(%v) Not Equal that(%v)", this.Checkpoint, that1.Checkpoint)
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return fmt.Errorf("Role this(%v) Not Equal that(%v)", *this.Role, *that1.Role)
		}
	} else if this.Role != nil {
		return fmt.Errorf("this.Role == nil && that.Role != nil")
	} else if that1.Role != nil {
		return fmt.Errorf("Role this(%v) Not Equal that(%v)", this.Role, that1.Role)
	}
	if len(this.Roles) != len(that1.Roles) {
		return fmt.Errorf("Roles this(%v) Not Equal that(%v)", len(this.Roles), len(that1.Roles))
	}
	for i := range this.Roles {
		if this.Roles[i] != that1.Roles[i] {
			return fmt.Errorf("Roles this[%v](%v) Not Equal that[%v](%v)", i, this.Roles[i], i, that1.Roles[i])
		}
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", *this.Hostname, *that1.Hostname)
		}
	} else if this.Hostname != nil {
		return fmt.Errorf("this.Hostname == nil && that.Hostname != nil")
	} else if that1.Hostname != nil {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.Principal != nil && that1.Principal != nil {
		if *this.Principal != *that1.Principal {
			return fmt.Errorf("Principal this(%v) Not Equal that(%v)", *this.Principal, *that1.Principal)
		}
	} else if this.Principal != nil {
		return fmt.Errorf("this.Principal == nil && that.Principal != nil")
	} else if that1.Principal != nil {
		return fmt.Errorf("Principal this(%v) Not Equal that(%v)", this.Principal, that1.Principal)
	}
	if this.WebUiURL != nil && that1.WebUiURL != nil {
		if *this.WebUiURL != *that1.WebUiURL {
			return fmt.Errorf("WebUiURL this(%v) Not Equal that(%v)", *this.WebUiURL, *that1.WebUiURL)
		}
	} else if this.WebUiURL != nil {
		return fmt.Errorf("this.WebUiURL == nil && that.WebUiURL != nil")
	} else if that1.WebUiURL != nil {
		return fmt.Errorf("WebUiURL this(%v) Not Equal that(%v)", this.WebUiURL, that1.WebUiURL)
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return fmt.Errorf("Capabilities this(%v) Not Equal that(%v)", len(this.Capabilities), len(that1.Capabilities))
	}
	for i := range this.Capabilities {
		if !this.Capabilities[i].Equal(&that1.Capabilities[i]) {
			return fmt.Errorf("Capabilities this[%v](%v) Not Equal that[%v](%v)", i, this.Capabilities[i], i, that1.Capabilities[i])
		}
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	return nil
}
func (this *FrameworkInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FrameworkInfo)
	if !ok {
		that2, ok := that.(FrameworkInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if this.FailoverTimeout != nil && that1.FailoverTimeout != nil {
		if *this.FailoverTimeout != *that1.FailoverTimeout {
			return false
		}
	} else if this.FailoverTimeout != nil {
		return false
	} else if that1.FailoverTimeout != nil {
		return false
	}
	if this.Checkpoint != nil && that1.Checkpoint != nil {
		if *this.Checkpoint != *that1.Checkpoint {
			return false
		}
	} else if this.Checkpoint != nil {
		return false
	} else if that1.Checkpoint != nil {
		return false
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return false
		}
	} else if this.Role != nil {
		return false
	} else if that1.Role != nil {
		return false
	}
	if len(this.Roles) != len(that1.Roles) {
		return false
	}
	for i := range this.Roles {
		if this.Roles[i] != that1.Roles[i] {
			return false
		}
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return false
		}
	} else if this.Hostname != nil {
		return false
	} else if that1.Hostname != nil {
		return false
	}
	if this.Principal != nil && that1.Principal != nil {
		if *this.Principal != *that1.Principal {
			return false
		}
	} else if this.Principal != nil {
		return false
	} else if that1.Principal != nil {
		return false
	}
	if this.WebUiURL != nil && that1.WebUiURL != nil {
		if *this.WebUiURL != *that1.WebUiURL {
			return false
		}
	} else if this.WebUiURL != nil {
		return false
	} else if that1.WebUiURL != nil {
		return false
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return false
	}
	for i := range this.Capabilities {
		if !this.Capabilities[i].Equal(&that1.Capabilities[i]) {
			return false
		}
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	return true
}
func (this *FrameworkInfo_Capability) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FrameworkInfo_Capability)
	if !ok {
		that2, ok := that.(FrameworkInfo_Capability)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FrameworkInfo_Capability")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FrameworkInfo_Capability but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FrameworkInfo_Capability but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	return nil
}
func (this *FrameworkInfo_Capability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FrameworkInfo_Capability)
	if !ok {
		that2, ok := that.(FrameworkInfo_Capability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *CheckInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CheckInfo)
	if !ok {
		that2, ok := that.(CheckInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CheckInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CheckInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CheckInfo but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Command.Equal(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	if !this.HTTP.Equal(that1.HTTP) {
		return fmt.Errorf("HTTP this(%v) Not Equal that(%v)", this.HTTP, that1.HTTP)
	}
	if !this.TCP.Equal(that1.TCP) {
		return fmt.Errorf("TCP this(%v) Not Equal that(%v)", this.TCP, that1.TCP)
	}
	if this.DelaySeconds != nil && that1.DelaySeconds != nil {
		if *this.DelaySeconds != *that1.DelaySeconds {
			return fmt.Errorf("DelaySeconds this(%v) Not Equal that(%v)", *this.DelaySeconds, *that1.DelaySeconds)
		}
	} else if this.DelaySeconds != nil {
		return fmt.Errorf("this.DelaySeconds == nil && that.DelaySeconds != nil")
	} else if that1.DelaySeconds != nil {
		return fmt.Errorf("DelaySeconds this(%v) Not Equal that(%v)", this.DelaySeconds, that1.DelaySeconds)
	}
	if this.IntervalSeconds != nil && that1.IntervalSeconds != nil {
		if *this.IntervalSeconds != *that1.IntervalSeconds {
			return fmt.Errorf("IntervalSeconds this(%v) Not Equal that(%v)", *this.IntervalSeconds, *that1.IntervalSeconds)
		}
	} else if this.IntervalSeconds != nil {
		return fmt.Errorf("this.IntervalSeconds == nil && that.IntervalSeconds != nil")
	} else if that1.IntervalSeconds != nil {
		return fmt.Errorf("IntervalSeconds this(%v) Not Equal that(%v)", this.IntervalSeconds, that1.IntervalSeconds)
	}
	if this.TimeoutSeconds != nil && that1.TimeoutSeconds != nil {
		if *this.TimeoutSeconds != *that1.TimeoutSeconds {
			return fmt.Errorf("TimeoutSeconds this(%v) Not Equal that(%v)", *this.TimeoutSeconds, *that1.TimeoutSeconds)
		}
	} else if this.TimeoutSeconds != nil {
		return fmt.Errorf("this.TimeoutSeconds == nil && that.TimeoutSeconds != nil")
	} else if that1.TimeoutSeconds != nil {
		return fmt.Errorf("TimeoutSeconds this(%v) Not Equal that(%v)", this.TimeoutSeconds, that1.TimeoutSeconds)
	}
	return nil
}
func (this *CheckInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckInfo)
	if !ok {
		that2, ok := that.(CheckInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Command.Equal(that1.Command) {
		return false
	}
	if !this.HTTP.Equal(that1.HTTP) {
		return false
	}
	if !this.TCP.Equal(that1.TCP) {
		return false
	}
	if this.DelaySeconds != nil && that1.DelaySeconds != nil {
		if *this.DelaySeconds != *that1.DelaySeconds {
			return false
		}
	} else if this.DelaySeconds != nil {
		return false
	} else if that1.DelaySeconds != nil {
		return false
	}
	if this.IntervalSeconds != nil && that1.IntervalSeconds != nil {
		if *this.IntervalSeconds != *that1.IntervalSeconds {
			return false
		}
	} else if this.IntervalSeconds != nil {
		return false
	} else if that1.IntervalSeconds != nil {
		return false
	}
	if this.TimeoutSeconds != nil && that1.TimeoutSeconds != nil {
		if *this.TimeoutSeconds != *that1.TimeoutSeconds {
			return false
		}
	} else if this.TimeoutSeconds != nil {
		return false
	} else if that1.TimeoutSeconds != nil {
		return false
	}
	return true
}
func (this *CheckInfo_Command) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CheckInfo_Command)
	if !ok {
		that2, ok := that.(CheckInfo_Command)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CheckInfo_Command")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CheckInfo_Command but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CheckInfo_Command but is not nil && this == nil")
	}
	if !this.Command.Equal(&that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	return nil
}
func (this *CheckInfo_Command) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckInfo_Command)
	if !ok {
		that2, ok := that.(CheckInfo_Command)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Command.Equal(&that1.Command) {
		return false
	}
	return true
}
func (this *CheckInfo_Http) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CheckInfo_Http)
	if !ok {
		that2, ok := that.(CheckInfo_Http)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CheckInfo_Http")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CheckInfo_Http but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CheckInfo_Http but is not nil && this == nil")
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return fmt.Errorf("Path this(%v) Not Equal that(%v)", *this.Path, *that1.Path)
		}
	} else if this.Path != nil {
		return fmt.Errorf("this.Path == nil && that.Path != nil")
	} else if that1.Path != nil {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	return nil
}
func (this *CheckInfo_Http) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckInfo_Http)
	if !ok {
		that2, ok := that.(CheckInfo_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return false
		}
	} else if this.Path != nil {
		return false
	} else if that1.Path != nil {
		return false
	}
	return true
}
func (this *CheckInfo_Tcp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CheckInfo_Tcp)
	if !ok {
		that2, ok := that.(CheckInfo_Tcp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CheckInfo_Tcp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CheckInfo_Tcp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CheckInfo_Tcp but is not nil && this == nil")
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	return nil
}
func (this *CheckInfo_Tcp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckInfo_Tcp)
	if !ok {
		that2, ok := that.(CheckInfo_Tcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *HealthCheck) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*HealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *HealthCheck")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *HealthCheck but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *HealthCheck but is not nil && this == nil")
	}
	if this.DelaySeconds != nil && that1.DelaySeconds != nil {
		if *this.DelaySeconds != *that1.DelaySeconds {
			return fmt.Errorf("DelaySeconds this(%v) Not Equal that(%v)", *this.DelaySeconds, *that1.DelaySeconds)
		}
	} else if this.DelaySeconds != nil {
		return fmt.Errorf("this.DelaySeconds == nil && that.DelaySeconds != nil")
	} else if that1.DelaySeconds != nil {
		return fmt.Errorf("DelaySeconds this(%v) Not Equal that(%v)", this.DelaySeconds, that1.DelaySeconds)
	}
	if this.IntervalSeconds != nil && that1.IntervalSeconds != nil {
		if *this.IntervalSeconds != *that1.IntervalSeconds {
			return fmt.Errorf("IntervalSeconds this(%v) Not Equal that(%v)", *this.IntervalSeconds, *that1.IntervalSeconds)
		}
	} else if this.IntervalSeconds != nil {
		return fmt.Errorf("this.IntervalSeconds == nil && that.IntervalSeconds != nil")
	} else if that1.IntervalSeconds != nil {
		return fmt.Errorf("IntervalSeconds this(%v) Not Equal that(%v)", this.IntervalSeconds, that1.IntervalSeconds)
	}
	if this.TimeoutSeconds != nil && that1.TimeoutSeconds != nil {
		if *this.TimeoutSeconds != *that1.TimeoutSeconds {
			return fmt.Errorf("TimeoutSeconds this(%v) Not Equal that(%v)", *this.TimeoutSeconds, *that1.TimeoutSeconds)
		}
	} else if this.TimeoutSeconds != nil {
		return fmt.Errorf("this.TimeoutSeconds == nil && that.TimeoutSeconds != nil")
	} else if that1.TimeoutSeconds != nil {
		return fmt.Errorf("TimeoutSeconds this(%v) Not Equal that(%v)", this.TimeoutSeconds, that1.TimeoutSeconds)
	}
	if this.ConsecutiveFailures != nil && that1.ConsecutiveFailures != nil {
		if *this.ConsecutiveFailures != *that1.ConsecutiveFailures {
			return fmt.Errorf("ConsecutiveFailures this(%v) Not Equal that(%v)", *this.ConsecutiveFailures, *that1.ConsecutiveFailures)
		}
	} else if this.ConsecutiveFailures != nil {
		return fmt.Errorf("this.ConsecutiveFailures == nil && that.ConsecutiveFailures != nil")
	} else if that1.ConsecutiveFailures != nil {
		return fmt.Errorf("ConsecutiveFailures this(%v) Not Equal that(%v)", this.ConsecutiveFailures, that1.ConsecutiveFailures)
	}
	if this.GracePeriodSeconds != nil && that1.GracePeriodSeconds != nil {
		if *this.GracePeriodSeconds != *that1.GracePeriodSeconds {
			return fmt.Errorf("GracePeriodSeconds this(%v) Not Equal that(%v)", *this.GracePeriodSeconds, *that1.GracePeriodSeconds)
		}
	} else if this.GracePeriodSeconds != nil {
		return fmt.Errorf("this.GracePeriodSeconds == nil && that.GracePeriodSeconds != nil")
	} else if that1.GracePeriodSeconds != nil {
		return fmt.Errorf("GracePeriodSeconds this(%v) Not Equal that(%v)", this.GracePeriodSeconds, that1.GracePeriodSeconds)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Command.Equal(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	if !this.HTTP.Equal(that1.HTTP) {
		return fmt.Errorf("HTTP this(%v) Not Equal that(%v)", this.HTTP, that1.HTTP)
	}
	if !this.TCP.Equal(that1.TCP) {
		return fmt.Errorf("TCP this(%v) Not Equal that(%v)", this.TCP, that1.TCP)
	}
	return nil
}
func (this *HealthCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck)
	if !ok {
		that2, ok := that.(HealthCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.DelaySeconds != nil && that1.DelaySeconds != nil {
		if *this.DelaySeconds != *that1.DelaySeconds {
			return false
		}
	} else if this.DelaySeconds != nil {
		return false
	} else if that1.DelaySeconds != nil {
		return false
	}
	if this.IntervalSeconds != nil && that1.IntervalSeconds != nil {
		if *this.IntervalSeconds != *that1.IntervalSeconds {
			return false
		}
	} else if this.IntervalSeconds != nil {
		return false
	} else if that1.IntervalSeconds != nil {
		return false
	}
	if this.TimeoutSeconds != nil && that1.TimeoutSeconds != nil {
		if *this.TimeoutSeconds != *that1.TimeoutSeconds {
			return false
		}
	} else if this.TimeoutSeconds != nil {
		return false
	} else if that1.TimeoutSeconds != nil {
		return false
	}
	if this.ConsecutiveFailures != nil && that1.ConsecutiveFailures != nil {
		if *this.ConsecutiveFailures != *that1.ConsecutiveFailures {
			return false
		}
	} else if this.ConsecutiveFailures != nil {
		return false
	} else if that1.ConsecutiveFailures != nil {
		return false
	}
	if this.GracePeriodSeconds != nil && that1.GracePeriodSeconds != nil {
		if *this.GracePeriodSeconds != *that1.GracePeriodSeconds {
			return false
		}
	} else if this.GracePeriodSeconds != nil {
		return false
	} else if that1.GracePeriodSeconds != nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Command.Equal(that1.Command) {
		return false
	}
	if !this.HTTP.Equal(that1.HTTP) {
		return false
	}
	if !this.TCP.Equal(that1.TCP) {
		return false
	}
	return true
}
func (this *HealthCheck_HTTPCheckInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*HealthCheck_HTTPCheckInfo)
	if !ok {
		that2, ok := that.(HealthCheck_HTTPCheckInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *HealthCheck_HTTPCheckInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *HealthCheck_HTTPCheckInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *HealthCheck_HTTPCheckInfo but is not nil && this == nil")
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", *this.Protocol, *that1.Protocol)
		}
	} else if this.Protocol != nil {
		return fmt.Errorf("this.Protocol == nil && that.Protocol != nil")
	} else if that1.Protocol != nil {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	if this.Scheme != nil && that1.Scheme != nil {
		if *this.Scheme != *that1.Scheme {
			return fmt.Errorf("Scheme this(%v) Not Equal that(%v)", *this.Scheme, *that1.Scheme)
		}
	} else if this.Scheme != nil {
		return fmt.Errorf("this.Scheme == nil && that.Scheme != nil")
	} else if that1.Scheme != nil {
		return fmt.Errorf("Scheme this(%v) Not Equal that(%v)", this.Scheme, that1.Scheme)
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return fmt.Errorf("Path this(%v) Not Equal that(%v)", *this.Path, *that1.Path)
		}
	} else if this.Path != nil {
		return fmt.Errorf("this.Path == nil && that.Path != nil")
	} else if that1.Path != nil {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	if len(this.Statuses) != len(that1.Statuses) {
		return fmt.Errorf("Statuses this(%v) Not Equal that(%v)", len(this.Statuses), len(that1.Statuses))
	}
	for i := range this.Statuses {
		if this.Statuses[i] != that1.Statuses[i] {
			return fmt.Errorf("Statuses this[%v](%v) Not Equal that[%v](%v)", i, this.Statuses[i], i, that1.Statuses[i])
		}
	}
	return nil
}
func (this *HealthCheck_HTTPCheckInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_HTTPCheckInfo)
	if !ok {
		that2, ok := that.(HealthCheck_HTTPCheckInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return false
		}
	} else if this.Protocol != nil {
		return false
	} else if that1.Protocol != nil {
		return false
	}
	if this.Scheme != nil && that1.Scheme != nil {
		if *this.Scheme != *that1.Scheme {
			return false
		}
	} else if this.Scheme != nil {
		return false
	} else if that1.Scheme != nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return false
		}
	} else if this.Path != nil {
		return false
	} else if that1.Path != nil {
		return false
	}
	if len(this.Statuses) != len(that1.Statuses) {
		return false
	}
	for i := range this.Statuses {
		if this.Statuses[i] != that1.Statuses[i] {
			return false
		}
	}
	return true
}
func (this *HealthCheck_TCPCheckInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*HealthCheck_TCPCheckInfo)
	if !ok {
		that2, ok := that.(HealthCheck_TCPCheckInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *HealthCheck_TCPCheckInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *HealthCheck_TCPCheckInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *HealthCheck_TCPCheckInfo but is not nil && this == nil")
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", *this.Protocol, *that1.Protocol)
		}
	} else if this.Protocol != nil {
		return fmt.Errorf("this.Protocol == nil && that.Protocol != nil")
	} else if that1.Protocol != nil {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	return nil
}
func (this *HealthCheck_TCPCheckInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HealthCheck_TCPCheckInfo)
	if !ok {
		that2, ok := that.(HealthCheck_TCPCheckInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return false
		}
	} else if this.Protocol != nil {
		return false
	} else if that1.Protocol != nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *KillPolicy) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*KillPolicy)
	if !ok {
		that2, ok := that.(KillPolicy)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *KillPolicy")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *KillPolicy but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *KillPolicy but is not nil && this == nil")
	}
	if !this.GracePeriod.Equal(that1.GracePeriod) {
		return fmt.Errorf("GracePeriod this(%v) Not Equal that(%v)", this.GracePeriod, that1.GracePeriod)
	}
	return nil
}
func (this *KillPolicy) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*KillPolicy)
	if !ok {
		that2, ok := that.(KillPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.GracePeriod.Equal(that1.GracePeriod) {
		return false
	}
	return true
}
func (this *CommandInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CommandInfo)
	if !ok {
		that2, ok := that.(CommandInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CommandInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CommandInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CommandInfo but is not nil && this == nil")
	}
	if len(this.URIs) != len(that1.URIs) {
		return fmt.Errorf("URIs this(%v) Not Equal that(%v)", len(this.URIs), len(that1.URIs))
	}
	for i := range this.URIs {
		if !this.URIs[i].Equal(&that1.URIs[i]) {
			return fmt.Errorf("URIs this[%v](%v) Not Equal that[%v](%v)", i, this.URIs[i], i, that1.URIs[i])
		}
	}
	if !this.Environment.Equal(that1.Environment) {
		return fmt.Errorf("Environment this(%v) Not Equal that(%v)", this.Environment, that1.Environment)
	}
	if this.Shell != nil && that1.Shell != nil {
		if *this.Shell != *that1.Shell {
			return fmt.Errorf("Shell this(%v) Not Equal that(%v)", *this.Shell, *that1.Shell)
		}
	} else if this.Shell != nil {
		return fmt.Errorf("this.Shell == nil && that.Shell != nil")
	} else if that1.Shell != nil {
		return fmt.Errorf("Shell this(%v) Not Equal that(%v)", this.Shell, that1.Shell)
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return fmt.Errorf("Value this(%v) Not Equal that(%v)", *this.Value, *that1.Value)
		}
	} else if this.Value != nil {
		return fmt.Errorf("this.Value == nil && that.Value != nil")
	} else if that1.Value != nil {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if len(this.Arguments) != len(that1.Arguments) {
		return fmt.Errorf("Arguments this(%v) Not Equal that(%v)", len(this.Arguments), len(that1.Arguments))
	}
	for i := range this.Arguments {
		if this.Arguments[i] != that1.Arguments[i] {
			return fmt.Errorf("Arguments this[%v](%v) Not Equal that[%v](%v)", i, this.Arguments[i], i, that1.Arguments[i])
		}
	}
	if this.User != nil && that1.User != nil {
		if *this.User != *that1.User {
			return fmt.Errorf("User this(%v) Not Equal that(%v)", *this.User, *that1.User)
		}
	} else if this.User != nil {
		return fmt.Errorf("this.User == nil && that.User != nil")
	} else if that1.User != nil {
		return fmt.Errorf("User this(%v) Not Equal that(%v)", this.User, that1.User)
	}
	return nil
}
func (this *CommandInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CommandInfo)
	if !ok {
		that2, ok := that.(CommandInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.URIs) != len(that1.URIs) {
		return false
	}
	for i := range this.URIs {
		if !this.URIs[i].Equal(&that1.URIs[i]) {
			return false
		}
	}
	if !this.Environment.Equal(that1.Environment) {
		return false
	}
	if this.Shell != nil && that1.Shell != nil {
		if *this.Shell != *that1.Shell {
			return false
		}
	} else if this.Shell != nil {
		return false
	} else if that1.Shell != nil {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	if len(this.Arguments) != len(that1.Arguments) {
		return false
	}
	for i := range this.Arguments {
		if this.Arguments[i] != that1.Arguments[i] {
			return false
		}
	}
	if this.User != nil && that1.User != nil {
		if *this.User != *that1.User {
			return false
		}
	} else if this.User != nil {
		return false
	} else if that1.User != nil {
		return false
	}
	return true
}
func (this *CommandInfo_URI) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CommandInfo_URI)
	if !ok {
		that2, ok := that.(CommandInfo_URI)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CommandInfo_URI")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CommandInfo_URI but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CommandInfo_URI but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if this.Executable != nil && that1.Executable != nil {
		if *this.Executable != *that1.Executable {
			return fmt.Errorf("Executable this(%v) Not Equal that(%v)", *this.Executable, *that1.Executable)
		}
	} else if this.Executable != nil {
		return fmt.Errorf("this.Executable == nil && that.Executable != nil")
	} else if that1.Executable != nil {
		return fmt.Errorf("Executable this(%v) Not Equal that(%v)", this.Executable, that1.Executable)
	}
	if this.Extract != nil && that1.Extract != nil {
		if *this.Extract != *that1.Extract {
			return fmt.Errorf("Extract this(%v) Not Equal that(%v)", *this.Extract, *that1.Extract)
		}
	} else if this.Extract != nil {
		return fmt.Errorf("this.Extract == nil && that.Extract != nil")
	} else if that1.Extract != nil {
		return fmt.Errorf("Extract this(%v) Not Equal that(%v)", this.Extract, that1.Extract)
	}
	if this.Cache != nil && that1.Cache != nil {
		if *this.Cache != *that1.Cache {
			return fmt.Errorf("Cache this(%v) Not Equal that(%v)", *this.Cache, *that1.Cache)
		}
	} else if this.Cache != nil {
		return fmt.Errorf("this.Cache == nil && that.Cache != nil")
	} else if that1.Cache != nil {
		return fmt.Errorf("Cache this(%v) Not Equal that(%v)", this.Cache, that1.Cache)
	}
	if this.OutputFile != nil && that1.OutputFile != nil {
		if *this.OutputFile != *that1.OutputFile {
			return fmt.Errorf("OutputFile this(%v) Not Equal that(%v)", *this.OutputFile, *that1.OutputFile)
		}
	} else if this.OutputFile != nil {
		return fmt.Errorf("this.OutputFile == nil && that.OutputFile != nil")
	} else if that1.OutputFile != nil {
		return fmt.Errorf("OutputFile this(%v) Not Equal that(%v)", this.OutputFile, that1.OutputFile)
	}
	return nil
}
func (this *CommandInfo_URI) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CommandInfo_URI)
	if !ok {
		that2, ok := that.(CommandInfo_URI)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Executable != nil && that1.Executable != nil {
		if *this.Executable != *that1.Executable {
			return false
		}
	} else if this.Executable != nil {
		return false
	} else if that1.Executable != nil {
		return false
	}
	if this.Extract != nil && that1.Extract != nil {
		if *this.Extract != *that1.Extract {
			return false
		}
	} else if this.Extract != nil {
		return false
	} else if that1.Extract != nil {
		return false
	}
	if this.Cache != nil && that1.Cache != nil {
		if *this.Cache != *that1.Cache {
			return false
		}
	} else if this.Cache != nil {
		return false
	} else if that1.Cache != nil {
		return false
	}
	if this.OutputFile != nil && that1.OutputFile != nil {
		if *this.OutputFile != *that1.OutputFile {
			return false
		}
	} else if this.OutputFile != nil {
		return false
	} else if that1.OutputFile != nil {
		return false
	}
	return true
}
func (this *ExecutorInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ExecutorInfo)
	if !ok {
		that2, ok := that.(ExecutorInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ExecutorInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ExecutorInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ExecutorInfo but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.ExecutorID.Equal(&that1.ExecutorID) {
		return fmt.Errorf("ExecutorID this(%v) Not Equal that(%v)", this.ExecutorID, that1.ExecutorID)
	}
	if !this.FrameworkID.Equal(that1.FrameworkID) {
		return fmt.Errorf("FrameworkID this(%v) Not Equal that(%v)", this.FrameworkID, that1.FrameworkID)
	}
	if !this.Command.Equal(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	if !this.Container.Equal(that1.Container) {
		return fmt.Errorf("Container this(%v) Not Equal that(%v)", this.Container, that1.Container)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return fmt.Errorf("Name this(%v) Not Equal that(%v)", *this.Name, *that1.Name)
		}
	} else if this.Name != nil {
		return fmt.Errorf("this.Name == nil && that.Name != nil")
	} else if that1.Name != nil {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Source != nil && that1.Source != nil {
		if *this.Source != *that1.Source {
			return fmt.Errorf("Source this(%v) Not Equal that(%v)", *this.Source, *that1.Source)
		}
	} else if this.Source != nil {
		return fmt.Errorf("this.Source == nil && that.Source != nil")
	} else if that1.Source != nil {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if !this.Discovery.Equal(that1.Discovery) {
		return fmt.Errorf("Discovery this(%v) Not Equal that(%v)", this.Discovery, that1.Discovery)
	}
	if !this.ShutdownGracePeriod.Equal(that1.ShutdownGracePeriod) {
		return fmt.Errorf("ShutdownGracePeriod this(%v) Not Equal that(%v)", this.ShutdownGracePeriod, that1.ShutdownGracePeriod)
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	return nil
}
func (this *ExecutorInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ExecutorInfo)
	if !ok {
		that2, ok := that.(ExecutorInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.ExecutorID.Equal(&that1.ExecutorID) {
		return false
	}
	if !this.FrameworkID.Equal(that1.FrameworkID) {
		return false
	}
	if !this.Command.Equal(that1.Command) {
		return false
	}
	if !this.Container.Equal(that1.Container) {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if this.Source != nil && that1.Source != nil {
		if *this.Source != *that1.Source {
			return false
		}
	} else if this.Source != nil {
		return false
	} else if that1.Source != nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if !this.Discovery.Equal(that1.Discovery) {
		return false
	}
	if !this.ShutdownGracePeriod.Equal(that1.ShutdownGracePeriod) {
		return false
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	return true
}
func (this *DomainInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DomainInfo)
	if !ok {
		that2, ok := that.(DomainInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DomainInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DomainInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DomainInfo but is not nil && this == nil")
	}
	if !this.FaultDomain.Equal(that1.FaultDomain) {
		return fmt.Errorf("FaultDomain this(%v) Not Equal that(%v)", this.FaultDomain, that1.FaultDomain)
	}
	return nil
}
func (this *DomainInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DomainInfo)
	if !ok {
		that2, ok := that.(DomainInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.FaultDomain.Equal(that1.FaultDomain) {
		return false
	}
	return true
}
func (this *DomainInfo_FaultDomain) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DomainInfo_FaultDomain)
	if !ok {
		that2, ok := that.(DomainInfo_FaultDomain)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DomainInfo_FaultDomain")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DomainInfo_FaultDomain but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DomainInfo_FaultDomain but is not nil && this == nil")
	}
	if !this.Region.Equal(&that1.Region) {
		return fmt.Errorf("Region this(%v) Not Equal that(%v)", this.Region, that1.Region)
	}
	if !this.Zone.Equal(&that1.Zone) {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	return nil
}
func (this *DomainInfo_FaultDomain) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DomainInfo_FaultDomain)
	if !ok {
		that2, ok := that.(DomainInfo_FaultDomain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Region.Equal(&that1.Region) {
		return false
	}
	if !this.Zone.Equal(&that1.Zone) {
		return false
	}
	return true
}
func (this *DomainInfo_FaultDomain_RegionInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DomainInfo_FaultDomain_RegionInfo)
	if !ok {
		that2, ok := that.(DomainInfo_FaultDomain_RegionInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DomainInfo_FaultDomain_RegionInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DomainInfo_FaultDomain_RegionInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DomainInfo_FaultDomain_RegionInfo but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	return nil
}
func (this *DomainInfo_FaultDomain_RegionInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DomainInfo_FaultDomain_RegionInfo)
	if !ok {
		that2, ok := that.(DomainInfo_FaultDomain_RegionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *DomainInfo_FaultDomain_ZoneInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DomainInfo_FaultDomain_ZoneInfo)
	if !ok {
		that2, ok := that.(DomainInfo_FaultDomain_ZoneInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DomainInfo_FaultDomain_ZoneInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DomainInfo_FaultDomain_ZoneInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DomainInfo_FaultDomain_ZoneInfo but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	return nil
}
func (this *DomainInfo_FaultDomain_ZoneInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DomainInfo_FaultDomain_ZoneInfo)
	if !ok {
		that2, ok := that.(DomainInfo_FaultDomain_ZoneInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *MasterInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MasterInfo)
	if !ok {
		that2, ok := that.(MasterInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MasterInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MasterInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MasterInfo but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.IP != that1.IP {
		return fmt.Errorf("IP this(%v) Not Equal that(%v)", this.IP, that1.IP)
	}
	if this.Port != nil && that1.Port != nil {
		if *this.Port != *that1.Port {
			return fmt.Errorf("Port this(%v) Not Equal that(%v)", *this.Port, *that1.Port)
		}
	} else if this.Port != nil {
		return fmt.Errorf("this.Port == nil && that.Port != nil")
	} else if that1.Port != nil {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	if this.PID != nil && that1.PID != nil {
		if *this.PID != *that1.PID {
			return fmt.Errorf("PID this(%v) Not Equal that(%v)", *this.PID, *that1.PID)
		}
	} else if this.PID != nil {
		return fmt.Errorf("this.PID == nil && that.PID != nil")
	} else if that1.PID != nil {
		return fmt.Errorf("PID this(%v) Not Equal that(%v)", this.PID, that1.PID)
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", *this.Hostname, *that1.Hostname)
		}
	} else if this.Hostname != nil {
		return fmt.Errorf("this.Hostname == nil && that.Hostname != nil")
	} else if that1.Hostname != nil {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.Version != nil && that1.Version != nil {
		if *this.Version != *that1.Version {
			return fmt.Errorf("Version this(%v) Not Equal that(%v)", *this.Version, *that1.Version)
		}
	} else if this.Version != nil {
		return fmt.Errorf("this.Version == nil && that.Version != nil")
	} else if that1.Version != nil {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if !this.Address.Equal(that1.Address) {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if !this.Domain.Equal(that1.Domain) {
		return fmt.Errorf("Domain this(%v) Not Equal that(%v)", this.Domain, that1.Domain)
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return fmt.Errorf("Capabilities this(%v) Not Equal that(%v)", len(this.Capabilities), len(that1.Capabilities))
	}
	for i := range this.Capabilities {
		if !this.Capabilities[i].Equal(&that1.Capabilities[i]) {
			return fmt.Errorf("Capabilities this[%v](%v) Not Equal that[%v](%v)", i, this.Capabilities[i], i, that1.Capabilities[i])
		}
	}
	return nil
}
func (this *MasterInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MasterInfo)
	if !ok {
		that2, ok := that.(MasterInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.IP != that1.IP {
		return false
	}
	if this.Port != nil && that1.Port != nil {
		if *this.Port != *that1.Port {
			return false
		}
	} else if this.Port != nil {
		return false
	} else if that1.Port != nil {
		return false
	}
	if this.PID != nil && that1.PID != nil {
		if *this.PID != *that1.PID {
			return false
		}
	} else if this.PID != nil {
		return false
	} else if that1.PID != nil {
		return false
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return false
		}
	} else if this.Hostname != nil {
		return false
	} else if that1.Hostname != nil {
		return false
	}
	if this.Version != nil && that1.Version != nil {
		if *this.Version != *that1.Version {
			return false
		}
	} else if this.Version != nil {
		return false
	} else if that1.Version != nil {
		return false
	}
	if !this.Address.Equal(that1.Address) {
		return false
	}
	if !this.Domain.Equal(that1.Domain) {
		return false
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return false
	}
	for i := range this.Capabilities {
		if !this.Capabilities[i].Equal(&that1.Capabilities[i]) {
			return false
		}
	}
	return true
}
func (this *MasterInfo_Capability) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MasterInfo_Capability)
	if !ok {
		that2, ok := that.(MasterInfo_Capability)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MasterInfo_Capability")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MasterInfo_Capability but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MasterInfo_Capability but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	return nil
}
func (this *MasterInfo_Capability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MasterInfo_Capability)
	if !ok {
		that2, ok := that.(MasterInfo_Capability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *AgentInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AgentInfo)
	if !ok {
		that2, ok := that.(AgentInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AgentInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AgentInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AgentInfo but is not nil && this == nil")
	}
	if this.Hostname != that1.Hostname {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.Port != nil && that1.Port != nil {
		if *this.Port != *that1.Port {
			return fmt.Errorf("Port this(%v) Not Equal that(%v)", *this.Port, *that1.Port)
		}
	} else if this.Port != nil {
		return fmt.Errorf("this.Port == nil && that.Port != nil")
	} else if that1.Port != nil {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return fmt.Errorf("Attributes this(%v) Not Equal that(%v)", len(this.Attributes), len(that1.Attributes))
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(&that1.Attributes[i]) {
			return fmt.Errorf("Attributes this[%v](%v) Not Equal that[%v](%v)", i, this.Attributes[i], i, that1.Attributes[i])
		}
	}
	if !this.ID.Equal(that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if !this.Domain.Equal(that1.Domain) {
		return fmt.Errorf("Domain this(%v) Not Equal that(%v)", this.Domain, that1.Domain)
	}
	return nil
}
func (this *AgentInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AgentInfo)
	if !ok {
		that2, ok := that.(AgentInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.Port != nil && that1.Port != nil {
		if *this.Port != *that1.Port {
			return false
		}
	} else if this.Port != nil {
		return false
	} else if that1.Port != nil {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(&that1.Attributes[i]) {
			return false
		}
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !this.Domain.Equal(that1.Domain) {
		return false
	}
	return true
}
func (this *AgentInfo_Capability) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AgentInfo_Capability)
	if !ok {
		that2, ok := that.(AgentInfo_Capability)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AgentInfo_Capability")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AgentInfo_Capability but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AgentInfo_Capability but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	return nil
}
func (this *AgentInfo_Capability) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AgentInfo_Capability)
	if !ok {
		that2, ok := that.(AgentInfo_Capability)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *CSIPluginContainerInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CSIPluginContainerInfo)
	if !ok {
		that2, ok := that.(CSIPluginContainerInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CSIPluginContainerInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CSIPluginContainerInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CSIPluginContainerInfo but is not nil && this == nil")
	}
	if len(this.Services) != len(that1.Services) {
		return fmt.Errorf("Services this(%v) Not Equal that(%v)", len(this.Services), len(that1.Services))
	}
	for i := range this.Services {
		if this.Services[i] != that1.Services[i] {
			return fmt.Errorf("Services this[%v](%v) Not Equal that[%v](%v)", i, this.Services[i], i, that1.Services[i])
		}
	}
	if !this.Command.Equal(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	if !this.Container.Equal(that1.Container) {
		return fmt.Errorf("Container this(%v) Not Equal that(%v)", this.Container, that1.Container)
	}
	return nil
}
func (this *CSIPluginContainerInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CSIPluginContainerInfo)
	if !ok {
		that2, ok := that.(CSIPluginContainerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if this.Services[i] != that1.Services[i] {
			return false
		}
	}
	if !this.Command.Equal(that1.Command) {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	if !this.Container.Equal(that1.Container) {
		return false
	}
	return true
}
func (this *CSIPluginInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CSIPluginInfo)
	if !ok {
		that2, ok := that.(CSIPluginInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CSIPluginInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CSIPluginInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CSIPluginInfo but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if len(this.Containers) != len(that1.Containers) {
		return fmt.Errorf("Containers this(%v) Not Equal that(%v)", len(this.Containers), len(that1.Containers))
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(&that1.Containers[i]) {
			return fmt.Errorf("Containers this[%v](%v) Not Equal that[%v](%v)", i, this.Containers[i], i, that1.Containers[i])
		}
	}
	return nil
}
func (this *CSIPluginInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CSIPluginInfo)
	if !ok {
		that2, ok := that.(CSIPluginInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(&that1.Containers[i]) {
			return false
		}
	}
	return true
}
func (this *ResourceProviderInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResourceProviderInfo)
	if !ok {
		that2, ok := that.(ResourceProviderInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResourceProviderInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResourceProviderInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResourceProviderInfo but is not nil && this == nil")
	}
	if !this.ID.Equal(that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return fmt.Errorf("Attributes this(%v) Not Equal that(%v)", len(this.Attributes), len(that1.Attributes))
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(&that1.Attributes[i]) {
			return fmt.Errorf("Attributes this[%v](%v) Not Equal that[%v](%v)", i, this.Attributes[i], i, that1.Attributes[i])
		}
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if len(this.DefaultReservations) != len(that1.DefaultReservations) {
		return fmt.Errorf("DefaultReservations this(%v) Not Equal that(%v)", len(this.DefaultReservations), len(that1.DefaultReservations))
	}
	for i := range this.DefaultReservations {
		if !this.DefaultReservations[i].Equal(&that1.DefaultReservations[i]) {
			return fmt.Errorf("DefaultReservations this[%v](%v) Not Equal that[%v](%v)", i, this.DefaultReservations[i], i, that1.DefaultReservations[i])
		}
	}
	if !this.Storage.Equal(that1.Storage) {
		return fmt.Errorf("Storage this(%v) Not Equal that(%v)", this.Storage, that1.Storage)
	}
	return nil
}
func (this *ResourceProviderInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceProviderInfo)
	if !ok {
		that2, ok := that.(ResourceProviderInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(&that1.Attributes[i]) {
			return false
		}
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.DefaultReservations) != len(that1.DefaultReservations) {
		return false
	}
	for i := range this.DefaultReservations {
		if !this.DefaultReservations[i].Equal(&that1.DefaultReservations[i]) {
			return false
		}
	}
	if !this.Storage.Equal(that1.Storage) {
		return false
	}
	return true
}
func (this *ResourceProviderInfo_Storage) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResourceProviderInfo_Storage)
	if !ok {
		that2, ok := that.(ResourceProviderInfo_Storage)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResourceProviderInfo_Storage")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResourceProviderInfo_Storage but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResourceProviderInfo_Storage but is not nil && this == nil")
	}
	if !this.Plugin.Equal(&that1.Plugin) {
		return fmt.Errorf("Plugin this(%v) Not Equal that(%v)", this.Plugin, that1.Plugin)
	}
	return nil
}
func (this *ResourceProviderInfo_Storage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceProviderInfo_Storage)
	if !ok {
		that2, ok := that.(ResourceProviderInfo_Storage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Plugin.Equal(&that1.Plugin) {
		return false
	}
	return true
}
func (this *Value) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Value")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Value but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Value but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Scalar.Equal(that1.Scalar) {
		return fmt.Errorf("Scalar this(%v) Not Equal that(%v)", this.Scalar, that1.Scalar)
	}
	if !this.Ranges.Equal(that1.Ranges) {
		return fmt.Errorf("Ranges this(%v) Not Equal that(%v)", this.Ranges, that1.Ranges)
	}
	if !this.Set.Equal(that1.Set) {
		return fmt.Errorf("Set this(%v) Not Equal that(%v)", this.Set, that1.Set)
	}
	if !this.Text.Equal(that1.Text) {
		return fmt.Errorf("Text this(%v) Not Equal that(%v)", this.Text, that1.Text)
	}
	return nil
}
func (this *Value) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Scalar.Equal(that1.Scalar) {
		return false
	}
	if !this.Ranges.Equal(that1.Ranges) {
		return false
	}
	if !this.Set.Equal(that1.Set) {
		return false
	}
	if !this.Text.Equal(that1.Text) {
		return false
	}
	return true
}
func (this *Value_Scalar) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Value_Scalar)
	if !ok {
		that2, ok := that.(Value_Scalar)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Value_Scalar")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Value_Scalar but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Value_Scalar but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Value_Scalar) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Scalar)
	if !ok {
		that2, ok := that.(Value_Scalar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Value_Range) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Value_Range)
	if !ok {
		that2, ok := that.(Value_Range)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Value_Range")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Value_Range but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Value_Range but is not nil && this == nil")
	}
	if this.Begin != that1.Begin {
		return fmt.Errorf("Begin this(%v) Not Equal that(%v)", this.Begin, that1.Begin)
	}
	if this.End != that1.End {
		return fmt.Errorf("End this(%v) Not Equal that(%v)", this.End, that1.End)
	}
	return nil
}
func (this *Value_Range) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Range)
	if !ok {
		that2, ok := that.(Value_Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Begin != that1.Begin {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *Value_Ranges) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Value_Ranges)
	if !ok {
		that2, ok := that.(Value_Ranges)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Value_Ranges")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Value_Ranges but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Value_Ranges but is not nil && this == nil")
	}
	if len(this.Range) != len(that1.Range) {
		return fmt.Errorf("Range this(%v) Not Equal that(%v)", len(this.Range), len(that1.Range))
	}
	for i := range this.Range {
		if !this.Range[i].Equal(&that1.Range[i]) {
			return fmt.Errorf("Range this[%v](%v) Not Equal that[%v](%v)", i, this.Range[i], i, that1.Range[i])
		}
	}
	return nil
}
func (this *Value_Ranges) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Ranges)
	if !ok {
		that2, ok := that.(Value_Ranges)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Range) != len(that1.Range) {
		return false
	}
	for i := range this.Range {
		if !this.Range[i].Equal(&that1.Range[i]) {
			return false
		}
	}
	return true
}
func (this *Value_Set) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Value_Set)
	if !ok {
		that2, ok := that.(Value_Set)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Value_Set")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Value_Set but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Value_Set but is not nil && this == nil")
	}
	if len(this.Item) != len(that1.Item) {
		return fmt.Errorf("Item this(%v) Not Equal that(%v)", len(this.Item), len(that1.Item))
	}
	for i := range this.Item {
		if this.Item[i] != that1.Item[i] {
			return fmt.Errorf("Item this[%v](%v) Not Equal that[%v](%v)", i, this.Item[i], i, that1.Item[i])
		}
	}
	return nil
}
func (this *Value_Set) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Set)
	if !ok {
		that2, ok := that.(Value_Set)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Item) != len(that1.Item) {
		return false
	}
	for i := range this.Item {
		if this.Item[i] != that1.Item[i] {
			return false
		}
	}
	return true
}
func (this *Value_Text) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Value_Text)
	if !ok {
		that2, ok := that.(Value_Text)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Value_Text")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Value_Text but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Value_Text but is not nil && this == nil")
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Value_Text) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value_Text)
	if !ok {
		that2, ok := that.(Value_Text)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Attribute) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Attribute)
	if !ok {
		that2, ok := that.(Attribute)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Attribute")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Attribute but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Attribute but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Scalar.Equal(that1.Scalar) {
		return fmt.Errorf("Scalar this(%v) Not Equal that(%v)", this.Scalar, that1.Scalar)
	}
	if !this.Ranges.Equal(that1.Ranges) {
		return fmt.Errorf("Ranges this(%v) Not Equal that(%v)", this.Ranges, that1.Ranges)
	}
	if !this.Set.Equal(that1.Set) {
		return fmt.Errorf("Set this(%v) Not Equal that(%v)", this.Set, that1.Set)
	}
	if !this.Text.Equal(that1.Text) {
		return fmt.Errorf("Text this(%v) Not Equal that(%v)", this.Text, that1.Text)
	}
	return nil
}
func (this *Attribute) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Attribute)
	if !ok {
		that2, ok := that.(Attribute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Scalar.Equal(that1.Scalar) {
		return false
	}
	if !this.Ranges.Equal(that1.Ranges) {
		return false
	}
	if !this.Set.Equal(that1.Set) {
		return false
	}
	if !this.Text.Equal(that1.Text) {
		return false
	}
	return true
}
func (this *Resource) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource)
	if !ok {
		that2, ok := that.(Resource)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource but is not nil && this == nil")
	}
	if !this.ProviderID.Equal(that1.ProviderID) {
		return fmt.Errorf("ProviderID this(%v) Not Equal that(%v)", this.ProviderID, that1.ProviderID)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return fmt.Errorf("Type this(%v) Not Equal that(%v)", *this.Type, *that1.Type)
		}
	} else if this.Type != nil {
		return fmt.Errorf("this.Type == nil && that.Type != nil")
	} else if that1.Type != nil {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Scalar.Equal(that1.Scalar) {
		return fmt.Errorf("Scalar this(%v) Not Equal that(%v)", this.Scalar, that1.Scalar)
	}
	if !this.Ranges.Equal(that1.Ranges) {
		return fmt.Errorf("Ranges this(%v) Not Equal that(%v)", this.Ranges, that1.Ranges)
	}
	if !this.Set.Equal(that1.Set) {
		return fmt.Errorf("Set this(%v) Not Equal that(%v)", this.Set, that1.Set)
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return fmt.Errorf("Role this(%v) Not Equal that(%v)", *this.Role, *that1.Role)
		}
	} else if this.Role != nil {
		return fmt.Errorf("this.Role == nil && that.Role != nil")
	} else if that1.Role != nil {
		return fmt.Errorf("Role this(%v) Not Equal that(%v)", this.Role, that1.Role)
	}
	if !this.AllocationInfo.Equal(that1.AllocationInfo) {
		return fmt.Errorf("AllocationInfo this(%v) Not Equal that(%v)", this.AllocationInfo, that1.AllocationInfo)
	}
	if !this.Reservation.Equal(that1.Reservation) {
		return fmt.Errorf("Reservation this(%v) Not Equal that(%v)", this.Reservation, that1.Reservation)
	}
	if len(this.Reservations) != len(that1.Reservations) {
		return fmt.Errorf("Reservations this(%v) Not Equal that(%v)", len(this.Reservations), len(that1.Reservations))
	}
	for i := range this.Reservations {
		if !this.Reservations[i].Equal(&that1.Reservations[i]) {
			return fmt.Errorf("Reservations this[%v](%v) Not Equal that[%v](%v)", i, this.Reservations[i], i, that1.Reservations[i])
		}
	}
	if !this.Disk.Equal(that1.Disk) {
		return fmt.Errorf("Disk this(%v) Not Equal that(%v)", this.Disk, that1.Disk)
	}
	if !this.Revocable.Equal(that1.Revocable) {
		return fmt.Errorf("Revocable this(%v) Not Equal that(%v)", this.Revocable, that1.Revocable)
	}
	if !this.Shared.Equal(that1.Shared) {
		return fmt.Errorf("Shared this(%v) Not Equal that(%v)", this.Shared, that1.Shared)
	}
	return nil
}
func (this *Resource) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource)
	if !ok {
		that2, ok := that.(Resource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ProviderID.Equal(that1.ProviderID) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if !this.Scalar.Equal(that1.Scalar) {
		return false
	}
	if !this.Ranges.Equal(that1.Ranges) {
		return false
	}
	if !this.Set.Equal(that1.Set) {
		return false
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return false
		}
	} else if this.Role != nil {
		return false
	} else if that1.Role != nil {
		return false
	}
	if !this.AllocationInfo.Equal(that1.AllocationInfo) {
		return false
	}
	if !this.Reservation.Equal(that1.Reservation) {
		return false
	}
	if len(this.Reservations) != len(that1.Reservations) {
		return false
	}
	for i := range this.Reservations {
		if !this.Reservations[i].Equal(&that1.Reservations[i]) {
			return false
		}
	}
	if !this.Disk.Equal(that1.Disk) {
		return false
	}
	if !this.Revocable.Equal(that1.Revocable) {
		return false
	}
	if !this.Shared.Equal(that1.Shared) {
		return false
	}
	return true
}
func (this *Resource_AllocationInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_AllocationInfo)
	if !ok {
		that2, ok := that.(Resource_AllocationInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_AllocationInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_AllocationInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_AllocationInfo but is not nil && this == nil")
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return fmt.Errorf("Role this(%v) Not Equal that(%v)", *this.Role, *that1.Role)
		}
	} else if this.Role != nil {
		return fmt.Errorf("this.Role == nil && that.Role != nil")
	} else if that1.Role != nil {
		return fmt.Errorf("Role this(%v) Not Equal that(%v)", this.Role, that1.Role)
	}
	return nil
}
func (this *Resource_AllocationInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_AllocationInfo)
	if !ok {
		that2, ok := that.(Resource_AllocationInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return false
		}
	} else if this.Role != nil {
		return false
	} else if that1.Role != nil {
		return false
	}
	return true
}
func (this *Resource_ReservationInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_ReservationInfo)
	if !ok {
		that2, ok := that.(Resource_ReservationInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_ReservationInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_ReservationInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_ReservationInfo but is not nil && this == nil")
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return fmt.Errorf("Type this(%v) Not Equal that(%v)", *this.Type, *that1.Type)
		}
	} else if this.Type != nil {
		return fmt.Errorf("this.Type == nil && that.Type != nil")
	} else if that1.Type != nil {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return fmt.Errorf("Role this(%v) Not Equal that(%v)", *this.Role, *that1.Role)
		}
	} else if this.Role != nil {
		return fmt.Errorf("this.Role == nil && that.Role != nil")
	} else if that1.Role != nil {
		return fmt.Errorf("Role this(%v) Not Equal that(%v)", this.Role, that1.Role)
	}
	if this.Principal != nil && that1.Principal != nil {
		if *this.Principal != *that1.Principal {
			return fmt.Errorf("Principal this(%v) Not Equal that(%v)", *this.Principal, *that1.Principal)
		}
	} else if this.Principal != nil {
		return fmt.Errorf("this.Principal == nil && that.Principal != nil")
	} else if that1.Principal != nil {
		return fmt.Errorf("Principal this(%v) Not Equal that(%v)", this.Principal, that1.Principal)
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	return nil
}
func (this *Resource_ReservationInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_ReservationInfo)
	if !ok {
		that2, ok := that.(Resource_ReservationInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return false
		}
	} else if this.Role != nil {
		return false
	} else if that1.Role != nil {
		return false
	}
	if this.Principal != nil && that1.Principal != nil {
		if *this.Principal != *that1.Principal {
			return false
		}
	} else if this.Principal != nil {
		return false
	} else if that1.Principal != nil {
		return false
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	return true
}
func (this *Resource_DiskInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_DiskInfo)
	if !ok {
		that2, ok := that.(Resource_DiskInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_DiskInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_DiskInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_DiskInfo but is not nil && this == nil")
	}
	if !this.Persistence.Equal(that1.Persistence) {
		return fmt.Errorf("Persistence this(%v) Not Equal that(%v)", this.Persistence, that1.Persistence)
	}
	if !this.Volume.Equal(that1.Volume) {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if !this.Source.Equal(that1.Source) {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	return nil
}
func (this *Resource_DiskInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_DiskInfo)
	if !ok {
		that2, ok := that.(Resource_DiskInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Persistence.Equal(that1.Persistence) {
		return false
	}
	if !this.Volume.Equal(that1.Volume) {
		return false
	}
	if !this.Source.Equal(that1.Source) {
		return false
	}
	return true
}
func (this *Resource_DiskInfo_Persistence) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_DiskInfo_Persistence)
	if !ok {
		that2, ok := that.(Resource_DiskInfo_Persistence)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_DiskInfo_Persistence")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_DiskInfo_Persistence but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_DiskInfo_Persistence but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.Principal != nil && that1.Principal != nil {
		if *this.Principal != *that1.Principal {
			return fmt.Errorf("Principal this(%v) Not Equal that(%v)", *this.Principal, *that1.Principal)
		}
	} else if this.Principal != nil {
		return fmt.Errorf("this.Principal == nil && that.Principal != nil")
	} else if that1.Principal != nil {
		return fmt.Errorf("Principal this(%v) Not Equal that(%v)", this.Principal, that1.Principal)
	}
	return nil
}
func (this *Resource_DiskInfo_Persistence) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_DiskInfo_Persistence)
	if !ok {
		that2, ok := that.(Resource_DiskInfo_Persistence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Principal != nil && that1.Principal != nil {
		if *this.Principal != *that1.Principal {
			return false
		}
	} else if this.Principal != nil {
		return false
	} else if that1.Principal != nil {
		return false
	}
	return true
}
func (this *Resource_DiskInfo_Source) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_DiskInfo_Source)
	if !ok {
		that2, ok := that.(Resource_DiskInfo_Source)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_DiskInfo_Source")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_DiskInfo_Source but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_DiskInfo_Source but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Path.Equal(that1.Path) {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	if !this.Mount.Equal(that1.Mount) {
		return fmt.Errorf("Mount this(%v) Not Equal that(%v)", this.Mount, that1.Mount)
	}
	if this.ID != nil && that1.ID != nil {
		if *this.ID != *that1.ID {
			return fmt.Errorf("ID this(%v) Not Equal that(%v)", *this.ID, *that1.ID)
		}
	} else if this.ID != nil {
		return fmt.Errorf("this.ID == nil && that.ID != nil")
	} else if that1.ID != nil {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return fmt.Errorf("Metadata this(%v) Not Equal that(%v)", this.Metadata, that1.Metadata)
	}
	if this.Profile != nil && that1.Profile != nil {
		if *this.Profile != *that1.Profile {
			return fmt.Errorf("Profile this(%v) Not Equal that(%v)", *this.Profile, *that1.Profile)
		}
	} else if this.Profile != nil {
		return fmt.Errorf("this.Profile == nil && that.Profile != nil")
	} else if that1.Profile != nil {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	return nil
}
func (this *Resource_DiskInfo_Source) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_DiskInfo_Source)
	if !ok {
		that2, ok := that.(Resource_DiskInfo_Source)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if !this.Mount.Equal(that1.Mount) {
		return false
	}
	if this.ID != nil && that1.ID != nil {
		if *this.ID != *that1.ID {
			return false
		}
	} else if this.ID != nil {
		return false
	} else if that1.ID != nil {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if this.Profile != nil && that1.Profile != nil {
		if *this.Profile != *that1.Profile {
			return false
		}
	} else if this.Profile != nil {
		return false
	} else if that1.Profile != nil {
		return false
	}
	return true
}
func (this *Resource_DiskInfo_Source_Path) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_DiskInfo_Source_Path)
	if !ok {
		that2, ok := that.(Resource_DiskInfo_Source_Path)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_DiskInfo_Source_Path")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_DiskInfo_Source_Path but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_DiskInfo_Source_Path but is not nil && this == nil")
	}
	if this.Root != nil && that1.Root != nil {
		if *this.Root != *that1.Root {
			return fmt.Errorf("Root this(%v) Not Equal that(%v)", *this.Root, *that1.Root)
		}
	} else if this.Root != nil {
		return fmt.Errorf("this.Root == nil && that.Root != nil")
	} else if that1.Root != nil {
		return fmt.Errorf("Root this(%v) Not Equal that(%v)", this.Root, that1.Root)
	}
	return nil
}
func (this *Resource_DiskInfo_Source_Path) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_DiskInfo_Source_Path)
	if !ok {
		that2, ok := that.(Resource_DiskInfo_Source_Path)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Root != nil && that1.Root != nil {
		if *this.Root != *that1.Root {
			return false
		}
	} else if this.Root != nil {
		return false
	} else if that1.Root != nil {
		return false
	}
	return true
}
func (this *Resource_DiskInfo_Source_Mount) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_DiskInfo_Source_Mount)
	if !ok {
		that2, ok := that.(Resource_DiskInfo_Source_Mount)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_DiskInfo_Source_Mount")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_DiskInfo_Source_Mount but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_DiskInfo_Source_Mount but is not nil && this == nil")
	}
	if this.Root != nil && that1.Root != nil {
		if *this.Root != *that1.Root {
			return fmt.Errorf("Root this(%v) Not Equal that(%v)", *this.Root, *that1.Root)
		}
	} else if this.Root != nil {
		return fmt.Errorf("this.Root == nil && that.Root != nil")
	} else if that1.Root != nil {
		return fmt.Errorf("Root this(%v) Not Equal that(%v)", this.Root, that1.Root)
	}
	return nil
}
func (this *Resource_DiskInfo_Source_Mount) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_DiskInfo_Source_Mount)
	if !ok {
		that2, ok := that.(Resource_DiskInfo_Source_Mount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Root != nil && that1.Root != nil {
		if *this.Root != *that1.Root {
			return false
		}
	} else if this.Root != nil {
		return false
	} else if that1.Root != nil {
		return false
	}
	return true
}
func (this *Resource_RevocableInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_RevocableInfo)
	if !ok {
		that2, ok := that.(Resource_RevocableInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_RevocableInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_RevocableInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_RevocableInfo but is not nil && this == nil")
	}
	return nil
}
func (this *Resource_RevocableInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_RevocableInfo)
	if !ok {
		that2, ok := that.(Resource_RevocableInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *Resource_SharedInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Resource_SharedInfo)
	if !ok {
		that2, ok := that.(Resource_SharedInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Resource_SharedInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Resource_SharedInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Resource_SharedInfo but is not nil && this == nil")
	}
	return nil
}
func (this *Resource_SharedInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Resource_SharedInfo)
	if !ok {
		that2, ok := that.(Resource_SharedInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *TrafficControlStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TrafficControlStatistics)
	if !ok {
		that2, ok := that.(TrafficControlStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TrafficControlStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TrafficControlStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TrafficControlStatistics but is not nil && this == nil")
	}
	if this.ID != that1.ID {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if this.Backlog != nil && that1.Backlog != nil {
		if *this.Backlog != *that1.Backlog {
			return fmt.Errorf("Backlog this(%v) Not Equal that(%v)", *this.Backlog, *that1.Backlog)
		}
	} else if this.Backlog != nil {
		return fmt.Errorf("this.Backlog == nil && that.Backlog != nil")
	} else if that1.Backlog != nil {
		return fmt.Errorf("Backlog this(%v) Not Equal that(%v)", this.Backlog, that1.Backlog)
	}
	if this.Bytes != nil && that1.Bytes != nil {
		if *this.Bytes != *that1.Bytes {
			return fmt.Errorf("Bytes this(%v) Not Equal that(%v)", *this.Bytes, *that1.Bytes)
		}
	} else if this.Bytes != nil {
		return fmt.Errorf("this.Bytes == nil && that.Bytes != nil")
	} else if that1.Bytes != nil {
		return fmt.Errorf("Bytes this(%v) Not Equal that(%v)", this.Bytes, that1.Bytes)
	}
	if this.Drops != nil && that1.Drops != nil {
		if *this.Drops != *that1.Drops {
			return fmt.Errorf("Drops this(%v) Not Equal that(%v)", *this.Drops, *that1.Drops)
		}
	} else if this.Drops != nil {
		return fmt.Errorf("this.Drops == nil && that.Drops != nil")
	} else if that1.Drops != nil {
		return fmt.Errorf("Drops this(%v) Not Equal that(%v)", this.Drops, that1.Drops)
	}
	if this.Overlimits != nil && that1.Overlimits != nil {
		if *this.Overlimits != *that1.Overlimits {
			return fmt.Errorf("Overlimits this(%v) Not Equal that(%v)", *this.Overlimits, *that1.Overlimits)
		}
	} else if this.Overlimits != nil {
		return fmt.Errorf("this.Overlimits == nil && that.Overlimits != nil")
	} else if that1.Overlimits != nil {
		return fmt.Errorf("Overlimits this(%v) Not Equal that(%v)", this.Overlimits, that1.Overlimits)
	}
	if this.Packets != nil && that1.Packets != nil {
		if *this.Packets != *that1.Packets {
			return fmt.Errorf("Packets this(%v) Not Equal that(%v)", *this.Packets, *that1.Packets)
		}
	} else if this.Packets != nil {
		return fmt.Errorf("this.Packets == nil && that.Packets != nil")
	} else if that1.Packets != nil {
		return fmt.Errorf("Packets this(%v) Not Equal that(%v)", this.Packets, that1.Packets)
	}
	if this.Qlen != nil && that1.Qlen != nil {
		if *this.Qlen != *that1.Qlen {
			return fmt.Errorf("Qlen this(%v) Not Equal that(%v)", *this.Qlen, *that1.Qlen)
		}
	} else if this.Qlen != nil {
		return fmt.Errorf("this.Qlen == nil && that.Qlen != nil")
	} else if that1.Qlen != nil {
		return fmt.Errorf("Qlen this(%v) Not Equal that(%v)", this.Qlen, that1.Qlen)
	}
	if this.RateBPS != nil && that1.RateBPS != nil {
		if *this.RateBPS != *that1.RateBPS {
			return fmt.Errorf("RateBPS this(%v) Not Equal that(%v)", *this.RateBPS, *that1.RateBPS)
		}
	} else if this.RateBPS != nil {
		return fmt.Errorf("this.RateBPS == nil && that.RateBPS != nil")
	} else if that1.RateBPS != nil {
		return fmt.Errorf("RateBPS this(%v) Not Equal that(%v)", this.RateBPS, that1.RateBPS)
	}
	if this.RatePPS != nil && that1.RatePPS != nil {
		if *this.RatePPS != *that1.RatePPS {
			return fmt.Errorf("RatePPS this(%v) Not Equal that(%v)", *this.RatePPS, *that1.RatePPS)
		}
	} else if this.RatePPS != nil {
		return fmt.Errorf("this.RatePPS == nil && that.RatePPS != nil")
	} else if that1.RatePPS != nil {
		return fmt.Errorf("RatePPS this(%v) Not Equal that(%v)", this.RatePPS, that1.RatePPS)
	}
	if this.Requeues != nil && that1.Requeues != nil {
		if *this.Requeues != *that1.Requeues {
			return fmt.Errorf("Requeues this(%v) Not Equal that(%v)", *this.Requeues, *that1.Requeues)
		}
	} else if this.Requeues != nil {
		return fmt.Errorf("this.Requeues == nil && that.Requeues != nil")
	} else if that1.Requeues != nil {
		return fmt.Errorf("Requeues this(%v) Not Equal that(%v)", this.Requeues, that1.Requeues)
	}
	return nil
}
func (this *TrafficControlStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TrafficControlStatistics)
	if !ok {
		that2, ok := that.(TrafficControlStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if this.Backlog != nil && that1.Backlog != nil {
		if *this.Backlog != *that1.Backlog {
			return false
		}
	} else if this.Backlog != nil {
		return false
	} else if that1.Backlog != nil {
		return false
	}
	if this.Bytes != nil && that1.Bytes != nil {
		if *this.Bytes != *that1.Bytes {
			return false
		}
	} else if this.Bytes != nil {
		return false
	} else if that1.Bytes != nil {
		return false
	}
	if this.Drops != nil && that1.Drops != nil {
		if *this.Drops != *that1.Drops {
			return false
		}
	} else if this.Drops != nil {
		return false
	} else if that1.Drops != nil {
		return false
	}
	if this.Overlimits != nil && that1.Overlimits != nil {
		if *this.Overlimits != *that1.Overlimits {
			return false
		}
	} else if this.Overlimits != nil {
		return false
	} else if that1.Overlimits != nil {
		return false
	}
	if this.Packets != nil && that1.Packets != nil {
		if *this.Packets != *that1.Packets {
			return false
		}
	} else if this.Packets != nil {
		return false
	} else if that1.Packets != nil {
		return false
	}
	if this.Qlen != nil && that1.Qlen != nil {
		if *this.Qlen != *that1.Qlen {
			return false
		}
	} else if this.Qlen != nil {
		return false
	} else if that1.Qlen != nil {
		return false
	}
	if this.RateBPS != nil && that1.RateBPS != nil {
		if *this.RateBPS != *that1.RateBPS {
			return false
		}
	} else if this.RateBPS != nil {
		return false
	} else if that1.RateBPS != nil {
		return false
	}
	if this.RatePPS != nil && that1.RatePPS != nil {
		if *this.RatePPS != *that1.RatePPS {
			return false
		}
	} else if this.RatePPS != nil {
		return false
	} else if that1.RatePPS != nil {
		return false
	}
	if this.Requeues != nil && that1.Requeues != nil {
		if *this.Requeues != *that1.Requeues {
			return false
		}
	} else if this.Requeues != nil {
		return false
	} else if that1.Requeues != nil {
		return false
	}
	return true
}
func (this *IpStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IpStatistics)
	if !ok {
		that2, ok := that.(IpStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IpStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IpStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IpStatistics but is not nil && this == nil")
	}
	if this.Forwarding != nil && that1.Forwarding != nil {
		if *this.Forwarding != *that1.Forwarding {
			return fmt.Errorf("Forwarding this(%v) Not Equal that(%v)", *this.Forwarding, *that1.Forwarding)
		}
	} else if this.Forwarding != nil {
		return fmt.Errorf("this.Forwarding == nil && that.Forwarding != nil")
	} else if that1.Forwarding != nil {
		return fmt.Errorf("Forwarding this(%v) Not Equal that(%v)", this.Forwarding, that1.Forwarding)
	}
	if this.DefaultTTL != nil && that1.DefaultTTL != nil {
		if *this.DefaultTTL != *that1.DefaultTTL {
			return fmt.Errorf("DefaultTTL this(%v) Not Equal that(%v)", *this.DefaultTTL, *that1.DefaultTTL)
		}
	} else if this.DefaultTTL != nil {
		return fmt.Errorf("this.DefaultTTL == nil && that.DefaultTTL != nil")
	} else if that1.DefaultTTL != nil {
		return fmt.Errorf("DefaultTTL this(%v) Not Equal that(%v)", this.DefaultTTL, that1.DefaultTTL)
	}
	if this.InReceives != nil && that1.InReceives != nil {
		if *this.InReceives != *that1.InReceives {
			return fmt.Errorf("InReceives this(%v) Not Equal that(%v)", *this.InReceives, *that1.InReceives)
		}
	} else if this.InReceives != nil {
		return fmt.Errorf("this.InReceives == nil && that.InReceives != nil")
	} else if that1.InReceives != nil {
		return fmt.Errorf("InReceives this(%v) Not Equal that(%v)", this.InReceives, that1.InReceives)
	}
	if this.InHdrErrors != nil && that1.InHdrErrors != nil {
		if *this.InHdrErrors != *that1.InHdrErrors {
			return fmt.Errorf("InHdrErrors this(%v) Not Equal that(%v)", *this.InHdrErrors, *that1.InHdrErrors)
		}
	} else if this.InHdrErrors != nil {
		return fmt.Errorf("this.InHdrErrors == nil && that.InHdrErrors != nil")
	} else if that1.InHdrErrors != nil {
		return fmt.Errorf("InHdrErrors this(%v) Not Equal that(%v)", this.InHdrErrors, that1.InHdrErrors)
	}
	if this.InAddrErrors != nil && that1.InAddrErrors != nil {
		if *this.InAddrErrors != *that1.InAddrErrors {
			return fmt.Errorf("InAddrErrors this(%v) Not Equal that(%v)", *this.InAddrErrors, *that1.InAddrErrors)
		}
	} else if this.InAddrErrors != nil {
		return fmt.Errorf("this.InAddrErrors == nil && that.InAddrErrors != nil")
	} else if that1.InAddrErrors != nil {
		return fmt.Errorf("InAddrErrors this(%v) Not Equal that(%v)", this.InAddrErrors, that1.InAddrErrors)
	}
	if this.ForwDatagrams != nil && that1.ForwDatagrams != nil {
		if *this.ForwDatagrams != *that1.ForwDatagrams {
			return fmt.Errorf("ForwDatagrams this(%v) Not Equal that(%v)", *this.ForwDatagrams, *that1.ForwDatagrams)
		}
	} else if this.ForwDatagrams != nil {
		return fmt.Errorf("this.ForwDatagrams == nil && that.ForwDatagrams != nil")
	} else if that1.ForwDatagrams != nil {
		return fmt.Errorf("ForwDatagrams this(%v) Not Equal that(%v)", this.ForwDatagrams, that1.ForwDatagrams)
	}
	if this.InUnknownProtos != nil && that1.InUnknownProtos != nil {
		if *this.InUnknownProtos != *that1.InUnknownProtos {
			return fmt.Errorf("InUnknownProtos this(%v) Not Equal that(%v)", *this.InUnknownProtos, *that1.InUnknownProtos)
		}
	} else if this.InUnknownProtos != nil {
		return fmt.Errorf("this.InUnknownProtos == nil && that.InUnknownProtos != nil")
	} else if that1.InUnknownProtos != nil {
		return fmt.Errorf("InUnknownProtos this(%v) Not Equal that(%v)", this.InUnknownProtos, that1.InUnknownProtos)
	}
	if this.InDiscards != nil && that1.InDiscards != nil {
		if *this.InDiscards != *that1.InDiscards {
			return fmt.Errorf("InDiscards this(%v) Not Equal that(%v)", *this.InDiscards, *that1.InDiscards)
		}
	} else if this.InDiscards != nil {
		return fmt.Errorf("this.InDiscards == nil && that.InDiscards != nil")
	} else if that1.InDiscards != nil {
		return fmt.Errorf("InDiscards this(%v) Not Equal that(%v)", this.InDiscards, that1.InDiscards)
	}
	if this.InDelivers != nil && that1.InDelivers != nil {
		if *this.InDelivers != *that1.InDelivers {
			return fmt.Errorf("InDelivers this(%v) Not Equal that(%v)", *this.InDelivers, *that1.InDelivers)
		}
	} else if this.InDelivers != nil {
		return fmt.Errorf("this.InDelivers == nil && that.InDelivers != nil")
	} else if that1.InDelivers != nil {
		return fmt.Errorf("InDelivers this(%v) Not Equal that(%v)", this.InDelivers, that1.InDelivers)
	}
	if this.OutRequests != nil && that1.OutRequests != nil {
		if *this.OutRequests != *that1.OutRequests {
			return fmt.Errorf("OutRequests this(%v) Not Equal that(%v)", *this.OutRequests, *that1.OutRequests)
		}
	} else if this.OutRequests != nil {
		return fmt.Errorf("this.OutRequests == nil && that.OutRequests != nil")
	} else if that1.OutRequests != nil {
		return fmt.Errorf("OutRequests this(%v) Not Equal that(%v)", this.OutRequests, that1.OutRequests)
	}
	if this.OutDiscards != nil && that1.OutDiscards != nil {
		if *this.OutDiscards != *that1.OutDiscards {
			return fmt.Errorf("OutDiscards this(%v) Not Equal that(%v)", *this.OutDiscards, *that1.OutDiscards)
		}
	} else if this.OutDiscards != nil {
		return fmt.Errorf("this.OutDiscards == nil && that.OutDiscards != nil")
	} else if that1.OutDiscards != nil {
		return fmt.Errorf("OutDiscards this(%v) Not Equal that(%v)", this.OutDiscards, that1.OutDiscards)
	}
	if this.OutNoRoutes != nil && that1.OutNoRoutes != nil {
		if *this.OutNoRoutes != *that1.OutNoRoutes {
			return fmt.Errorf("OutNoRoutes this(%v) Not Equal that(%v)", *this.OutNoRoutes, *that1.OutNoRoutes)
		}
	} else if this.OutNoRoutes != nil {
		return fmt.Errorf("this.OutNoRoutes == nil && that.OutNoRoutes != nil")
	} else if that1.OutNoRoutes != nil {
		return fmt.Errorf("OutNoRoutes this(%v) Not Equal that(%v)", this.OutNoRoutes, that1.OutNoRoutes)
	}
	if this.ReasmTimeout != nil && that1.ReasmTimeout != nil {
		if *this.ReasmTimeout != *that1.ReasmTimeout {
			return fmt.Errorf("ReasmTimeout this(%v) Not Equal that(%v)", *this.ReasmTimeout, *that1.ReasmTimeout)
		}
	} else if this.ReasmTimeout != nil {
		return fmt.Errorf("this.ReasmTimeout == nil && that.ReasmTimeout != nil")
	} else if that1.ReasmTimeout != nil {
		return fmt.Errorf("ReasmTimeout this(%v) Not Equal that(%v)", this.ReasmTimeout, that1.ReasmTimeout)
	}
	if this.ReasmReqds != nil && that1.ReasmReqds != nil {
		if *this.ReasmReqds != *that1.ReasmReqds {
			return fmt.Errorf("ReasmReqds this(%v) Not Equal that(%v)", *this.ReasmReqds, *that1.ReasmReqds)
		}
	} else if this.ReasmReqds != nil {
		return fmt.Errorf("this.ReasmReqds == nil && that.ReasmReqds != nil")
	} else if that1.ReasmReqds != nil {
		return fmt.Errorf("ReasmReqds this(%v) Not Equal that(%v)", this.ReasmReqds, that1.ReasmReqds)
	}
	if this.ReasmOKs != nil && that1.ReasmOKs != nil {
		if *this.ReasmOKs != *that1.ReasmOKs {
			return fmt.Errorf("ReasmOKs this(%v) Not Equal that(%v)", *this.ReasmOKs, *that1.ReasmOKs)
		}
	} else if this.ReasmOKs != nil {
		return fmt.Errorf("this.ReasmOKs == nil && that.ReasmOKs != nil")
	} else if that1.ReasmOKs != nil {
		return fmt.Errorf("ReasmOKs this(%v) Not Equal that(%v)", this.ReasmOKs, that1.ReasmOKs)
	}
	if this.ReasmFails != nil && that1.ReasmFails != nil {
		if *this.ReasmFails != *that1.ReasmFails {
			return fmt.Errorf("ReasmFails this(%v) Not Equal that(%v)", *this.ReasmFails, *that1.ReasmFails)
		}
	} else if this.ReasmFails != nil {
		return fmt.Errorf("this.ReasmFails == nil && that.ReasmFails != nil")
	} else if that1.ReasmFails != nil {
		return fmt.Errorf("ReasmFails this(%v) Not Equal that(%v)", this.ReasmFails, that1.ReasmFails)
	}
	if this.FragOKs != nil && that1.FragOKs != nil {
		if *this.FragOKs != *that1.FragOKs {
			return fmt.Errorf("FragOKs this(%v) Not Equal that(%v)", *this.FragOKs, *that1.FragOKs)
		}
	} else if this.FragOKs != nil {
		return fmt.Errorf("this.FragOKs == nil && that.FragOKs != nil")
	} else if that1.FragOKs != nil {
		return fmt.Errorf("FragOKs this(%v) Not Equal that(%v)", this.FragOKs, that1.FragOKs)
	}
	if this.FragFails != nil && that1.FragFails != nil {
		if *this.FragFails != *that1.FragFails {
			return fmt.Errorf("FragFails this(%v) Not Equal that(%v)", *this.FragFails, *that1.FragFails)
		}
	} else if this.FragFails != nil {
		return fmt.Errorf("this.FragFails == nil && that.FragFails != nil")
	} else if that1.FragFails != nil {
		return fmt.Errorf("FragFails this(%v) Not Equal that(%v)", this.FragFails, that1.FragFails)
	}
	if this.FragCreates != nil && that1.FragCreates != nil {
		if *this.FragCreates != *that1.FragCreates {
			return fmt.Errorf("FragCreates this(%v) Not Equal that(%v)", *this.FragCreates, *that1.FragCreates)
		}
	} else if this.FragCreates != nil {
		return fmt.Errorf("this.FragCreates == nil && that.FragCreates != nil")
	} else if that1.FragCreates != nil {
		return fmt.Errorf("FragCreates this(%v) Not Equal that(%v)", this.FragCreates, that1.FragCreates)
	}
	return nil
}
func (this *IpStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*IpStatistics)
	if !ok {
		that2, ok := that.(IpStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Forwarding != nil && that1.Forwarding != nil {
		if *this.Forwarding != *that1.Forwarding {
			return false
		}
	} else if this.Forwarding != nil {
		return false
	} else if that1.Forwarding != nil {
		return false
	}
	if this.DefaultTTL != nil && that1.DefaultTTL != nil {
		if *this.DefaultTTL != *that1.DefaultTTL {
			return false
		}
	} else if this.DefaultTTL != nil {
		return false
	} else if that1.DefaultTTL != nil {
		return false
	}
	if this.InReceives != nil && that1.InReceives != nil {
		if *this.InReceives != *that1.InReceives {
			return false
		}
	} else if this.InReceives != nil {
		return false
	} else if that1.InReceives != nil {
		return false
	}
	if this.InHdrErrors != nil && that1.InHdrErrors != nil {
		if *this.InHdrErrors != *that1.InHdrErrors {
			return false
		}
	} else if this.InHdrErrors != nil {
		return false
	} else if that1.InHdrErrors != nil {
		return false
	}
	if this.InAddrErrors != nil && that1.InAddrErrors != nil {
		if *this.InAddrErrors != *that1.InAddrErrors {
			return false
		}
	} else if this.InAddrErrors != nil {
		return false
	} else if that1.InAddrErrors != nil {
		return false
	}
	if this.ForwDatagrams != nil && that1.ForwDatagrams != nil {
		if *this.ForwDatagrams != *that1.ForwDatagrams {
			return false
		}
	} else if this.ForwDatagrams != nil {
		return false
	} else if that1.ForwDatagrams != nil {
		return false
	}
	if this.InUnknownProtos != nil && that1.InUnknownProtos != nil {
		if *this.InUnknownProtos != *that1.InUnknownProtos {
			return false
		}
	} else if this.InUnknownProtos != nil {
		return false
	} else if that1.InUnknownProtos != nil {
		return false
	}
	if this.InDiscards != nil && that1.InDiscards != nil {
		if *this.InDiscards != *that1.InDiscards {
			return false
		}
	} else if this.InDiscards != nil {
		return false
	} else if that1.InDiscards != nil {
		return false
	}
	if this.InDelivers != nil && that1.InDelivers != nil {
		if *this.InDelivers != *that1.InDelivers {
			return false
		}
	} else if this.InDelivers != nil {
		return false
	} else if that1.InDelivers != nil {
		return false
	}
	if this.OutRequests != nil && that1.OutRequests != nil {
		if *this.OutRequests != *that1.OutRequests {
			return false
		}
	} else if this.OutRequests != nil {
		return false
	} else if that1.OutRequests != nil {
		return false
	}
	if this.OutDiscards != nil && that1.OutDiscards != nil {
		if *this.OutDiscards != *that1.OutDiscards {
			return false
		}
	} else if this.OutDiscards != nil {
		return false
	} else if that1.OutDiscards != nil {
		return false
	}
	if this.OutNoRoutes != nil && that1.OutNoRoutes != nil {
		if *this.OutNoRoutes != *that1.OutNoRoutes {
			return false
		}
	} else if this.OutNoRoutes != nil {
		return false
	} else if that1.OutNoRoutes != nil {
		return false
	}
	if this.ReasmTimeout != nil && that1.ReasmTimeout != nil {
		if *this.ReasmTimeout != *that1.ReasmTimeout {
			return false
		}
	} else if this.ReasmTimeout != nil {
		return false
	} else if that1.ReasmTimeout != nil {
		return false
	}
	if this.ReasmReqds != nil && that1.ReasmReqds != nil {
		if *this.ReasmReqds != *that1.ReasmReqds {
			return false
		}
	} else if this.ReasmReqds != nil {
		return false
	} else if that1.ReasmReqds != nil {
		return false
	}
	if this.ReasmOKs != nil && that1.ReasmOKs != nil {
		if *this.ReasmOKs != *that1.ReasmOKs {
			return false
		}
	} else if this.ReasmOKs != nil {
		return false
	} else if that1.ReasmOKs != nil {
		return false
	}
	if this.ReasmFails != nil && that1.ReasmFails != nil {
		if *this.ReasmFails != *that1.ReasmFails {
			return false
		}
	} else if this.ReasmFails != nil {
		return false
	} else if that1.ReasmFails != nil {
		return false
	}
	if this.FragOKs != nil && that1.FragOKs != nil {
		if *this.FragOKs != *that1.FragOKs {
			return false
		}
	} else if this.FragOKs != nil {
		return false
	} else if that1.FragOKs != nil {
		return false
	}
	if this.FragFails != nil && that1.FragFails != nil {
		if *this.FragFails != *that1.FragFails {
			return false
		}
	} else if this.FragFails != nil {
		return false
	} else if that1.FragFails != nil {
		return false
	}
	if this.FragCreates != nil && that1.FragCreates != nil {
		if *this.FragCreates != *that1.FragCreates {
			return false
		}
	} else if this.FragCreates != nil {
		return false
	} else if that1.FragCreates != nil {
		return false
	}
	return true
}
func (this *IcmpStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IcmpStatistics)
	if !ok {
		that2, ok := that.(IcmpStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IcmpStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IcmpStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IcmpStatistics but is not nil && this == nil")
	}
	if this.InMsgs != nil && that1.InMsgs != nil {
		if *this.InMsgs != *that1.InMsgs {
			return fmt.Errorf("InMsgs this(%v) Not Equal that(%v)", *this.InMsgs, *that1.InMsgs)
		}
	} else if this.InMsgs != nil {
		return fmt.Errorf("this.InMsgs == nil && that.InMsgs != nil")
	} else if that1.InMsgs != nil {
		return fmt.Errorf("InMsgs this(%v) Not Equal that(%v)", this.InMsgs, that1.InMsgs)
	}
	if this.InErrors != nil && that1.InErrors != nil {
		if *this.InErrors != *that1.InErrors {
			return fmt.Errorf("InErrors this(%v) Not Equal that(%v)", *this.InErrors, *that1.InErrors)
		}
	} else if this.InErrors != nil {
		return fmt.Errorf("this.InErrors == nil && that.InErrors != nil")
	} else if that1.InErrors != nil {
		return fmt.Errorf("InErrors this(%v) Not Equal that(%v)", this.InErrors, that1.InErrors)
	}
	if this.InCsumErrors != nil && that1.InCsumErrors != nil {
		if *this.InCsumErrors != *that1.InCsumErrors {
			return fmt.Errorf("InCsumErrors this(%v) Not Equal that(%v)", *this.InCsumErrors, *that1.InCsumErrors)
		}
	} else if this.InCsumErrors != nil {
		return fmt.Errorf("this.InCsumErrors == nil && that.InCsumErrors != nil")
	} else if that1.InCsumErrors != nil {
		return fmt.Errorf("InCsumErrors this(%v) Not Equal that(%v)", this.InCsumErrors, that1.InCsumErrors)
	}
	if this.InDestUnreachs != nil && that1.InDestUnreachs != nil {
		if *this.InDestUnreachs != *that1.InDestUnreachs {
			return fmt.Errorf("InDestUnreachs this(%v) Not Equal that(%v)", *this.InDestUnreachs, *that1.InDestUnreachs)
		}
	} else if this.InDestUnreachs != nil {
		return fmt.Errorf("this.InDestUnreachs == nil && that.InDestUnreachs != nil")
	} else if that1.InDestUnreachs != nil {
		return fmt.Errorf("InDestUnreachs this(%v) Not Equal that(%v)", this.InDestUnreachs, that1.InDestUnreachs)
	}
	if this.InTimeExcds != nil && that1.InTimeExcds != nil {
		if *this.InTimeExcds != *that1.InTimeExcds {
			return fmt.Errorf("InTimeExcds this(%v) Not Equal that(%v)", *this.InTimeExcds, *that1.InTimeExcds)
		}
	} else if this.InTimeExcds != nil {
		return fmt.Errorf("this.InTimeExcds == nil && that.InTimeExcds != nil")
	} else if that1.InTimeExcds != nil {
		return fmt.Errorf("InTimeExcds this(%v) Not Equal that(%v)", this.InTimeExcds, that1.InTimeExcds)
	}
	if this.InParmProbs != nil && that1.InParmProbs != nil {
		if *this.InParmProbs != *that1.InParmProbs {
			return fmt.Errorf("InParmProbs this(%v) Not Equal that(%v)", *this.InParmProbs, *that1.InParmProbs)
		}
	} else if this.InParmProbs != nil {
		return fmt.Errorf("this.InParmProbs == nil && that.InParmProbs != nil")
	} else if that1.InParmProbs != nil {
		return fmt.Errorf("InParmProbs this(%v) Not Equal that(%v)", this.InParmProbs, that1.InParmProbs)
	}
	if this.InSrcQuenchs != nil && that1.InSrcQuenchs != nil {
		if *this.InSrcQuenchs != *that1.InSrcQuenchs {
			return fmt.Errorf("InSrcQuenchs this(%v) Not Equal that(%v)", *this.InSrcQuenchs, *that1.InSrcQuenchs)
		}
	} else if this.InSrcQuenchs != nil {
		return fmt.Errorf("this.InSrcQuenchs == nil && that.InSrcQuenchs != nil")
	} else if that1.InSrcQuenchs != nil {
		return fmt.Errorf("InSrcQuenchs this(%v) Not Equal that(%v)", this.InSrcQuenchs, that1.InSrcQuenchs)
	}
	if this.InRedirects != nil && that1.InRedirects != nil {
		if *this.InRedirects != *that1.InRedirects {
			return fmt.Errorf("InRedirects this(%v) Not Equal that(%v)", *this.InRedirects, *that1.InRedirects)
		}
	} else if this.InRedirects != nil {
		return fmt.Errorf("this.InRedirects == nil && that.InRedirects != nil")
	} else if that1.InRedirects != nil {
		return fmt.Errorf("InRedirects this(%v) Not Equal that(%v)", this.InRedirects, that1.InRedirects)
	}
	if this.InEchos != nil && that1.InEchos != nil {
		if *this.InEchos != *that1.InEchos {
			return fmt.Errorf("InEchos this(%v) Not Equal that(%v)", *this.InEchos, *that1.InEchos)
		}
	} else if this.InEchos != nil {
		return fmt.Errorf("this.InEchos == nil && that.InEchos != nil")
	} else if that1.InEchos != nil {
		return fmt.Errorf("InEchos this(%v) Not Equal that(%v)", this.InEchos, that1.InEchos)
	}
	if this.InEchoReps != nil && that1.InEchoReps != nil {
		if *this.InEchoReps != *that1.InEchoReps {
			return fmt.Errorf("InEchoReps this(%v) Not Equal that(%v)", *this.InEchoReps, *that1.InEchoReps)
		}
	} else if this.InEchoReps != nil {
		return fmt.Errorf("this.InEchoReps == nil && that.InEchoReps != nil")
	} else if that1.InEchoReps != nil {
		return fmt.Errorf("InEchoReps this(%v) Not Equal that(%v)", this.InEchoReps, that1.InEchoReps)
	}
	if this.InTimestamps != nil && that1.InTimestamps != nil {
		if *this.InTimestamps != *that1.InTimestamps {
			return fmt.Errorf("InTimestamps this(%v) Not Equal that(%v)", *this.InTimestamps, *that1.InTimestamps)
		}
	} else if this.InTimestamps != nil {
		return fmt.Errorf("this.InTimestamps == nil && that.InTimestamps != nil")
	} else if that1.InTimestamps != nil {
		return fmt.Errorf("InTimestamps this(%v) Not Equal that(%v)", this.InTimestamps, that1.InTimestamps)
	}
	if this.InTimestampReps != nil && that1.InTimestampReps != nil {
		if *this.InTimestampReps != *that1.InTimestampReps {
			return fmt.Errorf("InTimestampReps this(%v) Not Equal that(%v)", *this.InTimestampReps, *that1.InTimestampReps)
		}
	} else if this.InTimestampReps != nil {
		return fmt.Errorf("this.InTimestampReps == nil && that.InTimestampReps != nil")
	} else if that1.InTimestampReps != nil {
		return fmt.Errorf("InTimestampReps this(%v) Not Equal that(%v)", this.InTimestampReps, that1.InTimestampReps)
	}
	if this.InAddrMasks != nil && that1.InAddrMasks != nil {
		if *this.InAddrMasks != *that1.InAddrMasks {
			return fmt.Errorf("InAddrMasks this(%v) Not Equal that(%v)", *this.InAddrMasks, *that1.InAddrMasks)
		}
	} else if this.InAddrMasks != nil {
		return fmt.Errorf("this.InAddrMasks == nil && that.InAddrMasks != nil")
	} else if that1.InAddrMasks != nil {
		return fmt.Errorf("InAddrMasks this(%v) Not Equal that(%v)", this.InAddrMasks, that1.InAddrMasks)
	}
	if this.InAddrMaskReps != nil && that1.InAddrMaskReps != nil {
		if *this.InAddrMaskReps != *that1.InAddrMaskReps {
			return fmt.Errorf("InAddrMaskReps this(%v) Not Equal that(%v)", *this.InAddrMaskReps, *that1.InAddrMaskReps)
		}
	} else if this.InAddrMaskReps != nil {
		return fmt.Errorf("this.InAddrMaskReps == nil && that.InAddrMaskReps != nil")
	} else if that1.InAddrMaskReps != nil {
		return fmt.Errorf("InAddrMaskReps this(%v) Not Equal that(%v)", this.InAddrMaskReps, that1.InAddrMaskReps)
	}
	if this.OutMsgs != nil && that1.OutMsgs != nil {
		if *this.OutMsgs != *that1.OutMsgs {
			return fmt.Errorf("OutMsgs this(%v) Not Equal that(%v)", *this.OutMsgs, *that1.OutMsgs)
		}
	} else if this.OutMsgs != nil {
		return fmt.Errorf("this.OutMsgs == nil && that.OutMsgs != nil")
	} else if that1.OutMsgs != nil {
		return fmt.Errorf("OutMsgs this(%v) Not Equal that(%v)", this.OutMsgs, that1.OutMsgs)
	}
	if this.OutErrors != nil && that1.OutErrors != nil {
		if *this.OutErrors != *that1.OutErrors {
			return fmt.Errorf("OutErrors this(%v) Not Equal that(%v)", *this.OutErrors, *that1.OutErrors)
		}
	} else if this.OutErrors != nil {
		return fmt.Errorf("this.OutErrors == nil && that.OutErrors != nil")
	} else if that1.OutErrors != nil {
		return fmt.Errorf("OutErrors this(%v) Not Equal that(%v)", this.OutErrors, that1.OutErrors)
	}
	if this.OutDestUnreachs != nil && that1.OutDestUnreachs != nil {
		if *this.OutDestUnreachs != *that1.OutDestUnreachs {
			return fmt.Errorf("OutDestUnreachs this(%v) Not Equal that(%v)", *this.OutDestUnreachs, *that1.OutDestUnreachs)
		}
	} else if this.OutDestUnreachs != nil {
		return fmt.Errorf("this.OutDestUnreachs == nil && that.OutDestUnreachs != nil")
	} else if that1.OutDestUnreachs != nil {
		return fmt.Errorf("OutDestUnreachs this(%v) Not Equal that(%v)", this.OutDestUnreachs, that1.OutDestUnreachs)
	}
	if this.OutTimeExcds != nil && that1.OutTimeExcds != nil {
		if *this.OutTimeExcds != *that1.OutTimeExcds {
			return fmt.Errorf("OutTimeExcds this(%v) Not Equal that(%v)", *this.OutTimeExcds, *that1.OutTimeExcds)
		}
	} else if this.OutTimeExcds != nil {
		return fmt.Errorf("this.OutTimeExcds == nil && that.OutTimeExcds != nil")
	} else if that1.OutTimeExcds != nil {
		return fmt.Errorf("OutTimeExcds this(%v) Not Equal that(%v)", this.OutTimeExcds, that1.OutTimeExcds)
	}
	if this.OutParmProbs != nil && that1.OutParmProbs != nil {
		if *this.OutParmProbs != *that1.OutParmProbs {
			return fmt.Errorf("OutParmProbs this(%v) Not Equal that(%v)", *this.OutParmProbs, *that1.OutParmProbs)
		}
	} else if this.OutParmProbs != nil {
		return fmt.Errorf("this.OutParmProbs == nil && that.OutParmProbs != nil")
	} else if that1.OutParmProbs != nil {
		return fmt.Errorf("OutParmProbs this(%v) Not Equal that(%v)", this.OutParmProbs, that1.OutParmProbs)
	}
	if this.OutSrcQuenchs != nil && that1.OutSrcQuenchs != nil {
		if *this.OutSrcQuenchs != *that1.OutSrcQuenchs {
			return fmt.Errorf("OutSrcQuenchs this(%v) Not Equal that(%v)", *this.OutSrcQuenchs, *that1.OutSrcQuenchs)
		}
	} else if this.OutSrcQuenchs != nil {
		return fmt.Errorf("this.OutSrcQuenchs == nil && that.OutSrcQuenchs != nil")
	} else if that1.OutSrcQuenchs != nil {
		return fmt.Errorf("OutSrcQuenchs this(%v) Not Equal that(%v)", this.OutSrcQuenchs, that1.OutSrcQuenchs)
	}
	if this.OutRedirects != nil && that1.OutRedirects != nil {
		if *this.OutRedirects != *that1.OutRedirects {
			return fmt.Errorf("OutRedirects this(%v) Not Equal that(%v)", *this.OutRedirects, *that1.OutRedirects)
		}
	} else if this.OutRedirects != nil {
		return fmt.Errorf("this.OutRedirects == nil && that.OutRedirects != nil")
	} else if that1.OutRedirects != nil {
		return fmt.Errorf("OutRedirects this(%v) Not Equal that(%v)", this.OutRedirects, that1.OutRedirects)
	}
	if this.OutEchos != nil && that1.OutEchos != nil {
		if *this.OutEchos != *that1.OutEchos {
			return fmt.Errorf("OutEchos this(%v) Not Equal that(%v)", *this.OutEchos, *that1.OutEchos)
		}
	} else if this.OutEchos != nil {
		return fmt.Errorf("this.OutEchos == nil && that.OutEchos != nil")
	} else if that1.OutEchos != nil {
		return fmt.Errorf("OutEchos this(%v) Not Equal that(%v)", this.OutEchos, that1.OutEchos)
	}
	if this.OutEchoReps != nil && that1.OutEchoReps != nil {
		if *this.OutEchoReps != *that1.OutEchoReps {
			return fmt.Errorf("OutEchoReps this(%v) Not Equal that(%v)", *this.OutEchoReps, *that1.OutEchoReps)
		}
	} else if this.OutEchoReps != nil {
		return fmt.Errorf("this.OutEchoReps == nil && that.OutEchoReps != nil")
	} else if that1.OutEchoReps != nil {
		return fmt.Errorf("OutEchoReps this(%v) Not Equal that(%v)", this.OutEchoReps, that1.OutEchoReps)
	}
	if this.OutTimestamps != nil && that1.OutTimestamps != nil {
		if *this.OutTimestamps != *that1.OutTimestamps {
			return fmt.Errorf("OutTimestamps this(%v) Not Equal that(%v)", *this.OutTimestamps, *that1.OutTimestamps)
		}
	} else if this.OutTimestamps != nil {
		return fmt.Errorf("this.OutTimestamps == nil && that.OutTimestamps != nil")
	} else if that1.OutTimestamps != nil {
		return fmt.Errorf("OutTimestamps this(%v) Not Equal that(%v)", this.OutTimestamps, that1.OutTimestamps)
	}
	if this.OutTimestampReps != nil && that1.OutTimestampReps != nil {
		if *this.OutTimestampReps != *that1.OutTimestampReps {
			return fmt.Errorf("OutTimestampReps this(%v) Not Equal that(%v)", *this.OutTimestampReps, *that1.OutTimestampReps)
		}
	} else if this.OutTimestampReps != nil {
		return fmt.Errorf("this.OutTimestampReps == nil && that.OutTimestampReps != nil")
	} else if that1.OutTimestampReps != nil {
		return fmt.Errorf("OutTimestampReps this(%v) Not Equal that(%v)", this.OutTimestampReps, that1.OutTimestampReps)
	}
	if this.OutAddrMasks != nil && that1.OutAddrMasks != nil {
		if *this.OutAddrMasks != *that1.OutAddrMasks {
			return fmt.Errorf("OutAddrMasks this(%v) Not Equal that(%v)", *this.OutAddrMasks, *that1.OutAddrMasks)
		}
	} else if this.OutAddrMasks != nil {
		return fmt.Errorf("this.OutAddrMasks == nil && that.OutAddrMasks != nil")
	} else if that1.OutAddrMasks != nil {
		return fmt.Errorf("OutAddrMasks this(%v) Not Equal that(%v)", this.OutAddrMasks, that1.OutAddrMasks)
	}
	if this.OutAddrMaskReps != nil && that1.OutAddrMaskReps != nil {
		if *this.OutAddrMaskReps != *that1.OutAddrMaskReps {
			return fmt.Errorf("OutAddrMaskReps this(%v) Not Equal that(%v)", *this.OutAddrMaskReps, *that1.OutAddrMaskReps)
		}
	} else if this.OutAddrMaskReps != nil {
		return fmt.Errorf("this.OutAddrMaskReps == nil && that.OutAddrMaskReps != nil")
	} else if that1.OutAddrMaskReps != nil {
		return fmt.Errorf("OutAddrMaskReps this(%v) Not Equal that(%v)", this.OutAddrMaskReps, that1.OutAddrMaskReps)
	}
	return nil
}
func (this *IcmpStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*IcmpStatistics)
	if !ok {
		that2, ok := that.(IcmpStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.InMsgs != nil && that1.InMsgs != nil {
		if *this.InMsgs != *that1.InMsgs {
			return false
		}
	} else if this.InMsgs != nil {
		return false
	} else if that1.InMsgs != nil {
		return false
	}
	if this.InErrors != nil && that1.InErrors != nil {
		if *this.InErrors != *that1.InErrors {
			return false
		}
	} else if this.InErrors != nil {
		return false
	} else if that1.InErrors != nil {
		return false
	}
	if this.InCsumErrors != nil && that1.InCsumErrors != nil {
		if *this.InCsumErrors != *that1.InCsumErrors {
			return false
		}
	} else if this.InCsumErrors != nil {
		return false
	} else if that1.InCsumErrors != nil {
		return false
	}
	if this.InDestUnreachs != nil && that1.InDestUnreachs != nil {
		if *this.InDestUnreachs != *that1.InDestUnreachs {
			return false
		}
	} else if this.InDestUnreachs != nil {
		return false
	} else if that1.InDestUnreachs != nil {
		return false
	}
	if this.InTimeExcds != nil && that1.InTimeExcds != nil {
		if *this.InTimeExcds != *that1.InTimeExcds {
			return false
		}
	} else if this.InTimeExcds != nil {
		return false
	} else if that1.InTimeExcds != nil {
		return false
	}
	if this.InParmProbs != nil && that1.InParmProbs != nil {
		if *this.InParmProbs != *that1.InParmProbs {
			return false
		}
	} else if this.InParmProbs != nil {
		return false
	} else if that1.InParmProbs != nil {
		return false
	}
	if this.InSrcQuenchs != nil && that1.InSrcQuenchs != nil {
		if *this.InSrcQuenchs != *that1.InSrcQuenchs {
			return false
		}
	} else if this.InSrcQuenchs != nil {
		return false
	} else if that1.InSrcQuenchs != nil {
		return false
	}
	if this.InRedirects != nil && that1.InRedirects != nil {
		if *this.InRedirects != *that1.InRedirects {
			return false
		}
	} else if this.InRedirects != nil {
		return false
	} else if that1.InRedirects != nil {
		return false
	}
	if this.InEchos != nil && that1.InEchos != nil {
		if *this.InEchos != *that1.InEchos {
			return false
		}
	} else if this.InEchos != nil {
		return false
	} else if that1.InEchos != nil {
		return false
	}
	if this.InEchoReps != nil && that1.InEchoReps != nil {
		if *this.InEchoReps != *that1.InEchoReps {
			return false
		}
	} else if this.InEchoReps != nil {
		return false
	} else if that1.InEchoReps != nil {
		return false
	}
	if this.InTimestamps != nil && that1.InTimestamps != nil {
		if *this.InTimestamps != *that1.InTimestamps {
			return false
		}
	} else if this.InTimestamps != nil {
		return false
	} else if that1.InTimestamps != nil {
		return false
	}
	if this.InTimestampReps != nil && that1.InTimestampReps != nil {
		if *this.InTimestampReps != *that1.InTimestampReps {
			return false
		}
	} else if this.InTimestampReps != nil {
		return false
	} else if that1.InTimestampReps != nil {
		return false
	}
	if this.InAddrMasks != nil && that1.InAddrMasks != nil {
		if *this.InAddrMasks != *that1.InAddrMasks {
			return false
		}
	} else if this.InAddrMasks != nil {
		return false
	} else if that1.InAddrMasks != nil {
		return false
	}
	if this.InAddrMaskReps != nil && that1.InAddrMaskReps != nil {
		if *this.InAddrMaskReps != *that1.InAddrMaskReps {
			return false
		}
	} else if this.InAddrMaskReps != nil {
		return false
	} else if that1.InAddrMaskReps != nil {
		return false
	}
	if this.OutMsgs != nil && that1.OutMsgs != nil {
		if *this.OutMsgs != *that1.OutMsgs {
			return false
		}
	} else if this.OutMsgs != nil {
		return false
	} else if that1.OutMsgs != nil {
		return false
	}
	if this.OutErrors != nil && that1.OutErrors != nil {
		if *this.OutErrors != *that1.OutErrors {
			return false
		}
	} else if this.OutErrors != nil {
		return false
	} else if that1.OutErrors != nil {
		return false
	}
	if this.OutDestUnreachs != nil && that1.OutDestUnreachs != nil {
		if *this.OutDestUnreachs != *that1.OutDestUnreachs {
			return false
		}
	} else if this.OutDestUnreachs != nil {
		return false
	} else if that1.OutDestUnreachs != nil {
		return false
	}
	if this.OutTimeExcds != nil && that1.OutTimeExcds != nil {
		if *this.OutTimeExcds != *that1.OutTimeExcds {
			return false
		}
	} else if this.OutTimeExcds != nil {
		return false
	} else if that1.OutTimeExcds != nil {
		return false
	}
	if this.OutParmProbs != nil && that1.OutParmProbs != nil {
		if *this.OutParmProbs != *that1.OutParmProbs {
			return false
		}
	} else if this.OutParmProbs != nil {
		return false
	} else if that1.OutParmProbs != nil {
		return false
	}
	if this.OutSrcQuenchs != nil && that1.OutSrcQuenchs != nil {
		if *this.OutSrcQuenchs != *that1.OutSrcQuenchs {
			return false
		}
	} else if this.OutSrcQuenchs != nil {
		return false
	} else if that1.OutSrcQuenchs != nil {
		return false
	}
	if this.OutRedirects != nil && that1.OutRedirects != nil {
		if *this.OutRedirects != *that1.OutRedirects {
			return false
		}
	} else if this.OutRedirects != nil {
		return false
	} else if that1.OutRedirects != nil {
		return false
	}
	if this.OutEchos != nil && that1.OutEchos != nil {
		if *this.OutEchos != *that1.OutEchos {
			return false
		}
	} else if this.OutEchos != nil {
		return false
	} else if that1.OutEchos != nil {
		return false
	}
	if this.OutEchoReps != nil && that1.OutEchoReps != nil {
		if *this.OutEchoReps != *that1.OutEchoReps {
			return false
		}
	} else if this.OutEchoReps != nil {
		return false
	} else if that1.OutEchoReps != nil {
		return false
	}
	if this.OutTimestamps != nil && that1.OutTimestamps != nil {
		if *this.OutTimestamps != *that1.OutTimestamps {
			return false
		}
	} else if this.OutTimestamps != nil {
		return false
	} else if that1.OutTimestamps != nil {
		return false
	}
	if this.OutTimestampReps != nil && that1.OutTimestampReps != nil {
		if *this.OutTimestampReps != *that1.OutTimestampReps {
			return false
		}
	} else if this.OutTimestampReps != nil {
		return false
	} else if that1.OutTimestampReps != nil {
		return false
	}
	if this.OutAddrMasks != nil && that1.OutAddrMasks != nil {
		if *this.OutAddrMasks != *that1.OutAddrMasks {
			return false
		}
	} else if this.OutAddrMasks != nil {
		return false
	} else if that1.OutAddrMasks != nil {
		return false
	}
	if this.OutAddrMaskReps != nil && that1.OutAddrMaskReps != nil {
		if *this.OutAddrMaskReps != *that1.OutAddrMaskReps {
			return false
		}
	} else if this.OutAddrMaskReps != nil {
		return false
	} else if that1.OutAddrMaskReps != nil {
		return false
	}
	return true
}
func (this *TcpStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TcpStatistics)
	if !ok {
		that2, ok := that.(TcpStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TcpStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TcpStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TcpStatistics but is not nil && this == nil")
	}
	if this.RtoAlgorithm != nil && that1.RtoAlgorithm != nil {
		if *this.RtoAlgorithm != *that1.RtoAlgorithm {
			return fmt.Errorf("RtoAlgorithm this(%v) Not Equal that(%v)", *this.RtoAlgorithm, *that1.RtoAlgorithm)
		}
	} else if this.RtoAlgorithm != nil {
		return fmt.Errorf("this.RtoAlgorithm == nil && that.RtoAlgorithm != nil")
	} else if that1.RtoAlgorithm != nil {
		return fmt.Errorf("RtoAlgorithm this(%v) Not Equal that(%v)", this.RtoAlgorithm, that1.RtoAlgorithm)
	}
	if this.RtoMin != nil && that1.RtoMin != nil {
		if *this.RtoMin != *that1.RtoMin {
			return fmt.Errorf("RtoMin this(%v) Not Equal that(%v)", *this.RtoMin, *that1.RtoMin)
		}
	} else if this.RtoMin != nil {
		return fmt.Errorf("this.RtoMin == nil && that.RtoMin != nil")
	} else if that1.RtoMin != nil {
		return fmt.Errorf("RtoMin this(%v) Not Equal that(%v)", this.RtoMin, that1.RtoMin)
	}
	if this.RtoMax != nil && that1.RtoMax != nil {
		if *this.RtoMax != *that1.RtoMax {
			return fmt.Errorf("RtoMax this(%v) Not Equal that(%v)", *this.RtoMax, *that1.RtoMax)
		}
	} else if this.RtoMax != nil {
		return fmt.Errorf("this.RtoMax == nil && that.RtoMax != nil")
	} else if that1.RtoMax != nil {
		return fmt.Errorf("RtoMax this(%v) Not Equal that(%v)", this.RtoMax, that1.RtoMax)
	}
	if this.MaxConn != nil && that1.MaxConn != nil {
		if *this.MaxConn != *that1.MaxConn {
			return fmt.Errorf("MaxConn this(%v) Not Equal that(%v)", *this.MaxConn, *that1.MaxConn)
		}
	} else if this.MaxConn != nil {
		return fmt.Errorf("this.MaxConn == nil && that.MaxConn != nil")
	} else if that1.MaxConn != nil {
		return fmt.Errorf("MaxConn this(%v) Not Equal that(%v)", this.MaxConn, that1.MaxConn)
	}
	if this.ActiveOpens != nil && that1.ActiveOpens != nil {
		if *this.ActiveOpens != *that1.ActiveOpens {
			return fmt.Errorf("ActiveOpens this(%v) Not Equal that(%v)", *this.ActiveOpens, *that1.ActiveOpens)
		}
	} else if this.ActiveOpens != nil {
		return fmt.Errorf("this.ActiveOpens == nil && that.ActiveOpens != nil")
	} else if that1.ActiveOpens != nil {
		return fmt.Errorf("ActiveOpens this(%v) Not Equal that(%v)", this.ActiveOpens, that1.ActiveOpens)
	}
	if this.PassiveOpens != nil && that1.PassiveOpens != nil {
		if *this.PassiveOpens != *that1.PassiveOpens {
			return fmt.Errorf("PassiveOpens this(%v) Not Equal that(%v)", *this.PassiveOpens, *that1.PassiveOpens)
		}
	} else if this.PassiveOpens != nil {
		return fmt.Errorf("this.PassiveOpens == nil && that.PassiveOpens != nil")
	} else if that1.PassiveOpens != nil {
		return fmt.Errorf("PassiveOpens this(%v) Not Equal that(%v)", this.PassiveOpens, that1.PassiveOpens)
	}
	if this.AttemptFails != nil && that1.AttemptFails != nil {
		if *this.AttemptFails != *that1.AttemptFails {
			return fmt.Errorf("AttemptFails this(%v) Not Equal that(%v)", *this.AttemptFails, *that1.AttemptFails)
		}
	} else if this.AttemptFails != nil {
		return fmt.Errorf("this.AttemptFails == nil && that.AttemptFails != nil")
	} else if that1.AttemptFails != nil {
		return fmt.Errorf("AttemptFails this(%v) Not Equal that(%v)", this.AttemptFails, that1.AttemptFails)
	}
	if this.EstabResets != nil && that1.EstabResets != nil {
		if *this.EstabResets != *that1.EstabResets {
			return fmt.Errorf("EstabResets this(%v) Not Equal that(%v)", *this.EstabResets, *that1.EstabResets)
		}
	} else if this.EstabResets != nil {
		return fmt.Errorf("this.EstabResets == nil && that.EstabResets != nil")
	} else if that1.EstabResets != nil {
		return fmt.Errorf("EstabResets this(%v) Not Equal that(%v)", this.EstabResets, that1.EstabResets)
	}
	if this.CurrEstab != nil && that1.CurrEstab != nil {
		if *this.CurrEstab != *that1.CurrEstab {
			return fmt.Errorf("CurrEstab this(%v) Not Equal that(%v)", *this.CurrEstab, *that1.CurrEstab)
		}
	} else if this.CurrEstab != nil {
		return fmt.Errorf("this.CurrEstab == nil && that.CurrEstab != nil")
	} else if that1.CurrEstab != nil {
		return fmt.Errorf("CurrEstab this(%v) Not Equal that(%v)", this.CurrEstab, that1.CurrEstab)
	}
	if this.InSegs != nil && that1.InSegs != nil {
		if *this.InSegs != *that1.InSegs {
			return fmt.Errorf("InSegs this(%v) Not Equal that(%v)", *this.InSegs, *that1.InSegs)
		}
	} else if this.InSegs != nil {
		return fmt.Errorf("this.InSegs == nil && that.InSegs != nil")
	} else if that1.InSegs != nil {
		return fmt.Errorf("InSegs this(%v) Not Equal that(%v)", this.InSegs, that1.InSegs)
	}
	if this.OutSegs != nil && that1.OutSegs != nil {
		if *this.OutSegs != *that1.OutSegs {
			return fmt.Errorf("OutSegs this(%v) Not Equal that(%v)", *this.OutSegs, *that1.OutSegs)
		}
	} else if this.OutSegs != nil {
		return fmt.Errorf("this.OutSegs == nil && that.OutSegs != nil")
	} else if that1.OutSegs != nil {
		return fmt.Errorf("OutSegs this(%v) Not Equal that(%v)", this.OutSegs, that1.OutSegs)
	}
	if this.RetransSegs != nil && that1.RetransSegs != nil {
		if *this.RetransSegs != *that1.RetransSegs {
			return fmt.Errorf("RetransSegs this(%v) Not Equal that(%v)", *this.RetransSegs, *that1.RetransSegs)
		}
	} else if this.RetransSegs != nil {
		return fmt.Errorf("this.RetransSegs == nil && that.RetransSegs != nil")
	} else if that1.RetransSegs != nil {
		return fmt.Errorf("RetransSegs this(%v) Not Equal that(%v)", this.RetransSegs, that1.RetransSegs)
	}
	if this.InErrs != nil && that1.InErrs != nil {
		if *this.InErrs != *that1.InErrs {
			return fmt.Errorf("InErrs this(%v) Not Equal that(%v)", *this.InErrs, *that1.InErrs)
		}
	} else if this.InErrs != nil {
		return fmt.Errorf("this.InErrs == nil && that.InErrs != nil")
	} else if that1.InErrs != nil {
		return fmt.Errorf("InErrs this(%v) Not Equal that(%v)", this.InErrs, that1.InErrs)
	}
	if this.OutRsts != nil && that1.OutRsts != nil {
		if *this.OutRsts != *that1.OutRsts {
			return fmt.Errorf("OutRsts this(%v) Not Equal that(%v)", *this.OutRsts, *that1.OutRsts)
		}
	} else if this.OutRsts != nil {
		return fmt.Errorf("this.OutRsts == nil && that.OutRsts != nil")
	} else if that1.OutRsts != nil {
		return fmt.Errorf("OutRsts this(%v) Not Equal that(%v)", this.OutRsts, that1.OutRsts)
	}
	if this.InCsumErrors != nil && that1.InCsumErrors != nil {
		if *this.InCsumErrors != *that1.InCsumErrors {
			return fmt.Errorf("InCsumErrors this(%v) Not Equal that(%v)", *this.InCsumErrors, *that1.InCsumErrors)
		}
	} else if this.InCsumErrors != nil {
		return fmt.Errorf("this.InCsumErrors == nil && that.InCsumErrors != nil")
	} else if that1.InCsumErrors != nil {
		return fmt.Errorf("InCsumErrors this(%v) Not Equal that(%v)", this.InCsumErrors, that1.InCsumErrors)
	}
	return nil
}
func (this *TcpStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TcpStatistics)
	if !ok {
		that2, ok := that.(TcpStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.RtoAlgorithm != nil && that1.RtoAlgorithm != nil {
		if *this.RtoAlgorithm != *that1.RtoAlgorithm {
			return false
		}
	} else if this.RtoAlgorithm != nil {
		return false
	} else if that1.RtoAlgorithm != nil {
		return false
	}
	if this.RtoMin != nil && that1.RtoMin != nil {
		if *this.RtoMin != *that1.RtoMin {
			return false
		}
	} else if this.RtoMin != nil {
		return false
	} else if that1.RtoMin != nil {
		return false
	}
	if this.RtoMax != nil && that1.RtoMax != nil {
		if *this.RtoMax != *that1.RtoMax {
			return false
		}
	} else if this.RtoMax != nil {
		return false
	} else if that1.RtoMax != nil {
		return false
	}
	if this.MaxConn != nil && that1.MaxConn != nil {
		if *this.MaxConn != *that1.MaxConn {
			return false
		}
	} else if this.MaxConn != nil {
		return false
	} else if that1.MaxConn != nil {
		return false
	}
	if this.ActiveOpens != nil && that1.ActiveOpens != nil {
		if *this.ActiveOpens != *that1.ActiveOpens {
			return false
		}
	} else if this.ActiveOpens != nil {
		return false
	} else if that1.ActiveOpens != nil {
		return false
	}
	if this.PassiveOpens != nil && that1.PassiveOpens != nil {
		if *this.PassiveOpens != *that1.PassiveOpens {
			return false
		}
	} else if this.PassiveOpens != nil {
		return false
	} else if that1.PassiveOpens != nil {
		return false
	}
	if this.AttemptFails != nil && that1.AttemptFails != nil {
		if *this.AttemptFails != *that1.AttemptFails {
			return false
		}
	} else if this.AttemptFails != nil {
		return false
	} else if that1.AttemptFails != nil {
		return false
	}
	if this.EstabResets != nil && that1.EstabResets != nil {
		if *this.EstabResets != *that1.EstabResets {
			return false
		}
	} else if this.EstabResets != nil {
		return false
	} else if that1.EstabResets != nil {
		return false
	}
	if this.CurrEstab != nil && that1.CurrEstab != nil {
		if *this.CurrEstab != *that1.CurrEstab {
			return false
		}
	} else if this.CurrEstab != nil {
		return false
	} else if that1.CurrEstab != nil {
		return false
	}
	if this.InSegs != nil && that1.InSegs != nil {
		if *this.InSegs != *that1.InSegs {
			return false
		}
	} else if this.InSegs != nil {
		return false
	} else if that1.InSegs != nil {
		return false
	}
	if this.OutSegs != nil && that1.OutSegs != nil {
		if *this.OutSegs != *that1.OutSegs {
			return false
		}
	} else if this.OutSegs != nil {
		return false
	} else if that1.OutSegs != nil {
		return false
	}
	if this.RetransSegs != nil && that1.RetransSegs != nil {
		if *this.RetransSegs != *that1.RetransSegs {
			return false
		}
	} else if this.RetransSegs != nil {
		return false
	} else if that1.RetransSegs != nil {
		return false
	}
	if this.InErrs != nil && that1.InErrs != nil {
		if *this.InErrs != *that1.InErrs {
			return false
		}
	} else if this.InErrs != nil {
		return false
	} else if that1.InErrs != nil {
		return false
	}
	if this.OutRsts != nil && that1.OutRsts != nil {
		if *this.OutRsts != *that1.OutRsts {
			return false
		}
	} else if this.OutRsts != nil {
		return false
	} else if that1.OutRsts != nil {
		return false
	}
	if this.InCsumErrors != nil && that1.InCsumErrors != nil {
		if *this.InCsumErrors != *that1.InCsumErrors {
			return false
		}
	} else if this.InCsumErrors != nil {
		return false
	} else if that1.InCsumErrors != nil {
		return false
	}
	return true
}
func (this *UdpStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UdpStatistics)
	if !ok {
		that2, ok := that.(UdpStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UdpStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UdpStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UdpStatistics but is not nil && this == nil")
	}
	if this.InDatagrams != nil && that1.InDatagrams != nil {
		if *this.InDatagrams != *that1.InDatagrams {
			return fmt.Errorf("InDatagrams this(%v) Not Equal that(%v)", *this.InDatagrams, *that1.InDatagrams)
		}
	} else if this.InDatagrams != nil {
		return fmt.Errorf("this.InDatagrams == nil && that.InDatagrams != nil")
	} else if that1.InDatagrams != nil {
		return fmt.Errorf("InDatagrams this(%v) Not Equal that(%v)", this.InDatagrams, that1.InDatagrams)
	}
	if this.NoPorts != nil && that1.NoPorts != nil {
		if *this.NoPorts != *that1.NoPorts {
			return fmt.Errorf("NoPorts this(%v) Not Equal that(%v)", *this.NoPorts, *that1.NoPorts)
		}
	} else if this.NoPorts != nil {
		return fmt.Errorf("this.NoPorts == nil && that.NoPorts != nil")
	} else if that1.NoPorts != nil {
		return fmt.Errorf("NoPorts this(%v) Not Equal that(%v)", this.NoPorts, that1.NoPorts)
	}
	if this.InErrors != nil && that1.InErrors != nil {
		if *this.InErrors != *that1.InErrors {
			return fmt.Errorf("InErrors this(%v) Not Equal that(%v)", *this.InErrors, *that1.InErrors)
		}
	} else if this.InErrors != nil {
		return fmt.Errorf("this.InErrors == nil && that.InErrors != nil")
	} else if that1.InErrors != nil {
		return fmt.Errorf("InErrors this(%v) Not Equal that(%v)", this.InErrors, that1.InErrors)
	}
	if this.OutDatagrams != nil && that1.OutDatagrams != nil {
		if *this.OutDatagrams != *that1.OutDatagrams {
			return fmt.Errorf("OutDatagrams this(%v) Not Equal that(%v)", *this.OutDatagrams, *that1.OutDatagrams)
		}
	} else if this.OutDatagrams != nil {
		return fmt.Errorf("this.OutDatagrams == nil && that.OutDatagrams != nil")
	} else if that1.OutDatagrams != nil {
		return fmt.Errorf("OutDatagrams this(%v) Not Equal that(%v)", this.OutDatagrams, that1.OutDatagrams)
	}
	if this.RcvbufErrors != nil && that1.RcvbufErrors != nil {
		if *this.RcvbufErrors != *that1.RcvbufErrors {
			return fmt.Errorf("RcvbufErrors this(%v) Not Equal that(%v)", *this.RcvbufErrors, *that1.RcvbufErrors)
		}
	} else if this.RcvbufErrors != nil {
		return fmt.Errorf("this.RcvbufErrors == nil && that.RcvbufErrors != nil")
	} else if that1.RcvbufErrors != nil {
		return fmt.Errorf("RcvbufErrors this(%v) Not Equal that(%v)", this.RcvbufErrors, that1.RcvbufErrors)
	}
	if this.SndbufErrors != nil && that1.SndbufErrors != nil {
		if *this.SndbufErrors != *that1.SndbufErrors {
			return fmt.Errorf("SndbufErrors this(%v) Not Equal that(%v)", *this.SndbufErrors, *that1.SndbufErrors)
		}
	} else if this.SndbufErrors != nil {
		return fmt.Errorf("this.SndbufErrors == nil && that.SndbufErrors != nil")
	} else if that1.SndbufErrors != nil {
		return fmt.Errorf("SndbufErrors this(%v) Not Equal that(%v)", this.SndbufErrors, that1.SndbufErrors)
	}
	if this.InCsumErrors != nil && that1.InCsumErrors != nil {
		if *this.InCsumErrors != *that1.InCsumErrors {
			return fmt.Errorf("InCsumErrors this(%v) Not Equal that(%v)", *this.InCsumErrors, *that1.InCsumErrors)
		}
	} else if this.InCsumErrors != nil {
		return fmt.Errorf("this.InCsumErrors == nil && that.InCsumErrors != nil")
	} else if that1.InCsumErrors != nil {
		return fmt.Errorf("InCsumErrors this(%v) Not Equal that(%v)", this.InCsumErrors, that1.InCsumErrors)
	}
	if this.IgnoredMulti != nil && that1.IgnoredMulti != nil {
		if *this.IgnoredMulti != *that1.IgnoredMulti {
			return fmt.Errorf("IgnoredMulti this(%v) Not Equal that(%v)", *this.IgnoredMulti, *that1.IgnoredMulti)
		}
	} else if this.IgnoredMulti != nil {
		return fmt.Errorf("this.IgnoredMulti == nil && that.IgnoredMulti != nil")
	} else if that1.IgnoredMulti != nil {
		return fmt.Errorf("IgnoredMulti this(%v) Not Equal that(%v)", this.IgnoredMulti, that1.IgnoredMulti)
	}
	return nil
}
func (this *UdpStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UdpStatistics)
	if !ok {
		that2, ok := that.(UdpStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.InDatagrams != nil && that1.InDatagrams != nil {
		if *this.InDatagrams != *that1.InDatagrams {
			return false
		}
	} else if this.InDatagrams != nil {
		return false
	} else if that1.InDatagrams != nil {
		return false
	}
	if this.NoPorts != nil && that1.NoPorts != nil {
		if *this.NoPorts != *that1.NoPorts {
			return false
		}
	} else if this.NoPorts != nil {
		return false
	} else if that1.NoPorts != nil {
		return false
	}
	if this.InErrors != nil && that1.InErrors != nil {
		if *this.InErrors != *that1.InErrors {
			return false
		}
	} else if this.InErrors != nil {
		return false
	} else if that1.InErrors != nil {
		return false
	}
	if this.OutDatagrams != nil && that1.OutDatagrams != nil {
		if *this.OutDatagrams != *that1.OutDatagrams {
			return false
		}
	} else if this.OutDatagrams != nil {
		return false
	} else if that1.OutDatagrams != nil {
		return false
	}
	if this.RcvbufErrors != nil && that1.RcvbufErrors != nil {
		if *this.RcvbufErrors != *that1.RcvbufErrors {
			return false
		}
	} else if this.RcvbufErrors != nil {
		return false
	} else if that1.RcvbufErrors != nil {
		return false
	}
	if this.SndbufErrors != nil && that1.SndbufErrors != nil {
		if *this.SndbufErrors != *that1.SndbufErrors {
			return false
		}
	} else if this.SndbufErrors != nil {
		return false
	} else if that1.SndbufErrors != nil {
		return false
	}
	if this.InCsumErrors != nil && that1.InCsumErrors != nil {
		if *this.InCsumErrors != *that1.InCsumErrors {
			return false
		}
	} else if this.InCsumErrors != nil {
		return false
	} else if that1.InCsumErrors != nil {
		return false
	}
	if this.IgnoredMulti != nil && that1.IgnoredMulti != nil {
		if *this.IgnoredMulti != *that1.IgnoredMulti {
			return false
		}
	} else if this.IgnoredMulti != nil {
		return false
	} else if that1.IgnoredMulti != nil {
		return false
	}
	return true
}
func (this *SNMPStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SNMPStatistics)
	if !ok {
		that2, ok := that.(SNMPStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SNMPStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SNMPStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SNMPStatistics but is not nil && this == nil")
	}
	if !this.IPStats.Equal(that1.IPStats) {
		return fmt.Errorf("IPStats this(%v) Not Equal that(%v)", this.IPStats, that1.IPStats)
	}
	if !this.ICMPStats.Equal(that1.ICMPStats) {
		return fmt.Errorf("ICMPStats this(%v) Not Equal that(%v)", this.ICMPStats, that1.ICMPStats)
	}
	if !this.TCPStats.Equal(that1.TCPStats) {
		return fmt.Errorf("TCPStats this(%v) Not Equal that(%v)", this.TCPStats, that1.TCPStats)
	}
	if !this.UDPStats.Equal(that1.UDPStats) {
		return fmt.Errorf("UDPStats this(%v) Not Equal that(%v)", this.UDPStats, that1.UDPStats)
	}
	return nil
}
func (this *SNMPStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SNMPStatistics)
	if !ok {
		that2, ok := that.(SNMPStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.IPStats.Equal(that1.IPStats) {
		return false
	}
	if !this.ICMPStats.Equal(that1.ICMPStats) {
		return false
	}
	if !this.TCPStats.Equal(that1.TCPStats) {
		return false
	}
	if !this.UDPStats.Equal(that1.UDPStats) {
		return false
	}
	return true
}
func (this *DiskStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DiskStatistics)
	if !ok {
		that2, ok := that.(DiskStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DiskStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DiskStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DiskStatistics but is not nil && this == nil")
	}
	if !this.Source.Equal(that1.Source) {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	if !this.Persistence.Equal(that1.Persistence) {
		return fmt.Errorf("Persistence this(%v) Not Equal that(%v)", this.Persistence, that1.Persistence)
	}
	if this.LimitBytes != nil && that1.LimitBytes != nil {
		if *this.LimitBytes != *that1.LimitBytes {
			return fmt.Errorf("LimitBytes this(%v) Not Equal that(%v)", *this.LimitBytes, *that1.LimitBytes)
		}
	} else if this.LimitBytes != nil {
		return fmt.Errorf("this.LimitBytes == nil && that.LimitBytes != nil")
	} else if that1.LimitBytes != nil {
		return fmt.Errorf("LimitBytes this(%v) Not Equal that(%v)", this.LimitBytes, that1.LimitBytes)
	}
	if this.UsedBytes != nil && that1.UsedBytes != nil {
		if *this.UsedBytes != *that1.UsedBytes {
			return fmt.Errorf("UsedBytes this(%v) Not Equal that(%v)", *this.UsedBytes, *that1.UsedBytes)
		}
	} else if this.UsedBytes != nil {
		return fmt.Errorf("this.UsedBytes == nil && that.UsedBytes != nil")
	} else if that1.UsedBytes != nil {
		return fmt.Errorf("UsedBytes this(%v) Not Equal that(%v)", this.UsedBytes, that1.UsedBytes)
	}
	return nil
}
func (this *DiskStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DiskStatistics)
	if !ok {
		that2, ok := that.(DiskStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Source.Equal(that1.Source) {
		return false
	}
	if !this.Persistence.Equal(that1.Persistence) {
		return false
	}
	if this.LimitBytes != nil && that1.LimitBytes != nil {
		if *this.LimitBytes != *that1.LimitBytes {
			return false
		}
	} else if this.LimitBytes != nil {
		return false
	} else if that1.LimitBytes != nil {
		return false
	}
	if this.UsedBytes != nil && that1.UsedBytes != nil {
		if *this.UsedBytes != *that1.UsedBytes {
			return false
		}
	} else if this.UsedBytes != nil {
		return false
	} else if that1.UsedBytes != nil {
		return false
	}
	return true
}
func (this *ResourceStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResourceStatistics)
	if !ok {
		that2, ok := that.(ResourceStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResourceStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResourceStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResourceStatistics but is not nil && this == nil")
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if this.Processes != nil && that1.Processes != nil {
		if *this.Processes != *that1.Processes {
			return fmt.Errorf("Processes this(%v) Not Equal that(%v)", *this.Processes, *that1.Processes)
		}
	} else if this.Processes != nil {
		return fmt.Errorf("this.Processes == nil && that.Processes != nil")
	} else if that1.Processes != nil {
		return fmt.Errorf("Processes this(%v) Not Equal that(%v)", this.Processes, that1.Processes)
	}
	if this.Threads != nil && that1.Threads != nil {
		if *this.Threads != *that1.Threads {
			return fmt.Errorf("Threads this(%v) Not Equal that(%v)", *this.Threads, *that1.Threads)
		}
	} else if this.Threads != nil {
		return fmt.Errorf("this.Threads == nil && that.Threads != nil")
	} else if that1.Threads != nil {
		return fmt.Errorf("Threads this(%v) Not Equal that(%v)", this.Threads, that1.Threads)
	}
	if this.CPUsUserTimeSecs != nil && that1.CPUsUserTimeSecs != nil {
		if *this.CPUsUserTimeSecs != *that1.CPUsUserTimeSecs {
			return fmt.Errorf("CPUsUserTimeSecs this(%v) Not Equal that(%v)", *this.CPUsUserTimeSecs, *that1.CPUsUserTimeSecs)
		}
	} else if this.CPUsUserTimeSecs != nil {
		return fmt.Errorf("this.CPUsUserTimeSecs == nil && that.CPUsUserTimeSecs != nil")
	} else if that1.CPUsUserTimeSecs != nil {
		return fmt.Errorf("CPUsUserTimeSecs this(%v) Not Equal that(%v)", this.CPUsUserTimeSecs, that1.CPUsUserTimeSecs)
	}
	if this.CPUsSystemTimeSecs != nil && that1.CPUsSystemTimeSecs != nil {
		if *this.CPUsSystemTimeSecs != *that1.CPUsSystemTimeSecs {
			return fmt.Errorf("CPUsSystemTimeSecs this(%v) Not Equal that(%v)", *this.CPUsSystemTimeSecs, *that1.CPUsSystemTimeSecs)
		}
	} else if this.CPUsSystemTimeSecs != nil {
		return fmt.Errorf("this.CPUsSystemTimeSecs == nil && that.CPUsSystemTimeSecs != nil")
	} else if that1.CPUsSystemTimeSecs != nil {
		return fmt.Errorf("CPUsSystemTimeSecs this(%v) Not Equal that(%v)", this.CPUsSystemTimeSecs, that1.CPUsSystemTimeSecs)
	}
	if this.CPUsLimit != nil && that1.CPUsLimit != nil {
		if *this.CPUsLimit != *that1.CPUsLimit {
			return fmt.Errorf("CPUsLimit this(%v) Not Equal that(%v)", *this.CPUsLimit, *that1.CPUsLimit)
		}
	} else if this.CPUsLimit != nil {
		return fmt.Errorf("this.CPUsLimit == nil && that.CPUsLimit != nil")
	} else if that1.CPUsLimit != nil {
		return fmt.Errorf("CPUsLimit this(%v) Not Equal that(%v)", this.CPUsLimit, that1.CPUsLimit)
	}
	if this.CPUsNrPeriods != nil && that1.CPUsNrPeriods != nil {
		if *this.CPUsNrPeriods != *that1.CPUsNrPeriods {
			return fmt.Errorf("CPUsNrPeriods this(%v) Not Equal that(%v)", *this.CPUsNrPeriods, *that1.CPUsNrPeriods)
		}
	} else if this.CPUsNrPeriods != nil {
		return fmt.Errorf("this.CPUsNrPeriods == nil && that.CPUsNrPeriods != nil")
	} else if that1.CPUsNrPeriods != nil {
		return fmt.Errorf("CPUsNrPeriods this(%v) Not Equal that(%v)", this.CPUsNrPeriods, that1.CPUsNrPeriods)
	}
	if this.CPUsNrThrottled != nil && that1.CPUsNrThrottled != nil {
		if *this.CPUsNrThrottled != *that1.CPUsNrThrottled {
			return fmt.Errorf("CPUsNrThrottled this(%v) Not Equal that(%v)", *this.CPUsNrThrottled, *that1.CPUsNrThrottled)
		}
	} else if this.CPUsNrThrottled != nil {
		return fmt.Errorf("this.CPUsNrThrottled == nil && that.CPUsNrThrottled != nil")
	} else if that1.CPUsNrThrottled != nil {
		return fmt.Errorf("CPUsNrThrottled this(%v) Not Equal that(%v)", this.CPUsNrThrottled, that1.CPUsNrThrottled)
	}
	if this.CPUsThrottledTimeSecs != nil && that1.CPUsThrottledTimeSecs != nil {
		if *this.CPUsThrottledTimeSecs != *that1.CPUsThrottledTimeSecs {
			return fmt.Errorf("CPUsThrottledTimeSecs this(%v) Not Equal that(%v)", *this.CPUsThrottledTimeSecs, *that1.CPUsThrottledTimeSecs)
		}
	} else if this.CPUsThrottledTimeSecs != nil {
		return fmt.Errorf("this.CPUsThrottledTimeSecs == nil && that.CPUsThrottledTimeSecs != nil")
	} else if that1.CPUsThrottledTimeSecs != nil {
		return fmt.Errorf("CPUsThrottledTimeSecs this(%v) Not Equal that(%v)", this.CPUsThrottledTimeSecs, that1.CPUsThrottledTimeSecs)
	}
	if this.MemTotalBytes != nil && that1.MemTotalBytes != nil {
		if *this.MemTotalBytes != *that1.MemTotalBytes {
			return fmt.Errorf("MemTotalBytes this(%v) Not Equal that(%v)", *this.MemTotalBytes, *that1.MemTotalBytes)
		}
	} else if this.MemTotalBytes != nil {
		return fmt.Errorf("this.MemTotalBytes == nil && that.MemTotalBytes != nil")
	} else if that1.MemTotalBytes != nil {
		return fmt.Errorf("MemTotalBytes this(%v) Not Equal that(%v)", this.MemTotalBytes, that1.MemTotalBytes)
	}
	if this.MemTotalMemswBytes != nil && that1.MemTotalMemswBytes != nil {
		if *this.MemTotalMemswBytes != *that1.MemTotalMemswBytes {
			return fmt.Errorf("MemTotalMemswBytes this(%v) Not Equal that(%v)", *this.MemTotalMemswBytes, *that1.MemTotalMemswBytes)
		}
	} else if this.MemTotalMemswBytes != nil {
		return fmt.Errorf("this.MemTotalMemswBytes == nil && that.MemTotalMemswBytes != nil")
	} else if that1.MemTotalMemswBytes != nil {
		return fmt.Errorf("MemTotalMemswBytes this(%v) Not Equal that(%v)", this.MemTotalMemswBytes, that1.MemTotalMemswBytes)
	}
	if this.MemLimitBytes != nil && that1.MemLimitBytes != nil {
		if *this.MemLimitBytes != *that1.MemLimitBytes {
			return fmt.Errorf("MemLimitBytes this(%v) Not Equal that(%v)", *this.MemLimitBytes, *that1.MemLimitBytes)
		}
	} else if this.MemLimitBytes != nil {
		return fmt.Errorf("this.MemLimitBytes == nil && that.MemLimitBytes != nil")
	} else if that1.MemLimitBytes != nil {
		return fmt.Errorf("MemLimitBytes this(%v) Not Equal that(%v)", this.MemLimitBytes, that1.MemLimitBytes)
	}
	if this.MemSoftLimitBytes != nil && that1.MemSoftLimitBytes != nil {
		if *this.MemSoftLimitBytes != *that1.MemSoftLimitBytes {
			return fmt.Errorf("MemSoftLimitBytes this(%v) Not Equal that(%v)", *this.MemSoftLimitBytes, *that1.MemSoftLimitBytes)
		}
	} else if this.MemSoftLimitBytes != nil {
		return fmt.Errorf("this.MemSoftLimitBytes == nil && that.MemSoftLimitBytes != nil")
	} else if that1.MemSoftLimitBytes != nil {
		return fmt.Errorf("MemSoftLimitBytes this(%v) Not Equal that(%v)", this.MemSoftLimitBytes, that1.MemSoftLimitBytes)
	}
	if this.MemFileBytes != nil && that1.MemFileBytes != nil {
		if *this.MemFileBytes != *that1.MemFileBytes {
			return fmt.Errorf("MemFileBytes this(%v) Not Equal that(%v)", *this.MemFileBytes, *that1.MemFileBytes)
		}
	} else if this.MemFileBytes != nil {
		return fmt.Errorf("this.MemFileBytes == nil && that.MemFileBytes != nil")
	} else if that1.MemFileBytes != nil {
		return fmt.Errorf("MemFileBytes this(%v) Not Equal that(%v)", this.MemFileBytes, that1.MemFileBytes)
	}
	if this.MemAnonBytes != nil && that1.MemAnonBytes != nil {
		if *this.MemAnonBytes != *that1.MemAnonBytes {
			return fmt.Errorf("MemAnonBytes this(%v) Not Equal that(%v)", *this.MemAnonBytes, *that1.MemAnonBytes)
		}
	} else if this.MemAnonBytes != nil {
		return fmt.Errorf("this.MemAnonBytes == nil && that.MemAnonBytes != nil")
	} else if that1.MemAnonBytes != nil {
		return fmt.Errorf("MemAnonBytes this(%v) Not Equal that(%v)", this.MemAnonBytes, that1.MemAnonBytes)
	}
	if this.MemCacheBytes != nil && that1.MemCacheBytes != nil {
		if *this.MemCacheBytes != *that1.MemCacheBytes {
			return fmt.Errorf("MemCacheBytes this(%v) Not Equal that(%v)", *this.MemCacheBytes, *that1.MemCacheBytes)
		}
	} else if this.MemCacheBytes != nil {
		return fmt.Errorf("this.MemCacheBytes == nil && that.MemCacheBytes != nil")
	} else if that1.MemCacheBytes != nil {
		return fmt.Errorf("MemCacheBytes this(%v) Not Equal that(%v)", this.MemCacheBytes, that1.MemCacheBytes)
	}
	if this.MemRSSBytes != nil && that1.MemRSSBytes != nil {
		if *this.MemRSSBytes != *that1.MemRSSBytes {
			return fmt.Errorf("MemRSSBytes this(%v) Not Equal that(%v)", *this.MemRSSBytes, *that1.MemRSSBytes)
		}
	} else if this.MemRSSBytes != nil {
		return fmt.Errorf("this.MemRSSBytes == nil && that.MemRSSBytes != nil")
	} else if that1.MemRSSBytes != nil {
		return fmt.Errorf("MemRSSBytes this(%v) Not Equal that(%v)", this.MemRSSBytes, that1.MemRSSBytes)
	}
	if this.MemMappedFileBytes != nil && that1.MemMappedFileBytes != nil {
		if *this.MemMappedFileBytes != *that1.MemMappedFileBytes {
			return fmt.Errorf("MemMappedFileBytes this(%v) Not Equal that(%v)", *this.MemMappedFileBytes, *that1.MemMappedFileBytes)
		}
	} else if this.MemMappedFileBytes != nil {
		return fmt.Errorf("this.MemMappedFileBytes == nil && that.MemMappedFileBytes != nil")
	} else if that1.MemMappedFileBytes != nil {
		return fmt.Errorf("MemMappedFileBytes this(%v) Not Equal that(%v)", this.MemMappedFileBytes, that1.MemMappedFileBytes)
	}
	if this.MemSwapBytes != nil && that1.MemSwapBytes != nil {
		if *this.MemSwapBytes != *that1.MemSwapBytes {
			return fmt.Errorf("MemSwapBytes this(%v) Not Equal that(%v)", *this.MemSwapBytes, *that1.MemSwapBytes)
		}
	} else if this.MemSwapBytes != nil {
		return fmt.Errorf("this.MemSwapBytes == nil && that.MemSwapBytes != nil")
	} else if that1.MemSwapBytes != nil {
		return fmt.Errorf("MemSwapBytes this(%v) Not Equal that(%v)", this.MemSwapBytes, that1.MemSwapBytes)
	}
	if this.MemUnevictableBytes != nil && that1.MemUnevictableBytes != nil {
		if *this.MemUnevictableBytes != *that1.MemUnevictableBytes {
			return fmt.Errorf("MemUnevictableBytes this(%v) Not Equal that(%v)", *this.MemUnevictableBytes, *that1.MemUnevictableBytes)
		}
	} else if this.MemUnevictableBytes != nil {
		return fmt.Errorf("this.MemUnevictableBytes == nil && that.MemUnevictableBytes != nil")
	} else if that1.MemUnevictableBytes != nil {
		return fmt.Errorf("MemUnevictableBytes this(%v) Not Equal that(%v)", this.MemUnevictableBytes, that1.MemUnevictableBytes)
	}
	if this.MemLowPressureCounter != nil && that1.MemLowPressureCounter != nil {
		if *this.MemLowPressureCounter != *that1.MemLowPressureCounter {
			return fmt.Errorf("MemLowPressureCounter this(%v) Not Equal that(%v)", *this.MemLowPressureCounter, *that1.MemLowPressureCounter)
		}
	} else if this.MemLowPressureCounter != nil {
		return fmt.Errorf("this.MemLowPressureCounter == nil && that.MemLowPressureCounter != nil")
	} else if that1.MemLowPressureCounter != nil {
		return fmt.Errorf("MemLowPressureCounter this(%v) Not Equal that(%v)", this.MemLowPressureCounter, that1.MemLowPressureCounter)
	}
	if this.MemMediumPressureCounter != nil && that1.MemMediumPressureCounter != nil {
		if *this.MemMediumPressureCounter != *that1.MemMediumPressureCounter {
			return fmt.Errorf("MemMediumPressureCounter this(%v) Not Equal that(%v)", *this.MemMediumPressureCounter, *that1.MemMediumPressureCounter)
		}
	} else if this.MemMediumPressureCounter != nil {
		return fmt.Errorf("this.MemMediumPressureCounter == nil && that.MemMediumPressureCounter != nil")
	} else if that1.MemMediumPressureCounter != nil {
		return fmt.Errorf("MemMediumPressureCounter this(%v) Not Equal that(%v)", this.MemMediumPressureCounter, that1.MemMediumPressureCounter)
	}
	if this.MemCriticalPressureCounter != nil && that1.MemCriticalPressureCounter != nil {
		if *this.MemCriticalPressureCounter != *that1.MemCriticalPressureCounter {
			return fmt.Errorf("MemCriticalPressureCounter this(%v) Not Equal that(%v)", *this.MemCriticalPressureCounter, *that1.MemCriticalPressureCounter)
		}
	} else if this.MemCriticalPressureCounter != nil {
		return fmt.Errorf("this.MemCriticalPressureCounter == nil && that.MemCriticalPressureCounter != nil")
	} else if that1.MemCriticalPressureCounter != nil {
		return fmt.Errorf("MemCriticalPressureCounter this(%v) Not Equal that(%v)", this.MemCriticalPressureCounter, that1.MemCriticalPressureCounter)
	}
	if this.DiskLimitBytes != nil && that1.DiskLimitBytes != nil {
		if *this.DiskLimitBytes != *that1.DiskLimitBytes {
			return fmt.Errorf("DiskLimitBytes this(%v) Not Equal that(%v)", *this.DiskLimitBytes, *that1.DiskLimitBytes)
		}
	} else if this.DiskLimitBytes != nil {
		return fmt.Errorf("this.DiskLimitBytes == nil && that.DiskLimitBytes != nil")
	} else if that1.DiskLimitBytes != nil {
		return fmt.Errorf("DiskLimitBytes this(%v) Not Equal that(%v)", this.DiskLimitBytes, that1.DiskLimitBytes)
	}
	if this.DiskUsedBytes != nil && that1.DiskUsedBytes != nil {
		if *this.DiskUsedBytes != *that1.DiskUsedBytes {
			return fmt.Errorf("DiskUsedBytes this(%v) Not Equal that(%v)", *this.DiskUsedBytes, *that1.DiskUsedBytes)
		}
	} else if this.DiskUsedBytes != nil {
		return fmt.Errorf("this.DiskUsedBytes == nil && that.DiskUsedBytes != nil")
	} else if that1.DiskUsedBytes != nil {
		return fmt.Errorf("DiskUsedBytes this(%v) Not Equal that(%v)", this.DiskUsedBytes, that1.DiskUsedBytes)
	}
	if len(this.DiskStatistics) != len(that1.DiskStatistics) {
		return fmt.Errorf("DiskStatistics this(%v) Not Equal that(%v)", len(this.DiskStatistics), len(that1.DiskStatistics))
	}
	for i := range this.DiskStatistics {
		if !this.DiskStatistics[i].Equal(&that1.DiskStatistics[i]) {
			return fmt.Errorf("DiskStatistics this[%v](%v) Not Equal that[%v](%v)", i, this.DiskStatistics[i], i, that1.DiskStatistics[i])
		}
	}
	if !this.BlkioStatistics.Equal(that1.BlkioStatistics) {
		return fmt.Errorf("BlkioStatistics this(%v) Not Equal that(%v)", this.BlkioStatistics, that1.BlkioStatistics)
	}
	if !this.Perf.Equal(that1.Perf) {
		return fmt.Errorf("Perf this(%v) Not Equal that(%v)", this.Perf, that1.Perf)
	}
	if this.NetRxPackets != nil && that1.NetRxPackets != nil {
		if *this.NetRxPackets != *that1.NetRxPackets {
			return fmt.Errorf("NetRxPackets this(%v) Not Equal that(%v)", *this.NetRxPackets, *that1.NetRxPackets)
		}
	} else if this.NetRxPackets != nil {
		return fmt.Errorf("this.NetRxPackets == nil && that.NetRxPackets != nil")
	} else if that1.NetRxPackets != nil {
		return fmt.Errorf("NetRxPackets this(%v) Not Equal that(%v)", this.NetRxPackets, that1.NetRxPackets)
	}
	if this.NetRxBytes != nil && that1.NetRxBytes != nil {
		if *this.NetRxBytes != *that1.NetRxBytes {
			return fmt.Errorf("NetRxBytes this(%v) Not Equal that(%v)", *this.NetRxBytes, *that1.NetRxBytes)
		}
	} else if this.NetRxBytes != nil {
		return fmt.Errorf("this.NetRxBytes == nil && that.NetRxBytes != nil")
	} else if that1.NetRxBytes != nil {
		return fmt.Errorf("NetRxBytes this(%v) Not Equal that(%v)", this.NetRxBytes, that1.NetRxBytes)
	}
	if this.NetRxErrors != nil && that1.NetRxErrors != nil {
		if *this.NetRxErrors != *that1.NetRxErrors {
			return fmt.Errorf("NetRxErrors this(%v) Not Equal that(%v)", *this.NetRxErrors, *that1.NetRxErrors)
		}
	} else if this.NetRxErrors != nil {
		return fmt.Errorf("this.NetRxErrors == nil && that.NetRxErrors != nil")
	} else if that1.NetRxErrors != nil {
		return fmt.Errorf("NetRxErrors this(%v) Not Equal that(%v)", this.NetRxErrors, that1.NetRxErrors)
	}
	if this.NetRxDropped != nil && that1.NetRxDropped != nil {
		if *this.NetRxDropped != *that1.NetRxDropped {
			return fmt.Errorf("NetRxDropped this(%v) Not Equal that(%v)", *this.NetRxDropped, *that1.NetRxDropped)
		}
	} else if this.NetRxDropped != nil {
		return fmt.Errorf("this.NetRxDropped == nil && that.NetRxDropped != nil")
	} else if that1.NetRxDropped != nil {
		return fmt.Errorf("NetRxDropped this(%v) Not Equal that(%v)", this.NetRxDropped, that1.NetRxDropped)
	}
	if this.NetTxPackets != nil && that1.NetTxPackets != nil {
		if *this.NetTxPackets != *that1.NetTxPackets {
			return fmt.Errorf("NetTxPackets this(%v) Not Equal that(%v)", *this.NetTxPackets, *that1.NetTxPackets)
		}
	} else if this.NetTxPackets != nil {
		return fmt.Errorf("this.NetTxPackets == nil && that.NetTxPackets != nil")
	} else if that1.NetTxPackets != nil {
		return fmt.Errorf("NetTxPackets this(%v) Not Equal that(%v)", this.NetTxPackets, that1.NetTxPackets)
	}
	if this.NetTxBytes != nil && that1.NetTxBytes != nil {
		if *this.NetTxBytes != *that1.NetTxBytes {
			return fmt.Errorf("NetTxBytes this(%v) Not Equal that(%v)", *this.NetTxBytes, *that1.NetTxBytes)
		}
	} else if this.NetTxBytes != nil {
		return fmt.Errorf("this.NetTxBytes == nil && that.NetTxBytes != nil")
	} else if that1.NetTxBytes != nil {
		return fmt.Errorf("NetTxBytes this(%v) Not Equal that(%v)", this.NetTxBytes, that1.NetTxBytes)
	}
	if this.NetTxErrors != nil && that1.NetTxErrors != nil {
		if *this.NetTxErrors != *that1.NetTxErrors {
			return fmt.Errorf("NetTxErrors this(%v) Not Equal that(%v)", *this.NetTxErrors, *that1.NetTxErrors)
		}
	} else if this.NetTxErrors != nil {
		return fmt.Errorf("this.NetTxErrors == nil && that.NetTxErrors != nil")
	} else if that1.NetTxErrors != nil {
		return fmt.Errorf("NetTxErrors this(%v) Not Equal that(%v)", this.NetTxErrors, that1.NetTxErrors)
	}
	if this.NetTxDropped != nil && that1.NetTxDropped != nil {
		if *this.NetTxDropped != *that1.NetTxDropped {
			return fmt.Errorf("NetTxDropped this(%v) Not Equal that(%v)", *this.NetTxDropped, *that1.NetTxDropped)
		}
	} else if this.NetTxDropped != nil {
		return fmt.Errorf("this.NetTxDropped == nil && that.NetTxDropped != nil")
	} else if that1.NetTxDropped != nil {
		return fmt.Errorf("NetTxDropped this(%v) Not Equal that(%v)", this.NetTxDropped, that1.NetTxDropped)
	}
	if this.NetTCPRttMicrosecsP50 != nil && that1.NetTCPRttMicrosecsP50 != nil {
		if *this.NetTCPRttMicrosecsP50 != *that1.NetTCPRttMicrosecsP50 {
			return fmt.Errorf("NetTCPRttMicrosecsP50 this(%v) Not Equal that(%v)", *this.NetTCPRttMicrosecsP50, *that1.NetTCPRttMicrosecsP50)
		}
	} else if this.NetTCPRttMicrosecsP50 != nil {
		return fmt.Errorf("this.NetTCPRttMicrosecsP50 == nil && that.NetTCPRttMicrosecsP50 != nil")
	} else if that1.NetTCPRttMicrosecsP50 != nil {
		return fmt.Errorf("NetTCPRttMicrosecsP50 this(%v) Not Equal that(%v)", this.NetTCPRttMicrosecsP50, that1.NetTCPRttMicrosecsP50)
	}
	if this.NetTCPRttMicrosecsP90 != nil && that1.NetTCPRttMicrosecsP90 != nil {
		if *this.NetTCPRttMicrosecsP90 != *that1.NetTCPRttMicrosecsP90 {
			return fmt.Errorf("NetTCPRttMicrosecsP90 this(%v) Not Equal that(%v)", *this.NetTCPRttMicrosecsP90, *that1.NetTCPRttMicrosecsP90)
		}
	} else if this.NetTCPRttMicrosecsP90 != nil {
		return fmt.Errorf("this.NetTCPRttMicrosecsP90 == nil && that.NetTCPRttMicrosecsP90 != nil")
	} else if that1.NetTCPRttMicrosecsP90 != nil {
		return fmt.Errorf("NetTCPRttMicrosecsP90 this(%v) Not Equal that(%v)", this.NetTCPRttMicrosecsP90, that1.NetTCPRttMicrosecsP90)
	}
	if this.NetTCPRttMicrosecsP95 != nil && that1.NetTCPRttMicrosecsP95 != nil {
		if *this.NetTCPRttMicrosecsP95 != *that1.NetTCPRttMicrosecsP95 {
			return fmt.Errorf("NetTCPRttMicrosecsP95 this(%v) Not Equal that(%v)", *this.NetTCPRttMicrosecsP95, *that1.NetTCPRttMicrosecsP95)
		}
	} else if this.NetTCPRttMicrosecsP95 != nil {
		return fmt.Errorf("this.NetTCPRttMicrosecsP95 == nil && that.NetTCPRttMicrosecsP95 != nil")
	} else if that1.NetTCPRttMicrosecsP95 != nil {
		return fmt.Errorf("NetTCPRttMicrosecsP95 this(%v) Not Equal that(%v)", this.NetTCPRttMicrosecsP95, that1.NetTCPRttMicrosecsP95)
	}
	if this.NetTCPRttMicrosecsP99 != nil && that1.NetTCPRttMicrosecsP99 != nil {
		if *this.NetTCPRttMicrosecsP99 != *that1.NetTCPRttMicrosecsP99 {
			return fmt.Errorf("NetTCPRttMicrosecsP99 this(%v) Not Equal that(%v)", *this.NetTCPRttMicrosecsP99, *that1.NetTCPRttMicrosecsP99)
		}
	} else if this.NetTCPRttMicrosecsP99 != nil {
		return fmt.Errorf("this.NetTCPRttMicrosecsP99 == nil && that.NetTCPRttMicrosecsP99 != nil")
	} else if that1.NetTCPRttMicrosecsP99 != nil {
		return fmt.Errorf("NetTCPRttMicrosecsP99 this(%v) Not Equal that(%v)", this.NetTCPRttMicrosecsP99, that1.NetTCPRttMicrosecsP99)
	}
	if this.NetTCPActiveConnections != nil && that1.NetTCPActiveConnections != nil {
		if *this.NetTCPActiveConnections != *that1.NetTCPActiveConnections {
			return fmt.Errorf("NetTCPActiveConnections this(%v) Not Equal that(%v)", *this.NetTCPActiveConnections, *that1.NetTCPActiveConnections)
		}
	} else if this.NetTCPActiveConnections != nil {
		return fmt.Errorf("this.NetTCPActiveConnections == nil && that.NetTCPActiveConnections != nil")
	} else if that1.NetTCPActiveConnections != nil {
		return fmt.Errorf("NetTCPActiveConnections this(%v) Not Equal that(%v)", this.NetTCPActiveConnections, that1.NetTCPActiveConnections)
	}
	if this.NetTCPTimeWaitConnections != nil && that1.NetTCPTimeWaitConnections != nil {
		if *this.NetTCPTimeWaitConnections != *that1.NetTCPTimeWaitConnections {
			return fmt.Errorf("NetTCPTimeWaitConnections this(%v) Not Equal that(%v)", *this.NetTCPTimeWaitConnections, *that1.NetTCPTimeWaitConnections)
		}
	} else if this.NetTCPTimeWaitConnections != nil {
		return fmt.Errorf("this.NetTCPTimeWaitConnections == nil && that.NetTCPTimeWaitConnections != nil")
	} else if that1.NetTCPTimeWaitConnections != nil {
		return fmt.Errorf("NetTCPTimeWaitConnections this(%v) Not Equal that(%v)", this.NetTCPTimeWaitConnections, that1.NetTCPTimeWaitConnections)
	}
	if len(this.NetTrafficControlStatistics) != len(that1.NetTrafficControlStatistics) {
		return fmt.Errorf("NetTrafficControlStatistics this(%v) Not Equal that(%v)", len(this.NetTrafficControlStatistics), len(that1.NetTrafficControlStatistics))
	}
	for i := range this.NetTrafficControlStatistics {
		if !this.NetTrafficControlStatistics[i].Equal(&that1.NetTrafficControlStatistics[i]) {
			return fmt.Errorf("NetTrafficControlStatistics this[%v](%v) Not Equal that[%v](%v)", i, this.NetTrafficControlStatistics[i], i, that1.NetTrafficControlStatistics[i])
		}
	}
	if !this.NetSNMPStatistics.Equal(that1.NetSNMPStatistics) {
		return fmt.Errorf("NetSNMPStatistics this(%v) Not Equal that(%v)", this.NetSNMPStatistics, that1.NetSNMPStatistics)
	}
	return nil
}
func (this *ResourceStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceStatistics)
	if !ok {
		that2, ok := that.(ResourceStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Processes != nil && that1.Processes != nil {
		if *this.Processes != *that1.Processes {
			return false
		}
	} else if this.Processes != nil {
		return false
	} else if that1.Processes != nil {
		return false
	}
	if this.Threads != nil && that1.Threads != nil {
		if *this.Threads != *that1.Threads {
			return false
		}
	} else if this.Threads != nil {
		return false
	} else if that1.Threads != nil {
		return false
	}
	if this.CPUsUserTimeSecs != nil && that1.CPUsUserTimeSecs != nil {
		if *this.CPUsUserTimeSecs != *that1.CPUsUserTimeSecs {
			return false
		}
	} else if this.CPUsUserTimeSecs != nil {
		return false
	} else if that1.CPUsUserTimeSecs != nil {
		return false
	}
	if this.CPUsSystemTimeSecs != nil && that1.CPUsSystemTimeSecs != nil {
		if *this.CPUsSystemTimeSecs != *that1.CPUsSystemTimeSecs {
			return false
		}
	} else if this.CPUsSystemTimeSecs != nil {
		return false
	} else if that1.CPUsSystemTimeSecs != nil {
		return false
	}
	if this.CPUsLimit != nil && that1.CPUsLimit != nil {
		if *this.CPUsLimit != *that1.CPUsLimit {
			return false
		}
	} else if this.CPUsLimit != nil {
		return false
	} else if that1.CPUsLimit != nil {
		return false
	}
	if this.CPUsNrPeriods != nil && that1.CPUsNrPeriods != nil {
		if *this.CPUsNrPeriods != *that1.CPUsNrPeriods {
			return false
		}
	} else if this.CPUsNrPeriods != nil {
		return false
	} else if that1.CPUsNrPeriods != nil {
		return false
	}
	if this.CPUsNrThrottled != nil && that1.CPUsNrThrottled != nil {
		if *this.CPUsNrThrottled != *that1.CPUsNrThrottled {
			return false
		}
	} else if this.CPUsNrThrottled != nil {
		return false
	} else if that1.CPUsNrThrottled != nil {
		return false
	}
	if this.CPUsThrottledTimeSecs != nil && that1.CPUsThrottledTimeSecs != nil {
		if *this.CPUsThrottledTimeSecs != *that1.CPUsThrottledTimeSecs {
			return false
		}
	} else if this.CPUsThrottledTimeSecs != nil {
		return false
	} else if that1.CPUsThrottledTimeSecs != nil {
		return false
	}
	if this.MemTotalBytes != nil && that1.MemTotalBytes != nil {
		if *this.MemTotalBytes != *that1.MemTotalBytes {
			return false
		}
	} else if this.MemTotalBytes != nil {
		return false
	} else if that1.MemTotalBytes != nil {
		return false
	}
	if this.MemTotalMemswBytes != nil && that1.MemTotalMemswBytes != nil {
		if *this.MemTotalMemswBytes != *that1.MemTotalMemswBytes {
			return false
		}
	} else if this.MemTotalMemswBytes != nil {
		return false
	} else if that1.MemTotalMemswBytes != nil {
		return false
	}
	if this.MemLimitBytes != nil && that1.MemLimitBytes != nil {
		if *this.MemLimitBytes != *that1.MemLimitBytes {
			return false
		}
	} else if this.MemLimitBytes != nil {
		return false
	} else if that1.MemLimitBytes != nil {
		return false
	}
	if this.MemSoftLimitBytes != nil && that1.MemSoftLimitBytes != nil {
		if *this.MemSoftLimitBytes != *that1.MemSoftLimitBytes {
			return false
		}
	} else if this.MemSoftLimitBytes != nil {
		return false
	} else if that1.MemSoftLimitBytes != nil {
		return false
	}
	if this.MemFileBytes != nil && that1.MemFileBytes != nil {
		if *this.MemFileBytes != *that1.MemFileBytes {
			return false
		}
	} else if this.MemFileBytes != nil {
		return false
	} else if that1.MemFileBytes != nil {
		return false
	}
	if this.MemAnonBytes != nil && that1.MemAnonBytes != nil {
		if *this.MemAnonBytes != *that1.MemAnonBytes {
			return false
		}
	} else if this.MemAnonBytes != nil {
		return false
	} else if that1.MemAnonBytes != nil {
		return false
	}
	if this.MemCacheBytes != nil && that1.MemCacheBytes != nil {
		if *this.MemCacheBytes != *that1.MemCacheBytes {
			return false
		}
	} else if this.MemCacheBytes != nil {
		return false
	} else if that1.MemCacheBytes != nil {
		return false
	}
	if this.MemRSSBytes != nil && that1.MemRSSBytes != nil {
		if *this.MemRSSBytes != *that1.MemRSSBytes {
			return false
		}
	} else if this.MemRSSBytes != nil {
		return false
	} else if that1.MemRSSBytes != nil {
		return false
	}
	if this.MemMappedFileBytes != nil && that1.MemMappedFileBytes != nil {
		if *this.MemMappedFileBytes != *that1.MemMappedFileBytes {
			return false
		}
	} else if this.MemMappedFileBytes != nil {
		return false
	} else if that1.MemMappedFileBytes != nil {
		return false
	}
	if this.MemSwapBytes != nil && that1.MemSwapBytes != nil {
		if *this.MemSwapBytes != *that1.MemSwapBytes {
			return false
		}
	} else if this.MemSwapBytes != nil {
		return false
	} else if that1.MemSwapBytes != nil {
		return false
	}
	if this.MemUnevictableBytes != nil && that1.MemUnevictableBytes != nil {
		if *this.MemUnevictableBytes != *that1.MemUnevictableBytes {
			return false
		}
	} else if this.MemUnevictableBytes != nil {
		return false
	} else if that1.MemUnevictableBytes != nil {
		return false
	}
	if this.MemLowPressureCounter != nil && that1.MemLowPressureCounter != nil {
		if *this.MemLowPressureCounter != *that1.MemLowPressureCounter {
			return false
		}
	} else if this.MemLowPressureCounter != nil {
		return false
	} else if that1.MemLowPressureCounter != nil {
		return false
	}
	if this.MemMediumPressureCounter != nil && that1.MemMediumPressureCounter != nil {
		if *this.MemMediumPressureCounter != *that1.MemMediumPressureCounter {
			return false
		}
	} else if this.MemMediumPressureCounter != nil {
		return false
	} else if that1.MemMediumPressureCounter != nil {
		return false
	}
	if this.MemCriticalPressureCounter != nil && that1.MemCriticalPressureCounter != nil {
		if *this.MemCriticalPressureCounter != *that1.MemCriticalPressureCounter {
			return false
		}
	} else if this.MemCriticalPressureCounter != nil {
		return false
	} else if that1.MemCriticalPressureCounter != nil {
		return false
	}
	if this.DiskLimitBytes != nil && that1.DiskLimitBytes != nil {
		if *this.DiskLimitBytes != *that1.DiskLimitBytes {
			return false
		}
	} else if this.DiskLimitBytes != nil {
		return false
	} else if that1.DiskLimitBytes != nil {
		return false
	}
	if this.DiskUsedBytes != nil && that1.DiskUsedBytes != nil {
		if *this.DiskUsedBytes != *that1.DiskUsedBytes {
			return false
		}
	} else if this.DiskUsedBytes != nil {
		return false
	} else if that1.DiskUsedBytes != nil {
		return false
	}
	if len(this.DiskStatistics) != len(that1.DiskStatistics) {
		return false
	}
	for i := range this.DiskStatistics {
		if !this.DiskStatistics[i].Equal(&that1.DiskStatistics[i]) {
			return false
		}
	}
	if !this.BlkioStatistics.Equal(that1.BlkioStatistics) {
		return false
	}
	if !this.Perf.Equal(that1.Perf) {
		return false
	}
	if this.NetRxPackets != nil && that1.NetRxPackets != nil {
		if *this.NetRxPackets != *that1.NetRxPackets {
			return false
		}
	} else if this.NetRxPackets != nil {
		return false
	} else if that1.NetRxPackets != nil {
		return false
	}
	if this.NetRxBytes != nil && that1.NetRxBytes != nil {
		if *this.NetRxBytes != *that1.NetRxBytes {
			return false
		}
	} else if this.NetRxBytes != nil {
		return false
	} else if that1.NetRxBytes != nil {
		return false
	}
	if this.NetRxErrors != nil && that1.NetRxErrors != nil {
		if *this.NetRxErrors != *that1.NetRxErrors {
			return false
		}
	} else if this.NetRxErrors != nil {
		return false
	} else if that1.NetRxErrors != nil {
		return false
	}
	if this.NetRxDropped != nil && that1.NetRxDropped != nil {
		if *this.NetRxDropped != *that1.NetRxDropped {
			return false
		}
	} else if this.NetRxDropped != nil {
		return false
	} else if that1.NetRxDropped != nil {
		return false
	}
	if this.NetTxPackets != nil && that1.NetTxPackets != nil {
		if *this.NetTxPackets != *that1.NetTxPackets {
			return false
		}
	} else if this.NetTxPackets != nil {
		return false
	} else if that1.NetTxPackets != nil {
		return false
	}
	if this.NetTxBytes != nil && that1.NetTxBytes != nil {
		if *this.NetTxBytes != *that1.NetTxBytes {
			return false
		}
	} else if this.NetTxBytes != nil {
		return false
	} else if that1.NetTxBytes != nil {
		return false
	}
	if this.NetTxErrors != nil && that1.NetTxErrors != nil {
		if *this.NetTxErrors != *that1.NetTxErrors {
			return false
		}
	} else if this.NetTxErrors != nil {
		return false
	} else if that1.NetTxErrors != nil {
		return false
	}
	if this.NetTxDropped != nil && that1.NetTxDropped != nil {
		if *this.NetTxDropped != *that1.NetTxDropped {
			return false
		}
	} else if this.NetTxDropped != nil {
		return false
	} else if that1.NetTxDropped != nil {
		return false
	}
	if this.NetTCPRttMicrosecsP50 != nil && that1.NetTCPRttMicrosecsP50 != nil {
		if *this.NetTCPRttMicrosecsP50 != *that1.NetTCPRttMicrosecsP50 {
			return false
		}
	} else if this.NetTCPRttMicrosecsP50 != nil {
		return false
	} else if that1.NetTCPRttMicrosecsP50 != nil {
		return false
	}
	if this.NetTCPRttMicrosecsP90 != nil && that1.NetTCPRttMicrosecsP90 != nil {
		if *this.NetTCPRttMicrosecsP90 != *that1.NetTCPRttMicrosecsP90 {
			return false
		}
	} else if this.NetTCPRttMicrosecsP90 != nil {
		return false
	} else if that1.NetTCPRttMicrosecsP90 != nil {
		return false
	}
	if this.NetTCPRttMicrosecsP95 != nil && that1.NetTCPRttMicrosecsP95 != nil {
		if *this.NetTCPRttMicrosecsP95 != *that1.NetTCPRttMicrosecsP95 {
			return false
		}
	} else if this.NetTCPRttMicrosecsP95 != nil {
		return false
	} else if that1.NetTCPRttMicrosecsP95 != nil {
		return false
	}
	if this.NetTCPRttMicrosecsP99 != nil && that1.NetTCPRttMicrosecsP99 != nil {
		if *this.NetTCPRttMicrosecsP99 != *that1.NetTCPRttMicrosecsP99 {
			return false
		}
	} else if this.NetTCPRttMicrosecsP99 != nil {
		return false
	} else if that1.NetTCPRttMicrosecsP99 != nil {
		return false
	}
	if this.NetTCPActiveConnections != nil && that1.NetTCPActiveConnections != nil {
		if *this.NetTCPActiveConnections != *that1.NetTCPActiveConnections {
			return false
		}
	} else if this.NetTCPActiveConnections != nil {
		return false
	} else if that1.NetTCPActiveConnections != nil {
		return false
	}
	if this.NetTCPTimeWaitConnections != nil && that1.NetTCPTimeWaitConnections != nil {
		if *this.NetTCPTimeWaitConnections != *that1.NetTCPTimeWaitConnections {
			return false
		}
	} else if this.NetTCPTimeWaitConnections != nil {
		return false
	} else if that1.NetTCPTimeWaitConnections != nil {
		return false
	}
	if len(this.NetTrafficControlStatistics) != len(that1.NetTrafficControlStatistics) {
		return false
	}
	for i := range this.NetTrafficControlStatistics {
		if !this.NetTrafficControlStatistics[i].Equal(&that1.NetTrafficControlStatistics[i]) {
			return false
		}
	}
	if !this.NetSNMPStatistics.Equal(that1.NetSNMPStatistics) {
		return false
	}
	return true
}
func (this *ResourceUsage) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResourceUsage)
	if !ok {
		that2, ok := that.(ResourceUsage)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResourceUsage")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResourceUsage but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResourceUsage but is not nil && this == nil")
	}
	if len(this.Executors) != len(that1.Executors) {
		return fmt.Errorf("Executors this(%v) Not Equal that(%v)", len(this.Executors), len(that1.Executors))
	}
	for i := range this.Executors {
		if !this.Executors[i].Equal(&that1.Executors[i]) {
			return fmt.Errorf("Executors this[%v](%v) Not Equal that[%v](%v)", i, this.Executors[i], i, that1.Executors[i])
		}
	}
	if len(this.Total) != len(that1.Total) {
		return fmt.Errorf("Total this(%v) Not Equal that(%v)", len(this.Total), len(that1.Total))
	}
	for i := range this.Total {
		if !this.Total[i].Equal(&that1.Total[i]) {
			return fmt.Errorf("Total this[%v](%v) Not Equal that[%v](%v)", i, this.Total[i], i, that1.Total[i])
		}
	}
	return nil
}
func (this *ResourceUsage) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceUsage)
	if !ok {
		that2, ok := that.(ResourceUsage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Executors) != len(that1.Executors) {
		return false
	}
	for i := range this.Executors {
		if !this.Executors[i].Equal(&that1.Executors[i]) {
			return false
		}
	}
	if len(this.Total) != len(that1.Total) {
		return false
	}
	for i := range this.Total {
		if !this.Total[i].Equal(&that1.Total[i]) {
			return false
		}
	}
	return true
}
func (this *ResourceUsage_Executor) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResourceUsage_Executor)
	if !ok {
		that2, ok := that.(ResourceUsage_Executor)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResourceUsage_Executor")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResourceUsage_Executor but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResourceUsage_Executor but is not nil && this == nil")
	}
	if !this.ExecutorInfo.Equal(&that1.ExecutorInfo) {
		return fmt.Errorf("ExecutorInfo this(%v) Not Equal that(%v)", this.ExecutorInfo, that1.ExecutorInfo)
	}
	if len(this.Allocated) != len(that1.Allocated) {
		return fmt.Errorf("Allocated this(%v) Not Equal that(%v)", len(this.Allocated), len(that1.Allocated))
	}
	for i := range this.Allocated {
		if !this.Allocated[i].Equal(&that1.Allocated[i]) {
			return fmt.Errorf("Allocated this[%v](%v) Not Equal that[%v](%v)", i, this.Allocated[i], i, that1.Allocated[i])
		}
	}
	if !this.Statistics.Equal(that1.Statistics) {
		return fmt.Errorf("Statistics this(%v) Not Equal that(%v)", this.Statistics, that1.Statistics)
	}
	if !this.ContainerID.Equal(&that1.ContainerID) {
		return fmt.Errorf("ContainerID this(%v) Not Equal that(%v)", this.ContainerID, that1.ContainerID)
	}
	if len(this.Tasks) != len(that1.Tasks) {
		return fmt.Errorf("Tasks this(%v) Not Equal that(%v)", len(this.Tasks), len(that1.Tasks))
	}
	for i := range this.Tasks {
		if !this.Tasks[i].Equal(&that1.Tasks[i]) {
			return fmt.Errorf("Tasks this[%v](%v) Not Equal that[%v](%v)", i, this.Tasks[i], i, that1.Tasks[i])
		}
	}
	return nil
}
func (this *ResourceUsage_Executor) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceUsage_Executor)
	if !ok {
		that2, ok := that.(ResourceUsage_Executor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ExecutorInfo.Equal(&that1.ExecutorInfo) {
		return false
	}
	if len(this.Allocated) != len(that1.Allocated) {
		return false
	}
	for i := range this.Allocated {
		if !this.Allocated[i].Equal(&that1.Allocated[i]) {
			return false
		}
	}
	if !this.Statistics.Equal(that1.Statistics) {
		return false
	}
	if !this.ContainerID.Equal(&that1.ContainerID) {
		return false
	}
	if len(this.Tasks) != len(that1.Tasks) {
		return false
	}
	for i := range this.Tasks {
		if !this.Tasks[i].Equal(&that1.Tasks[i]) {
			return false
		}
	}
	return true
}
func (this *ResourceUsage_Executor_Task) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ResourceUsage_Executor_Task)
	if !ok {
		that2, ok := that.(ResourceUsage_Executor_Task)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ResourceUsage_Executor_Task")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ResourceUsage_Executor_Task but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ResourceUsage_Executor_Task but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if !this.ID.Equal(&that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	return nil
}
func (this *ResourceUsage_Executor_Task) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceUsage_Executor_Task)
	if !ok {
		that2, ok := that.(ResourceUsage_Executor_Task)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.ID.Equal(&that1.ID) {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	return true
}
func (this *PerfStatistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PerfStatistics)
	if !ok {
		that2, ok := that.(PerfStatistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PerfStatistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PerfStatistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PerfStatistics but is not nil && this == nil")
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if this.Duration != that1.Duration {
		return fmt.Errorf("Duration this(%v) Not Equal that(%v)", this.Duration, that1.Duration)
	}
	if this.Cycles != nil && that1.Cycles != nil {
		if *this.Cycles != *that1.Cycles {
			return fmt.Errorf("Cycles this(%v) Not Equal that(%v)", *this.Cycles, *that1.Cycles)
		}
	} else if this.Cycles != nil {
		return fmt.Errorf("this.Cycles == nil && that.Cycles != nil")
	} else if that1.Cycles != nil {
		return fmt.Errorf("Cycles this(%v) Not Equal that(%v)", this.Cycles, that1.Cycles)
	}
	if this.StalledCyclesFrontend != nil && that1.StalledCyclesFrontend != nil {
		if *this.StalledCyclesFrontend != *that1.StalledCyclesFrontend {
			return fmt.Errorf("StalledCyclesFrontend this(%v) Not Equal that(%v)", *this.StalledCyclesFrontend, *that1.StalledCyclesFrontend)
		}
	} else if this.StalledCyclesFrontend != nil {
		return fmt.Errorf("this.StalledCyclesFrontend == nil && that.StalledCyclesFrontend != nil")
	} else if that1.StalledCyclesFrontend != nil {
		return fmt.Errorf("StalledCyclesFrontend this(%v) Not Equal that(%v)", this.StalledCyclesFrontend, that1.StalledCyclesFrontend)
	}
	if this.StalledCyclesBackend != nil && that1.StalledCyclesBackend != nil {
		if *this.StalledCyclesBackend != *that1.StalledCyclesBackend {
			return fmt.Errorf("StalledCyclesBackend this(%v) Not Equal that(%v)", *this.StalledCyclesBackend, *that1.StalledCyclesBackend)
		}
	} else if this.StalledCyclesBackend != nil {
		return fmt.Errorf("this.StalledCyclesBackend == nil && that.StalledCyclesBackend != nil")
	} else if that1.StalledCyclesBackend != nil {
		return fmt.Errorf("StalledCyclesBackend this(%v) Not Equal that(%v)", this.StalledCyclesBackend, that1.StalledCyclesBackend)
	}
	if this.Instructions != nil && that1.Instructions != nil {
		if *this.Instructions != *that1.Instructions {
			return fmt.Errorf("Instructions this(%v) Not Equal that(%v)", *this.Instructions, *that1.Instructions)
		}
	} else if this.Instructions != nil {
		return fmt.Errorf("this.Instructions == nil && that.Instructions != nil")
	} else if that1.Instructions != nil {
		return fmt.Errorf("Instructions this(%v) Not Equal that(%v)", this.Instructions, that1.Instructions)
	}
	if this.CacheReferences != nil && that1.CacheReferences != nil {
		if *this.CacheReferences != *that1.CacheReferences {
			return fmt.Errorf("CacheReferences this(%v) Not Equal that(%v)", *this.CacheReferences, *that1.CacheReferences)
		}
	} else if this.CacheReferences != nil {
		return fmt.Errorf("this.CacheReferences == nil && that.CacheReferences != nil")
	} else if that1.CacheReferences != nil {
		return fmt.Errorf("CacheReferences this(%v) Not Equal that(%v)", this.CacheReferences, that1.CacheReferences)
	}
	if this.CacheMisses != nil && that1.CacheMisses != nil {
		if *this.CacheMisses != *that1.CacheMisses {
			return fmt.Errorf("CacheMisses this(%v) Not Equal that(%v)", *this.CacheMisses, *that1.CacheMisses)
		}
	} else if this.CacheMisses != nil {
		return fmt.Errorf("this.CacheMisses == nil && that.CacheMisses != nil")
	} else if that1.CacheMisses != nil {
		return fmt.Errorf("CacheMisses this(%v) Not Equal that(%v)", this.CacheMisses, that1.CacheMisses)
	}
	if this.Branches != nil && that1.Branches != nil {
		if *this.Branches != *that1.Branches {
			return fmt.Errorf("Branches this(%v) Not Equal that(%v)", *this.Branches, *that1.Branches)
		}
	} else if this.Branches != nil {
		return fmt.Errorf("this.Branches == nil && that.Branches != nil")
	} else if that1.Branches != nil {
		return fmt.Errorf("Branches this(%v) Not Equal that(%v)", this.Branches, that1.Branches)
	}
	if this.BranchMisses != nil && that1.BranchMisses != nil {
		if *this.BranchMisses != *that1.BranchMisses {
			return fmt.Errorf("BranchMisses this(%v) Not Equal that(%v)", *this.BranchMisses, *that1.BranchMisses)
		}
	} else if this.BranchMisses != nil {
		return fmt.Errorf("this.BranchMisses == nil && that.BranchMisses != nil")
	} else if that1.BranchMisses != nil {
		return fmt.Errorf("BranchMisses this(%v) Not Equal that(%v)", this.BranchMisses, that1.BranchMisses)
	}
	if this.BusCycles != nil && that1.BusCycles != nil {
		if *this.BusCycles != *that1.BusCycles {
			return fmt.Errorf("BusCycles this(%v) Not Equal that(%v)", *this.BusCycles, *that1.BusCycles)
		}
	} else if this.BusCycles != nil {
		return fmt.Errorf("this.BusCycles == nil && that.BusCycles != nil")
	} else if that1.BusCycles != nil {
		return fmt.Errorf("BusCycles this(%v) Not Equal that(%v)", this.BusCycles, that1.BusCycles)
	}
	if this.RefCycles != nil && that1.RefCycles != nil {
		if *this.RefCycles != *that1.RefCycles {
			return fmt.Errorf("RefCycles this(%v) Not Equal that(%v)", *this.RefCycles, *that1.RefCycles)
		}
	} else if this.RefCycles != nil {
		return fmt.Errorf("this.RefCycles == nil && that.RefCycles != nil")
	} else if that1.RefCycles != nil {
		return fmt.Errorf("RefCycles this(%v) Not Equal that(%v)", this.RefCycles, that1.RefCycles)
	}
	if this.CPUClock != nil && that1.CPUClock != nil {
		if *this.CPUClock != *that1.CPUClock {
			return fmt.Errorf("CPUClock this(%v) Not Equal that(%v)", *this.CPUClock, *that1.CPUClock)
		}
	} else if this.CPUClock != nil {
		return fmt.Errorf("this.CPUClock == nil && that.CPUClock != nil")
	} else if that1.CPUClock != nil {
		return fmt.Errorf("CPUClock this(%v) Not Equal that(%v)", this.CPUClock, that1.CPUClock)
	}
	if this.TaskClock != nil && that1.TaskClock != nil {
		if *this.TaskClock != *that1.TaskClock {
			return fmt.Errorf("TaskClock this(%v) Not Equal that(%v)", *this.TaskClock, *that1.TaskClock)
		}
	} else if this.TaskClock != nil {
		return fmt.Errorf("this.TaskClock == nil && that.TaskClock != nil")
	} else if that1.TaskClock != nil {
		return fmt.Errorf("TaskClock this(%v) Not Equal that(%v)", this.TaskClock, that1.TaskClock)
	}
	if this.PageFaults != nil && that1.PageFaults != nil {
		if *this.PageFaults != *that1.PageFaults {
			return fmt.Errorf("PageFaults this(%v) Not Equal that(%v)", *this.PageFaults, *that1.PageFaults)
		}
	} else if this.PageFaults != nil {
		return fmt.Errorf("this.PageFaults == nil && that.PageFaults != nil")
	} else if that1.PageFaults != nil {
		return fmt.Errorf("PageFaults this(%v) Not Equal that(%v)", this.PageFaults, that1.PageFaults)
	}
	if this.MinorFaults != nil && that1.MinorFaults != nil {
		if *this.MinorFaults != *that1.MinorFaults {
			return fmt.Errorf("MinorFaults this(%v) Not Equal that(%v)", *this.MinorFaults, *that1.MinorFaults)
		}
	} else if this.MinorFaults != nil {
		return fmt.Errorf("this.MinorFaults == nil && that.MinorFaults != nil")
	} else if that1.MinorFaults != nil {
		return fmt.Errorf("MinorFaults this(%v) Not Equal that(%v)", this.MinorFaults, that1.MinorFaults)
	}
	if this.MajorFaults != nil && that1.MajorFaults != nil {
		if *this.MajorFaults != *that1.MajorFaults {
			return fmt.Errorf("MajorFaults this(%v) Not Equal that(%v)", *this.MajorFaults, *that1.MajorFaults)
		}
	} else if this.MajorFaults != nil {
		return fmt.Errorf("this.MajorFaults == nil && that.MajorFaults != nil")
	} else if that1.MajorFaults != nil {
		return fmt.Errorf("MajorFaults this(%v) Not Equal that(%v)", this.MajorFaults, that1.MajorFaults)
	}
	if this.ContextSwitches != nil && that1.ContextSwitches != nil {
		if *this.ContextSwitches != *that1.ContextSwitches {
			return fmt.Errorf("ContextSwitches this(%v) Not Equal that(%v)", *this.ContextSwitches, *that1.ContextSwitches)
		}
	} else if this.ContextSwitches != nil {
		return fmt.Errorf("this.ContextSwitches == nil && that.ContextSwitches != nil")
	} else if that1.ContextSwitches != nil {
		return fmt.Errorf("ContextSwitches this(%v) Not Equal that(%v)", this.ContextSwitches, that1.ContextSwitches)
	}
	if this.CPUMigrations != nil && that1.CPUMigrations != nil {
		if *this.CPUMigrations != *that1.CPUMigrations {
			return fmt.Errorf("CPUMigrations this(%v) Not Equal that(%v)", *this.CPUMigrations, *that1.CPUMigrations)
		}
	} else if this.CPUMigrations != nil {
		return fmt.Errorf("this.CPUMigrations == nil && that.CPUMigrations != nil")
	} else if that1.CPUMigrations != nil {
		return fmt.Errorf("CPUMigrations this(%v) Not Equal that(%v)", this.CPUMigrations, that1.CPUMigrations)
	}
	if this.AlignmentFaults != nil && that1.AlignmentFaults != nil {
		if *this.AlignmentFaults != *that1.AlignmentFaults {
			return fmt.Errorf("AlignmentFaults this(%v) Not Equal that(%v)", *this.AlignmentFaults, *that1.AlignmentFaults)
		}
	} else if this.AlignmentFaults != nil {
		return fmt.Errorf("this.AlignmentFaults == nil && that.AlignmentFaults != nil")
	} else if that1.AlignmentFaults != nil {
		return fmt.Errorf("AlignmentFaults this(%v) Not Equal that(%v)", this.AlignmentFaults, that1.AlignmentFaults)
	}
	if this.EmulationFaults != nil && that1.EmulationFaults != nil {
		if *this.EmulationFaults != *that1.EmulationFaults {
			return fmt.Errorf("EmulationFaults this(%v) Not Equal that(%v)", *this.EmulationFaults, *that1.EmulationFaults)
		}
	} else if this.EmulationFaults != nil {
		return fmt.Errorf("this.EmulationFaults == nil && that.EmulationFaults != nil")
	} else if that1.EmulationFaults != nil {
		return fmt.Errorf("EmulationFaults this(%v) Not Equal that(%v)", this.EmulationFaults, that1.EmulationFaults)
	}
	if this.L1DcacheLoads != nil && that1.L1DcacheLoads != nil {
		if *this.L1DcacheLoads != *that1.L1DcacheLoads {
			return fmt.Errorf("L1DcacheLoads this(%v) Not Equal that(%v)", *this.L1DcacheLoads, *that1.L1DcacheLoads)
		}
	} else if this.L1DcacheLoads != nil {
		return fmt.Errorf("this.L1DcacheLoads == nil && that.L1DcacheLoads != nil")
	} else if that1.L1DcacheLoads != nil {
		return fmt.Errorf("L1DcacheLoads this(%v) Not Equal that(%v)", this.L1DcacheLoads, that1.L1DcacheLoads)
	}
	if this.L1DcacheLoadMisses != nil && that1.L1DcacheLoadMisses != nil {
		if *this.L1DcacheLoadMisses != *that1.L1DcacheLoadMisses {
			return fmt.Errorf("L1DcacheLoadMisses this(%v) Not Equal that(%v)", *this.L1DcacheLoadMisses, *that1.L1DcacheLoadMisses)
		}
	} else if this.L1DcacheLoadMisses != nil {
		return fmt.Errorf("this.L1DcacheLoadMisses == nil && that.L1DcacheLoadMisses != nil")
	} else if that1.L1DcacheLoadMisses != nil {
		return fmt.Errorf("L1DcacheLoadMisses this(%v) Not Equal that(%v)", this.L1DcacheLoadMisses, that1.L1DcacheLoadMisses)
	}
	if this.L1DcacheStores != nil && that1.L1DcacheStores != nil {
		if *this.L1DcacheStores != *that1.L1DcacheStores {
			return fmt.Errorf("L1DcacheStores this(%v) Not Equal that(%v)", *this.L1DcacheStores, *that1.L1DcacheStores)
		}
	} else if this.L1DcacheStores != nil {
		return fmt.Errorf("this.L1DcacheStores == nil && that.L1DcacheStores != nil")
	} else if that1.L1DcacheStores != nil {
		return fmt.Errorf("L1DcacheStores this(%v) Not Equal that(%v)", this.L1DcacheStores, that1.L1DcacheStores)
	}
	if this.L1DcacheStoreMisses != nil && that1.L1DcacheStoreMisses != nil {
		if *this.L1DcacheStoreMisses != *that1.L1DcacheStoreMisses {
			return fmt.Errorf("L1DcacheStoreMisses this(%v) Not Equal that(%v)", *this.L1DcacheStoreMisses, *that1.L1DcacheStoreMisses)
		}
	} else if this.L1DcacheStoreMisses != nil {
		return fmt.Errorf("this.L1DcacheStoreMisses == nil && that.L1DcacheStoreMisses != nil")
	} else if that1.L1DcacheStoreMisses != nil {
		return fmt.Errorf("L1DcacheStoreMisses this(%v) Not Equal that(%v)", this.L1DcacheStoreMisses, that1.L1DcacheStoreMisses)
	}
	if this.L1DcachePrefetches != nil && that1.L1DcachePrefetches != nil {
		if *this.L1DcachePrefetches != *that1.L1DcachePrefetches {
			return fmt.Errorf("L1DcachePrefetches this(%v) Not Equal that(%v)", *this.L1DcachePrefetches, *that1.L1DcachePrefetches)
		}
	} else if this.L1DcachePrefetches != nil {
		return fmt.Errorf("this.L1DcachePrefetches == nil && that.L1DcachePrefetches != nil")
	} else if that1.L1DcachePrefetches != nil {
		return fmt.Errorf("L1DcachePrefetches this(%v) Not Equal that(%v)", this.L1DcachePrefetches, that1.L1DcachePrefetches)
	}
	if this.L1DcachePrefetchMisses != nil && that1.L1DcachePrefetchMisses != nil {
		if *this.L1DcachePrefetchMisses != *that1.L1DcachePrefetchMisses {
			return fmt.Errorf("L1DcachePrefetchMisses this(%v) Not Equal that(%v)", *this.L1DcachePrefetchMisses, *that1.L1DcachePrefetchMisses)
		}
	} else if this.L1DcachePrefetchMisses != nil {
		return fmt.Errorf("this.L1DcachePrefetchMisses == nil && that.L1DcachePrefetchMisses != nil")
	} else if that1.L1DcachePrefetchMisses != nil {
		return fmt.Errorf("L1DcachePrefetchMisses this(%v) Not Equal that(%v)", this.L1DcachePrefetchMisses, that1.L1DcachePrefetchMisses)
	}
	if this.L1IcacheLoads != nil && that1.L1IcacheLoads != nil {
		if *this.L1IcacheLoads != *that1.L1IcacheLoads {
			return fmt.Errorf("L1IcacheLoads this(%v) Not Equal that(%v)", *this.L1IcacheLoads, *that1.L1IcacheLoads)
		}
	} else if this.L1IcacheLoads != nil {
		return fmt.Errorf("this.L1IcacheLoads == nil && that.L1IcacheLoads != nil")
	} else if that1.L1IcacheLoads != nil {
		return fmt.Errorf("L1IcacheLoads this(%v) Not Equal that(%v)", this.L1IcacheLoads, that1.L1IcacheLoads)
	}
	if this.L1IcacheLoadMisses != nil && that1.L1IcacheLoadMisses != nil {
		if *this.L1IcacheLoadMisses != *that1.L1IcacheLoadMisses {
			return fmt.Errorf("L1IcacheLoadMisses this(%v) Not Equal that(%v)", *this.L1IcacheLoadMisses, *that1.L1IcacheLoadMisses)
		}
	} else if this.L1IcacheLoadMisses != nil {
		return fmt.Errorf("this.L1IcacheLoadMisses == nil && that.L1IcacheLoadMisses != nil")
	} else if that1.L1IcacheLoadMisses != nil {
		return fmt.Errorf("L1IcacheLoadMisses this(%v) Not Equal that(%v)", this.L1IcacheLoadMisses, that1.L1IcacheLoadMisses)
	}
	if this.L1IcachePrefetches != nil && that1.L1IcachePrefetches != nil {
		if *this.L1IcachePrefetches != *that1.L1IcachePrefetches {
			return fmt.Errorf("L1IcachePrefetches this(%v) Not Equal that(%v)", *this.L1IcachePrefetches, *that1.L1IcachePrefetches)
		}
	} else if this.L1IcachePrefetches != nil {
		return fmt.Errorf("this.L1IcachePrefetches == nil && that.L1IcachePrefetches != nil")
	} else if that1.L1IcachePrefetches != nil {
		return fmt.Errorf("L1IcachePrefetches this(%v) Not Equal that(%v)", this.L1IcachePrefetches, that1.L1IcachePrefetches)
	}
	if this.L1IcachePrefetchMisses != nil && that1.L1IcachePrefetchMisses != nil {
		if *this.L1IcachePrefetchMisses != *that1.L1IcachePrefetchMisses {
			return fmt.Errorf("L1IcachePrefetchMisses this(%v) Not Equal that(%v)", *this.L1IcachePrefetchMisses, *that1.L1IcachePrefetchMisses)
		}
	} else if this.L1IcachePrefetchMisses != nil {
		return fmt.Errorf("this.L1IcachePrefetchMisses == nil && that.L1IcachePrefetchMisses != nil")
	} else if that1.L1IcachePrefetchMisses != nil {
		return fmt.Errorf("L1IcachePrefetchMisses this(%v) Not Equal that(%v)", this.L1IcachePrefetchMisses, that1.L1IcachePrefetchMisses)
	}
	if this.LLCLoads != nil && that1.LLCLoads != nil {
		if *this.LLCLoads != *that1.LLCLoads {
			return fmt.Errorf("LLCLoads this(%v) Not Equal that(%v)", *this.LLCLoads, *that1.LLCLoads)
		}
	} else if this.LLCLoads != nil {
		return fmt.Errorf("this.LLCLoads == nil && that.LLCLoads != nil")
	} else if that1.LLCLoads != nil {
		return fmt.Errorf("LLCLoads this(%v) Not Equal that(%v)", this.LLCLoads, that1.LLCLoads)
	}
	if this.LLCLoadMisses != nil && that1.LLCLoadMisses != nil {
		if *this.LLCLoadMisses != *that1.LLCLoadMisses {
			return fmt.Errorf("LLCLoadMisses this(%v) Not Equal that(%v)", *this.LLCLoadMisses, *that1.LLCLoadMisses)
		}
	} else if this.LLCLoadMisses != nil {
		return fmt.Errorf("this.LLCLoadMisses == nil && that.LLCLoadMisses != nil")
	} else if that1.LLCLoadMisses != nil {
		return fmt.Errorf("LLCLoadMisses this(%v) Not Equal that(%v)", this.LLCLoadMisses, that1.LLCLoadMisses)
	}
	if this.LLCStores != nil && that1.LLCStores != nil {
		if *this.LLCStores != *that1.LLCStores {
			return fmt.Errorf("LLCStores this(%v) Not Equal that(%v)", *this.LLCStores, *that1.LLCStores)
		}
	} else if this.LLCStores != nil {
		return fmt.Errorf("this.LLCStores == nil && that.LLCStores != nil")
	} else if that1.LLCStores != nil {
		return fmt.Errorf("LLCStores this(%v) Not Equal that(%v)", this.LLCStores, that1.LLCStores)
	}
	if this.LLCStoreMisses != nil && that1.LLCStoreMisses != nil {
		if *this.LLCStoreMisses != *that1.LLCStoreMisses {
			return fmt.Errorf("LLCStoreMisses this(%v) Not Equal that(%v)", *this.LLCStoreMisses, *that1.LLCStoreMisses)
		}
	} else if this.LLCStoreMisses != nil {
		return fmt.Errorf("this.LLCStoreMisses == nil && that.LLCStoreMisses != nil")
	} else if that1.LLCStoreMisses != nil {
		return fmt.Errorf("LLCStoreMisses this(%v) Not Equal that(%v)", this.LLCStoreMisses, that1.LLCStoreMisses)
	}
	if this.LLCPrefetches != nil && that1.LLCPrefetches != nil {
		if *this.LLCPrefetches != *that1.LLCPrefetches {
			return fmt.Errorf("LLCPrefetches this(%v) Not Equal that(%v)", *this.LLCPrefetches, *that1.LLCPrefetches)
		}
	} else if this.LLCPrefetches != nil {
		return fmt.Errorf("this.LLCPrefetches == nil && that.LLCPrefetches != nil")
	} else if that1.LLCPrefetches != nil {
		return fmt.Errorf("LLCPrefetches this(%v) Not Equal that(%v)", this.LLCPrefetches, that1.LLCPrefetches)
	}
	if this.LLCPrefetchMisses != nil && that1.LLCPrefetchMisses != nil {
		if *this.LLCPrefetchMisses != *that1.LLCPrefetchMisses {
			return fmt.Errorf("LLCPrefetchMisses this(%v) Not Equal that(%v)", *this.LLCPrefetchMisses, *that1.LLCPrefetchMisses)
		}
	} else if this.LLCPrefetchMisses != nil {
		return fmt.Errorf("this.LLCPrefetchMisses == nil && that.LLCPrefetchMisses != nil")
	} else if that1.LLCPrefetchMisses != nil {
		return fmt.Errorf("LLCPrefetchMisses this(%v) Not Equal that(%v)", this.LLCPrefetchMisses, that1.LLCPrefetchMisses)
	}
	if this.DTLBLoads != nil && that1.DTLBLoads != nil {
		if *this.DTLBLoads != *that1.DTLBLoads {
			return fmt.Errorf("DTLBLoads this(%v) Not Equal that(%v)", *this.DTLBLoads, *that1.DTLBLoads)
		}
	} else if this.DTLBLoads != nil {
		return fmt.Errorf("this.DTLBLoads == nil && that.DTLBLoads != nil")
	} else if that1.DTLBLoads != nil {
		return fmt.Errorf("DTLBLoads this(%v) Not Equal that(%v)", this.DTLBLoads, that1.DTLBLoads)
	}
	if this.DTLBLoadMisses != nil && that1.DTLBLoadMisses != nil {
		if *this.DTLBLoadMisses != *that1.DTLBLoadMisses {
			return fmt.Errorf("DTLBLoadMisses this(%v) Not Equal that(%v)", *this.DTLBLoadMisses, *that1.DTLBLoadMisses)
		}
	} else if this.DTLBLoadMisses != nil {
		return fmt.Errorf("this.DTLBLoadMisses == nil && that.DTLBLoadMisses != nil")
	} else if that1.DTLBLoadMisses != nil {
		return fmt.Errorf("DTLBLoadMisses this(%v) Not Equal that(%v)", this.DTLBLoadMisses, that1.DTLBLoadMisses)
	}
	if this.DTLBStores != nil && that1.DTLBStores != nil {
		if *this.DTLBStores != *that1.DTLBStores {
			return fmt.Errorf("DTLBStores this(%v) Not Equal that(%v)", *this.DTLBStores, *that1.DTLBStores)
		}
	} else if this.DTLBStores != nil {
		return fmt.Errorf("this.DTLBStores == nil && that.DTLBStores != nil")
	} else if that1.DTLBStores != nil {
		return fmt.Errorf("DTLBStores this(%v) Not Equal that(%v)", this.DTLBStores, that1.DTLBStores)
	}
	if this.DTLBStoreMisses != nil && that1.DTLBStoreMisses != nil {
		if *this.DTLBStoreMisses != *that1.DTLBStoreMisses {
			return fmt.Errorf("DTLBStoreMisses this(%v) Not Equal that(%v)", *this.DTLBStoreMisses, *that1.DTLBStoreMisses)
		}
	} else if this.DTLBStoreMisses != nil {
		return fmt.Errorf("this.DTLBStoreMisses == nil && that.DTLBStoreMisses != nil")
	} else if that1.DTLBStoreMisses != nil {
		return fmt.Errorf("DTLBStoreMisses this(%v) Not Equal that(%v)", this.DTLBStoreMisses, that1.DTLBStoreMisses)
	}
	if this.DTLBPrefetches != nil && that1.DTLBPrefetches != nil {
		if *this.DTLBPrefetches != *that1.DTLBPrefetches {
			return fmt.Errorf("DTLBPrefetches this(%v) Not Equal that(%v)", *this.DTLBPrefetches, *that1.DTLBPrefetches)
		}
	} else if this.DTLBPrefetches != nil {
		return fmt.Errorf("this.DTLBPrefetches == nil && that.DTLBPrefetches != nil")
	} else if that1.DTLBPrefetches != nil {
		return fmt.Errorf("DTLBPrefetches this(%v) Not Equal that(%v)", this.DTLBPrefetches, that1.DTLBPrefetches)
	}
	if this.DTLBPrefetchMisses != nil && that1.DTLBPrefetchMisses != nil {
		if *this.DTLBPrefetchMisses != *that1.DTLBPrefetchMisses {
			return fmt.Errorf("DTLBPrefetchMisses this(%v) Not Equal that(%v)", *this.DTLBPrefetchMisses, *that1.DTLBPrefetchMisses)
		}
	} else if this.DTLBPrefetchMisses != nil {
		return fmt.Errorf("this.DTLBPrefetchMisses == nil && that.DTLBPrefetchMisses != nil")
	} else if that1.DTLBPrefetchMisses != nil {
		return fmt.Errorf("DTLBPrefetchMisses this(%v) Not Equal that(%v)", this.DTLBPrefetchMisses, that1.DTLBPrefetchMisses)
	}
	if this.ITLBLoads != nil && that1.ITLBLoads != nil {
		if *this.ITLBLoads != *that1.ITLBLoads {
			return fmt.Errorf("ITLBLoads this(%v) Not Equal that(%v)", *this.ITLBLoads, *that1.ITLBLoads)
		}
	} else if this.ITLBLoads != nil {
		return fmt.Errorf("this.ITLBLoads == nil && that.ITLBLoads != nil")
	} else if that1.ITLBLoads != nil {
		return fmt.Errorf("ITLBLoads this(%v) Not Equal that(%v)", this.ITLBLoads, that1.ITLBLoads)
	}
	if this.ITLBLoadMisses != nil && that1.ITLBLoadMisses != nil {
		if *this.ITLBLoadMisses != *that1.ITLBLoadMisses {
			return fmt.Errorf("ITLBLoadMisses this(%v) Not Equal that(%v)", *this.ITLBLoadMisses, *that1.ITLBLoadMisses)
		}
	} else if this.ITLBLoadMisses != nil {
		return fmt.Errorf("this.ITLBLoadMisses == nil && that.ITLBLoadMisses != nil")
	} else if that1.ITLBLoadMisses != nil {
		return fmt.Errorf("ITLBLoadMisses this(%v) Not Equal that(%v)", this.ITLBLoadMisses, that1.ITLBLoadMisses)
	}
	if this.BranchLoads != nil && that1.BranchLoads != nil {
		if *this.BranchLoads != *that1.BranchLoads {
			return fmt.Errorf("BranchLoads this(%v) Not Equal that(%v)", *this.BranchLoads, *that1.BranchLoads)
		}
	} else if this.BranchLoads != nil {
		return fmt.Errorf("this.BranchLoads == nil && that.BranchLoads != nil")
	} else if that1.BranchLoads != nil {
		return fmt.Errorf("BranchLoads this(%v) Not Equal that(%v)", this.BranchLoads, that1.BranchLoads)
	}
	if this.BranchLoadMisses != nil && that1.BranchLoadMisses != nil {
		if *this.BranchLoadMisses != *that1.BranchLoadMisses {
			return fmt.Errorf("BranchLoadMisses this(%v) Not Equal that(%v)", *this.BranchLoadMisses, *that1.BranchLoadMisses)
		}
	} else if this.BranchLoadMisses != nil {
		return fmt.Errorf("this.BranchLoadMisses == nil && that.BranchLoadMisses != nil")
	} else if that1.BranchLoadMisses != nil {
		return fmt.Errorf("BranchLoadMisses this(%v) Not Equal that(%v)", this.BranchLoadMisses, that1.BranchLoadMisses)
	}
	if this.NodeLoads != nil && that1.NodeLoads != nil {
		if *this.NodeLoads != *that1.NodeLoads {
			return fmt.Errorf("NodeLoads this(%v) Not Equal that(%v)", *this.NodeLoads, *that1.NodeLoads)
		}
	} else if this.NodeLoads != nil {
		return fmt.Errorf("this.NodeLoads == nil && that.NodeLoads != nil")
	} else if that1.NodeLoads != nil {
		return fmt.Errorf("NodeLoads this(%v) Not Equal that(%v)", this.NodeLoads, that1.NodeLoads)
	}
	if this.NodeLoadMisses != nil && that1.NodeLoadMisses != nil {
		if *this.NodeLoadMisses != *that1.NodeLoadMisses {
			return fmt.Errorf("NodeLoadMisses this(%v) Not Equal that(%v)", *this.NodeLoadMisses, *that1.NodeLoadMisses)
		}
	} else if this.NodeLoadMisses != nil {
		return fmt.Errorf("this.NodeLoadMisses == nil && that.NodeLoadMisses != nil")
	} else if that1.NodeLoadMisses != nil {
		return fmt.Errorf("NodeLoadMisses this(%v) Not Equal that(%v)", this.NodeLoadMisses, that1.NodeLoadMisses)
	}
	if this.NodeStores != nil && that1.NodeStores != nil {
		if *this.NodeStores != *that1.NodeStores {
			return fmt.Errorf("NodeStores this(%v) Not Equal that(%v)", *this.NodeStores, *that1.NodeStores)
		}
	} else if this.NodeStores != nil {
		return fmt.Errorf("this.NodeStores == nil && that.NodeStores != nil")
	} else if that1.NodeStores != nil {
		return fmt.Errorf("NodeStores this(%v) Not Equal that(%v)", this.NodeStores, that1.NodeStores)
	}
	if this.NodeStoreMisses != nil && that1.NodeStoreMisses != nil {
		if *this.NodeStoreMisses != *that1.NodeStoreMisses {
			return fmt.Errorf("NodeStoreMisses this(%v) Not Equal that(%v)", *this.NodeStoreMisses, *that1.NodeStoreMisses)
		}
	} else if this.NodeStoreMisses != nil {
		return fmt.Errorf("this.NodeStoreMisses == nil && that.NodeStoreMisses != nil")
	} else if that1.NodeStoreMisses != nil {
		return fmt.Errorf("NodeStoreMisses this(%v) Not Equal that(%v)", this.NodeStoreMisses, that1.NodeStoreMisses)
	}
	if this.NodePrefetches != nil && that1.NodePrefetches != nil {
		if *this.NodePrefetches != *that1.NodePrefetches {
			return fmt.Errorf("NodePrefetches this(%v) Not Equal that(%v)", *this.NodePrefetches, *that1.NodePrefetches)
		}
	} else if this.NodePrefetches != nil {
		return fmt.Errorf("this.NodePrefetches == nil && that.NodePrefetches != nil")
	} else if that1.NodePrefetches != nil {
		return fmt.Errorf("NodePrefetches this(%v) Not Equal that(%v)", this.NodePrefetches, that1.NodePrefetches)
	}
	if this.NodePrefetchMisses != nil && that1.NodePrefetchMisses != nil {
		if *this.NodePrefetchMisses != *that1.NodePrefetchMisses {
			return fmt.Errorf("NodePrefetchMisses this(%v) Not Equal that(%v)", *this.NodePrefetchMisses, *that1.NodePrefetchMisses)
		}
	} else if this.NodePrefetchMisses != nil {
		return fmt.Errorf("this.NodePrefetchMisses == nil && that.NodePrefetchMisses != nil")
	} else if that1.NodePrefetchMisses != nil {
		return fmt.Errorf("NodePrefetchMisses this(%v) Not Equal that(%v)", this.NodePrefetchMisses, that1.NodePrefetchMisses)
	}
	return nil
}
func (this *PerfStatistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PerfStatistics)
	if !ok {
		that2, ok := that.(PerfStatistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.Cycles != nil && that1.Cycles != nil {
		if *this.Cycles != *that1.Cycles {
			return false
		}
	} else if this.Cycles != nil {
		return false
	} else if that1.Cycles != nil {
		return false
	}
	if this.StalledCyclesFrontend != nil && that1.StalledCyclesFrontend != nil {
		if *this.StalledCyclesFrontend != *that1.StalledCyclesFrontend {
			return false
		}
	} else if this.StalledCyclesFrontend != nil {
		return false
	} else if that1.StalledCyclesFrontend != nil {
		return false
	}
	if this.StalledCyclesBackend != nil && that1.StalledCyclesBackend != nil {
		if *this.StalledCyclesBackend != *that1.StalledCyclesBackend {
			return false
		}
	} else if this.StalledCyclesBackend != nil {
		return false
	} else if that1.StalledCyclesBackend != nil {
		return false
	}
	if this.Instructions != nil && that1.Instructions != nil {
		if *this.Instructions != *that1.Instructions {
			return false
		}
	} else if this.Instructions != nil {
		return false
	} else if that1.Instructions != nil {
		return false
	}
	if this.CacheReferences != nil && that1.CacheReferences != nil {
		if *this.CacheReferences != *that1.CacheReferences {
			return false
		}
	} else if this.CacheReferences != nil {
		return false
	} else if that1.CacheReferences != nil {
		return false
	}
	if this.CacheMisses != nil && that1.CacheMisses != nil {
		if *this.CacheMisses != *that1.CacheMisses {
			return false
		}
	} else if this.CacheMisses != nil {
		return false
	} else if that1.CacheMisses != nil {
		return false
	}
	if this.Branches != nil && that1.Branches != nil {
		if *this.Branches != *that1.Branches {
			return false
		}
	} else if this.Branches != nil {
		return false
	} else if that1.Branches != nil {
		return false
	}
	if this.BranchMisses != nil && that1.BranchMisses != nil {
		if *this.BranchMisses != *that1.BranchMisses {
			return false
		}
	} else if this.BranchMisses != nil {
		return false
	} else if that1.BranchMisses != nil {
		return false
	}
	if this.BusCycles != nil && that1.BusCycles != nil {
		if *this.BusCycles != *that1.BusCycles {
			return false
		}
	} else if this.BusCycles != nil {
		return false
	} else if that1.BusCycles != nil {
		return false
	}
	if this.RefCycles != nil && that1.RefCycles != nil {
		if *this.RefCycles != *that1.RefCycles {
			return false
		}
	} else if this.RefCycles != nil {
		return false
	} else if that1.RefCycles != nil {
		return false
	}
	if this.CPUClock != nil && that1.CPUClock != nil {
		if *this.CPUClock != *that1.CPUClock {
			return false
		}
	} else if this.CPUClock != nil {
		return false
	} else if that1.CPUClock != nil {
		return false
	}
	if this.TaskClock != nil && that1.TaskClock != nil {
		if *this.TaskClock != *that1.TaskClock {
			return false
		}
	} else if this.TaskClock != nil {
		return false
	} else if that1.TaskClock != nil {
		return false
	}
	if this.PageFaults != nil && that1.PageFaults != nil {
		if *this.PageFaults != *that1.PageFaults {
			return false
		}
	} else if this.PageFaults != nil {
		return false
	} else if that1.PageFaults != nil {
		return false
	}
	if this.MinorFaults != nil && that1.MinorFaults != nil {
		if *this.MinorFaults != *that1.MinorFaults {
			return false
		}
	} else if this.MinorFaults != nil {
		return false
	} else if that1.MinorFaults != nil {
		return false
	}
	if this.MajorFaults != nil && that1.MajorFaults != nil {
		if *this.MajorFaults != *that1.MajorFaults {
			return false
		}
	} else if this.MajorFaults != nil {
		return false
	} else if that1.MajorFaults != nil {
		return false
	}
	if this.ContextSwitches != nil && that1.ContextSwitches != nil {
		if *this.ContextSwitches != *that1.ContextSwitches {
			return false
		}
	} else if this.ContextSwitches != nil {
		return false
	} else if that1.ContextSwitches != nil {
		return false
	}
	if this.CPUMigrations != nil && that1.CPUMigrations != nil {
		if *this.CPUMigrations != *that1.CPUMigrations {
			return false
		}
	} else if this.CPUMigrations != nil {
		return false
	} else if that1.CPUMigrations != nil {
		return false
	}
	if this.AlignmentFaults != nil && that1.AlignmentFaults != nil {
		if *this.AlignmentFaults != *that1.AlignmentFaults {
			return false
		}
	} else if this.AlignmentFaults != nil {
		return false
	} else if that1.AlignmentFaults != nil {
		return false
	}
	if this.EmulationFaults != nil && that1.EmulationFaults != nil {
		if *this.EmulationFaults != *that1.EmulationFaults {
			return false
		}
	} else if this.EmulationFaults != nil {
		return false
	} else if that1.EmulationFaults != nil {
		return false
	}
	if this.L1DcacheLoads != nil && that1.L1DcacheLoads != nil {
		if *this.L1DcacheLoads != *that1.L1DcacheLoads {
			return false
		}
	} else if this.L1DcacheLoads != nil {
		return false
	} else if that1.L1DcacheLoads != nil {
		return false
	}
	if this.L1DcacheLoadMisses != nil && that1.L1DcacheLoadMisses != nil {
		if *this.L1DcacheLoadMisses != *that1.L1DcacheLoadMisses {
			return false
		}
	} else if this.L1DcacheLoadMisses != nil {
		return false
	} else if that1.L1DcacheLoadMisses != nil {
		return false
	}
	if this.L1DcacheStores != nil && that1.L1DcacheStores != nil {
		if *this.L1DcacheStores != *that1.L1DcacheStores {
			return false
		}
	} else if this.L1DcacheStores != nil {
		return false
	} else if that1.L1DcacheStores != nil {
		return false
	}
	if this.L1DcacheStoreMisses != nil && that1.L1DcacheStoreMisses != nil {
		if *this.L1DcacheStoreMisses != *that1.L1DcacheStoreMisses {
			return false
		}
	} else if this.L1DcacheStoreMisses != nil {
		return false
	} else if that1.L1DcacheStoreMisses != nil {
		return false
	}
	if this.L1DcachePrefetches != nil && that1.L1DcachePrefetches != nil {
		if *this.L1DcachePrefetches != *that1.L1DcachePrefetches {
			return false
		}
	} else if this.L1DcachePrefetches != nil {
		return false
	} else if that1.L1DcachePrefetches != nil {
		return false
	}
	if this.L1DcachePrefetchMisses != nil && that1.L1DcachePrefetchMisses != nil {
		if *this.L1DcachePrefetchMisses != *that1.L1DcachePrefetchMisses {
			return false
		}
	} else if this.L1DcachePrefetchMisses != nil {
		return false
	} else if that1.L1DcachePrefetchMisses != nil {
		return false
	}
	if this.L1IcacheLoads != nil && that1.L1IcacheLoads != nil {
		if *this.L1IcacheLoads != *that1.L1IcacheLoads {
			return false
		}
	} else if this.L1IcacheLoads != nil {
		return false
	} else if that1.L1IcacheLoads != nil {
		return false
	}
	if this.L1IcacheLoadMisses != nil && that1.L1IcacheLoadMisses != nil {
		if *this.L1IcacheLoadMisses != *that1.L1IcacheLoadMisses {
			return false
		}
	} else if this.L1IcacheLoadMisses != nil {
		return false
	} else if that1.L1IcacheLoadMisses != nil {
		return false
	}
	if this.L1IcachePrefetches != nil && that1.L1IcachePrefetches != nil {
		if *this.L1IcachePrefetches != *that1.L1IcachePrefetches {
			return false
		}
	} else if this.L1IcachePrefetches != nil {
		return false
	} else if that1.L1IcachePrefetches != nil {
		return false
	}
	if this.L1IcachePrefetchMisses != nil && that1.L1IcachePrefetchMisses != nil {
		if *this.L1IcachePrefetchMisses != *that1.L1IcachePrefetchMisses {
			return false
		}
	} else if this.L1IcachePrefetchMisses != nil {
		return false
	} else if that1.L1IcachePrefetchMisses != nil {
		return false
	}
	if this.LLCLoads != nil && that1.LLCLoads != nil {
		if *this.LLCLoads != *that1.LLCLoads {
			return false
		}
	} else if this.LLCLoads != nil {
		return false
	} else if that1.LLCLoads != nil {
		return false
	}
	if this.LLCLoadMisses != nil && that1.LLCLoadMisses != nil {
		if *this.LLCLoadMisses != *that1.LLCLoadMisses {
			return false
		}
	} else if this.LLCLoadMisses != nil {
		return false
	} else if that1.LLCLoadMisses != nil {
		return false
	}
	if this.LLCStores != nil && that1.LLCStores != nil {
		if *this.LLCStores != *that1.LLCStores {
			return false
		}
	} else if this.LLCStores != nil {
		return false
	} else if that1.LLCStores != nil {
		return false
	}
	if this.LLCStoreMisses != nil && that1.LLCStoreMisses != nil {
		if *this.LLCStoreMisses != *that1.LLCStoreMisses {
			return false
		}
	} else if this.LLCStoreMisses != nil {
		return false
	} else if that1.LLCStoreMisses != nil {
		return false
	}
	if this.LLCPrefetches != nil && that1.LLCPrefetches != nil {
		if *this.LLCPrefetches != *that1.LLCPrefetches {
			return false
		}
	} else if this.LLCPrefetches != nil {
		return false
	} else if that1.LLCPrefetches != nil {
		return false
	}
	if this.LLCPrefetchMisses != nil && that1.LLCPrefetchMisses != nil {
		if *this.LLCPrefetchMisses != *that1.LLCPrefetchMisses {
			return false
		}
	} else if this.LLCPrefetchMisses != nil {
		return false
	} else if that1.LLCPrefetchMisses != nil {
		return false
	}
	if this.DTLBLoads != nil && that1.DTLBLoads != nil {
		if *this.DTLBLoads != *that1.DTLBLoads {
			return false
		}
	} else if this.DTLBLoads != nil {
		return false
	} else if that1.DTLBLoads != nil {
		return false
	}
	if this.DTLBLoadMisses != nil && that1.DTLBLoadMisses != nil {
		if *this.DTLBLoadMisses != *that1.DTLBLoadMisses {
			return false
		}
	} else if this.DTLBLoadMisses != nil {
		return false
	} else if that1.DTLBLoadMisses != nil {
		return false
	}
	if this.DTLBStores != nil && that1.DTLBStores != nil {
		if *this.DTLBStores != *that1.DTLBStores {
			return false
		}
	} else if this.DTLBStores != nil {
		return false
	} else if that1.DTLBStores != nil {
		return false
	}
	if this.DTLBStoreMisses != nil && that1.DTLBStoreMisses != nil {
		if *this.DTLBStoreMisses != *that1.DTLBStoreMisses {
			return false
		}
	} else if this.DTLBStoreMisses != nil {
		return false
	} else if that1.DTLBStoreMisses != nil {
		return false
	}
	if this.DTLBPrefetches != nil && that1.DTLBPrefetches != nil {
		if *this.DTLBPrefetches != *that1.DTLBPrefetches {
			return false
		}
	} else if this.DTLBPrefetches != nil {
		return false
	} else if that1.DTLBPrefetches != nil {
		return false
	}
	if this.DTLBPrefetchMisses != nil && that1.DTLBPrefetchMisses != nil {
		if *this.DTLBPrefetchMisses != *that1.DTLBPrefetchMisses {
			return false
		}
	} else if this.DTLBPrefetchMisses != nil {
		return false
	} else if that1.DTLBPrefetchMisses != nil {
		return false
	}
	if this.ITLBLoads != nil && that1.ITLBLoads != nil {
		if *this.ITLBLoads != *that1.ITLBLoads {
			return false
		}
	} else if this.ITLBLoads != nil {
		return false
	} else if that1.ITLBLoads != nil {
		return false
	}
	if this.ITLBLoadMisses != nil && that1.ITLBLoadMisses != nil {
		if *this.ITLBLoadMisses != *that1.ITLBLoadMisses {
			return false
		}
	} else if this.ITLBLoadMisses != nil {
		return false
	} else if that1.ITLBLoadMisses != nil {
		return false
	}
	if this.BranchLoads != nil && that1.BranchLoads != nil {
		if *this.BranchLoads != *that1.BranchLoads {
			return false
		}
	} else if this.BranchLoads != nil {
		return false
	} else if that1.BranchLoads != nil {
		return false
	}
	if this.BranchLoadMisses != nil && that1.BranchLoadMisses != nil {
		if *this.BranchLoadMisses != *that1.BranchLoadMisses {
			return false
		}
	} else if this.BranchLoadMisses != nil {
		return false
	} else if that1.BranchLoadMisses != nil {
		return false
	}
	if this.NodeLoads != nil && that1.NodeLoads != nil {
		if *this.NodeLoads != *that1.NodeLoads {
			return false
		}
	} else if this.NodeLoads != nil {
		return false
	} else if that1.NodeLoads != nil {
		return false
	}
	if this.NodeLoadMisses != nil && that1.NodeLoadMisses != nil {
		if *this.NodeLoadMisses != *that1.NodeLoadMisses {
			return false
		}
	} else if this.NodeLoadMisses != nil {
		return false
	} else if that1.NodeLoadMisses != nil {
		return false
	}
	if this.NodeStores != nil && that1.NodeStores != nil {
		if *this.NodeStores != *that1.NodeStores {
			return false
		}
	} else if this.NodeStores != nil {
		return false
	} else if that1.NodeStores != nil {
		return false
	}
	if this.NodeStoreMisses != nil && that1.NodeStoreMisses != nil {
		if *this.NodeStoreMisses != *that1.NodeStoreMisses {
			return false
		}
	} else if this.NodeStoreMisses != nil {
		return false
	} else if that1.NodeStoreMisses != nil {
		return false
	}
	if this.NodePrefetches != nil && that1.NodePrefetches != nil {
		if *this.NodePrefetches != *that1.NodePrefetches {
			return false
		}
	} else if this.NodePrefetches != nil {
		return false
	} else if that1.NodePrefetches != nil {
		return false
	}
	if this.NodePrefetchMisses != nil && that1.NodePrefetchMisses != nil {
		if *this.NodePrefetchMisses != *that1.NodePrefetchMisses {
			return false
		}
	} else if this.NodePrefetchMisses != nil {
		return false
	} else if that1.NodePrefetchMisses != nil {
		return false
	}
	return true
}
func (this *Request) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Request")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Request but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Request but is not nil && this == nil")
	}
	if !this.AgentID.Equal(that1.AgentID) {
		return fmt.Errorf("AgentID this(%v) Not Equal that(%v)", this.AgentID, that1.AgentID)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	return nil
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.AgentID.Equal(that1.AgentID) {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	return true
}
func (this *Offer) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer)
	if !ok {
		that2, ok := that.(Offer)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer but is not nil && this == nil")
	}
	if !this.ID.Equal(&that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if !this.FrameworkID.Equal(&that1.FrameworkID) {
		return fmt.Errorf("FrameworkID this(%v) Not Equal that(%v)", this.FrameworkID, that1.FrameworkID)
	}
	if !this.AgentID.Equal(&that1.AgentID) {
		return fmt.Errorf("AgentID this(%v) Not Equal that(%v)", this.AgentID, that1.AgentID)
	}
	if this.Hostname != that1.Hostname {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if !this.URL.Equal(that1.URL) {
		return fmt.Errorf("URL this(%v) Not Equal that(%v)", this.URL, that1.URL)
	}
	if !this.Domain.Equal(that1.Domain) {
		return fmt.Errorf("Domain this(%v) Not Equal that(%v)", this.Domain, that1.Domain)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return fmt.Errorf("Attributes this(%v) Not Equal that(%v)", len(this.Attributes), len(that1.Attributes))
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(&that1.Attributes[i]) {
			return fmt.Errorf("Attributes this[%v](%v) Not Equal that[%v](%v)", i, this.Attributes[i], i, that1.Attributes[i])
		}
	}
	if len(this.ExecutorIDs) != len(that1.ExecutorIDs) {
		return fmt.Errorf("ExecutorIDs this(%v) Not Equal that(%v)", len(this.ExecutorIDs), len(that1.ExecutorIDs))
	}
	for i := range this.ExecutorIDs {
		if !this.ExecutorIDs[i].Equal(&that1.ExecutorIDs[i]) {
			return fmt.Errorf("ExecutorIDs this[%v](%v) Not Equal that[%v](%v)", i, this.ExecutorIDs[i], i, that1.ExecutorIDs[i])
		}
	}
	if !this.Unavailability.Equal(that1.Unavailability) {
		return fmt.Errorf("Unavailability this(%v) Not Equal that(%v)", this.Unavailability, that1.Unavailability)
	}
	if !this.AllocationInfo.Equal(that1.AllocationInfo) {
		return fmt.Errorf("AllocationInfo this(%v) Not Equal that(%v)", this.AllocationInfo, that1.AllocationInfo)
	}
	return nil
}
func (this *Offer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer)
	if !ok {
		that2, ok := that.(Offer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(&that1.ID) {
		return false
	}
	if !this.FrameworkID.Equal(&that1.FrameworkID) {
		return false
	}
	if !this.AgentID.Equal(&that1.AgentID) {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if !this.URL.Equal(that1.URL) {
		return false
	}
	if !this.Domain.Equal(that1.Domain) {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	if len(this.Attributes) != len(that1.Attributes) {
		return false
	}
	for i := range this.Attributes {
		if !this.Attributes[i].Equal(&that1.Attributes[i]) {
			return false
		}
	}
	if len(this.ExecutorIDs) != len(that1.ExecutorIDs) {
		return false
	}
	for i := range this.ExecutorIDs {
		if !this.ExecutorIDs[i].Equal(&that1.ExecutorIDs[i]) {
			return false
		}
	}
	if !this.Unavailability.Equal(that1.Unavailability) {
		return false
	}
	if !this.AllocationInfo.Equal(that1.AllocationInfo) {
		return false
	}
	return true
}
func (this *Offer_Operation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation)
	if !ok {
		that2, ok := that.(Offer_Operation)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.ID.Equal(that1.ID) {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if !this.Launch.Equal(that1.Launch) {
		return fmt.Errorf("Launch this(%v) Not Equal that(%v)", this.Launch, that1.Launch)
	}
	if !this.LaunchGroup.Equal(that1.LaunchGroup) {
		return fmt.Errorf("LaunchGroup this(%v) Not Equal that(%v)", this.LaunchGroup, that1.LaunchGroup)
	}
	if !this.Reserve.Equal(that1.Reserve) {
		return fmt.Errorf("Reserve this(%v) Not Equal that(%v)", this.Reserve, that1.Reserve)
	}
	if !this.Unreserve.Equal(that1.Unreserve) {
		return fmt.Errorf("Unreserve this(%v) Not Equal that(%v)", this.Unreserve, that1.Unreserve)
	}
	if !this.Create.Equal(that1.Create) {
		return fmt.Errorf("Create this(%v) Not Equal that(%v)", this.Create, that1.Create)
	}
	if !this.Destroy.Equal(that1.Destroy) {
		return fmt.Errorf("Destroy this(%v) Not Equal that(%v)", this.Destroy, that1.Destroy)
	}
	if !this.GrowVolume.Equal(that1.GrowVolume) {
		return fmt.Errorf("GrowVolume this(%v) Not Equal that(%v)", this.GrowVolume, that1.GrowVolume)
	}
	if !this.ShrinkVolume.Equal(that1.ShrinkVolume) {
		return fmt.Errorf("ShrinkVolume this(%v) Not Equal that(%v)", this.ShrinkVolume, that1.ShrinkVolume)
	}
	if !this.CreateDisk.Equal(that1.CreateDisk) {
		return fmt.Errorf("CreateDisk this(%v) Not Equal that(%v)", this.CreateDisk, that1.CreateDisk)
	}
	if !this.DestroyDisk.Equal(that1.DestroyDisk) {
		return fmt.Errorf("DestroyDisk this(%v) Not Equal that(%v)", this.DestroyDisk, that1.DestroyDisk)
	}
	return nil
}
func (this *Offer_Operation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation)
	if !ok {
		that2, ok := that.(Offer_Operation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !this.Launch.Equal(that1.Launch) {
		return false
	}
	if !this.LaunchGroup.Equal(that1.LaunchGroup) {
		return false
	}
	if !this.Reserve.Equal(that1.Reserve) {
		return false
	}
	if !this.Unreserve.Equal(that1.Unreserve) {
		return false
	}
	if !this.Create.Equal(that1.Create) {
		return false
	}
	if !this.Destroy.Equal(that1.Destroy) {
		return false
	}
	if !this.GrowVolume.Equal(that1.GrowVolume) {
		return false
	}
	if !this.ShrinkVolume.Equal(that1.ShrinkVolume) {
		return false
	}
	if !this.CreateDisk.Equal(that1.CreateDisk) {
		return false
	}
	if !this.DestroyDisk.Equal(that1.DestroyDisk) {
		return false
	}
	return true
}
func (this *Offer_Operation_Launch) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_Launch)
	if !ok {
		that2, ok := that.(Offer_Operation_Launch)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_Launch")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_Launch but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_Launch but is not nil && this == nil")
	}
	if len(this.TaskInfos) != len(that1.TaskInfos) {
		return fmt.Errorf("TaskInfos this(%v) Not Equal that(%v)", len(this.TaskInfos), len(that1.TaskInfos))
	}
	for i := range this.TaskInfos {
		if !this.TaskInfos[i].Equal(&that1.TaskInfos[i]) {
			return fmt.Errorf("TaskInfos this[%v](%v) Not Equal that[%v](%v)", i, this.TaskInfos[i], i, that1.TaskInfos[i])
		}
	}
	return nil
}
func (this *Offer_Operation_Launch) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_Launch)
	if !ok {
		that2, ok := that.(Offer_Operation_Launch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.TaskInfos) != len(that1.TaskInfos) {
		return false
	}
	for i := range this.TaskInfos {
		if !this.TaskInfos[i].Equal(&that1.TaskInfos[i]) {
			return false
		}
	}
	return true
}
func (this *Offer_Operation_LaunchGroup) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_LaunchGroup)
	if !ok {
		that2, ok := that.(Offer_Operation_LaunchGroup)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_LaunchGroup")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_LaunchGroup but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_LaunchGroup but is not nil && this == nil")
	}
	if !this.Executor.Equal(&that1.Executor) {
		return fmt.Errorf("Executor this(%v) Not Equal that(%v)", this.Executor, that1.Executor)
	}
	if !this.TaskGroup.Equal(&that1.TaskGroup) {
		return fmt.Errorf("TaskGroup this(%v) Not Equal that(%v)", this.TaskGroup, that1.TaskGroup)
	}
	return nil
}
func (this *Offer_Operation_LaunchGroup) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_LaunchGroup)
	if !ok {
		that2, ok := that.(Offer_Operation_LaunchGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Executor.Equal(&that1.Executor) {
		return false
	}
	if !this.TaskGroup.Equal(&that1.TaskGroup) {
		return false
	}
	return true
}
func (this *Offer_Operation_Reserve) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_Reserve)
	if !ok {
		that2, ok := that.(Offer_Operation_Reserve)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_Reserve")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_Reserve but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_Reserve but is not nil && this == nil")
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	return nil
}
func (this *Offer_Operation_Reserve) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_Reserve)
	if !ok {
		that2, ok := that.(Offer_Operation_Reserve)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	return true
}
func (this *Offer_Operation_Unreserve) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_Unreserve)
	if !ok {
		that2, ok := that.(Offer_Operation_Unreserve)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_Unreserve")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_Unreserve but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_Unreserve but is not nil && this == nil")
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	return nil
}
func (this *Offer_Operation_Unreserve) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_Unreserve)
	if !ok {
		that2, ok := that.(Offer_Operation_Unreserve)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	return true
}
func (this *Offer_Operation_Create) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_Create)
	if !ok {
		that2, ok := that.(Offer_Operation_Create)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_Create")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_Create but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_Create but is not nil && this == nil")
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return fmt.Errorf("Volumes this(%v) Not Equal that(%v)", len(this.Volumes), len(that1.Volumes))
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(&that1.Volumes[i]) {
			return fmt.Errorf("Volumes this[%v](%v) Not Equal that[%v](%v)", i, this.Volumes[i], i, that1.Volumes[i])
		}
	}
	return nil
}
func (this *Offer_Operation_Create) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_Create)
	if !ok {
		that2, ok := that.(Offer_Operation_Create)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(&that1.Volumes[i]) {
			return false
		}
	}
	return true
}
func (this *Offer_Operation_Destroy) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_Destroy)
	if !ok {
		that2, ok := that.(Offer_Operation_Destroy)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_Destroy")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_Destroy but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_Destroy but is not nil && this == nil")
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return fmt.Errorf("Volumes this(%v) Not Equal that(%v)", len(this.Volumes), len(that1.Volumes))
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(&that1.Volumes[i]) {
			return fmt.Errorf("Volumes this[%v](%v) Not Equal that[%v](%v)", i, this.Volumes[i], i, that1.Volumes[i])
		}
	}
	return nil
}
func (this *Offer_Operation_Destroy) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_Destroy)
	if !ok {
		that2, ok := that.(Offer_Operation_Destroy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(&that1.Volumes[i]) {
			return false
		}
	}
	return true
}
func (this *Offer_Operation_GrowVolume) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_GrowVolume)
	if !ok {
		that2, ok := that.(Offer_Operation_GrowVolume)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_GrowVolume")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_GrowVolume but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_GrowVolume but is not nil && this == nil")
	}
	if !this.Volume.Equal(&that1.Volume) {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if !this.Addition.Equal(&that1.Addition) {
		return fmt.Errorf("Addition this(%v) Not Equal that(%v)", this.Addition, that1.Addition)
	}
	return nil
}
func (this *Offer_Operation_GrowVolume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_GrowVolume)
	if !ok {
		that2, ok := that.(Offer_Operation_GrowVolume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Volume.Equal(&that1.Volume) {
		return false
	}
	if !this.Addition.Equal(&that1.Addition) {
		return false
	}
	return true
}
func (this *Offer_Operation_ShrinkVolume) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_ShrinkVolume)
	if !ok {
		that2, ok := that.(Offer_Operation_ShrinkVolume)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_ShrinkVolume")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_ShrinkVolume but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_ShrinkVolume but is not nil && this == nil")
	}
	if !this.Volume.Equal(&that1.Volume) {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if !this.Subtract.Equal(&that1.Subtract) {
		return fmt.Errorf("Subtract this(%v) Not Equal that(%v)", this.Subtract, that1.Subtract)
	}
	return nil
}
func (this *Offer_Operation_ShrinkVolume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_ShrinkVolume)
	if !ok {
		that2, ok := that.(Offer_Operation_ShrinkVolume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Volume.Equal(&that1.Volume) {
		return false
	}
	if !this.Subtract.Equal(&that1.Subtract) {
		return false
	}
	return true
}
func (this *Offer_Operation_CreateDisk) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_CreateDisk)
	if !ok {
		that2, ok := that.(Offer_Operation_CreateDisk)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_CreateDisk")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_CreateDisk but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_CreateDisk but is not nil && this == nil")
	}
	if !this.Source.Equal(&that1.Source) {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	if this.TargetType != that1.TargetType {
		return fmt.Errorf("TargetType this(%v) Not Equal that(%v)", this.TargetType, that1.TargetType)
	}
	return nil
}
func (this *Offer_Operation_CreateDisk) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_CreateDisk)
	if !ok {
		that2, ok := that.(Offer_Operation_CreateDisk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Source.Equal(&that1.Source) {
		return false
	}
	if this.TargetType != that1.TargetType {
		return false
	}
	return true
}
func (this *Offer_Operation_DestroyDisk) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Offer_Operation_DestroyDisk)
	if !ok {
		that2, ok := that.(Offer_Operation_DestroyDisk)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Offer_Operation_DestroyDisk")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Offer_Operation_DestroyDisk but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Offer_Operation_DestroyDisk but is not nil && this == nil")
	}
	if !this.Source.Equal(&that1.Source) {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	return nil
}
func (this *Offer_Operation_DestroyDisk) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Offer_Operation_DestroyDisk)
	if !ok {
		that2, ok := that.(Offer_Operation_DestroyDisk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Source.Equal(&that1.Source) {
		return false
	}
	return true
}
func (this *InverseOffer) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*InverseOffer)
	if !ok {
		that2, ok := that.(InverseOffer)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *InverseOffer")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *InverseOffer but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *InverseOffer but is not nil && this == nil")
	}
	if !this.OfferID.Equal(&that1.OfferID) {
		return fmt.Errorf("OfferID this(%v) Not Equal that(%v)", this.OfferID, that1.OfferID)
	}
	if !this.URL.Equal(that1.URL) {
		return fmt.Errorf("URL this(%v) Not Equal that(%v)", this.URL, that1.URL)
	}
	if !this.FrameworkID.Equal(&that1.FrameworkID) {
		return fmt.Errorf("FrameworkID this(%v) Not Equal that(%v)", this.FrameworkID, that1.FrameworkID)
	}
	if !this.AgentID.Equal(that1.AgentID) {
		return fmt.Errorf("AgentID this(%v) Not Equal that(%v)", this.AgentID, that1.AgentID)
	}
	if !this.Unavailability.Equal(&that1.Unavailability) {
		return fmt.Errorf("Unavailability this(%v) Not Equal that(%v)", this.Unavailability, that1.Unavailability)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	return nil
}
func (this *InverseOffer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*InverseOffer)
	if !ok {
		that2, ok := that.(InverseOffer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OfferID.Equal(&that1.OfferID) {
		return false
	}
	if !this.URL.Equal(that1.URL) {
		return false
	}
	if !this.FrameworkID.Equal(&that1.FrameworkID) {
		return false
	}
	if !this.AgentID.Equal(that1.AgentID) {
		return false
	}
	if !this.Unavailability.Equal(&that1.Unavailability) {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	return true
}
func (this *TaskInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TaskInfo)
	if !ok {
		that2, ok := that.(TaskInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TaskInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TaskInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TaskInfo but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if !this.TaskID.Equal(&that1.TaskID) {
		return fmt.Errorf("TaskID this(%v) Not Equal that(%v)", this.TaskID, that1.TaskID)
	}
	if !this.AgentID.Equal(&that1.AgentID) {
		return fmt.Errorf("AgentID this(%v) Not Equal that(%v)", this.AgentID, that1.AgentID)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	if !this.Executor.Equal(that1.Executor) {
		return fmt.Errorf("Executor this(%v) Not Equal that(%v)", this.Executor, that1.Executor)
	}
	if !this.Command.Equal(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	if !this.Container.Equal(that1.Container) {
		return fmt.Errorf("Container this(%v) Not Equal that(%v)", this.Container, that1.Container)
	}
	if !this.HealthCheck.Equal(that1.HealthCheck) {
		return fmt.Errorf("HealthCheck this(%v) Not Equal that(%v)", this.HealthCheck, that1.HealthCheck)
	}
	if !this.Check.Equal(that1.Check) {
		return fmt.Errorf("Check this(%v) Not Equal that(%v)", this.Check, that1.Check)
	}
	if !this.KillPolicy.Equal(that1.KillPolicy) {
		return fmt.Errorf("KillPolicy this(%v) Not Equal that(%v)", this.KillPolicy, that1.KillPolicy)
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	if !this.Discovery.Equal(that1.Discovery) {
		return fmt.Errorf("Discovery this(%v) Not Equal that(%v)", this.Discovery, that1.Discovery)
	}
	if !this.MaxCompletionTime.Equal(that1.MaxCompletionTime) {
		return fmt.Errorf("MaxCompletionTime this(%v) Not Equal that(%v)", this.MaxCompletionTime, that1.MaxCompletionTime)
	}
	return nil
}
func (this *TaskInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TaskInfo)
	if !ok {
		that2, ok := that.(TaskInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.TaskID.Equal(&that1.TaskID) {
		return false
	}
	if !this.AgentID.Equal(&that1.AgentID) {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	if !this.Executor.Equal(that1.Executor) {
		return false
	}
	if !this.Command.Equal(that1.Command) {
		return false
	}
	if !this.Container.Equal(that1.Container) {
		return false
	}
	if !this.HealthCheck.Equal(that1.HealthCheck) {
		return false
	}
	if !this.Check.Equal(that1.Check) {
		return false
	}
	if !this.KillPolicy.Equal(that1.KillPolicy) {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	if !this.Discovery.Equal(that1.Discovery) {
		return false
	}
	if !this.MaxCompletionTime.Equal(that1.MaxCompletionTime) {
		return false
	}
	return true
}
func (this *TaskGroupInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TaskGroupInfo)
	if !ok {
		that2, ok := that.(TaskGroupInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TaskGroupInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TaskGroupInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TaskGroupInfo but is not nil && this == nil")
	}
	if len(this.Tasks) != len(that1.Tasks) {
		return fmt.Errorf("Tasks this(%v) Not Equal that(%v)", len(this.Tasks), len(that1.Tasks))
	}
	for i := range this.Tasks {
		if !this.Tasks[i].Equal(&that1.Tasks[i]) {
			return fmt.Errorf("Tasks this[%v](%v) Not Equal that[%v](%v)", i, this.Tasks[i], i, that1.Tasks[i])
		}
	}
	return nil
}
func (this *TaskGroupInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TaskGroupInfo)
	if !ok {
		that2, ok := that.(TaskGroupInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Tasks) != len(that1.Tasks) {
		return false
	}
	for i := range this.Tasks {
		if !this.Tasks[i].Equal(&that1.Tasks[i]) {
			return false
		}
	}
	return true
}
func (this *Task) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Task)
	if !ok {
		that2, ok := that.(Task)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Task")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Task but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Task but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if !this.TaskID.Equal(&that1.TaskID) {
		return fmt.Errorf("TaskID this(%v) Not Equal that(%v)", this.TaskID, that1.TaskID)
	}
	if !this.FrameworkID.Equal(&that1.FrameworkID) {
		return fmt.Errorf("FrameworkID this(%v) Not Equal that(%v)", this.FrameworkID, that1.FrameworkID)
	}
	if !this.ExecutorID.Equal(that1.ExecutorID) {
		return fmt.Errorf("ExecutorID this(%v) Not Equal that(%v)", this.ExecutorID, that1.ExecutorID)
	}
	if !this.AgentID.Equal(&that1.AgentID) {
		return fmt.Errorf("AgentID this(%v) Not Equal that(%v)", this.AgentID, that1.AgentID)
	}
	if this.State != nil && that1.State != nil {
		if *this.State != *that1.State {
			return fmt.Errorf("State this(%v) Not Equal that(%v)", *this.State, *that1.State)
		}
	} else if this.State != nil {
		return fmt.Errorf("this.State == nil && that.State != nil")
	} else if that1.State != nil {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	if len(this.Statuses) != len(that1.Statuses) {
		return fmt.Errorf("Statuses this(%v) Not Equal that(%v)", len(this.Statuses), len(that1.Statuses))
	}
	for i := range this.Statuses {
		if !this.Statuses[i].Equal(&that1.Statuses[i]) {
			return fmt.Errorf("Statuses this[%v](%v) Not Equal that[%v](%v)", i, this.Statuses[i], i, that1.Statuses[i])
		}
	}
	if this.StatusUpdateState != nil && that1.StatusUpdateState != nil {
		if *this.StatusUpdateState != *that1.StatusUpdateState {
			return fmt.Errorf("StatusUpdateState this(%v) Not Equal that(%v)", *this.StatusUpdateState, *that1.StatusUpdateState)
		}
	} else if this.StatusUpdateState != nil {
		return fmt.Errorf("this.StatusUpdateState == nil && that.StatusUpdateState != nil")
	} else if that1.StatusUpdateState != nil {
		return fmt.Errorf("StatusUpdateState this(%v) Not Equal that(%v)", this.StatusUpdateState, that1.StatusUpdateState)
	}
	if !bytes.Equal(this.StatusUpdateUUID, that1.StatusUpdateUUID) {
		return fmt.Errorf("StatusUpdateUUID this(%v) Not Equal that(%v)", this.StatusUpdateUUID, that1.StatusUpdateUUID)
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	if !this.Discovery.Equal(that1.Discovery) {
		return fmt.Errorf("Discovery this(%v) Not Equal that(%v)", this.Discovery, that1.Discovery)
	}
	if !this.Container.Equal(that1.Container) {
		return fmt.Errorf("Container this(%v) Not Equal that(%v)", this.Container, that1.Container)
	}
	if this.User != nil && that1.User != nil {
		if *this.User != *that1.User {
			return fmt.Errorf("User this(%v) Not Equal that(%v)", *this.User, *that1.User)
		}
	} else if this.User != nil {
		return fmt.Errorf("this.User == nil && that.User != nil")
	} else if that1.User != nil {
		return fmt.Errorf("User this(%v) Not Equal that(%v)", this.User, that1.User)
	}
	return nil
}
func (this *Task) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Task)
	if !ok {
		that2, ok := that.(Task)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.TaskID.Equal(&that1.TaskID) {
		return false
	}
	if !this.FrameworkID.Equal(&that1.FrameworkID) {
		return false
	}
	if !this.ExecutorID.Equal(that1.ExecutorID) {
		return false
	}
	if !this.AgentID.Equal(&that1.AgentID) {
		return false
	}
	if this.State != nil && that1.State != nil {
		if *this.State != *that1.State {
			return false
		}
	} else if this.State != nil {
		return false
	} else if that1.State != nil {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	if len(this.Statuses) != len(that1.Statuses) {
		return false
	}
	for i := range this.Statuses {
		if !this.Statuses[i].Equal(&that1.Statuses[i]) {
			return false
		}
	}
	if this.StatusUpdateState != nil && that1.StatusUpdateState != nil {
		if *this.StatusUpdateState != *that1.StatusUpdateState {
			return false
		}
	} else if this.StatusUpdateState != nil {
		return false
	} else if that1.StatusUpdateState != nil {
		return false
	}
	if !bytes.Equal(this.StatusUpdateUUID, that1.StatusUpdateUUID) {
		return false
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	if !this.Discovery.Equal(that1.Discovery) {
		return false
	}
	if !this.Container.Equal(that1.Container) {
		return false
	}
	if this.User != nil && that1.User != nil {
		if *this.User != *that1.User {
			return false
		}
	} else if this.User != nil {
		return false
	} else if that1.User != nil {
		return false
	}
	return true
}
func (this *TaskResourceLimitation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TaskResourceLimitation)
	if !ok {
		that2, ok := that.(TaskResourceLimitation)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TaskResourceLimitation")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TaskResourceLimitation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TaskResourceLimitation but is not nil && this == nil")
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	return nil
}
func (this *TaskResourceLimitation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TaskResourceLimitation)
	if !ok {
		that2, ok := that.(TaskResourceLimitation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	return true
}
func (this *UUID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UUID)
	if !ok {
		that2, ok := that.(UUID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *UUID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UUID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UUID but is not nil && this == nil")
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *UUID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UUID)
	if !ok {
		that2, ok := that.(UUID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	return true
}
func (this *Operation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Operation)
	if !ok {
		that2, ok := that.(Operation)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Operation")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Operation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Operation but is not nil && this == nil")
	}
	if !this.FrameworkID.Equal(that1.FrameworkID) {
		return fmt.Errorf("FrameworkID this(%v) Not Equal that(%v)", this.FrameworkID, that1.FrameworkID)
	}
	if !this.AgentID.Equal(that1.AgentID) {
		return fmt.Errorf("AgentID this(%v) Not Equal that(%v)", this.AgentID, that1.AgentID)
	}
	if !this.Info.Equal(&that1.Info) {
		return fmt.Errorf("Info this(%v) Not Equal that(%v)", this.Info, that1.Info)
	}
	if !this.LatestStatus.Equal(&that1.LatestStatus) {
		return fmt.Errorf("LatestStatus this(%v) Not Equal that(%v)", this.LatestStatus, that1.LatestStatus)
	}
	if len(this.Statuses) != len(that1.Statuses) {
		return fmt.Errorf("Statuses this(%v) Not Equal that(%v)", len(this.Statuses), len(that1.Statuses))
	}
	for i := range this.Statuses {
		if !this.Statuses[i].Equal(&that1.Statuses[i]) {
			return fmt.Errorf("Statuses this[%v](%v) Not Equal that[%v](%v)", i, this.Statuses[i], i, that1.Statuses[i])
		}
	}
	if !this.UUID.Equal(&that1.UUID) {
		return fmt.Errorf("UUID this(%v) Not Equal that(%v)", this.UUID, that1.UUID)
	}
	return nil
}
func (this *Operation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Operation)
	if !ok {
		that2, ok := that.(Operation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.FrameworkID.Equal(that1.FrameworkID) {
		return false
	}
	if !this.AgentID.Equal(that1.AgentID) {
		return false
	}
	if !this.Info.Equal(&that1.Info) {
		return false
	}
	if !this.LatestStatus.Equal(&that1.LatestStatus) {
		return false
	}
	if len(this.Statuses) != len(that1.Statuses) {
		return false
	}
	for i := range this.Statuses {
		if !this.Statuses[i].Equal(&that1.Statuses[i]) {
			return false
		}
	}
	if !this.UUID.Equal(&that1.UUID) {
		return false
	}
	return true
}
func (this *OperationStatus) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OperationStatus)
	if !ok {
		that2, ok := that.(OperationStatus)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OperationStatus")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OperationStatus but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OperationStatus but is not nil && this == nil")
	}
	if !this.OperationID.Equal(that1.OperationID) {
		return fmt.Errorf("OperationID this(%v) Not Equal that(%v)", this.OperationID, that1.OperationID)
	}
	if this.State != that1.State {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if this.Message != nil && that1.Message != nil {
		if *this.Message != *that1.Message {
			return fmt.Errorf("Message this(%v) Not Equal that(%v)", *this.Message, *that1.Message)
		}
	} else if this.Message != nil {
		return fmt.Errorf("this.Message == nil && that.Message != nil")
	} else if that1.Message != nil {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if len(this.ConvertedResources) != len(that1.ConvertedResources) {
		return fmt.Errorf("ConvertedResources this(%v) Not Equal that(%v)", len(this.ConvertedResources), len(that1.ConvertedResources))
	}
	for i := range this.ConvertedResources {
		if !this.ConvertedResources[i].Equal(&that1.ConvertedResources[i]) {
			return fmt.Errorf("ConvertedResources this[%v](%v) Not Equal that[%v](%v)", i, this.ConvertedResources[i], i, that1.ConvertedResources[i])
		}
	}
	if !this.UUID.Equal(that1.UUID) {
		return fmt.Errorf("UUID this(%v) Not Equal that(%v)", this.UUID, that1.UUID)
	}
	return nil
}
func (this *OperationStatus) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OperationStatus)
	if !ok {
		that2, ok := that.(OperationStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.OperationID.Equal(that1.OperationID) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Message != nil && that1.Message != nil {
		if *this.Message != *that1.Message {
			return false
		}
	} else if this.Message != nil {
		return false
	} else if that1.Message != nil {
		return false
	}
	if len(this.ConvertedResources) != len(that1.ConvertedResources) {
		return false
	}
	for i := range this.ConvertedResources {
		if !this.ConvertedResources[i].Equal(&that1.ConvertedResources[i]) {
			return false
		}
	}
	if !this.UUID.Equal(that1.UUID) {
		return false
	}
	return true
}
func (this *CheckStatusInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CheckStatusInfo)
	if !ok {
		that2, ok := that.(CheckStatusInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CheckStatusInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CheckStatusInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CheckStatusInfo but is not nil && this == nil")
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return fmt.Errorf("Type this(%v) Not Equal that(%v)", *this.Type, *that1.Type)
		}
	} else if this.Type != nil {
		return fmt.Errorf("this.Type == nil && that.Type != nil")
	} else if that1.Type != nil {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Command.Equal(that1.Command) {
		return fmt.Errorf("Command this(%v) Not Equal that(%v)", this.Command, that1.Command)
	}
	if !this.HTTP.Equal(that1.HTTP) {
		return fmt.Errorf("HTTP this(%v) Not Equal that(%v)", this.HTTP, that1.HTTP)
	}
	if !this.TCP.Equal(that1.TCP) {
		return fmt.Errorf("TCP this(%v) Not Equal that(%v)", this.TCP, that1.TCP)
	}
	return nil
}
func (this *CheckStatusInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckStatusInfo)
	if !ok {
		that2, ok := that.(CheckStatusInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if !this.Command.Equal(that1.Command) {
		return false
	}
	if !this.HTTP.Equal(that1.HTTP) {
		return false
	}
	if !this.TCP.Equal(that1.TCP) {
		return false
	}
	return true
}
func (this *CheckStatusInfo_Command) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CheckStatusInfo_Command)
	if !ok {
		that2, ok := that.(CheckStatusInfo_Command)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CheckStatusInfo_Command")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CheckStatusInfo_Command but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CheckStatusInfo_Command but is not nil && this == nil")
	}
	if this.ExitCode != nil && that1.ExitCode != nil {
		if *this.ExitCode != *that1.ExitCode {
			return fmt.Errorf("ExitCode this(%v) Not Equal that(%v)", *this.ExitCode, *that1.ExitCode)
		}
	} else if this.ExitCode != nil {
		return fmt.Errorf("this.ExitCode == nil && that.ExitCode != nil")
	} else if that1.ExitCode != nil {
		return fmt.Errorf("ExitCode this(%v) Not Equal that(%v)", this.ExitCode, that1.ExitCode)
	}
	return nil
}
func (this *CheckStatusInfo_Command) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckStatusInfo_Command)
	if !ok {
		that2, ok := that.(CheckStatusInfo_Command)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ExitCode != nil && that1.ExitCode != nil {
		if *this.ExitCode != *that1.ExitCode {
			return false
		}
	} else if this.ExitCode != nil {
		return false
	} else if that1.ExitCode != nil {
		return false
	}
	return true
}
func (this *CheckStatusInfo_Http) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CheckStatusInfo_Http)
	if !ok {
		that2, ok := that.(CheckStatusInfo_Http)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CheckStatusInfo_Http")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CheckStatusInfo_Http but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CheckStatusInfo_Http but is not nil && this == nil")
	}
	if this.StatusCode != nil && that1.StatusCode != nil {
		if *this.StatusCode != *that1.StatusCode {
			return fmt.Errorf("StatusCode this(%v) Not Equal that(%v)", *this.StatusCode, *that1.StatusCode)
		}
	} else if this.StatusCode != nil {
		return fmt.Errorf("this.StatusCode == nil && that.StatusCode != nil")
	} else if that1.StatusCode != nil {
		return fmt.Errorf("StatusCode this(%v) Not Equal that(%v)", this.StatusCode, that1.StatusCode)
	}
	return nil
}
func (this *CheckStatusInfo_Http) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckStatusInfo_Http)
	if !ok {
		that2, ok := that.(CheckStatusInfo_Http)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.StatusCode != nil && that1.StatusCode != nil {
		if *this.StatusCode != *that1.StatusCode {
			return false
		}
	} else if this.StatusCode != nil {
		return false
	} else if that1.StatusCode != nil {
		return false
	}
	return true
}
func (this *CheckStatusInfo_Tcp) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CheckStatusInfo_Tcp)
	if !ok {
		that2, ok := that.(CheckStatusInfo_Tcp)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CheckStatusInfo_Tcp")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CheckStatusInfo_Tcp but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CheckStatusInfo_Tcp but is not nil && this == nil")
	}
	if this.Succeeded != nil && that1.Succeeded != nil {
		if *this.Succeeded != *that1.Succeeded {
			return fmt.Errorf("Succeeded this(%v) Not Equal that(%v)", *this.Succeeded, *that1.Succeeded)
		}
	} else if this.Succeeded != nil {
		return fmt.Errorf("this.Succeeded == nil && that.Succeeded != nil")
	} else if that1.Succeeded != nil {
		return fmt.Errorf("Succeeded this(%v) Not Equal that(%v)", this.Succeeded, that1.Succeeded)
	}
	return nil
}
func (this *CheckStatusInfo_Tcp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckStatusInfo_Tcp)
	if !ok {
		that2, ok := that.(CheckStatusInfo_Tcp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Succeeded != nil && that1.Succeeded != nil {
		if *this.Succeeded != *that1.Succeeded {
			return false
		}
	} else if this.Succeeded != nil {
		return false
	} else if that1.Succeeded != nil {
		return false
	}
	return true
}
func (this *TaskStatus) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TaskStatus)
	if !ok {
		that2, ok := that.(TaskStatus)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TaskStatus")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TaskStatus but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TaskStatus but is not nil && this == nil")
	}
	if !this.TaskID.Equal(&that1.TaskID) {
		return fmt.Errorf("TaskID this(%v) Not Equal that(%v)", this.TaskID, that1.TaskID)
	}
	if this.State != nil && that1.State != nil {
		if *this.State != *that1.State {
			return fmt.Errorf("State this(%v) Not Equal that(%v)", *this.State, *that1.State)
		}
	} else if this.State != nil {
		return fmt.Errorf("this.State == nil && that.State != nil")
	} else if that1.State != nil {
		return fmt.Errorf("State this(%v) Not Equal that(%v)", this.State, that1.State)
	}
	if this.Message != nil && that1.Message != nil {
		if *this.Message != *that1.Message {
			return fmt.Errorf("Message this(%v) Not Equal that(%v)", *this.Message, *that1.Message)
		}
	} else if this.Message != nil {
		return fmt.Errorf("this.Message == nil && that.Message != nil")
	} else if that1.Message != nil {
		return fmt.Errorf("Message this(%v) Not Equal that(%v)", this.Message, that1.Message)
	}
	if this.Source != nil && that1.Source != nil {
		if *this.Source != *that1.Source {
			return fmt.Errorf("Source this(%v) Not Equal that(%v)", *this.Source, *that1.Source)
		}
	} else if this.Source != nil {
		return fmt.Errorf("this.Source == nil && that.Source != nil")
	} else if that1.Source != nil {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	if this.Reason != nil && that1.Reason != nil {
		if *this.Reason != *that1.Reason {
			return fmt.Errorf("Reason this(%v) Not Equal that(%v)", *this.Reason, *that1.Reason)
		}
	} else if this.Reason != nil {
		return fmt.Errorf("this.Reason == nil && that.Reason != nil")
	} else if that1.Reason != nil {
		return fmt.Errorf("Reason this(%v) Not Equal that(%v)", this.Reason, that1.Reason)
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if !this.AgentID.Equal(that1.AgentID) {
		return fmt.Errorf("AgentID this(%v) Not Equal that(%v)", this.AgentID, that1.AgentID)
	}
	if !this.ExecutorID.Equal(that1.ExecutorID) {
		return fmt.Errorf("ExecutorID this(%v) Not Equal that(%v)", this.ExecutorID, that1.ExecutorID)
	}
	if this.Timestamp != nil && that1.Timestamp != nil {
		if *this.Timestamp != *that1.Timestamp {
			return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", *this.Timestamp, *that1.Timestamp)
		}
	} else if this.Timestamp != nil {
		return fmt.Errorf("this.Timestamp == nil && that.Timestamp != nil")
	} else if that1.Timestamp != nil {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if !bytes.Equal(this.UUID, that1.UUID) {
		return fmt.Errorf("UUID this(%v) Not Equal that(%v)", this.UUID, that1.UUID)
	}
	if this.Healthy != nil && that1.Healthy != nil {
		if *this.Healthy != *that1.Healthy {
			return fmt.Errorf("Healthy this(%v) Not Equal that(%v)", *this.Healthy, *that1.Healthy)
		}
	} else if this.Healthy != nil {
		return fmt.Errorf("this.Healthy == nil && that.Healthy != nil")
	} else if that1.Healthy != nil {
		return fmt.Errorf("Healthy this(%v) Not Equal that(%v)", this.Healthy, that1.Healthy)
	}
	if !this.CheckStatus.Equal(that1.CheckStatus) {
		return fmt.Errorf("CheckStatus this(%v) Not Equal that(%v)", this.CheckStatus, that1.CheckStatus)
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	if !this.ContainerStatus.Equal(that1.ContainerStatus) {
		return fmt.Errorf("ContainerStatus this(%v) Not Equal that(%v)", this.ContainerStatus, that1.ContainerStatus)
	}
	if !this.UnreachableTime.Equal(that1.UnreachableTime) {
		return fmt.Errorf("UnreachableTime this(%v) Not Equal that(%v)", this.UnreachableTime, that1.UnreachableTime)
	}
	if !this.Limitation.Equal(that1.Limitation) {
		return fmt.Errorf("Limitation this(%v) Not Equal that(%v)", this.Limitation, that1.Limitation)
	}
	return nil
}
func (this *TaskStatus) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TaskStatus)
	if !ok {
		that2, ok := that.(TaskStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.TaskID.Equal(&that1.TaskID) {
		return false
	}
	if this.State != nil && that1.State != nil {
		if *this.State != *that1.State {
			return false
		}
	} else if this.State != nil {
		return false
	} else if that1.State != nil {
		return false
	}
	if this.Message != nil && that1.Message != nil {
		if *this.Message != *that1.Message {
			return false
		}
	} else if this.Message != nil {
		return false
	} else if that1.Message != nil {
		return false
	}
	if this.Source != nil && that1.Source != nil {
		if *this.Source != *that1.Source {
			return false
		}
	} else if this.Source != nil {
		return false
	} else if that1.Source != nil {
		return false
	}
	if this.Reason != nil && that1.Reason != nil {
		if *this.Reason != *that1.Reason {
			return false
		}
	} else if this.Reason != nil {
		return false
	} else if that1.Reason != nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if !this.AgentID.Equal(that1.AgentID) {
		return false
	}
	if !this.ExecutorID.Equal(that1.ExecutorID) {
		return false
	}
	if this.Timestamp != nil && that1.Timestamp != nil {
		if *this.Timestamp != *that1.Timestamp {
			return false
		}
	} else if this.Timestamp != nil {
		return false
	} else if that1.Timestamp != nil {
		return false
	}
	if !bytes.Equal(this.UUID, that1.UUID) {
		return false
	}
	if this.Healthy != nil && that1.Healthy != nil {
		if *this.Healthy != *that1.Healthy {
			return false
		}
	} else if this.Healthy != nil {
		return false
	} else if that1.Healthy != nil {
		return false
	}
	if !this.CheckStatus.Equal(that1.CheckStatus) {
		return false
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	if !this.ContainerStatus.Equal(that1.ContainerStatus) {
		return false
	}
	if !this.UnreachableTime.Equal(that1.UnreachableTime) {
		return false
	}
	if !this.Limitation.Equal(that1.Limitation) {
		return false
	}
	return true
}
func (this *Filters) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Filters)
	if !ok {
		that2, ok := that.(Filters)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Filters")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Filters but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Filters but is not nil && this == nil")
	}
	if this.RefuseSeconds != nil && that1.RefuseSeconds != nil {
		if *this.RefuseSeconds != *that1.RefuseSeconds {
			return fmt.Errorf("RefuseSeconds this(%v) Not Equal that(%v)", *this.RefuseSeconds, *that1.RefuseSeconds)
		}
	} else if this.RefuseSeconds != nil {
		return fmt.Errorf("this.RefuseSeconds == nil && that.RefuseSeconds != nil")
	} else if that1.RefuseSeconds != nil {
		return fmt.Errorf("RefuseSeconds this(%v) Not Equal that(%v)", this.RefuseSeconds, that1.RefuseSeconds)
	}
	return nil
}
func (this *Filters) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Filters)
	if !ok {
		that2, ok := that.(Filters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.RefuseSeconds != nil && that1.RefuseSeconds != nil {
		if *this.RefuseSeconds != *that1.RefuseSeconds {
			return false
		}
	} else if this.RefuseSeconds != nil {
		return false
	} else if that1.RefuseSeconds != nil {
		return false
	}
	return true
}
func (this *Environment) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Environment)
	if !ok {
		that2, ok := that.(Environment)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Environment")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Environment but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Environment but is not nil && this == nil")
	}
	if len(this.Variables) != len(that1.Variables) {
		return fmt.Errorf("Variables this(%v) Not Equal that(%v)", len(this.Variables), len(that1.Variables))
	}
	for i := range this.Variables {
		if !this.Variables[i].Equal(&that1.Variables[i]) {
			return fmt.Errorf("Variables this[%v](%v) Not Equal that[%v](%v)", i, this.Variables[i], i, that1.Variables[i])
		}
	}
	return nil
}
func (this *Environment) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Environment)
	if !ok {
		that2, ok := that.(Environment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Variables) != len(that1.Variables) {
		return false
	}
	for i := range this.Variables {
		if !this.Variables[i].Equal(&that1.Variables[i]) {
			return false
		}
	}
	return true
}
func (this *Environment_Variable) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Environment_Variable)
	if !ok {
		that2, ok := that.(Environment_Variable)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Environment_Variable")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Environment_Variable but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Environment_Variable but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return fmt.Errorf("Type this(%v) Not Equal that(%v)", *this.Type, *that1.Type)
		}
	} else if this.Type != nil {
		return fmt.Errorf("this.Type == nil && that.Type != nil")
	} else if that1.Type != nil {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return fmt.Errorf("Value this(%v) Not Equal that(%v)", *this.Value, *that1.Value)
		}
	} else if this.Value != nil {
		return fmt.Errorf("this.Value == nil && that.Value != nil")
	} else if that1.Value != nil {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if !this.Secret.Equal(that1.Secret) {
		return fmt.Errorf("Secret this(%v) Not Equal that(%v)", this.Secret, that1.Secret)
	}
	return nil
}
func (this *Environment_Variable) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Environment_Variable)
	if !ok {
		that2, ok := that.(Environment_Variable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	if !this.Secret.Equal(that1.Secret) {
		return false
	}
	return true
}
func (this *Parameter) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Parameter)
	if !ok {
		that2, ok := that.(Parameter)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Parameter")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Parameter but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Parameter but is not nil && this == nil")
	}
	if this.Key != that1.Key {
		return fmt.Errorf("Key this(%v) Not Equal that(%v)", this.Key, that1.Key)
	}
	if this.Value != that1.Value {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Parameter) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Parameter)
	if !ok {
		that2, ok := that.(Parameter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *Parameters) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Parameters)
	if !ok {
		that2, ok := that.(Parameters)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Parameters")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Parameters but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Parameters but is not nil && this == nil")
	}
	if len(this.Parameter) != len(that1.Parameter) {
		return fmt.Errorf("Parameter this(%v) Not Equal that(%v)", len(this.Parameter), len(that1.Parameter))
	}
	for i := range this.Parameter {
		if !this.Parameter[i].Equal(&that1.Parameter[i]) {
			return fmt.Errorf("Parameter this[%v](%v) Not Equal that[%v](%v)", i, this.Parameter[i], i, that1.Parameter[i])
		}
	}
	return nil
}
func (this *Parameters) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Parameters)
	if !ok {
		that2, ok := that.(Parameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Parameter) != len(that1.Parameter) {
		return false
	}
	for i := range this.Parameter {
		if !this.Parameter[i].Equal(&that1.Parameter[i]) {
			return false
		}
	}
	return true
}
func (this *Credential) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Credential)
	if !ok {
		that2, ok := that.(Credential)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Credential")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Credential but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Credential but is not nil && this == nil")
	}
	if this.Principal != that1.Principal {
		return fmt.Errorf("Principal this(%v) Not Equal that(%v)", this.Principal, that1.Principal)
	}
	if this.Secret != nil && that1.Secret != nil {
		if *this.Secret != *that1.Secret {
			return fmt.Errorf("Secret this(%v) Not Equal that(%v)", *this.Secret, *that1.Secret)
		}
	} else if this.Secret != nil {
		return fmt.Errorf("this.Secret == nil && that.Secret != nil")
	} else if that1.Secret != nil {
		return fmt.Errorf("Secret this(%v) Not Equal that(%v)", this.Secret, that1.Secret)
	}
	return nil
}
func (this *Credential) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Credential)
	if !ok {
		that2, ok := that.(Credential)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Principal != that1.Principal {
		return false
	}
	if this.Secret != nil && that1.Secret != nil {
		if *this.Secret != *that1.Secret {
			return false
		}
	} else if this.Secret != nil {
		return false
	} else if that1.Secret != nil {
		return false
	}
	return true
}
func (this *Credentials) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Credentials)
	if !ok {
		that2, ok := that.(Credentials)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Credentials")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Credentials but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Credentials but is not nil && this == nil")
	}
	if len(this.Credentials) != len(that1.Credentials) {
		return fmt.Errorf("Credentials this(%v) Not Equal that(%v)", len(this.Credentials), len(that1.Credentials))
	}
	for i := range this.Credentials {
		if !this.Credentials[i].Equal(&that1.Credentials[i]) {
			return fmt.Errorf("Credentials this[%v](%v) Not Equal that[%v](%v)", i, this.Credentials[i], i, that1.Credentials[i])
		}
	}
	return nil
}
func (this *Credentials) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Credentials)
	if !ok {
		that2, ok := that.(Credentials)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Credentials) != len(that1.Credentials) {
		return false
	}
	for i := range this.Credentials {
		if !this.Credentials[i].Equal(&that1.Credentials[i]) {
			return false
		}
	}
	return true
}
func (this *Secret) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Secret)
	if !ok {
		that2, ok := that.(Secret)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Secret")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Secret but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Secret but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Reference.Equal(that1.Reference) {
		return fmt.Errorf("Reference this(%v) Not Equal that(%v)", this.Reference, that1.Reference)
	}
	if !this.Value.Equal(that1.Value) {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Secret) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Secret)
	if !ok {
		that2, ok := that.(Secret)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Reference.Equal(that1.Reference) {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Secret_Reference) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Secret_Reference)
	if !ok {
		that2, ok := that.(Secret_Reference)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Secret_Reference")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Secret_Reference but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Secret_Reference but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Key != nil && that1.Key != nil {
		if *this.Key != *that1.Key {
			return fmt.Errorf("Key this(%v) Not Equal that(%v)", *this.Key, *that1.Key)
		}
	} else if this.Key != nil {
		return fmt.Errorf("this.Key == nil && that.Key != nil")
	} else if that1.Key != nil {
		return fmt.Errorf("Key this(%v) Not Equal that(%v)", this.Key, that1.Key)
	}
	return nil
}
func (this *Secret_Reference) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Secret_Reference)
	if !ok {
		that2, ok := that.(Secret_Reference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Key != nil && that1.Key != nil {
		if *this.Key != *that1.Key {
			return false
		}
	} else if this.Key != nil {
		return false
	} else if that1.Key != nil {
		return false
	}
	return true
}
func (this *Secret_Value) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Secret_Value)
	if !ok {
		that2, ok := that.(Secret_Value)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Secret_Value")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Secret_Value but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Secret_Value but is not nil && this == nil")
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	return nil
}
func (this *Secret_Value) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Secret_Value)
	if !ok {
		that2, ok := that.(Secret_Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *RateLimit) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RateLimit)
	if !ok {
		that2, ok := that.(RateLimit)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RateLimit")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RateLimit but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RateLimit but is not nil && this == nil")
	}
	if this.QPS != nil && that1.QPS != nil {
		if *this.QPS != *that1.QPS {
			return fmt.Errorf("QPS this(%v) Not Equal that(%v)", *this.QPS, *that1.QPS)
		}
	} else if this.QPS != nil {
		return fmt.Errorf("this.QPS == nil && that.QPS != nil")
	} else if that1.QPS != nil {
		return fmt.Errorf("QPS this(%v) Not Equal that(%v)", this.QPS, that1.QPS)
	}
	if this.Principal != that1.Principal {
		return fmt.Errorf("Principal this(%v) Not Equal that(%v)", this.Principal, that1.Principal)
	}
	if this.Capacity != nil && that1.Capacity != nil {
		if *this.Capacity != *that1.Capacity {
			return fmt.Errorf("Capacity this(%v) Not Equal that(%v)", *this.Capacity, *that1.Capacity)
		}
	} else if this.Capacity != nil {
		return fmt.Errorf("this.Capacity == nil && that.Capacity != nil")
	} else if that1.Capacity != nil {
		return fmt.Errorf("Capacity this(%v) Not Equal that(%v)", this.Capacity, that1.Capacity)
	}
	return nil
}
func (this *RateLimit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RateLimit)
	if !ok {
		that2, ok := that.(RateLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.QPS != nil && that1.QPS != nil {
		if *this.QPS != *that1.QPS {
			return false
		}
	} else if this.QPS != nil {
		return false
	} else if that1.QPS != nil {
		return false
	}
	if this.Principal != that1.Principal {
		return false
	}
	if this.Capacity != nil && that1.Capacity != nil {
		if *this.Capacity != *that1.Capacity {
			return false
		}
	} else if this.Capacity != nil {
		return false
	} else if that1.Capacity != nil {
		return false
	}
	return true
}
func (this *RateLimits) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RateLimits)
	if !ok {
		that2, ok := that.(RateLimits)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RateLimits")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RateLimits but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RateLimits but is not nil && this == nil")
	}
	if len(this.Limits) != len(that1.Limits) {
		return fmt.Errorf("Limits this(%v) Not Equal that(%v)", len(this.Limits), len(that1.Limits))
	}
	for i := range this.Limits {
		if !this.Limits[i].Equal(&that1.Limits[i]) {
			return fmt.Errorf("Limits this[%v](%v) Not Equal that[%v](%v)", i, this.Limits[i], i, that1.Limits[i])
		}
	}
	if this.AggregateDefaultQPS != nil && that1.AggregateDefaultQPS != nil {
		if *this.AggregateDefaultQPS != *that1.AggregateDefaultQPS {
			return fmt.Errorf("AggregateDefaultQPS this(%v) Not Equal that(%v)", *this.AggregateDefaultQPS, *that1.AggregateDefaultQPS)
		}
	} else if this.AggregateDefaultQPS != nil {
		return fmt.Errorf("this.AggregateDefaultQPS == nil && that.AggregateDefaultQPS != nil")
	} else if that1.AggregateDefaultQPS != nil {
		return fmt.Errorf("AggregateDefaultQPS this(%v) Not Equal that(%v)", this.AggregateDefaultQPS, that1.AggregateDefaultQPS)
	}
	if this.AggregateDefaultCapacity != nil && that1.AggregateDefaultCapacity != nil {
		if *this.AggregateDefaultCapacity != *that1.AggregateDefaultCapacity {
			return fmt.Errorf("AggregateDefaultCapacity this(%v) Not Equal that(%v)", *this.AggregateDefaultCapacity, *that1.AggregateDefaultCapacity)
		}
	} else if this.AggregateDefaultCapacity != nil {
		return fmt.Errorf("this.AggregateDefaultCapacity == nil && that.AggregateDefaultCapacity != nil")
	} else if that1.AggregateDefaultCapacity != nil {
		return fmt.Errorf("AggregateDefaultCapacity this(%v) Not Equal that(%v)", this.AggregateDefaultCapacity, that1.AggregateDefaultCapacity)
	}
	return nil
}
func (this *RateLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RateLimits)
	if !ok {
		that2, ok := that.(RateLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Limits) != len(that1.Limits) {
		return false
	}
	for i := range this.Limits {
		if !this.Limits[i].Equal(&that1.Limits[i]) {
			return false
		}
	}
	if this.AggregateDefaultQPS != nil && that1.AggregateDefaultQPS != nil {
		if *this.AggregateDefaultQPS != *that1.AggregateDefaultQPS {
			return false
		}
	} else if this.AggregateDefaultQPS != nil {
		return false
	} else if that1.AggregateDefaultQPS != nil {
		return false
	}
	if this.AggregateDefaultCapacity != nil && that1.AggregateDefaultCapacity != nil {
		if *this.AggregateDefaultCapacity != *that1.AggregateDefaultCapacity {
			return false
		}
	} else if this.AggregateDefaultCapacity != nil {
		return false
	} else if that1.AggregateDefaultCapacity != nil {
		return false
	}
	return true
}
func (this *Image) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Image)
	if !ok {
		that2, ok := that.(Image)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Image")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Image but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Image but is not nil && this == nil")
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return fmt.Errorf("Type this(%v) Not Equal that(%v)", *this.Type, *that1.Type)
		}
	} else if this.Type != nil {
		return fmt.Errorf("this.Type == nil && that.Type != nil")
	} else if that1.Type != nil {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.Appc.Equal(that1.Appc) {
		return fmt.Errorf("Appc this(%v) Not Equal that(%v)", this.Appc, that1.Appc)
	}
	if !this.Docker.Equal(that1.Docker) {
		return fmt.Errorf("Docker this(%v) Not Equal that(%v)", this.Docker, that1.Docker)
	}
	if this.Cached != nil && that1.Cached != nil {
		if *this.Cached != *that1.Cached {
			return fmt.Errorf("Cached this(%v) Not Equal that(%v)", *this.Cached, *that1.Cached)
		}
	} else if this.Cached != nil {
		return fmt.Errorf("this.Cached == nil && that.Cached != nil")
	} else if that1.Cached != nil {
		return fmt.Errorf("Cached this(%v) Not Equal that(%v)", this.Cached, that1.Cached)
	}
	return nil
}
func (this *Image) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Image)
	if !ok {
		that2, ok := that.(Image)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if !this.Appc.Equal(that1.Appc) {
		return false
	}
	if !this.Docker.Equal(that1.Docker) {
		return false
	}
	if this.Cached != nil && that1.Cached != nil {
		if *this.Cached != *that1.Cached {
			return false
		}
	} else if this.Cached != nil {
		return false
	} else if that1.Cached != nil {
		return false
	}
	return true
}
func (this *Image_Appc) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Image_Appc)
	if !ok {
		that2, ok := that.(Image_Appc)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Image_Appc")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Image_Appc but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Image_Appc but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.ID != nil && that1.ID != nil {
		if *this.ID != *that1.ID {
			return fmt.Errorf("ID this(%v) Not Equal that(%v)", *this.ID, *that1.ID)
		}
	} else if this.ID != nil {
		return fmt.Errorf("this.ID == nil && that.ID != nil")
	} else if that1.ID != nil {
		return fmt.Errorf("ID this(%v) Not Equal that(%v)", this.ID, that1.ID)
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	return nil
}
func (this *Image_Appc) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Image_Appc)
	if !ok {
		that2, ok := that.(Image_Appc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ID != nil && that1.ID != nil {
		if *this.ID != *that1.ID {
			return false
		}
	} else if this.ID != nil {
		return false
	} else if that1.ID != nil {
		return false
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	return true
}
func (this *Image_Docker) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Image_Docker)
	if !ok {
		that2, ok := that.(Image_Docker)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Image_Docker")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Image_Docker but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Image_Docker but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if !this.Credential.Equal(that1.Credential) {
		return fmt.Errorf("Credential this(%v) Not Equal that(%v)", this.Credential, that1.Credential)
	}
	if !this.Config.Equal(that1.Config) {
		return fmt.Errorf("Config this(%v) Not Equal that(%v)", this.Config, that1.Config)
	}
	return nil
}
func (this *Image_Docker) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Image_Docker)
	if !ok {
		that2, ok := that.(Image_Docker)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Credential.Equal(that1.Credential) {
		return false
	}
	if !this.Config.Equal(that1.Config) {
		return false
	}
	return true
}
func (this *MountPropagation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MountPropagation)
	if !ok {
		that2, ok := that.(MountPropagation)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MountPropagation")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MountPropagation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MountPropagation but is not nil && this == nil")
	}
	if this.Mode != nil && that1.Mode != nil {
		if *this.Mode != *that1.Mode {
			return fmt.Errorf("Mode this(%v) Not Equal that(%v)", *this.Mode, *that1.Mode)
		}
	} else if this.Mode != nil {
		return fmt.Errorf("this.Mode == nil && that.Mode != nil")
	} else if that1.Mode != nil {
		return fmt.Errorf("Mode this(%v) Not Equal that(%v)", this.Mode, that1.Mode)
	}
	return nil
}
func (this *MountPropagation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MountPropagation)
	if !ok {
		that2, ok := that.(MountPropagation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mode != nil && that1.Mode != nil {
		if *this.Mode != *that1.Mode {
			return false
		}
	} else if this.Mode != nil {
		return false
	} else if that1.Mode != nil {
		return false
	}
	return true
}
func (this *Volume) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Volume)
	if !ok {
		that2, ok := that.(Volume)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Volume")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Volume but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Volume but is not nil && this == nil")
	}
	if this.Mode != nil && that1.Mode != nil {
		if *this.Mode != *that1.Mode {
			return fmt.Errorf("Mode this(%v) Not Equal that(%v)", *this.Mode, *that1.Mode)
		}
	} else if this.Mode != nil {
		return fmt.Errorf("this.Mode == nil && that.Mode != nil")
	} else if that1.Mode != nil {
		return fmt.Errorf("Mode this(%v) Not Equal that(%v)", this.Mode, that1.Mode)
	}
	if this.ContainerPath != that1.ContainerPath {
		return fmt.Errorf("ContainerPath this(%v) Not Equal that(%v)", this.ContainerPath, that1.ContainerPath)
	}
	if this.HostPath != nil && that1.HostPath != nil {
		if *this.HostPath != *that1.HostPath {
			return fmt.Errorf("HostPath this(%v) Not Equal that(%v)", *this.HostPath, *that1.HostPath)
		}
	} else if this.HostPath != nil {
		return fmt.Errorf("this.HostPath == nil && that.HostPath != nil")
	} else if that1.HostPath != nil {
		return fmt.Errorf("HostPath this(%v) Not Equal that(%v)", this.HostPath, that1.HostPath)
	}
	if !this.Image.Equal(that1.Image) {
		return fmt.Errorf("Image this(%v) Not Equal that(%v)", this.Image, that1.Image)
	}
	if !this.Source.Equal(that1.Source) {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	return nil
}
func (this *Volume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Volume)
	if !ok {
		that2, ok := that.(Volume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Mode != nil && that1.Mode != nil {
		if *this.Mode != *that1.Mode {
			return false
		}
	} else if this.Mode != nil {
		return false
	} else if that1.Mode != nil {
		return false
	}
	if this.ContainerPath != that1.ContainerPath {
		return false
	}
	if this.HostPath != nil && that1.HostPath != nil {
		if *this.HostPath != *that1.HostPath {
			return false
		}
	} else if this.HostPath != nil {
		return false
	} else if that1.HostPath != nil {
		return false
	}
	if !this.Image.Equal(that1.Image) {
		return false
	}
	if !this.Source.Equal(that1.Source) {
		return false
	}
	return true
}
func (this *Volume_Source) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Volume_Source)
	if !ok {
		that2, ok := that.(Volume_Source)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Volume_Source")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Volume_Source but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Volume_Source but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !this.DockerVolume.Equal(that1.DockerVolume) {
		return fmt.Errorf("DockerVolume this(%v) Not Equal that(%v)", this.DockerVolume, that1.DockerVolume)
	}
	if !this.HostPath.Equal(that1.HostPath) {
		return fmt.Errorf("HostPath this(%v) Not Equal that(%v)", this.HostPath, that1.HostPath)
	}
	if !this.SandboxPath.Equal(that1.SandboxPath) {
		return fmt.Errorf("SandboxPath this(%v) Not Equal that(%v)", this.SandboxPath, that1.SandboxPath)
	}
	if !this.Secret.Equal(that1.Secret) {
		return fmt.Errorf("Secret this(%v) Not Equal that(%v)", this.Secret, that1.Secret)
	}
	return nil
}
func (this *Volume_Source) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Volume_Source)
	if !ok {
		that2, ok := that.(Volume_Source)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.DockerVolume.Equal(that1.DockerVolume) {
		return false
	}
	if !this.HostPath.Equal(that1.HostPath) {
		return false
	}
	if !this.SandboxPath.Equal(that1.SandboxPath) {
		return false
	}
	if !this.Secret.Equal(that1.Secret) {
		return false
	}
	return true
}
func (this *Volume_Source_DockerVolume) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Volume_Source_DockerVolume)
	if !ok {
		that2, ok := that.(Volume_Source_DockerVolume)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Volume_Source_DockerVolume")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Volume_Source_DockerVolume but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Volume_Source_DockerVolume but is not nil && this == nil")
	}
	if this.Driver != nil && that1.Driver != nil {
		if *this.Driver != *that1.Driver {
			return fmt.Errorf("Driver this(%v) Not Equal that(%v)", *this.Driver, *that1.Driver)
		}
	} else if this.Driver != nil {
		return fmt.Errorf("this.Driver == nil && that.Driver != nil")
	} else if that1.Driver != nil {
		return fmt.Errorf("Driver this(%v) Not Equal that(%v)", this.Driver, that1.Driver)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if !this.DriverOptions.Equal(that1.DriverOptions) {
		return fmt.Errorf("DriverOptions this(%v) Not Equal that(%v)", this.DriverOptions, that1.DriverOptions)
	}
	return nil
}
func (this *Volume_Source_DockerVolume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Volume_Source_DockerVolume)
	if !ok {
		that2, ok := that.(Volume_Source_DockerVolume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Driver != nil && that1.Driver != nil {
		if *this.Driver != *that1.Driver {
			return false
		}
	} else if this.Driver != nil {
		return false
	} else if that1.Driver != nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.DriverOptions.Equal(that1.DriverOptions) {
		return false
	}
	return true
}
func (this *Volume_Source_HostPath) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Volume_Source_HostPath)
	if !ok {
		that2, ok := that.(Volume_Source_HostPath)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Volume_Source_HostPath")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Volume_Source_HostPath but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Volume_Source_HostPath but is not nil && this == nil")
	}
	if this.Path != that1.Path {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	if !this.MountPropagation.Equal(that1.MountPropagation) {
		return fmt.Errorf("MountPropagation this(%v) Not Equal that(%v)", this.MountPropagation, that1.MountPropagation)
	}
	return nil
}
func (this *Volume_Source_HostPath) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Volume_Source_HostPath)
	if !ok {
		that2, ok := that.(Volume_Source_HostPath)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if !this.MountPropagation.Equal(that1.MountPropagation) {
		return false
	}
	return true
}
func (this *Volume_Source_SandboxPath) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Volume_Source_SandboxPath)
	if !ok {
		that2, ok := that.(Volume_Source_SandboxPath)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Volume_Source_SandboxPath")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Volume_Source_SandboxPath but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Volume_Source_SandboxPath but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Path != that1.Path {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	return nil
}
func (this *Volume_Source_SandboxPath) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Volume_Source_SandboxPath)
	if !ok {
		that2, ok := that.(Volume_Source_SandboxPath)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *NetworkInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NetworkInfo)
	if !ok {
		that2, ok := that.(NetworkInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *NetworkInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NetworkInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NetworkInfo but is not nil && this == nil")
	}
	if len(this.IPAddresses) != len(that1.IPAddresses) {
		return fmt.Errorf("IPAddresses this(%v) Not Equal that(%v)", len(this.IPAddresses), len(that1.IPAddresses))
	}
	for i := range this.IPAddresses {
		if !this.IPAddresses[i].Equal(&that1.IPAddresses[i]) {
			return fmt.Errorf("IPAddresses this[%v](%v) Not Equal that[%v](%v)", i, this.IPAddresses[i], i, that1.IPAddresses[i])
		}
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return fmt.Errorf("Name this(%v) Not Equal that(%v)", *this.Name, *that1.Name)
		}
	} else if this.Name != nil {
		return fmt.Errorf("this.Name == nil && that.Name != nil")
	} else if that1.Name != nil {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if len(this.Groups) != len(that1.Groups) {
		return fmt.Errorf("Groups this(%v) Not Equal that(%v)", len(this.Groups), len(that1.Groups))
	}
	for i := range this.Groups {
		if this.Groups[i] != that1.Groups[i] {
			return fmt.Errorf("Groups this[%v](%v) Not Equal that[%v](%v)", i, this.Groups[i], i, that1.Groups[i])
		}
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	if len(this.PortMappings) != len(that1.PortMappings) {
		return fmt.Errorf("PortMappings this(%v) Not Equal that(%v)", len(this.PortMappings), len(that1.PortMappings))
	}
	for i := range this.PortMappings {
		if !this.PortMappings[i].Equal(&that1.PortMappings[i]) {
			return fmt.Errorf("PortMappings this[%v](%v) Not Equal that[%v](%v)", i, this.PortMappings[i], i, that1.PortMappings[i])
		}
	}
	return nil
}
func (this *NetworkInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NetworkInfo)
	if !ok {
		that2, ok := that.(NetworkInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.IPAddresses) != len(that1.IPAddresses) {
		return false
	}
	for i := range this.IPAddresses {
		if !this.IPAddresses[i].Equal(&that1.IPAddresses[i]) {
			return false
		}
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if len(this.Groups) != len(that1.Groups) {
		return false
	}
	for i := range this.Groups {
		if this.Groups[i] != that1.Groups[i] {
			return false
		}
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	if len(this.PortMappings) != len(that1.PortMappings) {
		return false
	}
	for i := range this.PortMappings {
		if !this.PortMappings[i].Equal(&that1.PortMappings[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkInfo_IPAddress) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NetworkInfo_IPAddress)
	if !ok {
		that2, ok := that.(NetworkInfo_IPAddress)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *NetworkInfo_IPAddress")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NetworkInfo_IPAddress but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NetworkInfo_IPAddress but is not nil && this == nil")
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", *this.Protocol, *that1.Protocol)
		}
	} else if this.Protocol != nil {
		return fmt.Errorf("this.Protocol == nil && that.Protocol != nil")
	} else if that1.Protocol != nil {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	if this.IPAddress != nil && that1.IPAddress != nil {
		if *this.IPAddress != *that1.IPAddress {
			return fmt.Errorf("IPAddress this(%v) Not Equal that(%v)", *this.IPAddress, *that1.IPAddress)
		}
	} else if this.IPAddress != nil {
		return fmt.Errorf("this.IPAddress == nil && that.IPAddress != nil")
	} else if that1.IPAddress != nil {
		return fmt.Errorf("IPAddress this(%v) Not Equal that(%v)", this.IPAddress, that1.IPAddress)
	}
	return nil
}
func (this *NetworkInfo_IPAddress) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NetworkInfo_IPAddress)
	if !ok {
		that2, ok := that.(NetworkInfo_IPAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return false
		}
	} else if this.Protocol != nil {
		return false
	} else if that1.Protocol != nil {
		return false
	}
	if this.IPAddress != nil && that1.IPAddress != nil {
		if *this.IPAddress != *that1.IPAddress {
			return false
		}
	} else if this.IPAddress != nil {
		return false
	} else if that1.IPAddress != nil {
		return false
	}
	return true
}
func (this *NetworkInfo_PortMapping) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NetworkInfo_PortMapping)
	if !ok {
		that2, ok := that.(NetworkInfo_PortMapping)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *NetworkInfo_PortMapping")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NetworkInfo_PortMapping but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NetworkInfo_PortMapping but is not nil && this == nil")
	}
	if this.HostPort != that1.HostPort {
		return fmt.Errorf("HostPort this(%v) Not Equal that(%v)", this.HostPort, that1.HostPort)
	}
	if this.ContainerPort != that1.ContainerPort {
		return fmt.Errorf("ContainerPort this(%v) Not Equal that(%v)", this.ContainerPort, that1.ContainerPort)
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", *this.Protocol, *that1.Protocol)
		}
	} else if this.Protocol != nil {
		return fmt.Errorf("this.Protocol == nil && that.Protocol != nil")
	} else if that1.Protocol != nil {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	return nil
}
func (this *NetworkInfo_PortMapping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NetworkInfo_PortMapping)
	if !ok {
		that2, ok := that.(NetworkInfo_PortMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return false
		}
	} else if this.Protocol != nil {
		return false
	} else if that1.Protocol != nil {
		return false
	}
	return true
}
func (this *CapabilityInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CapabilityInfo)
	if !ok {
		that2, ok := that.(CapabilityInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CapabilityInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CapabilityInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CapabilityInfo but is not nil && this == nil")
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return fmt.Errorf("Capabilities this(%v) Not Equal that(%v)", len(this.Capabilities), len(that1.Capabilities))
	}
	for i := range this.Capabilities {
		if this.Capabilities[i] != that1.Capabilities[i] {
			return fmt.Errorf("Capabilities this[%v](%v) Not Equal that[%v](%v)", i, this.Capabilities[i], i, that1.Capabilities[i])
		}
	}
	return nil
}
func (this *CapabilityInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CapabilityInfo)
	if !ok {
		that2, ok := that.(CapabilityInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return false
	}
	for i := range this.Capabilities {
		if this.Capabilities[i] != that1.Capabilities[i] {
			return false
		}
	}
	return true
}
func (this *LinuxInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LinuxInfo)
	if !ok {
		that2, ok := that.(LinuxInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *LinuxInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LinuxInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LinuxInfo but is not nil && this == nil")
	}
	if !this.CapabilityInfo.Equal(that1.CapabilityInfo) {
		return fmt.Errorf("CapabilityInfo this(%v) Not Equal that(%v)", this.CapabilityInfo, that1.CapabilityInfo)
	}
	if !this.BoundingCapabilities.Equal(that1.BoundingCapabilities) {
		return fmt.Errorf("BoundingCapabilities this(%v) Not Equal that(%v)", this.BoundingCapabilities, that1.BoundingCapabilities)
	}
	if !this.EffectiveCapabilities.Equal(that1.EffectiveCapabilities) {
		return fmt.Errorf("EffectiveCapabilities this(%v) Not Equal that(%v)", this.EffectiveCapabilities, that1.EffectiveCapabilities)
	}
	if this.SharePIDNamespace != nil && that1.SharePIDNamespace != nil {
		if *this.SharePIDNamespace != *that1.SharePIDNamespace {
			return fmt.Errorf("SharePIDNamespace this(%v) Not Equal that(%v)", *this.SharePIDNamespace, *that1.SharePIDNamespace)
		}
	} else if this.SharePIDNamespace != nil {
		return fmt.Errorf("this.SharePIDNamespace == nil && that.SharePIDNamespace != nil")
	} else if that1.SharePIDNamespace != nil {
		return fmt.Errorf("SharePIDNamespace this(%v) Not Equal that(%v)", this.SharePIDNamespace, that1.SharePIDNamespace)
	}
	return nil
}
func (this *LinuxInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LinuxInfo)
	if !ok {
		that2, ok := that.(LinuxInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CapabilityInfo.Equal(that1.CapabilityInfo) {
		return false
	}
	if !this.BoundingCapabilities.Equal(that1.BoundingCapabilities) {
		return false
	}
	if !this.EffectiveCapabilities.Equal(that1.EffectiveCapabilities) {
		return false
	}
	if this.SharePIDNamespace != nil && that1.SharePIDNamespace != nil {
		if *this.SharePIDNamespace != *that1.SharePIDNamespace {
			return false
		}
	} else if this.SharePIDNamespace != nil {
		return false
	} else if that1.SharePIDNamespace != nil {
		return false
	}
	return true
}
func (this *RLimitInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RLimitInfo)
	if !ok {
		that2, ok := that.(RLimitInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RLimitInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RLimitInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RLimitInfo but is not nil && this == nil")
	}
	if len(this.Rlimits) != len(that1.Rlimits) {
		return fmt.Errorf("Rlimits this(%v) Not Equal that(%v)", len(this.Rlimits), len(that1.Rlimits))
	}
	for i := range this.Rlimits {
		if !this.Rlimits[i].Equal(&that1.Rlimits[i]) {
			return fmt.Errorf("Rlimits this[%v](%v) Not Equal that[%v](%v)", i, this.Rlimits[i], i, that1.Rlimits[i])
		}
	}
	return nil
}
func (this *RLimitInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RLimitInfo)
	if !ok {
		that2, ok := that.(RLimitInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Rlimits) != len(that1.Rlimits) {
		return false
	}
	for i := range this.Rlimits {
		if !this.Rlimits[i].Equal(&that1.Rlimits[i]) {
			return false
		}
	}
	return true
}
func (this *RLimitInfo_RLimit) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RLimitInfo_RLimit)
	if !ok {
		that2, ok := that.(RLimitInfo_RLimit)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RLimitInfo_RLimit")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RLimitInfo_RLimit but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RLimitInfo_RLimit but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Hard != nil && that1.Hard != nil {
		if *this.Hard != *that1.Hard {
			return fmt.Errorf("Hard this(%v) Not Equal that(%v)", *this.Hard, *that1.Hard)
		}
	} else if this.Hard != nil {
		return fmt.Errorf("this.Hard == nil && that.Hard != nil")
	} else if that1.Hard != nil {
		return fmt.Errorf("Hard this(%v) Not Equal that(%v)", this.Hard, that1.Hard)
	}
	if this.Soft != nil && that1.Soft != nil {
		if *this.Soft != *that1.Soft {
			return fmt.Errorf("Soft this(%v) Not Equal that(%v)", *this.Soft, *that1.Soft)
		}
	} else if this.Soft != nil {
		return fmt.Errorf("this.Soft == nil && that.Soft != nil")
	} else if that1.Soft != nil {
		return fmt.Errorf("Soft this(%v) Not Equal that(%v)", this.Soft, that1.Soft)
	}
	return nil
}
func (this *RLimitInfo_RLimit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RLimitInfo_RLimit)
	if !ok {
		that2, ok := that.(RLimitInfo_RLimit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Hard != nil && that1.Hard != nil {
		if *this.Hard != *that1.Hard {
			return false
		}
	} else if this.Hard != nil {
		return false
	} else if that1.Hard != nil {
		return false
	}
	if this.Soft != nil && that1.Soft != nil {
		if *this.Soft != *that1.Soft {
			return false
		}
	} else if this.Soft != nil {
		return false
	} else if that1.Soft != nil {
		return false
	}
	return true
}
func (this *TTYInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TTYInfo)
	if !ok {
		that2, ok := that.(TTYInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TTYInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TTYInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TTYInfo but is not nil && this == nil")
	}
	if !this.WindowSize.Equal(that1.WindowSize) {
		return fmt.Errorf("WindowSize this(%v) Not Equal that(%v)", this.WindowSize, that1.WindowSize)
	}
	return nil
}
func (this *TTYInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TTYInfo)
	if !ok {
		that2, ok := that.(TTYInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.WindowSize.Equal(that1.WindowSize) {
		return false
	}
	return true
}
func (this *TTYInfo_WindowSize) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TTYInfo_WindowSize)
	if !ok {
		that2, ok := that.(TTYInfo_WindowSize)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TTYInfo_WindowSize")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TTYInfo_WindowSize but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TTYInfo_WindowSize but is not nil && this == nil")
	}
	if this.Rows != that1.Rows {
		return fmt.Errorf("Rows this(%v) Not Equal that(%v)", this.Rows, that1.Rows)
	}
	if this.Columns != that1.Columns {
		return fmt.Errorf("Columns this(%v) Not Equal that(%v)", this.Columns, that1.Columns)
	}
	return nil
}
func (this *TTYInfo_WindowSize) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TTYInfo_WindowSize)
	if !ok {
		that2, ok := that.(TTYInfo_WindowSize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Rows != that1.Rows {
		return false
	}
	if this.Columns != that1.Columns {
		return false
	}
	return true
}
func (this *ContainerInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainerInfo)
	if !ok {
		that2, ok := that.(ContainerInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainerInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainerInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainerInfo but is not nil && this == nil")
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return fmt.Errorf("Type this(%v) Not Equal that(%v)", *this.Type, *that1.Type)
		}
	} else if this.Type != nil {
		return fmt.Errorf("this.Type == nil && that.Type != nil")
	} else if that1.Type != nil {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return fmt.Errorf("Volumes this(%v) Not Equal that(%v)", len(this.Volumes), len(that1.Volumes))
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(&that1.Volumes[i]) {
			return fmt.Errorf("Volumes this[%v](%v) Not Equal that[%v](%v)", i, this.Volumes[i], i, that1.Volumes[i])
		}
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", *this.Hostname, *that1.Hostname)
		}
	} else if this.Hostname != nil {
		return fmt.Errorf("this.Hostname == nil && that.Hostname != nil")
	} else if that1.Hostname != nil {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if !this.Docker.Equal(that1.Docker) {
		return fmt.Errorf("Docker this(%v) Not Equal that(%v)", this.Docker, that1.Docker)
	}
	if !this.Mesos.Equal(that1.Mesos) {
		return fmt.Errorf("Mesos this(%v) Not Equal that(%v)", this.Mesos, that1.Mesos)
	}
	if len(this.NetworkInfos) != len(that1.NetworkInfos) {
		return fmt.Errorf("NetworkInfos this(%v) Not Equal that(%v)", len(this.NetworkInfos), len(that1.NetworkInfos))
	}
	for i := range this.NetworkInfos {
		if !this.NetworkInfos[i].Equal(&that1.NetworkInfos[i]) {
			return fmt.Errorf("NetworkInfos this[%v](%v) Not Equal that[%v](%v)", i, this.NetworkInfos[i], i, that1.NetworkInfos[i])
		}
	}
	if !this.LinuxInfo.Equal(that1.LinuxInfo) {
		return fmt.Errorf("LinuxInfo this(%v) Not Equal that(%v)", this.LinuxInfo, that1.LinuxInfo)
	}
	if !this.RlimitInfo.Equal(that1.RlimitInfo) {
		return fmt.Errorf("RlimitInfo this(%v) Not Equal that(%v)", this.RlimitInfo, that1.RlimitInfo)
	}
	if !this.TTYInfo.Equal(that1.TTYInfo) {
		return fmt.Errorf("TTYInfo this(%v) Not Equal that(%v)", this.TTYInfo, that1.TTYInfo)
	}
	return nil
}
func (this *ContainerInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerInfo)
	if !ok {
		that2, ok := that.(ContainerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if !this.Volumes[i].Equal(&that1.Volumes[i]) {
			return false
		}
	}
	if this.Hostname != nil && that1.Hostname != nil {
		if *this.Hostname != *that1.Hostname {
			return false
		}
	} else if this.Hostname != nil {
		return false
	} else if that1.Hostname != nil {
		return false
	}
	if !this.Docker.Equal(that1.Docker) {
		return false
	}
	if !this.Mesos.Equal(that1.Mesos) {
		return false
	}
	if len(this.NetworkInfos) != len(that1.NetworkInfos) {
		return false
	}
	for i := range this.NetworkInfos {
		if !this.NetworkInfos[i].Equal(&that1.NetworkInfos[i]) {
			return false
		}
	}
	if !this.LinuxInfo.Equal(that1.LinuxInfo) {
		return false
	}
	if !this.RlimitInfo.Equal(that1.RlimitInfo) {
		return false
	}
	if !this.TTYInfo.Equal(that1.TTYInfo) {
		return false
	}
	return true
}
func (this *ContainerInfo_DockerInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainerInfo_DockerInfo)
	if !ok {
		that2, ok := that.(ContainerInfo_DockerInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainerInfo_DockerInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainerInfo_DockerInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainerInfo_DockerInfo but is not nil && this == nil")
	}
	if this.Image != that1.Image {
		return fmt.Errorf("Image this(%v) Not Equal that(%v)", this.Image, that1.Image)
	}
	if this.Network != nil && that1.Network != nil {
		if *this.Network != *that1.Network {
			return fmt.Errorf("Network this(%v) Not Equal that(%v)", *this.Network, *that1.Network)
		}
	} else if this.Network != nil {
		return fmt.Errorf("this.Network == nil && that.Network != nil")
	} else if that1.Network != nil {
		return fmt.Errorf("Network this(%v) Not Equal that(%v)", this.Network, that1.Network)
	}
	if len(this.PortMappings) != len(that1.PortMappings) {
		return fmt.Errorf("PortMappings this(%v) Not Equal that(%v)", len(this.PortMappings), len(that1.PortMappings))
	}
	for i := range this.PortMappings {
		if !this.PortMappings[i].Equal(&that1.PortMappings[i]) {
			return fmt.Errorf("PortMappings this[%v](%v) Not Equal that[%v](%v)", i, this.PortMappings[i], i, that1.PortMappings[i])
		}
	}
	if this.Privileged != nil && that1.Privileged != nil {
		if *this.Privileged != *that1.Privileged {
			return fmt.Errorf("Privileged this(%v) Not Equal that(%v)", *this.Privileged, *that1.Privileged)
		}
	} else if this.Privileged != nil {
		return fmt.Errorf("this.Privileged == nil && that.Privileged != nil")
	} else if that1.Privileged != nil {
		return fmt.Errorf("Privileged this(%v) Not Equal that(%v)", this.Privileged, that1.Privileged)
	}
	if len(this.Parameters) != len(that1.Parameters) {
		return fmt.Errorf("Parameters this(%v) Not Equal that(%v)", len(this.Parameters), len(that1.Parameters))
	}
	for i := range this.Parameters {
		if !this.Parameters[i].Equal(&that1.Parameters[i]) {
			return fmt.Errorf("Parameters this[%v](%v) Not Equal that[%v](%v)", i, this.Parameters[i], i, that1.Parameters[i])
		}
	}
	if this.ForcePullImage != nil && that1.ForcePullImage != nil {
		if *this.ForcePullImage != *that1.ForcePullImage {
			return fmt.Errorf("ForcePullImage this(%v) Not Equal that(%v)", *this.ForcePullImage, *that1.ForcePullImage)
		}
	} else if this.ForcePullImage != nil {
		return fmt.Errorf("this.ForcePullImage == nil && that.ForcePullImage != nil")
	} else if that1.ForcePullImage != nil {
		return fmt.Errorf("ForcePullImage this(%v) Not Equal that(%v)", this.ForcePullImage, that1.ForcePullImage)
	}
	if this.VolumeDriver != nil && that1.VolumeDriver != nil {
		if *this.VolumeDriver != *that1.VolumeDriver {
			return fmt.Errorf("VolumeDriver this(%v) Not Equal that(%v)", *this.VolumeDriver, *that1.VolumeDriver)
		}
	} else if this.VolumeDriver != nil {
		return fmt.Errorf("this.VolumeDriver == nil && that.VolumeDriver != nil")
	} else if that1.VolumeDriver != nil {
		return fmt.Errorf("VolumeDriver this(%v) Not Equal that(%v)", this.VolumeDriver, that1.VolumeDriver)
	}
	return nil
}
func (this *ContainerInfo_DockerInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerInfo_DockerInfo)
	if !ok {
		that2, ok := that.(ContainerInfo_DockerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Image != that1.Image {
		return false
	}
	if this.Network != nil && that1.Network != nil {
		if *this.Network != *that1.Network {
			return false
		}
	} else if this.Network != nil {
		return false
	} else if that1.Network != nil {
		return false
	}
	if len(this.PortMappings) != len(that1.PortMappings) {
		return false
	}
	for i := range this.PortMappings {
		if !this.PortMappings[i].Equal(&that1.PortMappings[i]) {
			return false
		}
	}
	if this.Privileged != nil && that1.Privileged != nil {
		if *this.Privileged != *that1.Privileged {
			return false
		}
	} else if this.Privileged != nil {
		return false
	} else if that1.Privileged != nil {
		return false
	}
	if len(this.Parameters) != len(that1.Parameters) {
		return false
	}
	for i := range this.Parameters {
		if !this.Parameters[i].Equal(&that1.Parameters[i]) {
			return false
		}
	}
	if this.ForcePullImage != nil && that1.ForcePullImage != nil {
		if *this.ForcePullImage != *that1.ForcePullImage {
			return false
		}
	} else if this.ForcePullImage != nil {
		return false
	} else if that1.ForcePullImage != nil {
		return false
	}
	if this.VolumeDriver != nil && that1.VolumeDriver != nil {
		if *this.VolumeDriver != *that1.VolumeDriver {
			return false
		}
	} else if this.VolumeDriver != nil {
		return false
	} else if that1.VolumeDriver != nil {
		return false
	}
	return true
}
func (this *ContainerInfo_DockerInfo_PortMapping) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainerInfo_DockerInfo_PortMapping)
	if !ok {
		that2, ok := that.(ContainerInfo_DockerInfo_PortMapping)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainerInfo_DockerInfo_PortMapping")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainerInfo_DockerInfo_PortMapping but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainerInfo_DockerInfo_PortMapping but is not nil && this == nil")
	}
	if this.HostPort != that1.HostPort {
		return fmt.Errorf("HostPort this(%v) Not Equal that(%v)", this.HostPort, that1.HostPort)
	}
	if this.ContainerPort != that1.ContainerPort {
		return fmt.Errorf("ContainerPort this(%v) Not Equal that(%v)", this.ContainerPort, that1.ContainerPort)
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", *this.Protocol, *that1.Protocol)
		}
	} else if this.Protocol != nil {
		return fmt.Errorf("this.Protocol == nil && that.Protocol != nil")
	} else if that1.Protocol != nil {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	return nil
}
func (this *ContainerInfo_DockerInfo_PortMapping) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerInfo_DockerInfo_PortMapping)
	if !ok {
		that2, ok := that.(ContainerInfo_DockerInfo_PortMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return false
		}
	} else if this.Protocol != nil {
		return false
	} else if that1.Protocol != nil {
		return false
	}
	return true
}
func (this *ContainerInfo_MesosInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainerInfo_MesosInfo)
	if !ok {
		that2, ok := that.(ContainerInfo_MesosInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainerInfo_MesosInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainerInfo_MesosInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainerInfo_MesosInfo but is not nil && this == nil")
	}
	if !this.Image.Equal(that1.Image) {
		return fmt.Errorf("Image this(%v) Not Equal that(%v)", this.Image, that1.Image)
	}
	return nil
}
func (this *ContainerInfo_MesosInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerInfo_MesosInfo)
	if !ok {
		that2, ok := that.(ContainerInfo_MesosInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Image.Equal(that1.Image) {
		return false
	}
	return true
}
func (this *ContainerStatus) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainerStatus)
	if !ok {
		that2, ok := that.(ContainerStatus)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainerStatus")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainerStatus but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainerStatus but is not nil && this == nil")
	}
	if !this.ContainerID.Equal(that1.ContainerID) {
		return fmt.Errorf("ContainerID this(%v) Not Equal that(%v)", this.ContainerID, that1.ContainerID)
	}
	if len(this.NetworkInfos) != len(that1.NetworkInfos) {
		return fmt.Errorf("NetworkInfos this(%v) Not Equal that(%v)", len(this.NetworkInfos), len(that1.NetworkInfos))
	}
	for i := range this.NetworkInfos {
		if !this.NetworkInfos[i].Equal(&that1.NetworkInfos[i]) {
			return fmt.Errorf("NetworkInfos this[%v](%v) Not Equal that[%v](%v)", i, this.NetworkInfos[i], i, that1.NetworkInfos[i])
		}
	}
	if !this.CgroupInfo.Equal(that1.CgroupInfo) {
		return fmt.Errorf("CgroupInfo this(%v) Not Equal that(%v)", this.CgroupInfo, that1.CgroupInfo)
	}
	if this.ExecutorPID != nil && that1.ExecutorPID != nil {
		if *this.ExecutorPID != *that1.ExecutorPID {
			return fmt.Errorf("ExecutorPID this(%v) Not Equal that(%v)", *this.ExecutorPID, *that1.ExecutorPID)
		}
	} else if this.ExecutorPID != nil {
		return fmt.Errorf("this.ExecutorPID == nil && that.ExecutorPID != nil")
	} else if that1.ExecutorPID != nil {
		return fmt.Errorf("ExecutorPID this(%v) Not Equal that(%v)", this.ExecutorPID, that1.ExecutorPID)
	}
	return nil
}
func (this *ContainerStatus) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainerStatus)
	if !ok {
		that2, ok := that.(ContainerStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ContainerID.Equal(that1.ContainerID) {
		return false
	}
	if len(this.NetworkInfos) != len(that1.NetworkInfos) {
		return false
	}
	for i := range this.NetworkInfos {
		if !this.NetworkInfos[i].Equal(&that1.NetworkInfos[i]) {
			return false
		}
	}
	if !this.CgroupInfo.Equal(that1.CgroupInfo) {
		return false
	}
	if this.ExecutorPID != nil && that1.ExecutorPID != nil {
		if *this.ExecutorPID != *that1.ExecutorPID {
			return false
		}
	} else if this.ExecutorPID != nil {
		return false
	} else if that1.ExecutorPID != nil {
		return false
	}
	return true
}
func (this *CgroupInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo)
	if !ok {
		that2, ok := that.(CgroupInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo but is not nil && this == nil")
	}
	if !this.NetCLS.Equal(that1.NetCLS) {
		return fmt.Errorf("NetCLS this(%v) Not Equal that(%v)", this.NetCLS, that1.NetCLS)
	}
	return nil
}
func (this *CgroupInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo)
	if !ok {
		that2, ok := that.(CgroupInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.NetCLS.Equal(that1.NetCLS) {
		return false
	}
	return true
}
func (this *CgroupInfo_Blkio) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo_Blkio)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo_Blkio")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo_Blkio but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo_Blkio but is not nil && this == nil")
	}
	return nil
}
func (this *CgroupInfo_Blkio) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo_Blkio)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *CgroupInfo_Blkio_Value) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo_Blkio_Value)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_Value)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo_Blkio_Value")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo_Blkio_Value but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo_Blkio_Value but is not nil && this == nil")
	}
	if this.Op != nil && that1.Op != nil {
		if *this.Op != *that1.Op {
			return fmt.Errorf("Op this(%v) Not Equal that(%v)", *this.Op, *that1.Op)
		}
	} else if this.Op != nil {
		return fmt.Errorf("this.Op == nil && that.Op != nil")
	} else if that1.Op != nil {
		return fmt.Errorf("Op this(%v) Not Equal that(%v)", this.Op, that1.Op)
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return fmt.Errorf("Value this(%v) Not Equal that(%v)", *this.Value, *that1.Value)
		}
	} else if this.Value != nil {
		return fmt.Errorf("this.Value == nil && that.Value != nil")
	} else if that1.Value != nil {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *CgroupInfo_Blkio_Value) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo_Blkio_Value)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Op != nil && that1.Op != nil {
		if *this.Op != *that1.Op {
			return false
		}
	} else if this.Op != nil {
		return false
	} else if that1.Op != nil {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	return true
}
func (this *CgroupInfo_Blkio_CFQ) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo_Blkio_CFQ)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_CFQ)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo_Blkio_CFQ")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo_Blkio_CFQ but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo_Blkio_CFQ but is not nil && this == nil")
	}
	return nil
}
func (this *CgroupInfo_Blkio_CFQ) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo_Blkio_CFQ)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_CFQ)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *CgroupInfo_Blkio_CFQ_Statistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo_Blkio_CFQ_Statistics)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_CFQ_Statistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo_Blkio_CFQ_Statistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo_Blkio_CFQ_Statistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo_Blkio_CFQ_Statistics but is not nil && this == nil")
	}
	if !this.Device.Equal(that1.Device) {
		return fmt.Errorf("Device this(%v) Not Equal that(%v)", this.Device, that1.Device)
	}
	if this.Sectors != nil && that1.Sectors != nil {
		if *this.Sectors != *that1.Sectors {
			return fmt.Errorf("Sectors this(%v) Not Equal that(%v)", *this.Sectors, *that1.Sectors)
		}
	} else if this.Sectors != nil {
		return fmt.Errorf("this.Sectors == nil && that.Sectors != nil")
	} else if that1.Sectors != nil {
		return fmt.Errorf("Sectors this(%v) Not Equal that(%v)", this.Sectors, that1.Sectors)
	}
	if this.Time != nil && that1.Time != nil {
		if *this.Time != *that1.Time {
			return fmt.Errorf("Time this(%v) Not Equal that(%v)", *this.Time, *that1.Time)
		}
	} else if this.Time != nil {
		return fmt.Errorf("this.Time == nil && that.Time != nil")
	} else if that1.Time != nil {
		return fmt.Errorf("Time this(%v) Not Equal that(%v)", this.Time, that1.Time)
	}
	if len(this.IOServiced) != len(that1.IOServiced) {
		return fmt.Errorf("IOServiced this(%v) Not Equal that(%v)", len(this.IOServiced), len(that1.IOServiced))
	}
	for i := range this.IOServiced {
		if !this.IOServiced[i].Equal(&that1.IOServiced[i]) {
			return fmt.Errorf("IOServiced this[%v](%v) Not Equal that[%v](%v)", i, this.IOServiced[i], i, that1.IOServiced[i])
		}
	}
	if len(this.IOServiceBytes) != len(that1.IOServiceBytes) {
		return fmt.Errorf("IOServiceBytes this(%v) Not Equal that(%v)", len(this.IOServiceBytes), len(that1.IOServiceBytes))
	}
	for i := range this.IOServiceBytes {
		if !this.IOServiceBytes[i].Equal(&that1.IOServiceBytes[i]) {
			return fmt.Errorf("IOServiceBytes this[%v](%v) Not Equal that[%v](%v)", i, this.IOServiceBytes[i], i, that1.IOServiceBytes[i])
		}
	}
	if len(this.IOServiceTime) != len(that1.IOServiceTime) {
		return fmt.Errorf("IOServiceTime this(%v) Not Equal that(%v)", len(this.IOServiceTime), len(that1.IOServiceTime))
	}
	for i := range this.IOServiceTime {
		if !this.IOServiceTime[i].Equal(&that1.IOServiceTime[i]) {
			return fmt.Errorf("IOServiceTime this[%v](%v) Not Equal that[%v](%v)", i, this.IOServiceTime[i], i, that1.IOServiceTime[i])
		}
	}
	if len(this.IOWaitTime) != len(that1.IOWaitTime) {
		return fmt.Errorf("IOWaitTime this(%v) Not Equal that(%v)", len(this.IOWaitTime), len(that1.IOWaitTime))
	}
	for i := range this.IOWaitTime {
		if !this.IOWaitTime[i].Equal(&that1.IOWaitTime[i]) {
			return fmt.Errorf("IOWaitTime this[%v](%v) Not Equal that[%v](%v)", i, this.IOWaitTime[i], i, that1.IOWaitTime[i])
		}
	}
	if len(this.IOMerged) != len(that1.IOMerged) {
		return fmt.Errorf("IOMerged this(%v) Not Equal that(%v)", len(this.IOMerged), len(that1.IOMerged))
	}
	for i := range this.IOMerged {
		if !this.IOMerged[i].Equal(&that1.IOMerged[i]) {
			return fmt.Errorf("IOMerged this[%v](%v) Not Equal that[%v](%v)", i, this.IOMerged[i], i, that1.IOMerged[i])
		}
	}
	if len(this.IOQueued) != len(that1.IOQueued) {
		return fmt.Errorf("IOQueued this(%v) Not Equal that(%v)", len(this.IOQueued), len(that1.IOQueued))
	}
	for i := range this.IOQueued {
		if !this.IOQueued[i].Equal(&that1.IOQueued[i]) {
			return fmt.Errorf("IOQueued this[%v](%v) Not Equal that[%v](%v)", i, this.IOQueued[i], i, that1.IOQueued[i])
		}
	}
	return nil
}
func (this *CgroupInfo_Blkio_CFQ_Statistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo_Blkio_CFQ_Statistics)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_CFQ_Statistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Device.Equal(that1.Device) {
		return false
	}
	if this.Sectors != nil && that1.Sectors != nil {
		if *this.Sectors != *that1.Sectors {
			return false
		}
	} else if this.Sectors != nil {
		return false
	} else if that1.Sectors != nil {
		return false
	}
	if this.Time != nil && that1.Time != nil {
		if *this.Time != *that1.Time {
			return false
		}
	} else if this.Time != nil {
		return false
	} else if that1.Time != nil {
		return false
	}
	if len(this.IOServiced) != len(that1.IOServiced) {
		return false
	}
	for i := range this.IOServiced {
		if !this.IOServiced[i].Equal(&that1.IOServiced[i]) {
			return false
		}
	}
	if len(this.IOServiceBytes) != len(that1.IOServiceBytes) {
		return false
	}
	for i := range this.IOServiceBytes {
		if !this.IOServiceBytes[i].Equal(&that1.IOServiceBytes[i]) {
			return false
		}
	}
	if len(this.IOServiceTime) != len(that1.IOServiceTime) {
		return false
	}
	for i := range this.IOServiceTime {
		if !this.IOServiceTime[i].Equal(&that1.IOServiceTime[i]) {
			return false
		}
	}
	if len(this.IOWaitTime) != len(that1.IOWaitTime) {
		return false
	}
	for i := range this.IOWaitTime {
		if !this.IOWaitTime[i].Equal(&that1.IOWaitTime[i]) {
			return false
		}
	}
	if len(this.IOMerged) != len(that1.IOMerged) {
		return false
	}
	for i := range this.IOMerged {
		if !this.IOMerged[i].Equal(&that1.IOMerged[i]) {
			return false
		}
	}
	if len(this.IOQueued) != len(that1.IOQueued) {
		return false
	}
	for i := range this.IOQueued {
		if !this.IOQueued[i].Equal(&that1.IOQueued[i]) {
			return false
		}
	}
	return true
}
func (this *CgroupInfo_Blkio_Throttling) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo_Blkio_Throttling)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_Throttling)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo_Blkio_Throttling")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo_Blkio_Throttling but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo_Blkio_Throttling but is not nil && this == nil")
	}
	return nil
}
func (this *CgroupInfo_Blkio_Throttling) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo_Blkio_Throttling)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_Throttling)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *CgroupInfo_Blkio_Throttling_Statistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo_Blkio_Throttling_Statistics)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_Throttling_Statistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo_Blkio_Throttling_Statistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo_Blkio_Throttling_Statistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo_Blkio_Throttling_Statistics but is not nil && this == nil")
	}
	if !this.Device.Equal(that1.Device) {
		return fmt.Errorf("Device this(%v) Not Equal that(%v)", this.Device, that1.Device)
	}
	if len(this.IOServiced) != len(that1.IOServiced) {
		return fmt.Errorf("IOServiced this(%v) Not Equal that(%v)", len(this.IOServiced), len(that1.IOServiced))
	}
	for i := range this.IOServiced {
		if !this.IOServiced[i].Equal(&that1.IOServiced[i]) {
			return fmt.Errorf("IOServiced this[%v](%v) Not Equal that[%v](%v)", i, this.IOServiced[i], i, that1.IOServiced[i])
		}
	}
	if len(this.IOServiceBytes) != len(that1.IOServiceBytes) {
		return fmt.Errorf("IOServiceBytes this(%v) Not Equal that(%v)", len(this.IOServiceBytes), len(that1.IOServiceBytes))
	}
	for i := range this.IOServiceBytes {
		if !this.IOServiceBytes[i].Equal(&that1.IOServiceBytes[i]) {
			return fmt.Errorf("IOServiceBytes this[%v](%v) Not Equal that[%v](%v)", i, this.IOServiceBytes[i], i, that1.IOServiceBytes[i])
		}
	}
	return nil
}
func (this *CgroupInfo_Blkio_Throttling_Statistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo_Blkio_Throttling_Statistics)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_Throttling_Statistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Device.Equal(that1.Device) {
		return false
	}
	if len(this.IOServiced) != len(that1.IOServiced) {
		return false
	}
	for i := range this.IOServiced {
		if !this.IOServiced[i].Equal(&that1.IOServiced[i]) {
			return false
		}
	}
	if len(this.IOServiceBytes) != len(that1.IOServiceBytes) {
		return false
	}
	for i := range this.IOServiceBytes {
		if !this.IOServiceBytes[i].Equal(&that1.IOServiceBytes[i]) {
			return false
		}
	}
	return true
}
func (this *CgroupInfo_Blkio_Statistics) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo_Blkio_Statistics)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_Statistics)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo_Blkio_Statistics")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo_Blkio_Statistics but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo_Blkio_Statistics but is not nil && this == nil")
	}
	if len(this.CFQ) != len(that1.CFQ) {
		return fmt.Errorf("CFQ this(%v) Not Equal that(%v)", len(this.CFQ), len(that1.CFQ))
	}
	for i := range this.CFQ {
		if !this.CFQ[i].Equal(&that1.CFQ[i]) {
			return fmt.Errorf("CFQ this[%v](%v) Not Equal that[%v](%v)", i, this.CFQ[i], i, that1.CFQ[i])
		}
	}
	if len(this.CFQRecursive) != len(that1.CFQRecursive) {
		return fmt.Errorf("CFQRecursive this(%v) Not Equal that(%v)", len(this.CFQRecursive), len(that1.CFQRecursive))
	}
	for i := range this.CFQRecursive {
		if !this.CFQRecursive[i].Equal(&that1.CFQRecursive[i]) {
			return fmt.Errorf("CFQRecursive this[%v](%v) Not Equal that[%v](%v)", i, this.CFQRecursive[i], i, that1.CFQRecursive[i])
		}
	}
	if len(this.Throttling) != len(that1.Throttling) {
		return fmt.Errorf("Throttling this(%v) Not Equal that(%v)", len(this.Throttling), len(that1.Throttling))
	}
	for i := range this.Throttling {
		if !this.Throttling[i].Equal(that1.Throttling[i]) {
			return fmt.Errorf("Throttling this[%v](%v) Not Equal that[%v](%v)", i, this.Throttling[i], i, that1.Throttling[i])
		}
	}
	return nil
}
func (this *CgroupInfo_Blkio_Statistics) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo_Blkio_Statistics)
	if !ok {
		that2, ok := that.(CgroupInfo_Blkio_Statistics)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.CFQ) != len(that1.CFQ) {
		return false
	}
	for i := range this.CFQ {
		if !this.CFQ[i].Equal(&that1.CFQ[i]) {
			return false
		}
	}
	if len(this.CFQRecursive) != len(that1.CFQRecursive) {
		return false
	}
	for i := range this.CFQRecursive {
		if !this.CFQRecursive[i].Equal(&that1.CFQRecursive[i]) {
			return false
		}
	}
	if len(this.Throttling) != len(that1.Throttling) {
		return false
	}
	for i := range this.Throttling {
		if !this.Throttling[i].Equal(that1.Throttling[i]) {
			return false
		}
	}
	return true
}
func (this *CgroupInfo_NetCls) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CgroupInfo_NetCls)
	if !ok {
		that2, ok := that.(CgroupInfo_NetCls)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CgroupInfo_NetCls")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CgroupInfo_NetCls but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CgroupInfo_NetCls but is not nil && this == nil")
	}
	if this.ClassID != nil && that1.ClassID != nil {
		if *this.ClassID != *that1.ClassID {
			return fmt.Errorf("ClassID this(%v) Not Equal that(%v)", *this.ClassID, *that1.ClassID)
		}
	} else if this.ClassID != nil {
		return fmt.Errorf("this.ClassID == nil && that.ClassID != nil")
	} else if that1.ClassID != nil {
		return fmt.Errorf("ClassID this(%v) Not Equal that(%v)", this.ClassID, that1.ClassID)
	}
	return nil
}
func (this *CgroupInfo_NetCls) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CgroupInfo_NetCls)
	if !ok {
		that2, ok := that.(CgroupInfo_NetCls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClassID != nil && that1.ClassID != nil {
		if *this.ClassID != *that1.ClassID {
			return false
		}
	} else if this.ClassID != nil {
		return false
	} else if that1.ClassID != nil {
		return false
	}
	return true
}
func (this *Labels) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Labels)
	if !ok {
		that2, ok := that.(Labels)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Labels")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Labels but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Labels but is not nil && this == nil")
	}
	if len(this.Labels) != len(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", len(this.Labels), len(that1.Labels))
	}
	for i := range this.Labels {
		if !this.Labels[i].Equal(&that1.Labels[i]) {
			return fmt.Errorf("Labels this[%v](%v) Not Equal that[%v](%v)", i, this.Labels[i], i, that1.Labels[i])
		}
	}
	return nil
}
func (this *Labels) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Labels)
	if !ok {
		that2, ok := that.(Labels)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if !this.Labels[i].Equal(&that1.Labels[i]) {
			return false
		}
	}
	return true
}
func (this *Label) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Label)
	if !ok {
		that2, ok := that.(Label)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Label")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Label but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Label but is not nil && this == nil")
	}
	if this.Key != that1.Key {
		return fmt.Errorf("Key this(%v) Not Equal that(%v)", this.Key, that1.Key)
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return fmt.Errorf("Value this(%v) Not Equal that(%v)", *this.Value, *that1.Value)
		}
	} else if this.Value != nil {
		return fmt.Errorf("this.Value == nil && that.Value != nil")
	} else if that1.Value != nil {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Label) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Label)
	if !ok {
		that2, ok := that.(Label)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	return true
}
func (this *Port) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Port)
	if !ok {
		that2, ok := that.(Port)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Port")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Port but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Port but is not nil && this == nil")
	}
	if this.Number != that1.Number {
		return fmt.Errorf("Number this(%v) Not Equal that(%v)", this.Number, that1.Number)
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return fmt.Errorf("Name this(%v) Not Equal that(%v)", *this.Name, *that1.Name)
		}
	} else if this.Name != nil {
		return fmt.Errorf("this.Name == nil && that.Name != nil")
	} else if that1.Name != nil {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", *this.Protocol, *that1.Protocol)
		}
	} else if this.Protocol != nil {
		return fmt.Errorf("this.Protocol == nil && that.Protocol != nil")
	} else if that1.Protocol != nil {
		return fmt.Errorf("Protocol this(%v) Not Equal that(%v)", this.Protocol, that1.Protocol)
	}
	if this.Visibility != nil && that1.Visibility != nil {
		if *this.Visibility != *that1.Visibility {
			return fmt.Errorf("Visibility this(%v) Not Equal that(%v)", *this.Visibility, *that1.Visibility)
		}
	} else if this.Visibility != nil {
		return fmt.Errorf("this.Visibility == nil && that.Visibility != nil")
	} else if that1.Visibility != nil {
		return fmt.Errorf("Visibility this(%v) Not Equal that(%v)", this.Visibility, that1.Visibility)
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	return nil
}
func (this *Port) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Port)
	if !ok {
		that2, ok := that.(Port)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if this.Protocol != nil && that1.Protocol != nil {
		if *this.Protocol != *that1.Protocol {
			return false
		}
	} else if this.Protocol != nil {
		return false
	} else if that1.Protocol != nil {
		return false
	}
	if this.Visibility != nil && that1.Visibility != nil {
		if *this.Visibility != *that1.Visibility {
			return false
		}
	} else if this.Visibility != nil {
		return false
	} else if that1.Visibility != nil {
		return false
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	return true
}
func (this *Ports) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Ports)
	if !ok {
		that2, ok := that.(Ports)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Ports")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Ports but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Ports but is not nil && this == nil")
	}
	if len(this.Ports) != len(that1.Ports) {
		return fmt.Errorf("Ports this(%v) Not Equal that(%v)", len(this.Ports), len(that1.Ports))
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(&that1.Ports[i]) {
			return fmt.Errorf("Ports this[%v](%v) Not Equal that[%v](%v)", i, this.Ports[i], i, that1.Ports[i])
		}
	}
	return nil
}
func (this *Ports) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Ports)
	if !ok {
		that2, ok := that.(Ports)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(&that1.Ports[i]) {
			return false
		}
	}
	return true
}
func (this *DiscoveryInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DiscoveryInfo)
	if !ok {
		that2, ok := that.(DiscoveryInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DiscoveryInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DiscoveryInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DiscoveryInfo but is not nil && this == nil")
	}
	if this.Visibility != that1.Visibility {
		return fmt.Errorf("Visibility this(%v) Not Equal that(%v)", this.Visibility, that1.Visibility)
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return fmt.Errorf("Name this(%v) Not Equal that(%v)", *this.Name, *that1.Name)
		}
	} else if this.Name != nil {
		return fmt.Errorf("this.Name == nil && that.Name != nil")
	} else if that1.Name != nil {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Environment != nil && that1.Environment != nil {
		if *this.Environment != *that1.Environment {
			return fmt.Errorf("Environment this(%v) Not Equal that(%v)", *this.Environment, *that1.Environment)
		}
	} else if this.Environment != nil {
		return fmt.Errorf("this.Environment == nil && that.Environment != nil")
	} else if that1.Environment != nil {
		return fmt.Errorf("Environment this(%v) Not Equal that(%v)", this.Environment, that1.Environment)
	}
	if this.Location != nil && that1.Location != nil {
		if *this.Location != *that1.Location {
			return fmt.Errorf("Location this(%v) Not Equal that(%v)", *this.Location, *that1.Location)
		}
	} else if this.Location != nil {
		return fmt.Errorf("this.Location == nil && that.Location != nil")
	} else if that1.Location != nil {
		return fmt.Errorf("Location this(%v) Not Equal that(%v)", this.Location, that1.Location)
	}
	if this.Version != nil && that1.Version != nil {
		if *this.Version != *that1.Version {
			return fmt.Errorf("Version this(%v) Not Equal that(%v)", *this.Version, *that1.Version)
		}
	} else if this.Version != nil {
		return fmt.Errorf("this.Version == nil && that.Version != nil")
	} else if that1.Version != nil {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if !this.Ports.Equal(that1.Ports) {
		return fmt.Errorf("Ports this(%v) Not Equal that(%v)", this.Ports, that1.Ports)
	}
	if !this.Labels.Equal(that1.Labels) {
		return fmt.Errorf("Labels this(%v) Not Equal that(%v)", this.Labels, that1.Labels)
	}
	return nil
}
func (this *DiscoveryInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DiscoveryInfo)
	if !ok {
		that2, ok := that.(DiscoveryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Visibility != that1.Visibility {
		return false
	}
	if this.Name != nil && that1.Name != nil {
		if *this.Name != *that1.Name {
			return false
		}
	} else if this.Name != nil {
		return false
	} else if that1.Name != nil {
		return false
	}
	if this.Environment != nil && that1.Environment != nil {
		if *this.Environment != *that1.Environment {
			return false
		}
	} else if this.Environment != nil {
		return false
	} else if that1.Environment != nil {
		return false
	}
	if this.Location != nil && that1.Location != nil {
		if *this.Location != *that1.Location {
			return false
		}
	} else if this.Location != nil {
		return false
	} else if that1.Location != nil {
		return false
	}
	if this.Version != nil && that1.Version != nil {
		if *this.Version != *that1.Version {
			return false
		}
	} else if this.Version != nil {
		return false
	} else if that1.Version != nil {
		return false
	}
	if !this.Ports.Equal(that1.Ports) {
		return false
	}
	if !this.Labels.Equal(that1.Labels) {
		return false
	}
	return true
}
func (this *WeightInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WeightInfo)
	if !ok {
		that2, ok := that.(WeightInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *WeightInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *WeightInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *WeightInfo but is not nil && this == nil")
	}
	if this.Weight != that1.Weight {
		return fmt.Errorf("Weight this(%v) Not Equal that(%v)", this.Weight, that1.Weight)
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return fmt.Errorf("Role this(%v) Not Equal that(%v)", *this.Role, *that1.Role)
		}
	} else if this.Role != nil {
		return fmt.Errorf("this.Role == nil && that.Role != nil")
	} else if that1.Role != nil {
		return fmt.Errorf("Role this(%v) Not Equal that(%v)", this.Role, that1.Role)
	}
	return nil
}
func (this *WeightInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WeightInfo)
	if !ok {
		that2, ok := that.(WeightInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if this.Role != nil && that1.Role != nil {
		if *this.Role != *that1.Role {
			return false
		}
	} else if this.Role != nil {
		return false
	} else if that1.Role != nil {
		return false
	}
	return true
}
func (this *VersionInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*VersionInfo)
	if !ok {
		that2, ok := that.(VersionInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *VersionInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *VersionInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *VersionInfo but is not nil && this == nil")
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.BuildDate != nil && that1.BuildDate != nil {
		if *this.BuildDate != *that1.BuildDate {
			return fmt.Errorf("BuildDate this(%v) Not Equal that(%v)", *this.BuildDate, *that1.BuildDate)
		}
	} else if this.BuildDate != nil {
		return fmt.Errorf("this.BuildDate == nil && that.BuildDate != nil")
	} else if that1.BuildDate != nil {
		return fmt.Errorf("BuildDate this(%v) Not Equal that(%v)", this.BuildDate, that1.BuildDate)
	}
	if this.BuildTime != nil && that1.BuildTime != nil {
		if *this.BuildTime != *that1.BuildTime {
			return fmt.Errorf("BuildTime this(%v) Not Equal that(%v)", *this.BuildTime, *that1.BuildTime)
		}
	} else if this.BuildTime != nil {
		return fmt.Errorf("this.BuildTime == nil && that.BuildTime != nil")
	} else if that1.BuildTime != nil {
		return fmt.Errorf("BuildTime this(%v) Not Equal that(%v)", this.BuildTime, that1.BuildTime)
	}
	if this.BuildUser != nil && that1.BuildUser != nil {
		if *this.BuildUser != *that1.BuildUser {
			return fmt.Errorf("BuildUser this(%v) Not Equal that(%v)", *this.BuildUser, *that1.BuildUser)
		}
	} else if this.BuildUser != nil {
		return fmt.Errorf("this.BuildUser == nil && that.BuildUser != nil")
	} else if that1.BuildUser != nil {
		return fmt.Errorf("BuildUser this(%v) Not Equal that(%v)", this.BuildUser, that1.BuildUser)
	}
	if this.GitSHA != nil && that1.GitSHA != nil {
		if *this.GitSHA != *that1.GitSHA {
			return fmt.Errorf("GitSHA this(%v) Not Equal that(%v)", *this.GitSHA, *that1.GitSHA)
		}
	} else if this.GitSHA != nil {
		return fmt.Errorf("this.GitSHA == nil && that.GitSHA != nil")
	} else if that1.GitSHA != nil {
		return fmt.Errorf("GitSHA this(%v) Not Equal that(%v)", this.GitSHA, that1.GitSHA)
	}
	if this.GitBranch != nil && that1.GitBranch != nil {
		if *this.GitBranch != *that1.GitBranch {
			return fmt.Errorf("GitBranch this(%v) Not Equal that(%v)", *this.GitBranch, *that1.GitBranch)
		}
	} else if this.GitBranch != nil {
		return fmt.Errorf("this.GitBranch == nil && that.GitBranch != nil")
	} else if that1.GitBranch != nil {
		return fmt.Errorf("GitBranch this(%v) Not Equal that(%v)", this.GitBranch, that1.GitBranch)
	}
	if this.GitTag != nil && that1.GitTag != nil {
		if *this.GitTag != *that1.GitTag {
			return fmt.Errorf("GitTag this(%v) Not Equal that(%v)", *this.GitTag, *that1.GitTag)
		}
	} else if this.GitTag != nil {
		return fmt.Errorf("this.GitTag == nil && that.GitTag != nil")
	} else if that1.GitTag != nil {
		return fmt.Errorf("GitTag this(%v) Not Equal that(%v)", this.GitTag, that1.GitTag)
	}
	return nil
}
func (this *VersionInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VersionInfo)
	if !ok {
		that2, ok := that.(VersionInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.BuildDate != nil && that1.BuildDate != nil {
		if *this.BuildDate != *that1.BuildDate {
			return false
		}
	} else if this.BuildDate != nil {
		return false
	} else if that1.BuildDate != nil {
		return false
	}
	if this.BuildTime != nil && that1.BuildTime != nil {
		if *this.BuildTime != *that1.BuildTime {
			return false
		}
	} else if this.BuildTime != nil {
		return false
	} else if that1.BuildTime != nil {
		return false
	}
	if this.BuildUser != nil && that1.BuildUser != nil {
		if *this.BuildUser != *that1.BuildUser {
			return false
		}
	} else if this.BuildUser != nil {
		return false
	} else if that1.BuildUser != nil {
		return false
	}
	if this.GitSHA != nil && that1.GitSHA != nil {
		if *this.GitSHA != *that1.GitSHA {
			return false
		}
	} else if this.GitSHA != nil {
		return false
	} else if that1.GitSHA != nil {
		return false
	}
	if this.GitBranch != nil && that1.GitBranch != nil {
		if *this.GitBranch != *that1.GitBranch {
			return false
		}
	} else if this.GitBranch != nil {
		return false
	} else if that1.GitBranch != nil {
		return false
	}
	if this.GitTag != nil && that1.GitTag != nil {
		if *this.GitTag != *that1.GitTag {
			return false
		}
	} else if this.GitTag != nil {
		return false
	} else if that1.GitTag != nil {
		return false
	}
	return true
}
func (this *Flag) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Flag)
	if !ok {
		that2, ok := that.(Flag)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Flag")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Flag but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Flag but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return fmt.Errorf("Value this(%v) Not Equal that(%v)", *this.Value, *that1.Value)
		}
	} else if this.Value != nil {
		return fmt.Errorf("this.Value == nil && that.Value != nil")
	} else if that1.Value != nil {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Flag) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Flag)
	if !ok {
		that2, ok := that.(Flag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	return true
}
func (this *Role) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Role)
	if !ok {
		that2, ok := that.(Role)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Role")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Role but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Role but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Weight != that1.Weight {
		return fmt.Errorf("Weight this(%v) Not Equal that(%v)", this.Weight, that1.Weight)
	}
	if len(this.Frameworks) != len(that1.Frameworks) {
		return fmt.Errorf("Frameworks this(%v) Not Equal that(%v)", len(this.Frameworks), len(that1.Frameworks))
	}
	for i := range this.Frameworks {
		if !this.Frameworks[i].Equal(&that1.Frameworks[i]) {
			return fmt.Errorf("Frameworks this[%v](%v) Not Equal that[%v](%v)", i, this.Frameworks[i], i, that1.Frameworks[i])
		}
	}
	if len(this.Resources) != len(that1.Resources) {
		return fmt.Errorf("Resources this(%v) Not Equal that(%v)", len(this.Resources), len(that1.Resources))
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return fmt.Errorf("Resources this[%v](%v) Not Equal that[%v](%v)", i, this.Resources[i], i, that1.Resources[i])
		}
	}
	return nil
}
func (this *Role) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Role)
	if !ok {
		that2, ok := that.(Role)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	if len(this.Frameworks) != len(that1.Frameworks) {
		return false
	}
	for i := range this.Frameworks {
		if !this.Frameworks[i].Equal(&that1.Frameworks[i]) {
			return false
		}
	}
	if len(this.Resources) != len(that1.Resources) {
		return false
	}
	for i := range this.Resources {
		if !this.Resources[i].Equal(&that1.Resources[i]) {
			return false
		}
	}
	return true
}
func (this *Metric) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Metric)
	if !ok {
		that2, ok := that.(Metric)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Metric")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Metric but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Metric but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return fmt.Errorf("Value this(%v) Not Equal that(%v)", *this.Value, *that1.Value)
		}
	} else if this.Value != nil {
		return fmt.Errorf("this.Value == nil && that.Value != nil")
	} else if that1.Value != nil {
		return fmt.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	return nil
}
func (this *Metric) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Metric)
	if !ok {
		that2, ok := that.(Metric)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	return true
}
func (this *FileInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FileInfo)
	if !ok {
		that2, ok := that.(FileInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FileInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FileInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FileInfo but is not nil && this == nil")
	}
	if this.Path != that1.Path {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	if this.Nlink != nil && that1.Nlink != nil {
		if *this.Nlink != *that1.Nlink {
			return fmt.Errorf("Nlink this(%v) Not Equal that(%v)", *this.Nlink, *that1.Nlink)
		}
	} else if this.Nlink != nil {
		return fmt.Errorf("this.Nlink == nil && that.Nlink != nil")
	} else if that1.Nlink != nil {
		return fmt.Errorf("Nlink this(%v) Not Equal that(%v)", this.Nlink, that1.Nlink)
	}
	if this.Size != nil && that1.Size != nil {
		if *this.Size != *that1.Size {
			return fmt.Errorf("Size this(%v) Not Equal that(%v)", *this.Size, *that1.Size)
		}
	} else if this.Size != nil {
		return fmt.Errorf("this.Size == nil && that.Size != nil")
	} else if that1.Size != nil {
		return fmt.Errorf("Size this(%v) Not Equal that(%v)", this.Size, that1.Size)
	}
	if !this.Mtime.Equal(that1.Mtime) {
		return fmt.Errorf("Mtime this(%v) Not Equal that(%v)", this.Mtime, that1.Mtime)
	}
	if this.Mode != nil && that1.Mode != nil {
		if *this.Mode != *that1.Mode {
			return fmt.Errorf("Mode this(%v) Not Equal that(%v)", *this.Mode, *that1.Mode)
		}
	} else if this.Mode != nil {
		return fmt.Errorf("this.Mode == nil && that.Mode != nil")
	} else if that1.Mode != nil {
		return fmt.Errorf("Mode this(%v) Not Equal that(%v)", this.Mode, that1.Mode)
	}
	if this.UID != nil && that1.UID != nil {
		if *this.UID != *that1.UID {
			return fmt.Errorf("UID this(%v) Not Equal that(%v)", *this.UID, *that1.UID)
		}
	} else if this.UID != nil {
		return fmt.Errorf("this.UID == nil && that.UID != nil")
	} else if that1.UID != nil {
		return fmt.Errorf("UID this(%v) Not Equal that(%v)", this.UID, that1.UID)
	}
	if this.GID != nil && that1.GID != nil {
		if *this.GID != *that1.GID {
			return fmt.Errorf("GID this(%v) Not Equal that(%v)", *this.GID, *that1.GID)
		}
	} else if this.GID != nil {
		return fmt.Errorf("this.GID == nil && that.GID != nil")
	} else if that1.GID != nil {
		return fmt.Errorf("GID this(%v) Not Equal that(%v)", this.GID, that1.GID)
	}
	return nil
}
func (this *FileInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FileInfo)
	if !ok {
		that2, ok := that.(FileInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Nlink != nil && that1.Nlink != nil {
		if *this.Nlink != *that1.Nlink {
			return false
		}
	} else if this.Nlink != nil {
		return false
	} else if that1.Nlink != nil {
		return false
	}
	if this.Size != nil && that1.Size != nil {
		if *this.Size != *that1.Size {
			return false
		}
	} else if this.Size != nil {
		return false
	} else if that1.Size != nil {
		return false
	}
	if !this.Mtime.Equal(that1.Mtime) {
		return false
	}
	if this.Mode != nil && that1.Mode != nil {
		if *this.Mode != *that1.Mode {
			return false
		}
	} else if this.Mode != nil {
		return false
	} else if that1.Mode != nil {
		return false
	}
	if this.UID != nil && that1.UID != nil {
		if *this.UID != *that1.UID {
			return false
		}
	} else if this.UID != nil {
		return false
	} else if that1.UID != nil {
		return false
	}
	if this.GID != nil && that1.GID != nil {
		if *this.GID != *that1.GID {
			return false
		}
	} else if this.GID != nil {
		return false
	} else if that1.GID != nil {
		return false
	}
	return true
}
func (this *Device) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Device)
	if !ok {
		that2, ok := that.(Device)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Device")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Device but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Device but is not nil && this == nil")
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return fmt.Errorf("Path this(%v) Not Equal that(%v)", *this.Path, *that1.Path)
		}
	} else if this.Path != nil {
		return fmt.Errorf("this.Path == nil && that.Path != nil")
	} else if that1.Path != nil {
		return fmt.Errorf("Path this(%v) Not Equal that(%v)", this.Path, that1.Path)
	}
	if !this.Number.Equal(that1.Number) {
		return fmt.Errorf("Number this(%v) Not Equal that(%v)", this.Number, that1.Number)
	}
	return nil
}
func (this *Device) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Device)
	if !ok {
		that2, ok := that.(Device)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != nil && that1.Path != nil {
		if *this.Path != *that1.Path {
			return false
		}
	} else if this.Path != nil {
		return false
	} else if that1.Path != nil {
		return false
	}
	if !this.Number.Equal(that1.Number) {
		return false
	}
	return true
}
func (this *Device_Number) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Device_Number)
	if !ok {
		that2, ok := that.(Device_Number)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Device_Number")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Device_Number but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Device_Number but is not nil && this == nil")
	}
	if this.MajorNumber != nil && that1.MajorNumber != nil {
		if *this.MajorNumber != *that1.MajorNumber {
			return fmt.Errorf("MajorNumber this(%v) Not Equal that(%v)", *this.MajorNumber, *that1.MajorNumber)
		}
	} else if this.MajorNumber != nil {
		return fmt.Errorf("this.MajorNumber == nil && that.MajorNumber != nil")
	} else if that1.MajorNumber != nil {
		return fmt.Errorf("MajorNumber this(%v) Not Equal that(%v)", this.MajorNumber, that1.MajorNumber)
	}
	if this.MinorNumber != nil && that1.MinorNumber != nil {
		if *this.MinorNumber != *that1.MinorNumber {
			return fmt.Errorf("MinorNumber this(%v) Not Equal that(%v)", *this.MinorNumber, *that1.MinorNumber)
		}
	} else if this.MinorNumber != nil {
		return fmt.Errorf("this.MinorNumber == nil && that.MinorNumber != nil")
	} else if that1.MinorNumber != nil {
		return fmt.Errorf("MinorNumber this(%v) Not Equal that(%v)", this.MinorNumber, that1.MinorNumber)
	}
	return nil
}
func (this *Device_Number) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Device_Number)
	if !ok {
		that2, ok := that.(Device_Number)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.MajorNumber != nil && that1.MajorNumber != nil {
		if *this.MajorNumber != *that1.MajorNumber {
			return false
		}
	} else if this.MajorNumber != nil {
		return false
	} else if that1.MajorNumber != nil {
		return false
	}
	if this.MinorNumber != nil && that1.MinorNumber != nil {
		if *this.MinorNumber != *that1.MinorNumber {
			return false
		}
	} else if this.MinorNumber != nil {
		return false
	} else if that1.MinorNumber != nil {
		return false
	}
	return true
}
func (this *DeviceAccess) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeviceAccess)
	if !ok {
		that2, ok := that.(DeviceAccess)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeviceAccess")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeviceAccess but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeviceAccess but is not nil && this == nil")
	}
	if !this.Device.Equal(&that1.Device) {
		return fmt.Errorf("Device this(%v) Not Equal that(%v)", this.Device, that1.Device)
	}
	if !this.Access.Equal(&that1.Access) {
		return fmt.Errorf("Access this(%v) Not Equal that(%v)", this.Access, that1.Access)
	}
	return nil
}
func (this *DeviceAccess) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeviceAccess)
	if !ok {
		that2, ok := that.(DeviceAccess)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Device.Equal(&that1.Device) {
		return false
	}
	if !this.Access.Equal(&that1.Access) {
		return false
	}
	return true
}
func (this *DeviceAccess_Access) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeviceAccess_Access)
	if !ok {
		that2, ok := that.(DeviceAccess_Access)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeviceAccess_Access")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeviceAccess_Access but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeviceAccess_Access but is not nil && this == nil")
	}
	if this.Read != nil && that1.Read != nil {
		if *this.Read != *that1.Read {
			return fmt.Errorf("Read this(%v) Not Equal that(%v)", *this.Read, *that1.Read)
		}
	} else if this.Read != nil {
		return fmt.Errorf("this.Read == nil && that.Read != nil")
	} else if that1.Read != nil {
		return fmt.Errorf("Read this(%v) Not Equal that(%v)", this.Read, that1.Read)
	}
	if this.Write != nil && that1.Write != nil {
		if *this.Write != *that1.Write {
			return fmt.Errorf("Write this(%v) Not Equal that(%v)", *this.Write, *that1.Write)
		}
	} else if this.Write != nil {
		return fmt.Errorf("this.Write == nil && that.Write != nil")
	} else if that1.Write != nil {
		return fmt.Errorf("Write this(%v) Not Equal that(%v)", this.Write, that1.Write)
	}
	if this.Mknod != nil && that1.Mknod != nil {
		if *this.Mknod != *that1.Mknod {
			return fmt.Errorf("Mknod this(%v) Not Equal that(%v)", *this.Mknod, *that1.Mknod)
		}
	} else if this.Mknod != nil {
		return fmt.Errorf("this.Mknod == nil && that.Mknod != nil")
	} else if that1.Mknod != nil {
		return fmt.Errorf("Mknod this(%v) Not Equal that(%v)", this.Mknod, that1.Mknod)
	}
	return nil
}
func (this *DeviceAccess_Access) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeviceAccess_Access)
	if !ok {
		that2, ok := that.(DeviceAccess_Access)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Read != nil && that1.Read != nil {
		if *this.Read != *that1.Read {
			return false
		}
	} else if this.Read != nil {
		return false
	} else if that1.Read != nil {
		return false
	}
	if this.Write != nil && that1.Write != nil {
		if *this.Write != *that1.Write {
			return false
		}
	} else if this.Write != nil {
		return false
	} else if that1.Write != nil {
		return false
	}
	if this.Mknod != nil && that1.Mknod != nil {
		if *this.Mknod != *that1.Mknod {
			return false
		}
	} else if this.Mknod != nil {
		return false
	} else if that1.Mknod != nil {
		return false
	}
	return true
}
func (this *DeviceWhitelist) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DeviceWhitelist)
	if !ok {
		that2, ok := that.(DeviceWhitelist)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DeviceWhitelist")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DeviceWhitelist but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DeviceWhitelist but is not nil && this == nil")
	}
	if len(this.AllowedDevices) != len(that1.AllowedDevices) {
		return fmt.Errorf("AllowedDevices this(%v) Not Equal that(%v)", len(this.AllowedDevices), len(that1.AllowedDevices))
	}
	for i := range this.AllowedDevices {
		if !this.AllowedDevices[i].Equal(&that1.AllowedDevices[i]) {
			return fmt.Errorf("AllowedDevices this[%v](%v) Not Equal that[%v](%v)", i, this.AllowedDevices[i], i, that1.AllowedDevices[i])
		}
	}
	return nil
}
func (this *DeviceWhitelist) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeviceWhitelist)
	if !ok {
		that2, ok := that.(DeviceWhitelist)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.AllowedDevices) != len(that1.AllowedDevices) {
		return false
	}
	for i := range this.AllowedDevices {
		if !this.AllowedDevices[i].Equal(&that1.AllowedDevices[i]) {
			return false
		}
	}
	return true
}
func (this *FrameworkID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.FrameworkID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OfferID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.OfferID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AgentID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.AgentID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.TaskID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutorID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.ExecutorID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.ContainerID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.Parent != nil {
		s = append(s, "Parent: "+fmt.Sprintf("%#v", this.Parent)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceProviderID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.ResourceProviderID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OperationID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.OperationID{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.TimeInfo{")
	s = append(s, "Nanoseconds: "+fmt.Sprintf("%#v", this.Nanoseconds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DurationInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.DurationInfo{")
	s = append(s, "Nanoseconds: "+fmt.Sprintf("%#v", this.Nanoseconds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.Address{")
	if this.Hostname != nil {
		s = append(s, "Hostname: "+valueToGoStringMesos(this.Hostname, "string")+",\n")
	}
	if this.IP != nil {
		s = append(s, "IP: "+valueToGoStringMesos(this.IP, "string")+",\n")
	}
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *URL) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.URL{")
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	s = append(s, "Address: "+strings.Replace(this.Address.GoString(), `&`, ``, 1)+",\n")
	if this.Path != nil {
		s = append(s, "Path: "+valueToGoStringMesos(this.Path, "string")+",\n")
	}
	if this.Query != nil {
		s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	}
	if this.Fragment != nil {
		s = append(s, "Fragment: "+valueToGoStringMesos(this.Fragment, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Unavailability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Unavailability{")
	s = append(s, "Start: "+strings.Replace(this.Start.GoString(), `&`, ``, 1)+",\n")
	if this.Duration != nil {
		s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MachineID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.MachineID{")
	if this.Hostname != nil {
		s = append(s, "Hostname: "+valueToGoStringMesos(this.Hostname, "string")+",\n")
	}
	if this.IP != nil {
		s = append(s, "IP: "+valueToGoStringMesos(this.IP, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MachineInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.MachineInfo{")
	s = append(s, "ID: "+strings.Replace(this.ID.GoString(), `&`, ``, 1)+",\n")
	if this.Mode != nil {
		s = append(s, "Mode: "+valueToGoStringMesos(this.Mode, "MachineInfo_Mode")+",\n")
	}
	if this.Unavailability != nil {
		s = append(s, "Unavailability: "+fmt.Sprintf("%#v", this.Unavailability)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FrameworkInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&mesos.FrameworkInfo{")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.FailoverTimeout != nil {
		s = append(s, "FailoverTimeout: "+valueToGoStringMesos(this.FailoverTimeout, "float64")+",\n")
	}
	if this.Checkpoint != nil {
		s = append(s, "Checkpoint: "+valueToGoStringMesos(this.Checkpoint, "bool")+",\n")
	}
	if this.Role != nil {
		s = append(s, "Role: "+valueToGoStringMesos(this.Role, "string")+",\n")
	}
	if this.Roles != nil {
		s = append(s, "Roles: "+fmt.Sprintf("%#v", this.Roles)+",\n")
	}
	if this.Hostname != nil {
		s = append(s, "Hostname: "+valueToGoStringMesos(this.Hostname, "string")+",\n")
	}
	if this.Principal != nil {
		s = append(s, "Principal: "+valueToGoStringMesos(this.Principal, "string")+",\n")
	}
	if this.WebUiURL != nil {
		s = append(s, "WebUiURL: "+valueToGoStringMesos(this.WebUiURL, "string")+",\n")
	}
	if this.Capabilities != nil {
		s = append(s, "Capabilities: "+fmt.Sprintf("%#v", this.Capabilities)+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FrameworkInfo_Capability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.FrameworkInfo_Capability{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&mesos.CheckInfo{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Command != nil {
		s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	}
	if this.HTTP != nil {
		s = append(s, "HTTP: "+fmt.Sprintf("%#v", this.HTTP)+",\n")
	}
	if this.TCP != nil {
		s = append(s, "TCP: "+fmt.Sprintf("%#v", this.TCP)+",\n")
	}
	if this.DelaySeconds != nil {
		s = append(s, "DelaySeconds: "+valueToGoStringMesos(this.DelaySeconds, "float64")+",\n")
	}
	if this.IntervalSeconds != nil {
		s = append(s, "IntervalSeconds: "+valueToGoStringMesos(this.IntervalSeconds, "float64")+",\n")
	}
	if this.TimeoutSeconds != nil {
		s = append(s, "TimeoutSeconds: "+valueToGoStringMesos(this.TimeoutSeconds, "float64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckInfo_Command) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.CheckInfo_Command{")
	s = append(s, "Command: "+strings.Replace(this.Command.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckInfo_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.CheckInfo_Http{")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	if this.Path != nil {
		s = append(s, "Path: "+valueToGoStringMesos(this.Path, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckInfo_Tcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.CheckInfo_Tcp{")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HealthCheck) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&mesos.HealthCheck{")
	if this.DelaySeconds != nil {
		s = append(s, "DelaySeconds: "+valueToGoStringMesos(this.DelaySeconds, "float64")+",\n")
	}
	if this.IntervalSeconds != nil {
		s = append(s, "IntervalSeconds: "+valueToGoStringMesos(this.IntervalSeconds, "float64")+",\n")
	}
	if this.TimeoutSeconds != nil {
		s = append(s, "TimeoutSeconds: "+valueToGoStringMesos(this.TimeoutSeconds, "float64")+",\n")
	}
	if this.ConsecutiveFailures != nil {
		s = append(s, "ConsecutiveFailures: "+valueToGoStringMesos(this.ConsecutiveFailures, "uint32")+",\n")
	}
	if this.GracePeriodSeconds != nil {
		s = append(s, "GracePeriodSeconds: "+valueToGoStringMesos(this.GracePeriodSeconds, "float64")+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Command != nil {
		s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	}
	if this.HTTP != nil {
		s = append(s, "HTTP: "+fmt.Sprintf("%#v", this.HTTP)+",\n")
	}
	if this.TCP != nil {
		s = append(s, "TCP: "+fmt.Sprintf("%#v", this.TCP)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HealthCheck_HTTPCheckInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.HealthCheck_HTTPCheckInfo{")
	if this.Protocol != nil {
		s = append(s, "Protocol: "+valueToGoStringMesos(this.Protocol, "NetworkInfo_Protocol")+",\n")
	}
	if this.Scheme != nil {
		s = append(s, "Scheme: "+valueToGoStringMesos(this.Scheme, "string")+",\n")
	}
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	if this.Path != nil {
		s = append(s, "Path: "+valueToGoStringMesos(this.Path, "string")+",\n")
	}
	if this.Statuses != nil {
		s = append(s, "Statuses: "+fmt.Sprintf("%#v", this.Statuses)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HealthCheck_TCPCheckInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.HealthCheck_TCPCheckInfo{")
	if this.Protocol != nil {
		s = append(s, "Protocol: "+valueToGoStringMesos(this.Protocol, "NetworkInfo_Protocol")+",\n")
	}
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KillPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.KillPolicy{")
	if this.GracePeriod != nil {
		s = append(s, "GracePeriod: "+fmt.Sprintf("%#v", this.GracePeriod)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CommandInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mesos.CommandInfo{")
	if this.URIs != nil {
		s = append(s, "URIs: "+fmt.Sprintf("%#v", this.URIs)+",\n")
	}
	if this.Environment != nil {
		s = append(s, "Environment: "+fmt.Sprintf("%#v", this.Environment)+",\n")
	}
	if this.Shell != nil {
		s = append(s, "Shell: "+valueToGoStringMesos(this.Shell, "bool")+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+valueToGoStringMesos(this.Value, "string")+",\n")
	}
	if this.Arguments != nil {
		s = append(s, "Arguments: "+fmt.Sprintf("%#v", this.Arguments)+",\n")
	}
	if this.User != nil {
		s = append(s, "User: "+valueToGoStringMesos(this.User, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CommandInfo_URI) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.CommandInfo_URI{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.Executable != nil {
		s = append(s, "Executable: "+valueToGoStringMesos(this.Executable, "bool")+",\n")
	}
	if this.Extract != nil {
		s = append(s, "Extract: "+valueToGoStringMesos(this.Extract, "bool")+",\n")
	}
	if this.Cache != nil {
		s = append(s, "Cache: "+valueToGoStringMesos(this.Cache, "bool")+",\n")
	}
	if this.OutputFile != nil {
		s = append(s, "OutputFile: "+valueToGoStringMesos(this.OutputFile, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecutorInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&mesos.ExecutorInfo{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "ExecutorID: "+strings.Replace(this.ExecutorID.GoString(), `&`, ``, 1)+",\n")
	if this.FrameworkID != nil {
		s = append(s, "FrameworkID: "+fmt.Sprintf("%#v", this.FrameworkID)+",\n")
	}
	if this.Command != nil {
		s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	}
	if this.Container != nil {
		s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	}
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	if this.Name != nil {
		s = append(s, "Name: "+valueToGoStringMesos(this.Name, "string")+",\n")
	}
	if this.Source != nil {
		s = append(s, "Source: "+valueToGoStringMesos(this.Source, "string")+",\n")
	}
	if this.Data != nil {
		s = append(s, "Data: "+valueToGoStringMesos(this.Data, "byte")+",\n")
	}
	if this.Discovery != nil {
		s = append(s, "Discovery: "+fmt.Sprintf("%#v", this.Discovery)+",\n")
	}
	if this.ShutdownGracePeriod != nil {
		s = append(s, "ShutdownGracePeriod: "+fmt.Sprintf("%#v", this.ShutdownGracePeriod)+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.DomainInfo{")
	if this.FaultDomain != nil {
		s = append(s, "FaultDomain: "+fmt.Sprintf("%#v", this.FaultDomain)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainInfo_FaultDomain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.DomainInfo_FaultDomain{")
	s = append(s, "Region: "+strings.Replace(this.Region.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Zone: "+strings.Replace(this.Zone.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainInfo_FaultDomain_RegionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.DomainInfo_FaultDomain_RegionInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainInfo_FaultDomain_ZoneInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.DomainInfo_FaultDomain_ZoneInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MasterInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&mesos.MasterInfo{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "IP: "+fmt.Sprintf("%#v", this.IP)+",\n")
	if this.Port != nil {
		s = append(s, "Port: "+valueToGoStringMesos(this.Port, "uint32")+",\n")
	}
	if this.PID != nil {
		s = append(s, "PID: "+valueToGoStringMesos(this.PID, "string")+",\n")
	}
	if this.Hostname != nil {
		s = append(s, "Hostname: "+valueToGoStringMesos(this.Hostname, "string")+",\n")
	}
	if this.Version != nil {
		s = append(s, "Version: "+valueToGoStringMesos(this.Version, "string")+",\n")
	}
	if this.Address != nil {
		s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	}
	if this.Domain != nil {
		s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	}
	if this.Capabilities != nil {
		s = append(s, "Capabilities: "+fmt.Sprintf("%#v", this.Capabilities)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MasterInfo_Capability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.MasterInfo_Capability{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AgentInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mesos.AgentInfo{")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	if this.Port != nil {
		s = append(s, "Port: "+valueToGoStringMesos(this.Port, "int32")+",\n")
	}
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	if this.Attributes != nil {
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", this.Attributes)+",\n")
	}
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.Domain != nil {
		s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AgentInfo_Capability) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.AgentInfo_Capability{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CSIPluginContainerInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.CSIPluginContainerInfo{")
	if this.Services != nil {
		s = append(s, "Services: "+fmt.Sprintf("%#v", this.Services)+",\n")
	}
	if this.Command != nil {
		s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	}
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	if this.Container != nil {
		s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CSIPluginInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.CSIPluginInfo{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Containers != nil {
		s = append(s, "Containers: "+fmt.Sprintf("%#v", this.Containers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceProviderInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mesos.ResourceProviderInfo{")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.Attributes != nil {
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", this.Attributes)+",\n")
	}
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.DefaultReservations != nil {
		s = append(s, "DefaultReservations: "+fmt.Sprintf("%#v", this.DefaultReservations)+",\n")
	}
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceProviderInfo_Storage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.ResourceProviderInfo_Storage{")
	s = append(s, "Plugin: "+strings.Replace(this.Plugin.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.Value{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Scalar != nil {
		s = append(s, "Scalar: "+fmt.Sprintf("%#v", this.Scalar)+",\n")
	}
	if this.Ranges != nil {
		s = append(s, "Ranges: "+fmt.Sprintf("%#v", this.Ranges)+",\n")
	}
	if this.Set != nil {
		s = append(s, "Set: "+fmt.Sprintf("%#v", this.Set)+",\n")
	}
	if this.Text != nil {
		s = append(s, "Text: "+fmt.Sprintf("%#v", this.Text)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Scalar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Value_Scalar{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Range) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Value_Range{")
	s = append(s, "Begin: "+fmt.Sprintf("%#v", this.Begin)+",\n")
	s = append(s, "End: "+fmt.Sprintf("%#v", this.End)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Ranges) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Value_Ranges{")
	if this.Range != nil {
		s = append(s, "Range: "+fmt.Sprintf("%#v", this.Range)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Set) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Value_Set{")
	if this.Item != nil {
		s = append(s, "Item: "+fmt.Sprintf("%#v", this.Item)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Value_Text) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Value_Text{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Attribute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mesos.Attribute{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Scalar != nil {
		s = append(s, "Scalar: "+fmt.Sprintf("%#v", this.Scalar)+",\n")
	}
	if this.Ranges != nil {
		s = append(s, "Ranges: "+fmt.Sprintf("%#v", this.Ranges)+",\n")
	}
	if this.Set != nil {
		s = append(s, "Set: "+fmt.Sprintf("%#v", this.Set)+",\n")
	}
	if this.Text != nil {
		s = append(s, "Text: "+fmt.Sprintf("%#v", this.Text)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&mesos.Resource{")
	if this.ProviderID != nil {
		s = append(s, "ProviderID: "+fmt.Sprintf("%#v", this.ProviderID)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Type != nil {
		s = append(s, "Type: "+valueToGoStringMesos(this.Type, "Value_Type")+",\n")
	}
	if this.Scalar != nil {
		s = append(s, "Scalar: "+fmt.Sprintf("%#v", this.Scalar)+",\n")
	}
	if this.Ranges != nil {
		s = append(s, "Ranges: "+fmt.Sprintf("%#v", this.Ranges)+",\n")
	}
	if this.Set != nil {
		s = append(s, "Set: "+fmt.Sprintf("%#v", this.Set)+",\n")
	}
	if this.Role != nil {
		s = append(s, "Role: "+valueToGoStringMesos(this.Role, "string")+",\n")
	}
	if this.AllocationInfo != nil {
		s = append(s, "AllocationInfo: "+fmt.Sprintf("%#v", this.AllocationInfo)+",\n")
	}
	if this.Reservation != nil {
		s = append(s, "Reservation: "+fmt.Sprintf("%#v", this.Reservation)+",\n")
	}
	if this.Reservations != nil {
		s = append(s, "Reservations: "+fmt.Sprintf("%#v", this.Reservations)+",\n")
	}
	if this.Disk != nil {
		s = append(s, "Disk: "+fmt.Sprintf("%#v", this.Disk)+",\n")
	}
	if this.Revocable != nil {
		s = append(s, "Revocable: "+fmt.Sprintf("%#v", this.Revocable)+",\n")
	}
	if this.Shared != nil {
		s = append(s, "Shared: "+fmt.Sprintf("%#v", this.Shared)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_AllocationInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Resource_AllocationInfo{")
	if this.Role != nil {
		s = append(s, "Role: "+valueToGoStringMesos(this.Role, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_ReservationInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.Resource_ReservationInfo{")
	if this.Type != nil {
		s = append(s, "Type: "+valueToGoStringMesos(this.Type, "Resource_ReservationInfo_Type")+",\n")
	}
	if this.Role != nil {
		s = append(s, "Role: "+valueToGoStringMesos(this.Role, "string")+",\n")
	}
	if this.Principal != nil {
		s = append(s, "Principal: "+valueToGoStringMesos(this.Principal, "string")+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_DiskInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.Resource_DiskInfo{")
	if this.Persistence != nil {
		s = append(s, "Persistence: "+fmt.Sprintf("%#v", this.Persistence)+",\n")
	}
	if this.Volume != nil {
		s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	}
	if this.Source != nil {
		s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_DiskInfo_Persistence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Resource_DiskInfo_Persistence{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	if this.Principal != nil {
		s = append(s, "Principal: "+valueToGoStringMesos(this.Principal, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_DiskInfo_Source) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mesos.Resource_DiskInfo_Source{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Mount != nil {
		s = append(s, "Mount: "+fmt.Sprintf("%#v", this.Mount)+",\n")
	}
	if this.ID != nil {
		s = append(s, "ID: "+valueToGoStringMesos(this.ID, "string")+",\n")
	}
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	if this.Profile != nil {
		s = append(s, "Profile: "+valueToGoStringMesos(this.Profile, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_DiskInfo_Source_Path) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Resource_DiskInfo_Source_Path{")
	if this.Root != nil {
		s = append(s, "Root: "+valueToGoStringMesos(this.Root, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_DiskInfo_Source_Mount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Resource_DiskInfo_Source_Mount{")
	if this.Root != nil {
		s = append(s, "Root: "+valueToGoStringMesos(this.Root, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_RevocableInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&mesos.Resource_RevocableInfo{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Resource_SharedInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&mesos.Resource_SharedInfo{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrafficControlStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&mesos.TrafficControlStatistics{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	if this.Backlog != nil {
		s = append(s, "Backlog: "+valueToGoStringMesos(this.Backlog, "uint64")+",\n")
	}
	if this.Bytes != nil {
		s = append(s, "Bytes: "+valueToGoStringMesos(this.Bytes, "uint64")+",\n")
	}
	if this.Drops != nil {
		s = append(s, "Drops: "+valueToGoStringMesos(this.Drops, "uint64")+",\n")
	}
	if this.Overlimits != nil {
		s = append(s, "Overlimits: "+valueToGoStringMesos(this.Overlimits, "uint64")+",\n")
	}
	if this.Packets != nil {
		s = append(s, "Packets: "+valueToGoStringMesos(this.Packets, "uint64")+",\n")
	}
	if this.Qlen != nil {
		s = append(s, "Qlen: "+valueToGoStringMesos(this.Qlen, "uint64")+",\n")
	}
	if this.RateBPS != nil {
		s = append(s, "RateBPS: "+valueToGoStringMesos(this.RateBPS, "uint64")+",\n")
	}
	if this.RatePPS != nil {
		s = append(s, "RatePPS: "+valueToGoStringMesos(this.RatePPS, "uint64")+",\n")
	}
	if this.Requeues != nil {
		s = append(s, "Requeues: "+valueToGoStringMesos(this.Requeues, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&mesos.IpStatistics{")
	if this.Forwarding != nil {
		s = append(s, "Forwarding: "+valueToGoStringMesos(this.Forwarding, "int64")+",\n")
	}
	if this.DefaultTTL != nil {
		s = append(s, "DefaultTTL: "+valueToGoStringMesos(this.DefaultTTL, "int64")+",\n")
	}
	if this.InReceives != nil {
		s = append(s, "InReceives: "+valueToGoStringMesos(this.InReceives, "int64")+",\n")
	}
	if this.InHdrErrors != nil {
		s = append(s, "InHdrErrors: "+valueToGoStringMesos(this.InHdrErrors, "int64")+",\n")
	}
	if this.InAddrErrors != nil {
		s = append(s, "InAddrErrors: "+valueToGoStringMesos(this.InAddrErrors, "int64")+",\n")
	}
	if this.ForwDatagrams != nil {
		s = append(s, "ForwDatagrams: "+valueToGoStringMesos(this.ForwDatagrams, "int64")+",\n")
	}
	if this.InUnknownProtos != nil {
		s = append(s, "InUnknownProtos: "+valueToGoStringMesos(this.InUnknownProtos, "int64")+",\n")
	}
	if this.InDiscards != nil {
		s = append(s, "InDiscards: "+valueToGoStringMesos(this.InDiscards, "int64")+",\n")
	}
	if this.InDelivers != nil {
		s = append(s, "InDelivers: "+valueToGoStringMesos(this.InDelivers, "int64")+",\n")
	}
	if this.OutRequests != nil {
		s = append(s, "OutRequests: "+valueToGoStringMesos(this.OutRequests, "int64")+",\n")
	}
	if this.OutDiscards != nil {
		s = append(s, "OutDiscards: "+valueToGoStringMesos(this.OutDiscards, "int64")+",\n")
	}
	if this.OutNoRoutes != nil {
		s = append(s, "OutNoRoutes: "+valueToGoStringMesos(this.OutNoRoutes, "int64")+",\n")
	}
	if this.ReasmTimeout != nil {
		s = append(s, "ReasmTimeout: "+valueToGoStringMesos(this.ReasmTimeout, "int64")+",\n")
	}
	if this.ReasmReqds != nil {
		s = append(s, "ReasmReqds: "+valueToGoStringMesos(this.ReasmReqds, "int64")+",\n")
	}
	if this.ReasmOKs != nil {
		s = append(s, "ReasmOKs: "+valueToGoStringMesos(this.ReasmOKs, "int64")+",\n")
	}
	if this.ReasmFails != nil {
		s = append(s, "ReasmFails: "+valueToGoStringMesos(this.ReasmFails, "int64")+",\n")
	}
	if this.FragOKs != nil {
		s = append(s, "FragOKs: "+valueToGoStringMesos(this.FragOKs, "int64")+",\n")
	}
	if this.FragFails != nil {
		s = append(s, "FragFails: "+valueToGoStringMesos(this.FragFails, "int64")+",\n")
	}
	if this.FragCreates != nil {
		s = append(s, "FragCreates: "+valueToGoStringMesos(this.FragCreates, "int64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IcmpStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 31)
	s = append(s, "&mesos.IcmpStatistics{")
	if this.InMsgs != nil {
		s = append(s, "InMsgs: "+valueToGoStringMesos(this.InMsgs, "int64")+",\n")
	}
	if this.InErrors != nil {
		s = append(s, "InErrors: "+valueToGoStringMesos(this.InErrors, "int64")+",\n")
	}
	if this.InCsumErrors != nil {
		s = append(s, "InCsumErrors: "+valueToGoStringMesos(this.InCsumErrors, "int64")+",\n")
	}
	if this.InDestUnreachs != nil {
		s = append(s, "InDestUnreachs: "+valueToGoStringMesos(this.InDestUnreachs, "int64")+",\n")
	}
	if this.InTimeExcds != nil {
		s = append(s, "InTimeExcds: "+valueToGoStringMesos(this.InTimeExcds, "int64")+",\n")
	}
	if this.InParmProbs != nil {
		s = append(s, "InParmProbs: "+valueToGoStringMesos(this.InParmProbs, "int64")+",\n")
	}
	if this.InSrcQuenchs != nil {
		s = append(s, "InSrcQuenchs: "+valueToGoStringMesos(this.InSrcQuenchs, "int64")+",\n")
	}
	if this.InRedirects != nil {
		s = append(s, "InRedirects: "+valueToGoStringMesos(this.InRedirects, "int64")+",\n")
	}
	if this.InEchos != nil {
		s = append(s, "InEchos: "+valueToGoStringMesos(this.InEchos, "int64")+",\n")
	}
	if this.InEchoReps != nil {
		s = append(s, "InEchoReps: "+valueToGoStringMesos(this.InEchoReps, "int64")+",\n")
	}
	if this.InTimestamps != nil {
		s = append(s, "InTimestamps: "+valueToGoStringMesos(this.InTimestamps, "int64")+",\n")
	}
	if this.InTimestampReps != nil {
		s = append(s, "InTimestampReps: "+valueToGoStringMesos(this.InTimestampReps, "int64")+",\n")
	}
	if this.InAddrMasks != nil {
		s = append(s, "InAddrMasks: "+valueToGoStringMesos(this.InAddrMasks, "int64")+",\n")
	}
	if this.InAddrMaskReps != nil {
		s = append(s, "InAddrMaskReps: "+valueToGoStringMesos(this.InAddrMaskReps, "int64")+",\n")
	}
	if this.OutMsgs != nil {
		s = append(s, "OutMsgs: "+valueToGoStringMesos(this.OutMsgs, "int64")+",\n")
	}
	if this.OutErrors != nil {
		s = append(s, "OutErrors: "+valueToGoStringMesos(this.OutErrors, "int64")+",\n")
	}
	if this.OutDestUnreachs != nil {
		s = append(s, "OutDestUnreachs: "+valueToGoStringMesos(this.OutDestUnreachs, "int64")+",\n")
	}
	if this.OutTimeExcds != nil {
		s = append(s, "OutTimeExcds: "+valueToGoStringMesos(this.OutTimeExcds, "int64")+",\n")
	}
	if this.OutParmProbs != nil {
		s = append(s, "OutParmProbs: "+valueToGoStringMesos(this.OutParmProbs, "int64")+",\n")
	}
	if this.OutSrcQuenchs != nil {
		s = append(s, "OutSrcQuenchs: "+valueToGoStringMesos(this.OutSrcQuenchs, "int64")+",\n")
	}
	if this.OutRedirects != nil {
		s = append(s, "OutRedirects: "+valueToGoStringMesos(this.OutRedirects, "int64")+",\n")
	}
	if this.OutEchos != nil {
		s = append(s, "OutEchos: "+valueToGoStringMesos(this.OutEchos, "int64")+",\n")
	}
	if this.OutEchoReps != nil {
		s = append(s, "OutEchoReps: "+valueToGoStringMesos(this.OutEchoReps, "int64")+",\n")
	}
	if this.OutTimestamps != nil {
		s = append(s, "OutTimestamps: "+valueToGoStringMesos(this.OutTimestamps, "int64")+",\n")
	}
	if this.OutTimestampReps != nil {
		s = append(s, "OutTimestampReps: "+valueToGoStringMesos(this.OutTimestampReps, "int64")+",\n")
	}
	if this.OutAddrMasks != nil {
		s = append(s, "OutAddrMasks: "+valueToGoStringMesos(this.OutAddrMasks, "int64")+",\n")
	}
	if this.OutAddrMaskReps != nil {
		s = append(s, "OutAddrMaskReps: "+valueToGoStringMesos(this.OutAddrMaskReps, "int64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TcpStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&mesos.TcpStatistics{")
	if this.RtoAlgorithm != nil {
		s = append(s, "RtoAlgorithm: "+valueToGoStringMesos(this.RtoAlgorithm, "int64")+",\n")
	}
	if this.RtoMin != nil {
		s = append(s, "RtoMin: "+valueToGoStringMesos(this.RtoMin, "int64")+",\n")
	}
	if this.RtoMax != nil {
		s = append(s, "RtoMax: "+valueToGoStringMesos(this.RtoMax, "int64")+",\n")
	}
	if this.MaxConn != nil {
		s = append(s, "MaxConn: "+valueToGoStringMesos(this.MaxConn, "int64")+",\n")
	}
	if this.ActiveOpens != nil {
		s = append(s, "ActiveOpens: "+valueToGoStringMesos(this.ActiveOpens, "int64")+",\n")
	}
	if this.PassiveOpens != nil {
		s = append(s, "PassiveOpens: "+valueToGoStringMesos(this.PassiveOpens, "int64")+",\n")
	}
	if this.AttemptFails != nil {
		s = append(s, "AttemptFails: "+valueToGoStringMesos(this.AttemptFails, "int64")+",\n")
	}
	if this.EstabResets != nil {
		s = append(s, "EstabResets: "+valueToGoStringMesos(this.EstabResets, "int64")+",\n")
	}
	if this.CurrEstab != nil {
		s = append(s, "CurrEstab: "+valueToGoStringMesos(this.CurrEstab, "int64")+",\n")
	}
	if this.InSegs != nil {
		s = append(s, "InSegs: "+valueToGoStringMesos(this.InSegs, "int64")+",\n")
	}
	if this.OutSegs != nil {
		s = append(s, "OutSegs: "+valueToGoStringMesos(this.OutSegs, "int64")+",\n")
	}
	if this.RetransSegs != nil {
		s = append(s, "RetransSegs: "+valueToGoStringMesos(this.RetransSegs, "int64")+",\n")
	}
	if this.InErrs != nil {
		s = append(s, "InErrs: "+valueToGoStringMesos(this.InErrs, "int64")+",\n")
	}
	if this.OutRsts != nil {
		s = append(s, "OutRsts: "+valueToGoStringMesos(this.OutRsts, "int64")+",\n")
	}
	if this.InCsumErrors != nil {
		s = append(s, "InCsumErrors: "+valueToGoStringMesos(this.InCsumErrors, "int64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UdpStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&mesos.UdpStatistics{")
	if this.InDatagrams != nil {
		s = append(s, "InDatagrams: "+valueToGoStringMesos(this.InDatagrams, "int64")+",\n")
	}
	if this.NoPorts != nil {
		s = append(s, "NoPorts: "+valueToGoStringMesos(this.NoPorts, "int64")+",\n")
	}
	if this.InErrors != nil {
		s = append(s, "InErrors: "+valueToGoStringMesos(this.InErrors, "int64")+",\n")
	}
	if this.OutDatagrams != nil {
		s = append(s, "OutDatagrams: "+valueToGoStringMesos(this.OutDatagrams, "int64")+",\n")
	}
	if this.RcvbufErrors != nil {
		s = append(s, "RcvbufErrors: "+valueToGoStringMesos(this.RcvbufErrors, "int64")+",\n")
	}
	if this.SndbufErrors != nil {
		s = append(s, "SndbufErrors: "+valueToGoStringMesos(this.SndbufErrors, "int64")+",\n")
	}
	if this.InCsumErrors != nil {
		s = append(s, "InCsumErrors: "+valueToGoStringMesos(this.InCsumErrors, "int64")+",\n")
	}
	if this.IgnoredMulti != nil {
		s = append(s, "IgnoredMulti: "+valueToGoStringMesos(this.IgnoredMulti, "int64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SNMPStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.SNMPStatistics{")
	if this.IPStats != nil {
		s = append(s, "IPStats: "+fmt.Sprintf("%#v", this.IPStats)+",\n")
	}
	if this.ICMPStats != nil {
		s = append(s, "ICMPStats: "+fmt.Sprintf("%#v", this.ICMPStats)+",\n")
	}
	if this.TCPStats != nil {
		s = append(s, "TCPStats: "+fmt.Sprintf("%#v", this.TCPStats)+",\n")
	}
	if this.UDPStats != nil {
		s = append(s, "UDPStats: "+fmt.Sprintf("%#v", this.UDPStats)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiskStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.DiskStatistics{")
	if this.Source != nil {
		s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	}
	if this.Persistence != nil {
		s = append(s, "Persistence: "+fmt.Sprintf("%#v", this.Persistence)+",\n")
	}
	if this.LimitBytes != nil {
		s = append(s, "LimitBytes: "+valueToGoStringMesos(this.LimitBytes, "uint64")+",\n")
	}
	if this.UsedBytes != nil {
		s = append(s, "UsedBytes: "+valueToGoStringMesos(this.UsedBytes, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 48)
	s = append(s, "&mesos.ResourceStatistics{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	if this.Processes != nil {
		s = append(s, "Processes: "+valueToGoStringMesos(this.Processes, "uint32")+",\n")
	}
	if this.Threads != nil {
		s = append(s, "Threads: "+valueToGoStringMesos(this.Threads, "uint32")+",\n")
	}
	if this.CPUsUserTimeSecs != nil {
		s = append(s, "CPUsUserTimeSecs: "+valueToGoStringMesos(this.CPUsUserTimeSecs, "float64")+",\n")
	}
	if this.CPUsSystemTimeSecs != nil {
		s = append(s, "CPUsSystemTimeSecs: "+valueToGoStringMesos(this.CPUsSystemTimeSecs, "float64")+",\n")
	}
	if this.CPUsLimit != nil {
		s = append(s, "CPUsLimit: "+valueToGoStringMesos(this.CPUsLimit, "float64")+",\n")
	}
	if this.CPUsNrPeriods != nil {
		s = append(s, "CPUsNrPeriods: "+valueToGoStringMesos(this.CPUsNrPeriods, "uint32")+",\n")
	}
	if this.CPUsNrThrottled != nil {
		s = append(s, "CPUsNrThrottled: "+valueToGoStringMesos(this.CPUsNrThrottled, "uint32")+",\n")
	}
	if this.CPUsThrottledTimeSecs != nil {
		s = append(s, "CPUsThrottledTimeSecs: "+valueToGoStringMesos(this.CPUsThrottledTimeSecs, "float64")+",\n")
	}
	if this.MemTotalBytes != nil {
		s = append(s, "MemTotalBytes: "+valueToGoStringMesos(this.MemTotalBytes, "uint64")+",\n")
	}
	if this.MemTotalMemswBytes != nil {
		s = append(s, "MemTotalMemswBytes: "+valueToGoStringMesos(this.MemTotalMemswBytes, "uint64")+",\n")
	}
	if this.MemLimitBytes != nil {
		s = append(s, "MemLimitBytes: "+valueToGoStringMesos(this.MemLimitBytes, "uint64")+",\n")
	}
	if this.MemSoftLimitBytes != nil {
		s = append(s, "MemSoftLimitBytes: "+valueToGoStringMesos(this.MemSoftLimitBytes, "uint64")+",\n")
	}
	if this.MemFileBytes != nil {
		s = append(s, "MemFileBytes: "+valueToGoStringMesos(this.MemFileBytes, "uint64")+",\n")
	}
	if this.MemAnonBytes != nil {
		s = append(s, "MemAnonBytes: "+valueToGoStringMesos(this.MemAnonBytes, "uint64")+",\n")
	}
	if this.MemCacheBytes != nil {
		s = append(s, "MemCacheBytes: "+valueToGoStringMesos(this.MemCacheBytes, "uint64")+",\n")
	}
	if this.MemRSSBytes != nil {
		s = append(s, "MemRSSBytes: "+valueToGoStringMesos(this.MemRSSBytes, "uint64")+",\n")
	}
	if this.MemMappedFileBytes != nil {
		s = append(s, "MemMappedFileBytes: "+valueToGoStringMesos(this.MemMappedFileBytes, "uint64")+",\n")
	}
	if this.MemSwapBytes != nil {
		s = append(s, "MemSwapBytes: "+valueToGoStringMesos(this.MemSwapBytes, "uint64")+",\n")
	}
	if this.MemUnevictableBytes != nil {
		s = append(s, "MemUnevictableBytes: "+valueToGoStringMesos(this.MemUnevictableBytes, "uint64")+",\n")
	}
	if this.MemLowPressureCounter != nil {
		s = append(s, "MemLowPressureCounter: "+valueToGoStringMesos(this.MemLowPressureCounter, "uint64")+",\n")
	}
	if this.MemMediumPressureCounter != nil {
		s = append(s, "MemMediumPressureCounter: "+valueToGoStringMesos(this.MemMediumPressureCounter, "uint64")+",\n")
	}
	if this.MemCriticalPressureCounter != nil {
		s = append(s, "MemCriticalPressureCounter: "+valueToGoStringMesos(this.MemCriticalPressureCounter, "uint64")+",\n")
	}
	if this.DiskLimitBytes != nil {
		s = append(s, "DiskLimitBytes: "+valueToGoStringMesos(this.DiskLimitBytes, "uint64")+",\n")
	}
	if this.DiskUsedBytes != nil {
		s = append(s, "DiskUsedBytes: "+valueToGoStringMesos(this.DiskUsedBytes, "uint64")+",\n")
	}
	if this.DiskStatistics != nil {
		s = append(s, "DiskStatistics: "+fmt.Sprintf("%#v", this.DiskStatistics)+",\n")
	}
	if this.BlkioStatistics != nil {
		s = append(s, "BlkioStatistics: "+fmt.Sprintf("%#v", this.BlkioStatistics)+",\n")
	}
	if this.Perf != nil {
		s = append(s, "Perf: "+fmt.Sprintf("%#v", this.Perf)+",\n")
	}
	if this.NetRxPackets != nil {
		s = append(s, "NetRxPackets: "+valueToGoStringMesos(this.NetRxPackets, "uint64")+",\n")
	}
	if this.NetRxBytes != nil {
		s = append(s, "NetRxBytes: "+valueToGoStringMesos(this.NetRxBytes, "uint64")+",\n")
	}
	if this.NetRxErrors != nil {
		s = append(s, "NetRxErrors: "+valueToGoStringMesos(this.NetRxErrors, "uint64")+",\n")
	}
	if this.NetRxDropped != nil {
		s = append(s, "NetRxDropped: "+valueToGoStringMesos(this.NetRxDropped, "uint64")+",\n")
	}
	if this.NetTxPackets != nil {
		s = append(s, "NetTxPackets: "+valueToGoStringMesos(this.NetTxPackets, "uint64")+",\n")
	}
	if this.NetTxBytes != nil {
		s = append(s, "NetTxBytes: "+valueToGoStringMesos(this.NetTxBytes, "uint64")+",\n")
	}
	if this.NetTxErrors != nil {
		s = append(s, "NetTxErrors: "+valueToGoStringMesos(this.NetTxErrors, "uint64")+",\n")
	}
	if this.NetTxDropped != nil {
		s = append(s, "NetTxDropped: "+valueToGoStringMesos(this.NetTxDropped, "uint64")+",\n")
	}
	if this.NetTCPRttMicrosecsP50 != nil {
		s = append(s, "NetTCPRttMicrosecsP50: "+valueToGoStringMesos(this.NetTCPRttMicrosecsP50, "float64")+",\n")
	}
	if this.NetTCPRttMicrosecsP90 != nil {
		s = append(s, "NetTCPRttMicrosecsP90: "+valueToGoStringMesos(this.NetTCPRttMicrosecsP90, "float64")+",\n")
	}
	if this.NetTCPRttMicrosecsP95 != nil {
		s = append(s, "NetTCPRttMicrosecsP95: "+valueToGoStringMesos(this.NetTCPRttMicrosecsP95, "float64")+",\n")
	}
	if this.NetTCPRttMicrosecsP99 != nil {
		s = append(s, "NetTCPRttMicrosecsP99: "+valueToGoStringMesos(this.NetTCPRttMicrosecsP99, "float64")+",\n")
	}
	if this.NetTCPActiveConnections != nil {
		s = append(s, "NetTCPActiveConnections: "+valueToGoStringMesos(this.NetTCPActiveConnections, "float64")+",\n")
	}
	if this.NetTCPTimeWaitConnections != nil {
		s = append(s, "NetTCPTimeWaitConnections: "+valueToGoStringMesos(this.NetTCPTimeWaitConnections, "float64")+",\n")
	}
	if this.NetTrafficControlStatistics != nil {
		s = append(s, "NetTrafficControlStatistics: "+fmt.Sprintf("%#v", this.NetTrafficControlStatistics)+",\n")
	}
	if this.NetSNMPStatistics != nil {
		s = append(s, "NetSNMPStatistics: "+fmt.Sprintf("%#v", this.NetSNMPStatistics)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceUsage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.ResourceUsage{")
	if this.Executors != nil {
		s = append(s, "Executors: "+fmt.Sprintf("%#v", this.Executors)+",\n")
	}
	if this.Total != nil {
		s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceUsage_Executor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.ResourceUsage_Executor{")
	s = append(s, "ExecutorInfo: "+strings.Replace(this.ExecutorInfo.GoString(), `&`, ``, 1)+",\n")
	if this.Allocated != nil {
		s = append(s, "Allocated: "+fmt.Sprintf("%#v", this.Allocated)+",\n")
	}
	if this.Statistics != nil {
		s = append(s, "Statistics: "+fmt.Sprintf("%#v", this.Statistics)+",\n")
	}
	s = append(s, "ContainerID: "+strings.Replace(this.ContainerID.GoString(), `&`, ``, 1)+",\n")
	if this.Tasks != nil {
		s = append(s, "Tasks: "+fmt.Sprintf("%#v", this.Tasks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceUsage_Executor_Task) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.ResourceUsage_Executor_Task{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ID: "+strings.Replace(this.ID.GoString(), `&`, ``, 1)+",\n")
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PerfStatistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 57)
	s = append(s, "&mesos.PerfStatistics{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	if this.Cycles != nil {
		s = append(s, "Cycles: "+valueToGoStringMesos(this.Cycles, "uint64")+",\n")
	}
	if this.StalledCyclesFrontend != nil {
		s = append(s, "StalledCyclesFrontend: "+valueToGoStringMesos(this.StalledCyclesFrontend, "uint64")+",\n")
	}
	if this.StalledCyclesBackend != nil {
		s = append(s, "StalledCyclesBackend: "+valueToGoStringMesos(this.StalledCyclesBackend, "uint64")+",\n")
	}
	if this.Instructions != nil {
		s = append(s, "Instructions: "+valueToGoStringMesos(this.Instructions, "uint64")+",\n")
	}
	if this.CacheReferences != nil {
		s = append(s, "CacheReferences: "+valueToGoStringMesos(this.CacheReferences, "uint64")+",\n")
	}
	if this.CacheMisses != nil {
		s = append(s, "CacheMisses: "+valueToGoStringMesos(this.CacheMisses, "uint64")+",\n")
	}
	if this.Branches != nil {
		s = append(s, "Branches: "+valueToGoStringMesos(this.Branches, "uint64")+",\n")
	}
	if this.BranchMisses != nil {
		s = append(s, "BranchMisses: "+valueToGoStringMesos(this.BranchMisses, "uint64")+",\n")
	}
	if this.BusCycles != nil {
		s = append(s, "BusCycles: "+valueToGoStringMesos(this.BusCycles, "uint64")+",\n")
	}
	if this.RefCycles != nil {
		s = append(s, "RefCycles: "+valueToGoStringMesos(this.RefCycles, "uint64")+",\n")
	}
	if this.CPUClock != nil {
		s = append(s, "CPUClock: "+valueToGoStringMesos(this.CPUClock, "float64")+",\n")
	}
	if this.TaskClock != nil {
		s = append(s, "TaskClock: "+valueToGoStringMesos(this.TaskClock, "float64")+",\n")
	}
	if this.PageFaults != nil {
		s = append(s, "PageFaults: "+valueToGoStringMesos(this.PageFaults, "uint64")+",\n")
	}
	if this.MinorFaults != nil {
		s = append(s, "MinorFaults: "+valueToGoStringMesos(this.MinorFaults, "uint64")+",\n")
	}
	if this.MajorFaults != nil {
		s = append(s, "MajorFaults: "+valueToGoStringMesos(this.MajorFaults, "uint64")+",\n")
	}
	if this.ContextSwitches != nil {
		s = append(s, "ContextSwitches: "+valueToGoStringMesos(this.ContextSwitches, "uint64")+",\n")
	}
	if this.CPUMigrations != nil {
		s = append(s, "CPUMigrations: "+valueToGoStringMesos(this.CPUMigrations, "uint64")+",\n")
	}
	if this.AlignmentFaults != nil {
		s = append(s, "AlignmentFaults: "+valueToGoStringMesos(this.AlignmentFaults, "uint64")+",\n")
	}
	if this.EmulationFaults != nil {
		s = append(s, "EmulationFaults: "+valueToGoStringMesos(this.EmulationFaults, "uint64")+",\n")
	}
	if this.L1DcacheLoads != nil {
		s = append(s, "L1DcacheLoads: "+valueToGoStringMesos(this.L1DcacheLoads, "uint64")+",\n")
	}
	if this.L1DcacheLoadMisses != nil {
		s = append(s, "L1DcacheLoadMisses: "+valueToGoStringMesos(this.L1DcacheLoadMisses, "uint64")+",\n")
	}
	if this.L1DcacheStores != nil {
		s = append(s, "L1DcacheStores: "+valueToGoStringMesos(this.L1DcacheStores, "uint64")+",\n")
	}
	if this.L1DcacheStoreMisses != nil {
		s = append(s, "L1DcacheStoreMisses: "+valueToGoStringMesos(this.L1DcacheStoreMisses, "uint64")+",\n")
	}
	if this.L1DcachePrefetches != nil {
		s = append(s, "L1DcachePrefetches: "+valueToGoStringMesos(this.L1DcachePrefetches, "uint64")+",\n")
	}
	if this.L1DcachePrefetchMisses != nil {
		s = append(s, "L1DcachePrefetchMisses: "+valueToGoStringMesos(this.L1DcachePrefetchMisses, "uint64")+",\n")
	}
	if this.L1IcacheLoads != nil {
		s = append(s, "L1IcacheLoads: "+valueToGoStringMesos(this.L1IcacheLoads, "uint64")+",\n")
	}
	if this.L1IcacheLoadMisses != nil {
		s = append(s, "L1IcacheLoadMisses: "+valueToGoStringMesos(this.L1IcacheLoadMisses, "uint64")+",\n")
	}
	if this.L1IcachePrefetches != nil {
		s = append(s, "L1IcachePrefetches: "+valueToGoStringMesos(this.L1IcachePrefetches, "uint64")+",\n")
	}
	if this.L1IcachePrefetchMisses != nil {
		s = append(s, "L1IcachePrefetchMisses: "+valueToGoStringMesos(this.L1IcachePrefetchMisses, "uint64")+",\n")
	}
	if this.LLCLoads != nil {
		s = append(s, "LLCLoads: "+valueToGoStringMesos(this.LLCLoads, "uint64")+",\n")
	}
	if this.LLCLoadMisses != nil {
		s = append(s, "LLCLoadMisses: "+valueToGoStringMesos(this.LLCLoadMisses, "uint64")+",\n")
	}
	if this.LLCStores != nil {
		s = append(s, "LLCStores: "+valueToGoStringMesos(this.LLCStores, "uint64")+",\n")
	}
	if this.LLCStoreMisses != nil {
		s = append(s, "LLCStoreMisses: "+valueToGoStringMesos(this.LLCStoreMisses, "uint64")+",\n")
	}
	if this.LLCPrefetches != nil {
		s = append(s, "LLCPrefetches: "+valueToGoStringMesos(this.LLCPrefetches, "uint64")+",\n")
	}
	if this.LLCPrefetchMisses != nil {
		s = append(s, "LLCPrefetchMisses: "+valueToGoStringMesos(this.LLCPrefetchMisses, "uint64")+",\n")
	}
	if this.DTLBLoads != nil {
		s = append(s, "DTLBLoads: "+valueToGoStringMesos(this.DTLBLoads, "uint64")+",\n")
	}
	if this.DTLBLoadMisses != nil {
		s = append(s, "DTLBLoadMisses: "+valueToGoStringMesos(this.DTLBLoadMisses, "uint64")+",\n")
	}
	if this.DTLBStores != nil {
		s = append(s, "DTLBStores: "+valueToGoStringMesos(this.DTLBStores, "uint64")+",\n")
	}
	if this.DTLBStoreMisses != nil {
		s = append(s, "DTLBStoreMisses: "+valueToGoStringMesos(this.DTLBStoreMisses, "uint64")+",\n")
	}
	if this.DTLBPrefetches != nil {
		s = append(s, "DTLBPrefetches: "+valueToGoStringMesos(this.DTLBPrefetches, "uint64")+",\n")
	}
	if this.DTLBPrefetchMisses != nil {
		s = append(s, "DTLBPrefetchMisses: "+valueToGoStringMesos(this.DTLBPrefetchMisses, "uint64")+",\n")
	}
	if this.ITLBLoads != nil {
		s = append(s, "ITLBLoads: "+valueToGoStringMesos(this.ITLBLoads, "uint64")+",\n")
	}
	if this.ITLBLoadMisses != nil {
		s = append(s, "ITLBLoadMisses: "+valueToGoStringMesos(this.ITLBLoadMisses, "uint64")+",\n")
	}
	if this.BranchLoads != nil {
		s = append(s, "BranchLoads: "+valueToGoStringMesos(this.BranchLoads, "uint64")+",\n")
	}
	if this.BranchLoadMisses != nil {
		s = append(s, "BranchLoadMisses: "+valueToGoStringMesos(this.BranchLoadMisses, "uint64")+",\n")
	}
	if this.NodeLoads != nil {
		s = append(s, "NodeLoads: "+valueToGoStringMesos(this.NodeLoads, "uint64")+",\n")
	}
	if this.NodeLoadMisses != nil {
		s = append(s, "NodeLoadMisses: "+valueToGoStringMesos(this.NodeLoadMisses, "uint64")+",\n")
	}
	if this.NodeStores != nil {
		s = append(s, "NodeStores: "+valueToGoStringMesos(this.NodeStores, "uint64")+",\n")
	}
	if this.NodeStoreMisses != nil {
		s = append(s, "NodeStoreMisses: "+valueToGoStringMesos(this.NodeStoreMisses, "uint64")+",\n")
	}
	if this.NodePrefetches != nil {
		s = append(s, "NodePrefetches: "+valueToGoStringMesos(this.NodePrefetches, "uint64")+",\n")
	}
	if this.NodePrefetchMisses != nil {
		s = append(s, "NodePrefetchMisses: "+valueToGoStringMesos(this.NodePrefetchMisses, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Request{")
	if this.AgentID != nil {
		s = append(s, "AgentID: "+fmt.Sprintf("%#v", this.AgentID)+",\n")
	}
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&mesos.Offer{")
	s = append(s, "ID: "+strings.Replace(this.ID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "FrameworkID: "+strings.Replace(this.FrameworkID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "AgentID: "+strings.Replace(this.AgentID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	if this.URL != nil {
		s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	}
	if this.Domain != nil {
		s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	}
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	if this.Attributes != nil {
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", this.Attributes)+",\n")
	}
	if this.ExecutorIDs != nil {
		s = append(s, "ExecutorIDs: "+fmt.Sprintf("%#v", this.ExecutorIDs)+",\n")
	}
	if this.Unavailability != nil {
		s = append(s, "Unavailability: "+fmt.Sprintf("%#v", this.Unavailability)+",\n")
	}
	if this.AllocationInfo != nil {
		s = append(s, "AllocationInfo: "+fmt.Sprintf("%#v", this.AllocationInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&mesos.Offer_Operation{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.ID != nil {
		s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	}
	if this.Launch != nil {
		s = append(s, "Launch: "+fmt.Sprintf("%#v", this.Launch)+",\n")
	}
	if this.LaunchGroup != nil {
		s = append(s, "LaunchGroup: "+fmt.Sprintf("%#v", this.LaunchGroup)+",\n")
	}
	if this.Reserve != nil {
		s = append(s, "Reserve: "+fmt.Sprintf("%#v", this.Reserve)+",\n")
	}
	if this.Unreserve != nil {
		s = append(s, "Unreserve: "+fmt.Sprintf("%#v", this.Unreserve)+",\n")
	}
	if this.Create != nil {
		s = append(s, "Create: "+fmt.Sprintf("%#v", this.Create)+",\n")
	}
	if this.Destroy != nil {
		s = append(s, "Destroy: "+fmt.Sprintf("%#v", this.Destroy)+",\n")
	}
	if this.GrowVolume != nil {
		s = append(s, "GrowVolume: "+fmt.Sprintf("%#v", this.GrowVolume)+",\n")
	}
	if this.ShrinkVolume != nil {
		s = append(s, "ShrinkVolume: "+fmt.Sprintf("%#v", this.ShrinkVolume)+",\n")
	}
	if this.CreateDisk != nil {
		s = append(s, "CreateDisk: "+fmt.Sprintf("%#v", this.CreateDisk)+",\n")
	}
	if this.DestroyDisk != nil {
		s = append(s, "DestroyDisk: "+fmt.Sprintf("%#v", this.DestroyDisk)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_Launch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Offer_Operation_Launch{")
	if this.TaskInfos != nil {
		s = append(s, "TaskInfos: "+fmt.Sprintf("%#v", this.TaskInfos)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_LaunchGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Offer_Operation_LaunchGroup{")
	s = append(s, "Executor: "+strings.Replace(this.Executor.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "TaskGroup: "+strings.Replace(this.TaskGroup.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_Reserve) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Offer_Operation_Reserve{")
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_Unreserve) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Offer_Operation_Unreserve{")
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_Create) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Offer_Operation_Create{")
	if this.Volumes != nil {
		s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_Destroy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Offer_Operation_Destroy{")
	if this.Volumes != nil {
		s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_GrowVolume) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Offer_Operation_GrowVolume{")
	s = append(s, "Volume: "+strings.Replace(this.Volume.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Addition: "+strings.Replace(this.Addition.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_ShrinkVolume) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Offer_Operation_ShrinkVolume{")
	s = append(s, "Volume: "+strings.Replace(this.Volume.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Subtract: "+strings.Replace(this.Subtract.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_CreateDisk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Offer_Operation_CreateDisk{")
	s = append(s, "Source: "+strings.Replace(this.Source.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "TargetType: "+fmt.Sprintf("%#v", this.TargetType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Offer_Operation_DestroyDisk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Offer_Operation_DestroyDisk{")
	s = append(s, "Source: "+strings.Replace(this.Source.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InverseOffer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mesos.InverseOffer{")
	s = append(s, "OfferID: "+strings.Replace(this.OfferID.GoString(), `&`, ``, 1)+",\n")
	if this.URL != nil {
		s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	}
	s = append(s, "FrameworkID: "+strings.Replace(this.FrameworkID.GoString(), `&`, ``, 1)+",\n")
	if this.AgentID != nil {
		s = append(s, "AgentID: "+fmt.Sprintf("%#v", this.AgentID)+",\n")
	}
	s = append(s, "Unavailability: "+strings.Replace(this.Unavailability.GoString(), `&`, ``, 1)+",\n")
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&mesos.TaskInfo{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "TaskID: "+strings.Replace(this.TaskID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "AgentID: "+strings.Replace(this.AgentID.GoString(), `&`, ``, 1)+",\n")
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	if this.Executor != nil {
		s = append(s, "Executor: "+fmt.Sprintf("%#v", this.Executor)+",\n")
	}
	if this.Command != nil {
		s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	}
	if this.Container != nil {
		s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	}
	if this.HealthCheck != nil {
		s = append(s, "HealthCheck: "+fmt.Sprintf("%#v", this.HealthCheck)+",\n")
	}
	if this.Check != nil {
		s = append(s, "Check: "+fmt.Sprintf("%#v", this.Check)+",\n")
	}
	if this.KillPolicy != nil {
		s = append(s, "KillPolicy: "+fmt.Sprintf("%#v", this.KillPolicy)+",\n")
	}
	if this.Data != nil {
		s = append(s, "Data: "+valueToGoStringMesos(this.Data, "byte")+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	if this.Discovery != nil {
		s = append(s, "Discovery: "+fmt.Sprintf("%#v", this.Discovery)+",\n")
	}
	if this.MaxCompletionTime != nil {
		s = append(s, "MaxCompletionTime: "+fmt.Sprintf("%#v", this.MaxCompletionTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskGroupInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.TaskGroupInfo{")
	if this.Tasks != nil {
		s = append(s, "Tasks: "+fmt.Sprintf("%#v", this.Tasks)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Task) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&mesos.Task{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "TaskID: "+strings.Replace(this.TaskID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "FrameworkID: "+strings.Replace(this.FrameworkID.GoString(), `&`, ``, 1)+",\n")
	if this.ExecutorID != nil {
		s = append(s, "ExecutorID: "+fmt.Sprintf("%#v", this.ExecutorID)+",\n")
	}
	s = append(s, "AgentID: "+strings.Replace(this.AgentID.GoString(), `&`, ``, 1)+",\n")
	if this.State != nil {
		s = append(s, "State: "+valueToGoStringMesos(this.State, "TaskState")+",\n")
	}
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	if this.Statuses != nil {
		s = append(s, "Statuses: "+fmt.Sprintf("%#v", this.Statuses)+",\n")
	}
	if this.StatusUpdateState != nil {
		s = append(s, "StatusUpdateState: "+valueToGoStringMesos(this.StatusUpdateState, "TaskState")+",\n")
	}
	if this.StatusUpdateUUID != nil {
		s = append(s, "StatusUpdateUUID: "+valueToGoStringMesos(this.StatusUpdateUUID, "byte")+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	if this.Discovery != nil {
		s = append(s, "Discovery: "+fmt.Sprintf("%#v", this.Discovery)+",\n")
	}
	if this.Container != nil {
		s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	}
	if this.User != nil {
		s = append(s, "User: "+valueToGoStringMesos(this.User, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskResourceLimitation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.TaskResourceLimitation{")
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UUID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.UUID{")
	if this.Value != nil {
		s = append(s, "Value: "+valueToGoStringMesos(this.Value, "byte")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Operation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&mesos.Operation{")
	if this.FrameworkID != nil {
		s = append(s, "FrameworkID: "+fmt.Sprintf("%#v", this.FrameworkID)+",\n")
	}
	if this.AgentID != nil {
		s = append(s, "AgentID: "+fmt.Sprintf("%#v", this.AgentID)+",\n")
	}
	s = append(s, "Info: "+strings.Replace(this.Info.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "LatestStatus: "+strings.Replace(this.LatestStatus.GoString(), `&`, ``, 1)+",\n")
	if this.Statuses != nil {
		s = append(s, "Statuses: "+fmt.Sprintf("%#v", this.Statuses)+",\n")
	}
	s = append(s, "UUID: "+strings.Replace(this.UUID.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OperationStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.OperationStatus{")
	if this.OperationID != nil {
		s = append(s, "OperationID: "+fmt.Sprintf("%#v", this.OperationID)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+valueToGoStringMesos(this.Message, "string")+",\n")
	}
	if this.ConvertedResources != nil {
		s = append(s, "ConvertedResources: "+fmt.Sprintf("%#v", this.ConvertedResources)+",\n")
	}
	if this.UUID != nil {
		s = append(s, "UUID: "+fmt.Sprintf("%#v", this.UUID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckStatusInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.CheckStatusInfo{")
	if this.Type != nil {
		s = append(s, "Type: "+valueToGoStringMesos(this.Type, "CheckInfo_Type")+",\n")
	}
	if this.Command != nil {
		s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	}
	if this.HTTP != nil {
		s = append(s, "HTTP: "+fmt.Sprintf("%#v", this.HTTP)+",\n")
	}
	if this.TCP != nil {
		s = append(s, "TCP: "+fmt.Sprintf("%#v", this.TCP)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckStatusInfo_Command) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.CheckStatusInfo_Command{")
	if this.ExitCode != nil {
		s = append(s, "ExitCode: "+valueToGoStringMesos(this.ExitCode, "int32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckStatusInfo_Http) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.CheckStatusInfo_Http{")
	if this.StatusCode != nil {
		s = append(s, "StatusCode: "+valueToGoStringMesos(this.StatusCode, "uint32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckStatusInfo_Tcp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.CheckStatusInfo_Tcp{")
	if this.Succeeded != nil {
		s = append(s, "Succeeded: "+valueToGoStringMesos(this.Succeeded, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TaskStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&mesos.TaskStatus{")
	s = append(s, "TaskID: "+strings.Replace(this.TaskID.GoString(), `&`, ``, 1)+",\n")
	if this.State != nil {
		s = append(s, "State: "+valueToGoStringMesos(this.State, "TaskState")+",\n")
	}
	if this.Message != nil {
		s = append(s, "Message: "+valueToGoStringMesos(this.Message, "string")+",\n")
	}
	if this.Source != nil {
		s = append(s, "Source: "+valueToGoStringMesos(this.Source, "TaskStatus_Source")+",\n")
	}
	if this.Reason != nil {
		s = append(s, "Reason: "+valueToGoStringMesos(this.Reason, "TaskStatus_Reason")+",\n")
	}
	if this.Data != nil {
		s = append(s, "Data: "+valueToGoStringMesos(this.Data, "byte")+",\n")
	}
	if this.AgentID != nil {
		s = append(s, "AgentID: "+fmt.Sprintf("%#v", this.AgentID)+",\n")
	}
	if this.ExecutorID != nil {
		s = append(s, "ExecutorID: "+fmt.Sprintf("%#v", this.ExecutorID)+",\n")
	}
	if this.Timestamp != nil {
		s = append(s, "Timestamp: "+valueToGoStringMesos(this.Timestamp, "float64")+",\n")
	}
	if this.UUID != nil {
		s = append(s, "UUID: "+valueToGoStringMesos(this.UUID, "byte")+",\n")
	}
	if this.Healthy != nil {
		s = append(s, "Healthy: "+valueToGoStringMesos(this.Healthy, "bool")+",\n")
	}
	if this.CheckStatus != nil {
		s = append(s, "CheckStatus: "+fmt.Sprintf("%#v", this.CheckStatus)+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	if this.ContainerStatus != nil {
		s = append(s, "ContainerStatus: "+fmt.Sprintf("%#v", this.ContainerStatus)+",\n")
	}
	if this.UnreachableTime != nil {
		s = append(s, "UnreachableTime: "+fmt.Sprintf("%#v", this.UnreachableTime)+",\n")
	}
	if this.Limitation != nil {
		s = append(s, "Limitation: "+fmt.Sprintf("%#v", this.Limitation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Filters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Filters{")
	if this.RefuseSeconds != nil {
		s = append(s, "RefuseSeconds: "+valueToGoStringMesos(this.RefuseSeconds, "float64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Environment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Environment{")
	if this.Variables != nil {
		s = append(s, "Variables: "+fmt.Sprintf("%#v", this.Variables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Environment_Variable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.Environment_Variable{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Type != nil {
		s = append(s, "Type: "+valueToGoStringMesos(this.Type, "Environment_Variable_Type")+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+valueToGoStringMesos(this.Value, "string")+",\n")
	}
	if this.Secret != nil {
		s = append(s, "Secret: "+fmt.Sprintf("%#v", this.Secret)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Parameter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Parameter{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Parameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Parameters{")
	if this.Parameter != nil {
		s = append(s, "Parameter: "+fmt.Sprintf("%#v", this.Parameter)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Credential) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Credential{")
	s = append(s, "Principal: "+fmt.Sprintf("%#v", this.Principal)+",\n")
	if this.Secret != nil {
		s = append(s, "Secret: "+valueToGoStringMesos(this.Secret, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Credentials) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Credentials{")
	if this.Credentials != nil {
		s = append(s, "Credentials: "+fmt.Sprintf("%#v", this.Credentials)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Secret) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.Secret{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Reference != nil {
		s = append(s, "Reference: "+fmt.Sprintf("%#v", this.Reference)+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Secret_Reference) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Secret_Reference{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Key != nil {
		s = append(s, "Key: "+valueToGoStringMesos(this.Key, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Secret_Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Secret_Value{")
	if this.Data != nil {
		s = append(s, "Data: "+valueToGoStringMesos(this.Data, "byte")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RateLimit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.RateLimit{")
	if this.QPS != nil {
		s = append(s, "QPS: "+valueToGoStringMesos(this.QPS, "float64")+",\n")
	}
	s = append(s, "Principal: "+fmt.Sprintf("%#v", this.Principal)+",\n")
	if this.Capacity != nil {
		s = append(s, "Capacity: "+valueToGoStringMesos(this.Capacity, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RateLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.RateLimits{")
	if this.Limits != nil {
		s = append(s, "Limits: "+fmt.Sprintf("%#v", this.Limits)+",\n")
	}
	if this.AggregateDefaultQPS != nil {
		s = append(s, "AggregateDefaultQPS: "+valueToGoStringMesos(this.AggregateDefaultQPS, "float64")+",\n")
	}
	if this.AggregateDefaultCapacity != nil {
		s = append(s, "AggregateDefaultCapacity: "+valueToGoStringMesos(this.AggregateDefaultCapacity, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Image) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.Image{")
	if this.Type != nil {
		s = append(s, "Type: "+valueToGoStringMesos(this.Type, "Image_Type")+",\n")
	}
	if this.Appc != nil {
		s = append(s, "Appc: "+fmt.Sprintf("%#v", this.Appc)+",\n")
	}
	if this.Docker != nil {
		s = append(s, "Docker: "+fmt.Sprintf("%#v", this.Docker)+",\n")
	}
	if this.Cached != nil {
		s = append(s, "Cached: "+valueToGoStringMesos(this.Cached, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Image_Appc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.Image_Appc{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ID != nil {
		s = append(s, "ID: "+valueToGoStringMesos(this.ID, "string")+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Image_Docker) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.Image_Docker{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Credential != nil {
		s = append(s, "Credential: "+fmt.Sprintf("%#v", this.Credential)+",\n")
	}
	if this.Config != nil {
		s = append(s, "Config: "+fmt.Sprintf("%#v", this.Config)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MountPropagation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.MountPropagation{")
	if this.Mode != nil {
		s = append(s, "Mode: "+valueToGoStringMesos(this.Mode, "MountPropagation_Mode")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Volume) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.Volume{")
	if this.Mode != nil {
		s = append(s, "Mode: "+valueToGoStringMesos(this.Mode, "Volume_Mode")+",\n")
	}
	s = append(s, "ContainerPath: "+fmt.Sprintf("%#v", this.ContainerPath)+",\n")
	if this.HostPath != nil {
		s = append(s, "HostPath: "+valueToGoStringMesos(this.HostPath, "string")+",\n")
	}
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	if this.Source != nil {
		s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Volume_Source) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.Volume_Source{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.DockerVolume != nil {
		s = append(s, "DockerVolume: "+fmt.Sprintf("%#v", this.DockerVolume)+",\n")
	}
	if this.HostPath != nil {
		s = append(s, "HostPath: "+fmt.Sprintf("%#v", this.HostPath)+",\n")
	}
	if this.SandboxPath != nil {
		s = append(s, "SandboxPath: "+fmt.Sprintf("%#v", this.SandboxPath)+",\n")
	}
	if this.Secret != nil {
		s = append(s, "Secret: "+fmt.Sprintf("%#v", this.Secret)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Volume_Source_DockerVolume) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.Volume_Source_DockerVolume{")
	if this.Driver != nil {
		s = append(s, "Driver: "+valueToGoStringMesos(this.Driver, "string")+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.DriverOptions != nil {
		s = append(s, "DriverOptions: "+fmt.Sprintf("%#v", this.DriverOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Volume_Source_HostPath) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Volume_Source_HostPath{")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.MountPropagation != nil {
		s = append(s, "MountPropagation: "+fmt.Sprintf("%#v", this.MountPropagation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Volume_Source_SandboxPath) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Volume_Source_SandboxPath{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.NetworkInfo{")
	if this.IPAddresses != nil {
		s = append(s, "IPAddresses: "+fmt.Sprintf("%#v", this.IPAddresses)+",\n")
	}
	if this.Name != nil {
		s = append(s, "Name: "+valueToGoStringMesos(this.Name, "string")+",\n")
	}
	if this.Groups != nil {
		s = append(s, "Groups: "+fmt.Sprintf("%#v", this.Groups)+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	if this.PortMappings != nil {
		s = append(s, "PortMappings: "+fmt.Sprintf("%#v", this.PortMappings)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInfo_IPAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.NetworkInfo_IPAddress{")
	if this.Protocol != nil {
		s = append(s, "Protocol: "+valueToGoStringMesos(this.Protocol, "NetworkInfo_Protocol")+",\n")
	}
	if this.IPAddress != nil {
		s = append(s, "IPAddress: "+valueToGoStringMesos(this.IPAddress, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInfo_PortMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.NetworkInfo_PortMapping{")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	if this.Protocol != nil {
		s = append(s, "Protocol: "+valueToGoStringMesos(this.Protocol, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CapabilityInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.CapabilityInfo{")
	if this.Capabilities != nil {
		s = append(s, "Capabilities: "+fmt.Sprintf("%#v", this.Capabilities)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LinuxInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.LinuxInfo{")
	if this.CapabilityInfo != nil {
		s = append(s, "CapabilityInfo: "+fmt.Sprintf("%#v", this.CapabilityInfo)+",\n")
	}
	if this.BoundingCapabilities != nil {
		s = append(s, "BoundingCapabilities: "+fmt.Sprintf("%#v", this.BoundingCapabilities)+",\n")
	}
	if this.EffectiveCapabilities != nil {
		s = append(s, "EffectiveCapabilities: "+fmt.Sprintf("%#v", this.EffectiveCapabilities)+",\n")
	}
	if this.SharePIDNamespace != nil {
		s = append(s, "SharePIDNamespace: "+valueToGoStringMesos(this.SharePIDNamespace, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RLimitInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.RLimitInfo{")
	if this.Rlimits != nil {
		s = append(s, "Rlimits: "+fmt.Sprintf("%#v", this.Rlimits)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RLimitInfo_RLimit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.RLimitInfo_RLimit{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Hard != nil {
		s = append(s, "Hard: "+valueToGoStringMesos(this.Hard, "uint64")+",\n")
	}
	if this.Soft != nil {
		s = append(s, "Soft: "+valueToGoStringMesos(this.Soft, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TTYInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.TTYInfo{")
	if this.WindowSize != nil {
		s = append(s, "WindowSize: "+fmt.Sprintf("%#v", this.WindowSize)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TTYInfo_WindowSize) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.TTYInfo_WindowSize{")
	s = append(s, "Rows: "+fmt.Sprintf("%#v", this.Rows)+",\n")
	s = append(s, "Columns: "+fmt.Sprintf("%#v", this.Columns)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&mesos.ContainerInfo{")
	if this.Type != nil {
		s = append(s, "Type: "+valueToGoStringMesos(this.Type, "ContainerInfo_Type")+",\n")
	}
	if this.Volumes != nil {
		s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	}
	if this.Hostname != nil {
		s = append(s, "Hostname: "+valueToGoStringMesos(this.Hostname, "string")+",\n")
	}
	if this.Docker != nil {
		s = append(s, "Docker: "+fmt.Sprintf("%#v", this.Docker)+",\n")
	}
	if this.Mesos != nil {
		s = append(s, "Mesos: "+fmt.Sprintf("%#v", this.Mesos)+",\n")
	}
	if this.NetworkInfos != nil {
		s = append(s, "NetworkInfos: "+fmt.Sprintf("%#v", this.NetworkInfos)+",\n")
	}
	if this.LinuxInfo != nil {
		s = append(s, "LinuxInfo: "+fmt.Sprintf("%#v", this.LinuxInfo)+",\n")
	}
	if this.RlimitInfo != nil {
		s = append(s, "RlimitInfo: "+fmt.Sprintf("%#v", this.RlimitInfo)+",\n")
	}
	if this.TTYInfo != nil {
		s = append(s, "TTYInfo: "+fmt.Sprintf("%#v", this.TTYInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerInfo_DockerInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&mesos.ContainerInfo_DockerInfo{")
	s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	if this.Network != nil {
		s = append(s, "Network: "+valueToGoStringMesos(this.Network, "ContainerInfo_DockerInfo_Network")+",\n")
	}
	if this.PortMappings != nil {
		s = append(s, "PortMappings: "+fmt.Sprintf("%#v", this.PortMappings)+",\n")
	}
	if this.Privileged != nil {
		s = append(s, "Privileged: "+valueToGoStringMesos(this.Privileged, "bool")+",\n")
	}
	if this.Parameters != nil {
		s = append(s, "Parameters: "+fmt.Sprintf("%#v", this.Parameters)+",\n")
	}
	if this.ForcePullImage != nil {
		s = append(s, "ForcePullImage: "+valueToGoStringMesos(this.ForcePullImage, "bool")+",\n")
	}
	if this.VolumeDriver != nil {
		s = append(s, "VolumeDriver: "+valueToGoStringMesos(this.VolumeDriver, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerInfo_DockerInfo_PortMapping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.ContainerInfo_DockerInfo_PortMapping{")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	if this.Protocol != nil {
		s = append(s, "Protocol: "+valueToGoStringMesos(this.Protocol, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerInfo_MesosInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.ContainerInfo_MesosInfo{")
	if this.Image != nil {
		s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.ContainerStatus{")
	if this.ContainerID != nil {
		s = append(s, "ContainerID: "+fmt.Sprintf("%#v", this.ContainerID)+",\n")
	}
	if this.NetworkInfos != nil {
		s = append(s, "NetworkInfos: "+fmt.Sprintf("%#v", this.NetworkInfos)+",\n")
	}
	if this.CgroupInfo != nil {
		s = append(s, "CgroupInfo: "+fmt.Sprintf("%#v", this.CgroupInfo)+",\n")
	}
	if this.ExecutorPID != nil {
		s = append(s, "ExecutorPID: "+valueToGoStringMesos(this.ExecutorPID, "uint32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.CgroupInfo{")
	if this.NetCLS != nil {
		s = append(s, "NetCLS: "+fmt.Sprintf("%#v", this.NetCLS)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo_Blkio) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&mesos.CgroupInfo_Blkio{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo_Blkio_Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.CgroupInfo_Blkio_Value{")
	if this.Op != nil {
		s = append(s, "Op: "+valueToGoStringMesos(this.Op, "CgroupInfo_Blkio_Operation")+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+valueToGoStringMesos(this.Value, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo_Blkio_CFQ) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&mesos.CgroupInfo_Blkio_CFQ{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo_Blkio_CFQ_Statistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&mesos.CgroupInfo_Blkio_CFQ_Statistics{")
	if this.Device != nil {
		s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	}
	if this.Sectors != nil {
		s = append(s, "Sectors: "+valueToGoStringMesos(this.Sectors, "uint64")+",\n")
	}
	if this.Time != nil {
		s = append(s, "Time: "+valueToGoStringMesos(this.Time, "uint64")+",\n")
	}
	if this.IOServiced != nil {
		s = append(s, "IOServiced: "+fmt.Sprintf("%#v", this.IOServiced)+",\n")
	}
	if this.IOServiceBytes != nil {
		s = append(s, "IOServiceBytes: "+fmt.Sprintf("%#v", this.IOServiceBytes)+",\n")
	}
	if this.IOServiceTime != nil {
		s = append(s, "IOServiceTime: "+fmt.Sprintf("%#v", this.IOServiceTime)+",\n")
	}
	if this.IOWaitTime != nil {
		s = append(s, "IOWaitTime: "+fmt.Sprintf("%#v", this.IOWaitTime)+",\n")
	}
	if this.IOMerged != nil {
		s = append(s, "IOMerged: "+fmt.Sprintf("%#v", this.IOMerged)+",\n")
	}
	if this.IOQueued != nil {
		s = append(s, "IOQueued: "+fmt.Sprintf("%#v", this.IOQueued)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo_Blkio_Throttling) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&mesos.CgroupInfo_Blkio_Throttling{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo_Blkio_Throttling_Statistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.CgroupInfo_Blkio_Throttling_Statistics{")
	if this.Device != nil {
		s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	}
	if this.IOServiced != nil {
		s = append(s, "IOServiced: "+fmt.Sprintf("%#v", this.IOServiced)+",\n")
	}
	if this.IOServiceBytes != nil {
		s = append(s, "IOServiceBytes: "+fmt.Sprintf("%#v", this.IOServiceBytes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo_Blkio_Statistics) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.CgroupInfo_Blkio_Statistics{")
	if this.CFQ != nil {
		s = append(s, "CFQ: "+fmt.Sprintf("%#v", this.CFQ)+",\n")
	}
	if this.CFQRecursive != nil {
		s = append(s, "CFQRecursive: "+fmt.Sprintf("%#v", this.CFQRecursive)+",\n")
	}
	if this.Throttling != nil {
		s = append(s, "Throttling: "+fmt.Sprintf("%#v", this.Throttling)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CgroupInfo_NetCls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.CgroupInfo_NetCls{")
	if this.ClassID != nil {
		s = append(s, "ClassID: "+valueToGoStringMesos(this.ClassID, "uint32")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Labels) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Labels{")
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Label) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Label{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+valueToGoStringMesos(this.Value, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Port) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&mesos.Port{")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	if this.Name != nil {
		s = append(s, "Name: "+valueToGoStringMesos(this.Name, "string")+",\n")
	}
	if this.Protocol != nil {
		s = append(s, "Protocol: "+valueToGoStringMesos(this.Protocol, "string")+",\n")
	}
	if this.Visibility != nil {
		s = append(s, "Visibility: "+valueToGoStringMesos(this.Visibility, "DiscoveryInfo_Visibility")+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Ports) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.Ports{")
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DiscoveryInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&mesos.DiscoveryInfo{")
	s = append(s, "Visibility: "+fmt.Sprintf("%#v", this.Visibility)+",\n")
	if this.Name != nil {
		s = append(s, "Name: "+valueToGoStringMesos(this.Name, "string")+",\n")
	}
	if this.Environment != nil {
		s = append(s, "Environment: "+valueToGoStringMesos(this.Environment, "string")+",\n")
	}
	if this.Location != nil {
		s = append(s, "Location: "+valueToGoStringMesos(this.Location, "string")+",\n")
	}
	if this.Version != nil {
		s = append(s, "Version: "+valueToGoStringMesos(this.Version, "string")+",\n")
	}
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WeightInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.WeightInfo{")
	s = append(s, "Weight: "+fmt.Sprintf("%#v", this.Weight)+",\n")
	if this.Role != nil {
		s = append(s, "Role: "+valueToGoStringMesos(this.Role, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VersionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&mesos.VersionInfo{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.BuildDate != nil {
		s = append(s, "BuildDate: "+valueToGoStringMesos(this.BuildDate, "string")+",\n")
	}
	if this.BuildTime != nil {
		s = append(s, "BuildTime: "+valueToGoStringMesos(this.BuildTime, "float64")+",\n")
	}
	if this.BuildUser != nil {
		s = append(s, "BuildUser: "+valueToGoStringMesos(this.BuildUser, "string")+",\n")
	}
	if this.GitSHA != nil {
		s = append(s, "GitSHA: "+valueToGoStringMesos(this.GitSHA, "string")+",\n")
	}
	if this.GitBranch != nil {
		s = append(s, "GitBranch: "+valueToGoStringMesos(this.GitBranch, "string")+",\n")
	}
	if this.GitTag != nil {
		s = append(s, "GitTag: "+valueToGoStringMesos(this.GitTag, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Flag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Flag{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+valueToGoStringMesos(this.Value, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Role) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&mesos.Role{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Weight: "+fmt.Sprintf("%#v", this.Weight)+",\n")
	if this.Frameworks != nil {
		s = append(s, "Frameworks: "+fmt.Sprintf("%#v", this.Frameworks)+",\n")
	}
	if this.Resources != nil {
		s = append(s, "Resources: "+fmt.Sprintf("%#v", this.Resources)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Metric) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Metric{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Value != nil {
		s = append(s, "Value: "+valueToGoStringMesos(this.Value, "float64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&mesos.FileInfo{")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.Nlink != nil {
		s = append(s, "Nlink: "+valueToGoStringMesos(this.Nlink, "int32")+",\n")
	}
	if this.Size != nil {
		s = append(s, "Size: "+valueToGoStringMesos(this.Size, "uint64")+",\n")
	}
	if this.Mtime != nil {
		s = append(s, "Mtime: "+fmt.Sprintf("%#v", this.Mtime)+",\n")
	}
	if this.Mode != nil {
		s = append(s, "Mode: "+valueToGoStringMesos(this.Mode, "uint32")+",\n")
	}
	if this.UID != nil {
		s = append(s, "UID: "+valueToGoStringMesos(this.UID, "string")+",\n")
	}
	if this.GID != nil {
		s = append(s, "GID: "+valueToGoStringMesos(this.GID, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Device) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Device{")
	if this.Path != nil {
		s = append(s, "Path: "+valueToGoStringMesos(this.Path, "string")+",\n")
	}
	if this.Number != nil {
		s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Device_Number) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.Device_Number{")
	if this.MajorNumber != nil {
		s = append(s, "MajorNumber: "+valueToGoStringMesos(this.MajorNumber, "uint64")+",\n")
	}
	if this.MinorNumber != nil {
		s = append(s, "MinorNumber: "+valueToGoStringMesos(this.MinorNumber, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceAccess) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&mesos.DeviceAccess{")
	s = append(s, "Device: "+strings.Replace(this.Device.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Access: "+strings.Replace(this.Access.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceAccess_Access) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&mesos.DeviceAccess_Access{")
	if this.Read != nil {
		s = append(s, "Read: "+valueToGoStringMesos(this.Read, "bool")+",\n")
	}
	if this.Write != nil {
		s = append(s, "Write: "+valueToGoStringMesos(this.Write, "bool")+",\n")
	}
	if this.Mknod != nil {
		s = append(s, "Mknod: "+valueToGoStringMesos(this.Mknod, "bool")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeviceWhitelist) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&mesos.DeviceWhitelist{")
	if this.AllowedDevices != nil {
		s = append(s, "AllowedDevices: "+fmt.Sprintf("%#v", this.AllowedDevices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMesos(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *FrameworkID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameworkID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *OfferID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfferID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *AgentID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *TaskID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *ExecutorID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *ContainerID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	if m.Parent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Parent.ProtoSize()))
		n1, err := m.Parent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ResourceProviderID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceProviderID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *OperationID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *TimeInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Nanoseconds))
	return i, nil
}

func (m *DurationInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DurationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Nanoseconds))
	return i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hostname != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Hostname)))
		i += copy(dAtA[i:], *m.Hostname)
	}
	if m.IP != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.IP)))
		i += copy(dAtA[i:], *m.IP)
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Port))
	return i, nil
}

func (m *URL) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URL) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Scheme)))
	i += copy(dAtA[i:], m.Scheme)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Address.ProtoSize()))
	n2, err := m.Address.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Path != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Path)))
		i += copy(dAtA[i:], *m.Path)
	}
	if len(m.Query) > 0 {
		for _, msg := range m.Query {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Fragment != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Fragment)))
		i += copy(dAtA[i:], *m.Fragment)
	}
	return i, nil
}

func (m *Unavailability) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Unavailability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Start.ProtoSize()))
	n3, err := m.Start.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.Duration != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Duration.ProtoSize()))
		n4, err := m.Duration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *MachineID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hostname != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Hostname)))
		i += copy(dAtA[i:], *m.Hostname)
	}
	if m.IP != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.IP)))
		i += copy(dAtA[i:], *m.IP)
	}
	return i, nil
}

func (m *MachineInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MachineInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.ID.ProtoSize()))
	n5, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.Mode != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Mode))
	}
	if m.Unavailability != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Unavailability.ProtoSize()))
		n6, err := m.Unavailability.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *FrameworkInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameworkInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.User)))
	i += copy(dAtA[i:], m.User)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.ID != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ID.ProtoSize()))
		n7, err := m.ID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.FailoverTimeout != nil {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.FailoverTimeout))))
	}
	if m.Checkpoint != nil {
		dAtA[i] = 0x28
		i++
		if *m.Checkpoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Role != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Role)))
		i += copy(dAtA[i:], *m.Role)
	}
	if m.Hostname != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Hostname)))
		i += copy(dAtA[i:], *m.Hostname)
	}
	if m.Principal != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Principal)))
		i += copy(dAtA[i:], *m.Principal)
	}
	if m.WebUiURL != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.WebUiURL)))
		i += copy(dAtA[i:], *m.WebUiURL)
	}
	if len(m.Capabilities) > 0 {
		for _, msg := range m.Capabilities {
			dAtA[i] = 0x52
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Labels != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n8, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *FrameworkInfo_Capability) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrameworkInfo_Capability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *CheckInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.Command != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Command.ProtoSize()))
		n9, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.HTTP != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.HTTP.ProtoSize()))
		n10, err := m.HTTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DelaySeconds != nil {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.DelaySeconds))))
	}
	if m.IntervalSeconds != nil {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.IntervalSeconds))))
	}
	if m.TimeoutSeconds != nil {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.TimeoutSeconds))))
	}
	if m.TCP != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.TCP.ProtoSize()))
		n11, err := m.TCP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *CheckInfo_Command) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckInfo_Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Command.ProtoSize()))
	n12, err := m.Command.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *CheckInfo_Http) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckInfo_Http) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Port))
	if m.Path != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Path)))
		i += copy(dAtA[i:], *m.Path)
	}
	return i, nil
}

func (m *CheckInfo_Tcp) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckInfo_Tcp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Port))
	return i, nil
}

func (m *HealthCheck) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HTTP != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.HTTP.ProtoSize()))
		n13, err := m.HTTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.DelaySeconds != nil {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.DelaySeconds))))
	}
	if m.IntervalSeconds != nil {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.IntervalSeconds))))
	}
	if m.TimeoutSeconds != nil {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.TimeoutSeconds))))
	}
	if m.ConsecutiveFailures != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ConsecutiveFailures))
	}
	if m.GracePeriodSeconds != nil {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.GracePeriodSeconds))))
	}
	if m.Command != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Command.ProtoSize()))
		n14, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.TCP != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.TCP.ProtoSize()))
		n15, err := m.TCP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *HealthCheck_HTTPCheckInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck_HTTPCheckInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Port))
	if m.Path != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Path)))
		i += copy(dAtA[i:], *m.Path)
	}
	if m.Scheme != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Scheme)))
		i += copy(dAtA[i:], *m.Scheme)
	}
	if len(m.Statuses) > 0 {
		for _, num := range m.Statuses {
			dAtA[i] = 0x20
			i++
			i = encodeVarintMesos(dAtA, i, uint64(num))
		}
	}
	if m.Protocol != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Protocol))
	}
	return i, nil
}

func (m *HealthCheck_TCPCheckInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheck_TCPCheckInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Port))
	if m.Protocol != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Protocol))
	}
	return i, nil
}

func (m *KillPolicy) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KillPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GracePeriod != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.GracePeriod.ProtoSize()))
		n16, err := m.GracePeriod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *CommandInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URIs) > 0 {
		for _, msg := range m.URIs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Environment != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Environment.ProtoSize()))
		n17, err := m.Environment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Value != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.User != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.User)))
		i += copy(dAtA[i:], *m.User)
	}
	if m.Shell != nil {
		dAtA[i] = 0x30
		i++
		if *m.Shell {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Arguments) > 0 {
		for _, s := range m.Arguments {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CommandInfo_URI) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandInfo_URI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	if m.Executable != nil {
		dAtA[i] = 0x10
		i++
		if *m.Executable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Extract != nil {
		dAtA[i] = 0x18
		i++
		if *m.Extract {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Cache != nil {
		dAtA[i] = 0x20
		i++
		if *m.Cache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OutputFile != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.OutputFile)))
		i += copy(dAtA[i:], *m.OutputFile)
	}
	return i, nil
}

func (m *ExecutorInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.ExecutorID.ProtoSize()))
	n18, err := m.ExecutorID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if m.Data != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Command != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Command.ProtoSize()))
		n19, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.FrameworkID != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.FrameworkID.ProtoSize()))
		n20, err := m.FrameworkID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Name != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Source != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Source)))
		i += copy(dAtA[i:], *m.Source)
	}
	if m.Container != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Container.ProtoSize()))
		n21, err := m.Container.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Discovery != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Discovery.ProtoSize()))
		n22, err := m.Discovery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.ShutdownGracePeriod != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ShutdownGracePeriod.ProtoSize()))
		n23, err := m.ShutdownGracePeriod.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Labels != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n24, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	dAtA[i] = 0x78
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *DomainInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FaultDomain != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.FaultDomain.ProtoSize()))
		n25, err := m.FaultDomain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *DomainInfo_FaultDomain) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainInfo_FaultDomain) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Region.ProtoSize()))
	n26, err := m.Region.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Zone.ProtoSize()))
	n27, err := m.Zone.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	return i, nil
}

func (m *DomainInfo_FaultDomain_RegionInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainInfo_FaultDomain_RegionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *DomainInfo_FaultDomain_ZoneInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainInfo_FaultDomain_ZoneInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *MasterInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MasterInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.ID)))
	i += copy(dAtA[i:], m.ID)
	dAtA[i] = 0x10
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.IP))
	if m.Port == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Port))
	}
	if m.PID != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.PID)))
		i += copy(dAtA[i:], *m.PID)
	}
	if m.Hostname != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Hostname)))
		i += copy(dAtA[i:], *m.Hostname)
	}
	if m.Version != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Version)))
		i += copy(dAtA[i:], *m.Version)
	}
	if m.Address != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Address.ProtoSize()))
		n28, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Domain != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Domain.ProtoSize()))
		n29, err := m.Domain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.Capabilities) > 0 {
		for _, msg := range m.Capabilities {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MasterInfo_Capability) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MasterInfo_Capability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *AgentInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Hostname)))
	i += copy(dAtA[i:], m.Hostname)
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ID != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ID.ProtoSize()))
		n30, err := m.ID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.Port != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Port))
	}
	if m.Domain != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Domain.ProtoSize()))
		n31, err := m.Domain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *AgentInfo_Capability) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentInfo_Capability) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *CSIPluginContainerInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSIPluginContainerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, num := range m.Services {
			dAtA[i] = 0x8
			i++
			i = encodeVarintMesos(dAtA, i, uint64(num))
		}
	}
	if m.Command != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Command.ProtoSize()))
		n32, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Container != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Container.ProtoSize()))
		n33, err := m.Container.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *CSIPluginInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CSIPluginInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Type)))
	i += copy(dAtA[i:], m.Type)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.Containers) > 0 {
		for _, msg := range m.Containers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResourceProviderInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceProviderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ID.ProtoSize()))
		n34, err := m.ID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Type)))
	i += copy(dAtA[i:], m.Type)
	dAtA[i] = 0x22
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if len(m.DefaultReservations) > 0 {
		for _, msg := range m.DefaultReservations {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Storage != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Storage.ProtoSize()))
		n35, err := m.Storage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *ResourceProviderInfo_Storage) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceProviderInfo_Storage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Plugin.ProtoSize()))
	n36, err := m.Plugin.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n36
	return i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.Scalar != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Scalar.ProtoSize()))
		n37, err := m.Scalar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Ranges != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Ranges.ProtoSize()))
		n38, err := m.Ranges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Set != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Set.ProtoSize()))
		n39, err := m.Set.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Text != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Text.ProtoSize()))
		n40, err := m.Text.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *Value_Scalar) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_Scalar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(m.Value))))
	return i, nil
}

func (m *Value_Range) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Begin))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.End))
	return i, nil
}

func (m *Value_Ranges) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_Ranges) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Range) > 0 {
		for _, msg := range m.Range {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Value_Set) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_Set) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, s := range m.Item {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Value_Text) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value_Text) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *Attribute) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attribute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x10
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.Scalar != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Scalar.ProtoSize()))
		n41, err := m.Scalar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Ranges != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Ranges.ProtoSize()))
		n42, err := m.Ranges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Text != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Text.ProtoSize()))
		n43, err := m.Text.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Set != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Set.ProtoSize()))
		n44, err := m.Set.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *Resource) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Type == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Type))
	}
	if m.Scalar != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Scalar.ProtoSize()))
		n45, err := m.Scalar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Ranges != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Ranges.ProtoSize()))
		n46, err := m.Ranges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Set != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Set.ProtoSize()))
		n47, err := m.Set.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.Role != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Role)))
		i += copy(dAtA[i:], *m.Role)
	}
	if m.Disk != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Disk.ProtoSize()))
		n48, err := m.Disk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.Reservation != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Reservation.ProtoSize()))
		n49, err := m.Reservation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Revocable != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Revocable.ProtoSize()))
		n50, err := m.Revocable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Shared != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Shared.ProtoSize()))
		n51, err := m.Shared.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.AllocationInfo != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.AllocationInfo.ProtoSize()))
		n52, err := m.AllocationInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.ProviderID != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ProviderID.ProtoSize()))
		n53, err := m.ProviderID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.Reservations) > 0 {
		for _, msg := range m.Reservations {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Resource_AllocationInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_AllocationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Role != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Role)))
		i += copy(dAtA[i:], *m.Role)
	}
	return i, nil
}

func (m *Resource_ReservationInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_ReservationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Principal != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Principal)))
		i += copy(dAtA[i:], *m.Principal)
	}
	if m.Labels != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n54, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.Role != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Role)))
		i += copy(dAtA[i:], *m.Role)
	}
	if m.Type != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Type))
	}
	return i, nil
}

func (m *Resource_DiskInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_DiskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Persistence != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Persistence.ProtoSize()))
		n55, err := m.Persistence.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.Volume != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Volume.ProtoSize()))
		n56, err := m.Volume.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.Source != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Source.ProtoSize()))
		n57, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}

func (m *Resource_DiskInfo_Persistence) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_DiskInfo_Persistence) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.ID)))
	i += copy(dAtA[i:], m.ID)
	if m.Principal != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Principal)))
		i += copy(dAtA[i:], *m.Principal)
	}
	return i, nil
}

func (m *Resource_DiskInfo_Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_DiskInfo_Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.Path != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Path.ProtoSize()))
		n58, err := m.Path.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.Mount != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Mount.ProtoSize()))
		n59, err := m.Mount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.ID != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.ID)))
		i += copy(dAtA[i:], *m.ID)
	}
	if m.Metadata != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Metadata.ProtoSize()))
		n60, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.Profile != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Profile)))
		i += copy(dAtA[i:], *m.Profile)
	}
	return i, nil
}

func (m *Resource_DiskInfo_Source_Path) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_DiskInfo_Source_Path) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Root != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Root)))
		i += copy(dAtA[i:], *m.Root)
	}
	return i, nil
}

func (m *Resource_DiskInfo_Source_Mount) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_DiskInfo_Source_Mount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Root != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Root)))
		i += copy(dAtA[i:], *m.Root)
	}
	return i, nil
}

func (m *Resource_RevocableInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_RevocableInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Resource_SharedInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource_SharedInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TrafficControlStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficControlStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.ID)))
	i += copy(dAtA[i:], m.ID)
	if m.Backlog != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Backlog))
	}
	if m.Bytes != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Bytes))
	}
	if m.Drops != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Drops))
	}
	if m.Overlimits != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Overlimits))
	}
	if m.Packets != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Packets))
	}
	if m.Qlen != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Qlen))
	}
	if m.RateBPS != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.RateBPS))
	}
	if m.RatePPS != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.RatePPS))
	}
	if m.Requeues != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Requeues))
	}
	return i, nil
}

func (m *IpStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Forwarding != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Forwarding))
	}
	if m.DefaultTTL != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DefaultTTL))
	}
	if m.InReceives != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InReceives))
	}
	if m.InHdrErrors != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InHdrErrors))
	}
	if m.InAddrErrors != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InAddrErrors))
	}
	if m.ForwDatagrams != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ForwDatagrams))
	}
	if m.InUnknownProtos != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InUnknownProtos))
	}
	if m.InDiscards != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InDiscards))
	}
	if m.InDelivers != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InDelivers))
	}
	if m.OutRequests != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutRequests))
	}
	if m.OutDiscards != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutDiscards))
	}
	if m.OutNoRoutes != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutNoRoutes))
	}
	if m.ReasmTimeout != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ReasmTimeout))
	}
	if m.ReasmReqds != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ReasmReqds))
	}
	if m.ReasmOKs != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ReasmOKs))
	}
	if m.ReasmFails != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ReasmFails))
	}
	if m.FragOKs != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.FragOKs))
	}
	if m.FragFails != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.FragFails))
	}
	if m.FragCreates != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.FragCreates))
	}
	return i, nil
}

func (m *IcmpStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcmpStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InMsgs != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InMsgs))
	}
	if m.InErrors != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InErrors))
	}
	if m.InCsumErrors != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InCsumErrors))
	}
	if m.InDestUnreachs != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InDestUnreachs))
	}
	if m.InTimeExcds != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InTimeExcds))
	}
	if m.InParmProbs != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InParmProbs))
	}
	if m.InSrcQuenchs != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InSrcQuenchs))
	}
	if m.InRedirects != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InRedirects))
	}
	if m.InEchos != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InEchos))
	}
	if m.InEchoReps != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InEchoReps))
	}
	if m.InTimestamps != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InTimestamps))
	}
	if m.InTimestampReps != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InTimestampReps))
	}
	if m.InAddrMasks != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InAddrMasks))
	}
	if m.InAddrMaskReps != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InAddrMaskReps))
	}
	if m.OutMsgs != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutMsgs))
	}
	if m.OutErrors != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutErrors))
	}
	if m.OutDestUnreachs != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutDestUnreachs))
	}
	if m.OutTimeExcds != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutTimeExcds))
	}
	if m.OutParmProbs != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutParmProbs))
	}
	if m.OutSrcQuenchs != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutSrcQuenchs))
	}
	if m.OutRedirects != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutRedirects))
	}
	if m.OutEchos != nil {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutEchos))
	}
	if m.OutEchoReps != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutEchoReps))
	}
	if m.OutTimestamps != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutTimestamps))
	}
	if m.OutTimestampReps != nil {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutTimestampReps))
	}
	if m.OutAddrMasks != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutAddrMasks))
	}
	if m.OutAddrMaskReps != nil {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutAddrMaskReps))
	}
	return i, nil
}

func (m *TcpStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RtoAlgorithm != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.RtoAlgorithm))
	}
	if m.RtoMin != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.RtoMin))
	}
	if m.RtoMax != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.RtoMax))
	}
	if m.MaxConn != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MaxConn))
	}
	if m.ActiveOpens != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ActiveOpens))
	}
	if m.PassiveOpens != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.PassiveOpens))
	}
	if m.AttemptFails != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.AttemptFails))
	}
	if m.EstabResets != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.EstabResets))
	}
	if m.CurrEstab != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.CurrEstab))
	}
	if m.InSegs != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InSegs))
	}
	if m.OutSegs != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutSegs))
	}
	if m.RetransSegs != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.RetransSegs))
	}
	if m.InErrs != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InErrs))
	}
	if m.OutRsts != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutRsts))
	}
	if m.InCsumErrors != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InCsumErrors))
	}
	return i, nil
}

func (m *UdpStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UdpStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InDatagrams != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InDatagrams))
	}
	if m.NoPorts != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NoPorts))
	}
	if m.InErrors != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InErrors))
	}
	if m.OutDatagrams != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.OutDatagrams))
	}
	if m.RcvbufErrors != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.RcvbufErrors))
	}
	if m.SndbufErrors != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.SndbufErrors))
	}
	if m.InCsumErrors != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.InCsumErrors))
	}
	if m.IgnoredMulti != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.IgnoredMulti))
	}
	return i, nil
}

func (m *SNMPStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNMPStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IPStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.IPStats.ProtoSize()))
		n61, err := m.IPStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.ICMPStats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ICMPStats.ProtoSize()))
		n62, err := m.ICMPStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.TCPStats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.TCPStats.ProtoSize()))
		n63, err := m.TCPStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.UDPStats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.UDPStats.ProtoSize()))
		n64, err := m.UDPStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}

func (m *DiskStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Source.ProtoSize()))
		n65, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.Persistence != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Persistence.ProtoSize()))
		n66, err := m.Persistence.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.LimitBytes != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.LimitBytes))
	}
	if m.UsedBytes != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.UsedBytes))
	}
	return i, nil
}

func (m *ResourceStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(m.Timestamp))))
	if m.CPUsUserTimeSecs != nil {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.CPUsUserTimeSecs))))
	}
	if m.CPUsSystemTimeSecs != nil {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.CPUsSystemTimeSecs))))
	}
	if m.CPUsLimit != nil {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.CPUsLimit))))
	}
	if m.MemRSSBytes != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemRSSBytes))
	}
	if m.MemLimitBytes != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemLimitBytes))
	}
	if m.CPUsNrPeriods != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.CPUsNrPeriods))
	}
	if m.CPUsNrThrottled != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.CPUsNrThrottled))
	}
	if m.CPUsThrottledTimeSecs != nil {
		dAtA[i] = 0x49
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.CPUsThrottledTimeSecs))))
	}
	if m.MemFileBytes != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemFileBytes))
	}
	if m.MemAnonBytes != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemAnonBytes))
	}
	if m.MemMappedFileBytes != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemMappedFileBytes))
	}
	if m.Perf != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Perf.ProtoSize()))
		n67, err := m.Perf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.NetRxPackets != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NetRxPackets))
	}
	if m.NetRxBytes != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NetRxBytes))
	}
	if m.NetRxErrors != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NetRxErrors))
	}
	if m.NetRxDropped != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NetRxDropped))
	}
	if m.NetTxPackets != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NetTxPackets))
	}
	if m.NetTxBytes != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NetTxBytes))
	}
	if m.NetTxErrors != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NetTxErrors))
	}
	if m.NetTxDropped != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NetTxDropped))
	}
	if m.NetTCPRttMicrosecsP50 != nil {
		dAtA[i] = 0xb1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.NetTCPRttMicrosecsP50))))
	}
	if m.NetTCPRttMicrosecsP90 != nil {
		dAtA[i] = 0xb9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.NetTCPRttMicrosecsP90))))
	}
	if m.NetTCPRttMicrosecsP95 != nil {
		dAtA[i] = 0xc1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.NetTCPRttMicrosecsP95))))
	}
	if m.NetTCPRttMicrosecsP99 != nil {
		dAtA[i] = 0xc9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.NetTCPRttMicrosecsP99))))
	}
	if m.DiskLimitBytes != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DiskLimitBytes))
	}
	if m.DiskUsedBytes != nil {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DiskUsedBytes))
	}
	if m.NetTCPActiveConnections != nil {
		dAtA[i] = 0xe1
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.NetTCPActiveConnections))))
	}
	if m.NetTCPTimeWaitConnections != nil {
		dAtA[i] = 0xe9
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.NetTCPTimeWaitConnections))))
	}
	if m.Processes != nil {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Processes))
	}
	if m.Threads != nil {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Threads))
	}
	if m.MemLowPressureCounter != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemLowPressureCounter))
	}
	if m.MemMediumPressureCounter != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemMediumPressureCounter))
	}
	if m.MemCriticalPressureCounter != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemCriticalPressureCounter))
	}
	if len(m.NetTrafficControlStatistics) > 0 {
		for _, msg := range m.NetTrafficControlStatistics {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MemTotalBytes != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemTotalBytes))
	}
	if m.MemTotalMemswBytes != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemTotalMemswBytes))
	}
	if m.MemSoftLimitBytes != nil {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemSoftLimitBytes))
	}
	if m.MemCacheBytes != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemCacheBytes))
	}
	if m.MemSwapBytes != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemSwapBytes))
	}
	if m.MemUnevictableBytes != nil {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MemUnevictableBytes))
	}
	if m.NetSNMPStatistics != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.NetSNMPStatistics.ProtoSize()))
		n68, err := m.NetSNMPStatistics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if len(m.DiskStatistics) > 0 {
		for _, msg := range m.DiskStatistics {
			dAtA[i] = 0xda
			i++
			dAtA[i] = 0x2
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BlkioStatistics != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.BlkioStatistics.ProtoSize()))
		n69, err := m.BlkioStatistics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}

func (m *ResourceUsage) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceUsage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Executors) > 0 {
		for _, msg := range m.Executors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Total) > 0 {
		for _, msg := range m.Total {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResourceUsage_Executor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceUsage_Executor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.ExecutorInfo.ProtoSize()))
	n70, err := m.ExecutorInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n70
	if len(m.Allocated) > 0 {
		for _, msg := range m.Allocated {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Statistics != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Statistics.ProtoSize()))
		n71, err := m.Statistics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.ContainerID.ProtoSize()))
	n72, err := m.ContainerID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n72
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResourceUsage_Executor_Task) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceUsage_Executor_Task) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.ID.ProtoSize()))
	n73, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n73
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Labels != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n74, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	return i, nil
}

func (m *PerfStatistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerfStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(m.Timestamp))))
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(m.Duration))))
	if m.Cycles != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Cycles))
	}
	if m.StalledCyclesFrontend != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.StalledCyclesFrontend))
	}
	if m.StalledCyclesBackend != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.StalledCyclesBackend))
	}
	if m.Instructions != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Instructions))
	}
	if m.CacheReferences != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.CacheReferences))
	}
	if m.CacheMisses != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.CacheMisses))
	}
	if m.Branches != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Branches))
	}
	if m.BranchMisses != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.BranchMisses))
	}
	if m.BusCycles != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.BusCycles))
	}
	if m.RefCycles != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.RefCycles))
	}
	if m.CPUClock != nil {
		dAtA[i] = 0x69
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.CPUClock))))
	}
	if m.TaskClock != nil {
		dAtA[i] = 0x71
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.TaskClock))))
	}
	if m.PageFaults != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.PageFaults))
	}
	if m.MinorFaults != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MinorFaults))
	}
	if m.MajorFaults != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MajorFaults))
	}
	if m.ContextSwitches != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ContextSwitches))
	}
	if m.CPUMigrations != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.CPUMigrations))
	}
	if m.AlignmentFaults != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.AlignmentFaults))
	}
	if m.EmulationFaults != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.EmulationFaults))
	}
	if m.L1DcacheLoads != nil {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1DcacheLoads))
	}
	if m.L1DcacheLoadMisses != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1DcacheLoadMisses))
	}
	if m.L1DcacheStores != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1DcacheStores))
	}
	if m.L1DcacheStoreMisses != nil {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1DcacheStoreMisses))
	}
	if m.L1DcachePrefetches != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1DcachePrefetches))
	}
	if m.L1DcachePrefetchMisses != nil {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1DcachePrefetchMisses))
	}
	if m.L1IcacheLoads != nil {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1IcacheLoads))
	}
	if m.L1IcacheLoadMisses != nil {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1IcacheLoadMisses))
	}
	if m.L1IcachePrefetches != nil {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1IcachePrefetches))
	}
	if m.L1IcachePrefetchMisses != nil {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.L1IcachePrefetchMisses))
	}
	if m.LLCLoads != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.LLCLoads))
	}
	if m.LLCLoadMisses != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.LLCLoadMisses))
	}
	if m.LLCStores != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.LLCStores))
	}
	if m.LLCStoreMisses != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.LLCStoreMisses))
	}
	if m.LLCPrefetches != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.LLCPrefetches))
	}
	if m.LLCPrefetchMisses != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.LLCPrefetchMisses))
	}
	if m.DTLBLoads != nil {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DTLBLoads))
	}
	if m.DTLBLoadMisses != nil {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DTLBLoadMisses))
	}
	if m.DTLBStores != nil {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DTLBStores))
	}
	if m.DTLBStoreMisses != nil {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DTLBStoreMisses))
	}
	if m.DTLBPrefetches != nil {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DTLBPrefetches))
	}
	if m.DTLBPrefetchMisses != nil {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.DTLBPrefetchMisses))
	}
	if m.ITLBLoads != nil {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ITLBLoads))
	}
	if m.ITLBLoadMisses != nil {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ITLBLoadMisses))
	}
	if m.BranchLoads != nil {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.BranchLoads))
	}
	if m.BranchLoadMisses != nil {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.BranchLoadMisses))
	}
	if m.NodeLoads != nil {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NodeLoads))
	}
	if m.NodeLoadMisses != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NodeLoadMisses))
	}
	if m.NodeStores != nil {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NodeStores))
	}
	if m.NodeStoreMisses != nil {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NodeStoreMisses))
	}
	if m.NodePrefetches != nil {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NodePrefetches))
	}
	if m.NodePrefetchMisses != nil {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.NodePrefetchMisses))
	}
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AgentID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.AgentID.ProtoSize()))
		n75, err := m.AgentID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Offer) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.ID.ProtoSize()))
	n76, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n76
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.FrameworkID.ProtoSize()))
	n77, err := m.FrameworkID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n77
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.AgentID.ProtoSize()))
	n78, err := m.AgentID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n78
	dAtA[i] = 0x22
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Hostname)))
	i += copy(dAtA[i:], m.Hostname)
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExecutorIDs) > 0 {
		for _, msg := range m.ExecutorIDs {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attributes) > 0 {
		for _, msg := range m.Attributes {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.URL != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.URL.ProtoSize()))
		n79, err := m.URL.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.Unavailability != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Unavailability.ProtoSize()))
		n80, err := m.Unavailability.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.AllocationInfo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.AllocationInfo.ProtoSize()))
		n81, err := m.AllocationInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.Domain != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Domain.ProtoSize()))
		n82, err := m.Domain.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	return i, nil
}

func (m *Offer_Operation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.Launch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Launch.ProtoSize()))
		n83, err := m.Launch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if m.Reserve != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Reserve.ProtoSize()))
		n84, err := m.Reserve.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if m.Unreserve != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Unreserve.ProtoSize()))
		n85, err := m.Unreserve.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if m.Create != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Create.ProtoSize()))
		n86, err := m.Create.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if m.Destroy != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Destroy.ProtoSize()))
		n87, err := m.Destroy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.LaunchGroup != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.LaunchGroup.ProtoSize()))
		n88, err := m.LaunchGroup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.ID != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ID.ProtoSize()))
		n89, err := m.ID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.GrowVolume != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.GrowVolume.ProtoSize()))
		n90, err := m.GrowVolume.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if m.ShrinkVolume != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ShrinkVolume.ProtoSize()))
		n91, err := m.ShrinkVolume.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.CreateDisk != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.CreateDisk.ProtoSize()))
		n92, err := m.CreateDisk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.DestroyDisk != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.DestroyDisk.ProtoSize()))
		n93, err := m.DestroyDisk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	return i, nil
}

func (m *Offer_Operation_Launch) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_Launch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TaskInfos) > 0 {
		for _, msg := range m.TaskInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Offer_Operation_LaunchGroup) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_LaunchGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Executor.ProtoSize()))
	n94, err := m.Executor.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n94
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.TaskGroup.ProtoSize()))
	n95, err := m.TaskGroup.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n95
	return i, nil
}

func (m *Offer_Operation_Reserve) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_Reserve) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Offer_Operation_Unreserve) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_Unreserve) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Offer_Operation_Create) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_Create) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Volumes) > 0 {
		for _, msg := range m.Volumes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Offer_Operation_Destroy) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_Destroy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Volumes) > 0 {
		for _, msg := range m.Volumes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Offer_Operation_GrowVolume) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_GrowVolume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Volume.ProtoSize()))
	n96, err := m.Volume.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n96
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Addition.ProtoSize()))
	n97, err := m.Addition.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n97
	return i, nil
}

func (m *Offer_Operation_ShrinkVolume) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_ShrinkVolume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Volume.ProtoSize()))
	n98, err := m.Volume.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n98
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Subtract.ProtoSize()))
	n99, err := m.Subtract.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n99
	return i, nil
}

func (m *Offer_Operation_CreateDisk) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_CreateDisk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Source.ProtoSize()))
	n100, err := m.Source.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n100
	dAtA[i] = 0x10
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.TargetType))
	return i, nil
}

func (m *Offer_Operation_DestroyDisk) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offer_Operation_DestroyDisk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Source.ProtoSize()))
	n101, err := m.Source.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n101
	return i, nil
}

func (m *InverseOffer) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InverseOffer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.OfferID.ProtoSize()))
	n102, err := m.OfferID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n102
	if m.URL != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.URL.ProtoSize()))
		n103, err := m.URL.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.FrameworkID.ProtoSize()))
	n104, err := m.FrameworkID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n104
	if m.AgentID != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.AgentID.ProtoSize()))
		n105, err := m.AgentID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Unavailability.ProtoSize()))
	n106, err := m.Unavailability.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n106
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.TaskID.ProtoSize()))
	n107, err := m.TaskID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n107
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.AgentID.ProtoSize()))
	n108, err := m.AgentID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n108
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Executor != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Executor.ProtoSize()))
		n109, err := m.Executor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n109
	}
	if m.Data != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Command != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Command.ProtoSize()))
		n110, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	if m.HealthCheck != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.HealthCheck.ProtoSize()))
		n111, err := m.HealthCheck.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	if m.Container != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Container.ProtoSize()))
		n112, err := m.Container.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n112
	}
	if m.Labels != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n113, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n113
	}
	if m.Discovery != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Discovery.ProtoSize()))
		n114, err := m.Discovery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n114
	}
	if m.KillPolicy != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.KillPolicy.ProtoSize()))
		n115, err := m.KillPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	if m.Check != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Check.ProtoSize()))
		n116, err := m.Check.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	if m.MaxCompletionTime != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.MaxCompletionTime.ProtoSize()))
		n117, err := m.MaxCompletionTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	return i, nil
}

func (m *TaskGroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskGroupInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Task) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Task) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.TaskID.ProtoSize()))
	n118, err := m.TaskID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n118
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.FrameworkID.ProtoSize()))
	n119, err := m.FrameworkID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n119
	if m.ExecutorID != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ExecutorID.ProtoSize()))
		n120, err := m.ExecutorID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n120
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.AgentID.ProtoSize()))
	n121, err := m.AgentID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n121
	if m.State == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.State))
	}
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Statuses) > 0 {
		for _, msg := range m.Statuses {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.StatusUpdateState != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.StatusUpdateState))
	}
	if m.StatusUpdateUUID != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(m.StatusUpdateUUID)))
		i += copy(dAtA[i:], m.StatusUpdateUUID)
	}
	if m.Labels != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n122, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	if m.Discovery != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Discovery.ProtoSize()))
		n123, err := m.Discovery.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	if m.Container != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Container.ProtoSize()))
		n124, err := m.Container.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n124
	}
	if m.User != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.User)))
		i += copy(dAtA[i:], *m.User)
	}
	return i, nil
}

func (m *TaskResourceLimitation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskResourceLimitation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UUID) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Operation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Operation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FrameworkID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.FrameworkID.ProtoSize()))
		n125, err := m.FrameworkID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n125
	}
	if m.AgentID != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.AgentID.ProtoSize()))
		n126, err := m.AgentID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n126
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Info.ProtoSize()))
	n127, err := m.Info.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n127
	dAtA[i] = 0x22
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.LatestStatus.ProtoSize()))
	n128, err := m.LatestStatus.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n128
	if len(m.Statuses) > 0 {
		for _, msg := range m.Statuses {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.UUID.ProtoSize()))
	n129, err := m.UUID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n129
	return i, nil
}

func (m *OperationStatus) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperationStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OperationID != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.OperationID.ProtoSize()))
		n130, err := m.OperationID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n130
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.State))
	if m.Message != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if len(m.ConvertedResources) > 0 {
		for _, msg := range m.ConvertedResources {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UUID != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.UUID.ProtoSize()))
		n131, err := m.UUID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n131
	}
	return i, nil
}

func (m *CheckStatusInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckStatusInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Type))
	}
	if m.Command != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Command.ProtoSize()))
		n132, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n132
	}
	if m.HTTP != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.HTTP.ProtoSize()))
		n133, err := m.HTTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n133
	}
	if m.TCP != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.TCP.ProtoSize()))
		n134, err := m.TCP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n134
	}
	return i, nil
}

func (m *CheckStatusInfo_Command) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckStatusInfo_Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExitCode != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ExitCode))
	}
	return i, nil
}

func (m *CheckStatusInfo_Http) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckStatusInfo_Http) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StatusCode != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.StatusCode))
	}
	return i, nil
}

func (m *CheckStatusInfo_Tcp) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckStatusInfo_Tcp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Succeeded != nil {
		dAtA[i] = 0x8
		i++
		if *m.Succeeded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TaskStatus) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.TaskID.ProtoSize()))
	n135, err := m.TaskID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n135
	if m.State == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.State))
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Message != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.AgentID != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.AgentID.ProtoSize()))
		n136, err := m.AgentID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n136
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x31
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.Timestamp))))
	}
	if m.ExecutorID != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ExecutorID.ProtoSize()))
		n137, err := m.ExecutorID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n137
	}
	if m.Healthy != nil {
		dAtA[i] = 0x40
		i++
		if *m.Healthy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Source != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Source))
	}
	if m.Reason != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Reason))
	}
	if m.UUID != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(m.UUID)))
		i += copy(dAtA[i:], m.UUID)
	}
	if m.Labels != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n138, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n138
	}
	if m.ContainerStatus != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ContainerStatus.ProtoSize()))
		n139, err := m.ContainerStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n139
	}
	if m.UnreachableTime != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.UnreachableTime.ProtoSize()))
		n140, err := m.UnreachableTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n140
	}
	if m.CheckStatus != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.CheckStatus.ProtoSize()))
		n141, err := m.CheckStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n141
	}
	if m.Limitation != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Limitation.ProtoSize()))
		n142, err := m.Limitation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n142
	}
	return i, nil
}

func (m *Filters) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RefuseSeconds != nil {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.RefuseSeconds))))
	}
	return i, nil
}

func (m *Environment) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Environment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		for _, msg := range m.Variables {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Environment_Variable) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Environment_Variable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.Type != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Type))
	}
	if m.Secret != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Secret.ProtoSize()))
		n143, err := m.Secret.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n143
	}
	return i, nil
}

func (m *Parameter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parameter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Key)))
	i += copy(dAtA[i:], m.Key)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *Parameters) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Parameters) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Parameter) > 0 {
		for _, msg := range m.Parameter {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Credential) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credential) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Principal)))
	i += copy(dAtA[i:], m.Principal)
	if m.Secret != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Secret)))
		i += copy(dAtA[i:], *m.Secret)
	}
	return i, nil
}

func (m *Credentials) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Credentials) > 0 {
		for _, msg := range m.Credentials {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Secret) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Secret) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.Reference != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Reference.ProtoSize()))
		n144, err := m.Reference.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n144
	}
	if m.Value != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Value.ProtoSize()))
		n145, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n145
	}
	return i, nil
}

func (m *Secret_Reference) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Secret_Reference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	return i, nil
}

func (m *Secret_Value) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Secret_Value) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("data")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *RateLimit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QPS != nil {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.QPS))))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Principal)))
	i += copy(dAtA[i:], m.Principal)
	if m.Capacity != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Capacity))
	}
	return i, nil
}

func (m *RateLimits) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for _, msg := range m.Limits {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AggregateDefaultQPS != nil {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.AggregateDefaultQPS))))
	}
	if m.AggregateDefaultCapacity != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.AggregateDefaultCapacity))
	}
	return i, nil
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Type))
	}
	if m.Appc != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Appc.ProtoSize()))
		n146, err := m.Appc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n146
	}
	if m.Docker != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Docker.ProtoSize()))
		n147, err := m.Docker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n147
	}
	if m.Cached != nil {
		dAtA[i] = 0x20
		i++
		if *m.Cached {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Image_Appc) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image_Appc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.ID != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.ID)))
		i += copy(dAtA[i:], *m.ID)
	}
	if m.Labels != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n148, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n148
	}
	return i, nil
}

func (m *Image_Docker) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image_Docker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Credential != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Credential.ProtoSize()))
		n149, err := m.Credential.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n149
	}
	if m.Config != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Config.ProtoSize()))
		n150, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n150
	}
	return i, nil
}

func (m *MountPropagation) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountPropagation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Mode))
	}
	return i, nil
}

func (m *Volume) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Volume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.ContainerPath)))
	i += copy(dAtA[i:], m.ContainerPath)
	if m.HostPath != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.HostPath)))
		i += copy(dAtA[i:], *m.HostPath)
	}
	if m.Mode == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("mode")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Mode))
	}
	if m.Image != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Image.ProtoSize()))
		n151, err := m.Image.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n151
	}
	if m.Source != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Source.ProtoSize()))
		n152, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n152
	}
	return i, nil
}

func (m *Volume_Source) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Volume_Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.DockerVolume != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.DockerVolume.ProtoSize()))
		n153, err := m.DockerVolume.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n153
	}
	if m.SandboxPath != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.SandboxPath.ProtoSize()))
		n154, err := m.SandboxPath.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n154
	}
	if m.Secret != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Secret.ProtoSize()))
		n155, err := m.Secret.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n155
	}
	if m.HostPath != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.HostPath.ProtoSize()))
		n156, err := m.HostPath.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n156
	}
	return i, nil
}

func (m *Volume_Source_DockerVolume) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Volume_Source_DockerVolume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Driver != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Driver)))
		i += copy(dAtA[i:], *m.Driver)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.DriverOptions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.DriverOptions.ProtoSize()))
		n157, err := m.DriverOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n157
	}
	return i, nil
}

func (m *Volume_Source_HostPath) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Volume_Source_HostPath) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	if m.MountPropagation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.MountPropagation.ProtoSize()))
		n158, err := m.MountPropagation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n158
	}
	return i, nil
}

func (m *Volume_Source_SandboxPath) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Volume_Source_SandboxPath) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	return i, nil
}

func (m *NetworkInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Labels != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n159, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n159
	}
	if len(m.IPAddresses) > 0 {
		for _, msg := range m.IPAddresses {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Name != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if len(m.PortMappings) > 0 {
		for _, msg := range m.PortMappings {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NetworkInfo_IPAddress) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo_IPAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Protocol != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Protocol))
	}
	if m.IPAddress != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.IPAddress)))
		i += copy(dAtA[i:], *m.IPAddress)
	}
	return i, nil
}

func (m *NetworkInfo_PortMapping) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo_PortMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.HostPort))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.ContainerPort))
	if m.Protocol != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Protocol)))
		i += copy(dAtA[i:], *m.Protocol)
	}
	return i, nil
}

func (m *CapabilityInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapabilityInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, num := range m.Capabilities {
			dAtA[i] = 0x8
			i++
			i = encodeVarintMesos(dAtA, i, uint64(num))
		}
	}
	return i, nil
}

func (m *LinuxInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CapabilityInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.CapabilityInfo.ProtoSize()))
		n160, err := m.CapabilityInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n160
	}
	if m.BoundingCapabilities != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.BoundingCapabilities.ProtoSize()))
		n161, err := m.BoundingCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n161
	}
	if m.EffectiveCapabilities != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.EffectiveCapabilities.ProtoSize()))
		n162, err := m.EffectiveCapabilities.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n162
	}
	if m.SharePIDNamespace != nil {
		dAtA[i] = 0x20
		i++
		if *m.SharePIDNamespace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RLimitInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RLimitInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rlimits) > 0 {
		for _, msg := range m.Rlimits {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RLimitInfo_RLimit) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RLimitInfo_RLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Type))
	if m.Hard != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Hard))
	}
	if m.Soft != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Soft))
	}
	return i, nil
}

func (m *TTYInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TTYInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WindowSize != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.WindowSize.ProtoSize()))
		n163, err := m.WindowSize.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n163
	}
	return i, nil
}

func (m *TTYInfo_WindowSize) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TTYInfo_WindowSize) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Rows))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Columns))
	return i, nil
}

func (m *ContainerInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Type))
	}
	if len(m.Volumes) > 0 {
		for _, msg := range m.Volumes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Docker != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Docker.ProtoSize()))
		n164, err := m.Docker.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n164
	}
	if m.Hostname != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Hostname)))
		i += copy(dAtA[i:], *m.Hostname)
	}
	if m.Mesos != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Mesos.ProtoSize()))
		n165, err := m.Mesos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n165
	}
	if len(m.NetworkInfos) > 0 {
		for _, msg := range m.NetworkInfos {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LinuxInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.LinuxInfo.ProtoSize()))
		n166, err := m.LinuxInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n166
	}
	if m.RlimitInfo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.RlimitInfo.ProtoSize()))
		n167, err := m.RlimitInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n167
	}
	if m.TTYInfo != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.TTYInfo.ProtoSize()))
		n168, err := m.TTYInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n168
	}
	return i, nil
}

func (m *ContainerInfo_DockerInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerInfo_DockerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Image)))
	i += copy(dAtA[i:], m.Image)
	if m.Network != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Network))
	}
	if len(m.PortMappings) > 0 {
		for _, msg := range m.PortMappings {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Privileged != nil {
		dAtA[i] = 0x20
		i++
		if *m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Parameters) > 0 {
		for _, msg := range m.Parameters {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ForcePullImage != nil {
		dAtA[i] = 0x30
		i++
		if *m.ForcePullImage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VolumeDriver != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.VolumeDriver)))
		i += copy(dAtA[i:], *m.VolumeDriver)
	}
	return i, nil
}

func (m *ContainerInfo_DockerInfo_PortMapping) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerInfo_DockerInfo_PortMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.HostPort))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.ContainerPort))
	if m.Protocol != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Protocol)))
		i += copy(dAtA[i:], *m.Protocol)
	}
	return i, nil
}

func (m *ContainerInfo_MesosInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerInfo_MesosInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Image != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Image.ProtoSize()))
		n169, err := m.Image.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n169
	}
	return i, nil
}

func (m *ContainerStatus) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NetworkInfos) > 0 {
		for _, msg := range m.NetworkInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CgroupInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.CgroupInfo.ProtoSize()))
		n170, err := m.CgroupInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n170
	}
	if m.ExecutorPID != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ExecutorPID))
	}
	if m.ContainerID != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.ContainerID.ProtoSize()))
		n171, err := m.ContainerID.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n171
	}
	return i, nil
}

func (m *CgroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NetCLS != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.NetCLS.ProtoSize()))
		n172, err := m.NetCLS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n172
	}
	return i, nil
}

func (m *CgroupInfo_Blkio) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo_Blkio) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CgroupInfo_Blkio_Value) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo_Blkio_Value) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Op))
	}
	if m.Value != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Value))
	}
	return i, nil
}

func (m *CgroupInfo_Blkio_CFQ) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo_Blkio_CFQ) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Device != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Device.ProtoSize()))
		n173, err := m.Device.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n173
	}
	if m.Sectors != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Sectors))
	}
	if m.Time != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Time))
	}
	if len(m.IOServiced) > 0 {
		for _, msg := range m.IOServiced {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IOServiceBytes) > 0 {
		for _, msg := range m.IOServiceBytes {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IOServiceTime) > 0 {
		for _, msg := range m.IOServiceTime {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IOWaitTime) > 0 {
		for _, msg := range m.IOWaitTime {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IOMerged) > 0 {
		for _, msg := range m.IOMerged {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IOQueued) > 0 {
		for _, msg := range m.IOQueued {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CgroupInfo_Blkio_Throttling) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo_Blkio_Throttling) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CgroupInfo_Blkio_Throttling_Statistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo_Blkio_Throttling_Statistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Device != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Device.ProtoSize()))
		n174, err := m.Device.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n174
	}
	if len(m.IOServiced) > 0 {
		for _, msg := range m.IOServiced {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IOServiceBytes) > 0 {
		for _, msg := range m.IOServiceBytes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CgroupInfo_Blkio_Statistics) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo_Blkio_Statistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CFQ) > 0 {
		for _, msg := range m.CFQ {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CFQRecursive) > 0 {
		for _, msg := range m.CFQRecursive {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Throttling) > 0 {
		for _, msg := range m.Throttling {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CgroupInfo_NetCls) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CgroupInfo_NetCls) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClassID != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.ClassID))
	}
	return i, nil
}

func (m *Labels) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Labels) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Key)))
	i += copy(dAtA[i:], m.Key)
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	return i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Number))
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Protocol != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Protocol)))
		i += copy(dAtA[i:], *m.Protocol)
	}
	if m.Visibility != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Visibility))
	}
	if m.Labels != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n175, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n175
	}
	return i, nil
}

func (m *Ports) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ports) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DiscoveryInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscoveryInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Visibility))
	if m.Name != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.Environment != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Environment)))
		i += copy(dAtA[i:], *m.Environment)
	}
	if m.Location != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Location)))
		i += copy(dAtA[i:], *m.Location)
	}
	if m.Version != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Version)))
		i += copy(dAtA[i:], *m.Version)
	}
	if m.Ports != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Ports.ProtoSize()))
		n176, err := m.Ports.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n176
	}
	if m.Labels != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Labels.ProtoSize()))
		n177, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n177
	}
	return i, nil
}

func (m *WeightInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WeightInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x9
	i++
	i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(m.Weight))))
	if m.Role != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Role)))
		i += copy(dAtA[i:], *m.Role)
	}
	return i, nil
}

func (m *VersionInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Version)))
	i += copy(dAtA[i:], m.Version)
	if m.BuildDate != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.BuildDate)))
		i += copy(dAtA[i:], *m.BuildDate)
	}
	if m.BuildTime != nil {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.BuildTime))))
	}
	if m.BuildUser != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.BuildUser)))
		i += copy(dAtA[i:], *m.BuildUser)
	}
	if m.GitSHA != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.GitSHA)))
		i += copy(dAtA[i:], *m.GitSHA)
	}
	if m.GitBranch != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.GitBranch)))
		i += copy(dAtA[i:], *m.GitBranch)
	}
	if m.GitTag != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.GitTag)))
		i += copy(dAtA[i:], *m.GitTag)
	}
	return i, nil
}

func (m *Flag) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	return i, nil
}

func (m *Role) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Role) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x11
	i++
	i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(m.Weight))))
	if len(m.Frameworks) > 0 {
		for _, msg := range m.Frameworks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Metric) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Value != nil {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Mesos(dAtA, i, uint64(math.Float64bits(float64(*m.Value))))
	}
	return i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(len(m.Path)))
	i += copy(dAtA[i:], m.Path)
	if m.Nlink != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Nlink))
	}
	if m.Size != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Size))
	}
	if m.Mtime != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Mtime.ProtoSize()))
		n178, err := m.Mtime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n178
	}
	if m.Mode != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.Mode))
	}
	if m.UID != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.UID)))
		i += copy(dAtA[i:], *m.UID)
	}
	if m.GID != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.GID)))
		i += copy(dAtA[i:], *m.GID)
	}
	return i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Path != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesos(dAtA, i, uint64(len(*m.Path)))
		i += copy(dAtA[i:], *m.Path)
	}
	if m.Number != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesos(dAtA, i, uint64(m.Number.ProtoSize()))
		n179, err := m.Number.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n179
	}
	return i, nil
}

func (m *Device_Number) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device_Number) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MajorNumber == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("major_number")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MajorNumber))
	}
	if m.MinorNumber == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("minor_number")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesos(dAtA, i, uint64(*m.MinorNumber))
	}
	return i, nil
}

func (m *DeviceAccess) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceAccess) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Device.ProtoSize()))
	n180, err := m.Device.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n180
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesos(dAtA, i, uint64(m.Access.ProtoSize()))
	n181, err := m.Access.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n181
	return i, nil
}

func (m *DeviceAccess_Access) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceAccess_Access) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Read != nil {
		dAtA[i] = 0x8
		i++
		if *m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Write != nil {
		dAtA[i] = 0x10
		i++
		if *m.Write {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Mknod != nil {
		dAtA[i] = 0x18
		i++
		if *m.Mknod {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeviceWhitelist) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceWhitelist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AllowedDevices) > 0 {
		for _, msg := range m.AllowedDevices {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesos(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Mesos(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Mesos(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMesos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedFrameworkID(r randyMesos, easy bool) *FrameworkID {
	this := &FrameworkID{}
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOfferID(r randyMesos, easy bool) *OfferID {
	this := &OfferID{}
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAgentID(r randyMesos, easy bool) *AgentID {
	this := &AgentID{}
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTaskID(r randyMesos, easy bool) *TaskID {
	this := &TaskID{}
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedExecutorID(r randyMesos, easy bool) *ExecutorID {
	this := &ExecutorID{}
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainerID(r randyMesos, easy bool) *ContainerID {
	this := &ContainerID{}
	this.Value = string(randStringMesos(r))
	if r.Intn(10) == 0 {
		this.Parent = NewPopulatedContainerID(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResourceProviderID(r randyMesos, easy bool) *ResourceProviderID {
	this := &ResourceProviderID{}
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOperationID(r randyMesos, easy bool) *OperationID {
	this := &OperationID{}
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTimeInfo(r randyMesos, easy bool) *TimeInfo {
	this := &TimeInfo{}
	this.Nanoseconds = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Nanoseconds *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDurationInfo(r randyMesos, easy bool) *DurationInfo {
	this := &DurationInfo{}
	this.Nanoseconds = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Nanoseconds *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAddress(r randyMesos, easy bool) *Address {
	this := &Address{}
	if r.Intn(10) != 0 {
		v1 := string(randStringMesos(r))
		this.Hostname = &v1
	}
	if r.Intn(10) != 0 {
		v2 := string(randStringMesos(r))
		this.IP = &v2
	}
	this.Port = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Port *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedURL(r randyMesos, easy bool) *URL {
	this := &URL{}
	this.Scheme = string(randStringMesos(r))
	v3 := NewPopulatedAddress(r, easy)
	this.Address = *v3
	if r.Intn(10) != 0 {
		v4 := string(randStringMesos(r))
		this.Path = &v4
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.Query = make([]Parameter, v5)
		for i := 0; i < v5; i++ {
			v6 := NewPopulatedParameter(r, easy)
			this.Query[i] = *v6
		}
	}
	if r.Intn(10) != 0 {
		v7 := string(randStringMesos(r))
		this.Fragment = &v7
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUnavailability(r randyMesos, easy bool) *Unavailability {
	this := &Unavailability{}
	v8 := NewPopulatedTimeInfo(r, easy)
	this.Start = *v8
	if r.Intn(10) != 0 {
		this.Duration = NewPopulatedDurationInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMachineID(r randyMesos, easy bool) *MachineID {
	this := &MachineID{}
	if r.Intn(10) != 0 {
		v9 := string(randStringMesos(r))
		this.Hostname = &v9
	}
	if r.Intn(10) != 0 {
		v10 := string(randStringMesos(r))
		this.IP = &v10
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMachineInfo(r randyMesos, easy bool) *MachineInfo {
	this := &MachineInfo{}
	v11 := NewPopulatedMachineID(r, easy)
	this.ID = *v11
	if r.Intn(10) != 0 {
		v12 := MachineInfo_Mode([]int32{1, 2, 3}[r.Intn(3)])
		this.Mode = &v12
	}
	if r.Intn(10) != 0 {
		this.Unavailability = NewPopulatedUnavailability(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFrameworkInfo(r randyMesos, easy bool) *FrameworkInfo {
	this := &FrameworkInfo{}
	this.User = string(randStringMesos(r))
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		this.ID = NewPopulatedFrameworkID(r, easy)
	}
	if r.Intn(10) != 0 {
		v13 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v13 *= -1
		}
		this.FailoverTimeout = &v13
	}
	if r.Intn(10) != 0 {
		v14 := bool(bool(r.Intn(2) == 0))
		this.Checkpoint = &v14
	}
	if r.Intn(10) != 0 {
		v15 := string(randStringMesos(r))
		this.Role = &v15
	}
	if r.Intn(10) != 0 {
		v16 := string(randStringMesos(r))
		this.Hostname = &v16
	}
	if r.Intn(10) != 0 {
		v17 := string(randStringMesos(r))
		this.Principal = &v17
	}
	if r.Intn(10) != 0 {
		v18 := string(randStringMesos(r))
		this.WebUiURL = &v18
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(5)
		this.Capabilities = make([]FrameworkInfo_Capability, v19)
		for i := 0; i < v19; i++ {
			v20 := NewPopulatedFrameworkInfo_Capability(r, easy)
			this.Capabilities[i] = *v20
		}
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if r.Intn(10) != 0 {
		v21 := r.Intn(10)
		this.Roles = make([]string, v21)
		for i := 0; i < v21; i++ {
			this.Roles[i] = string(randStringMesos(r))
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFrameworkInfo_Capability(r randyMesos, easy bool) *FrameworkInfo_Capability {
	this := &FrameworkInfo_Capability{}
	this.Type = FrameworkInfo_Capability_Type([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8}[r.Intn(9)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckInfo(r randyMesos, easy bool) *CheckInfo {
	this := &CheckInfo{}
	this.Type = CheckInfo_Type([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(10) != 0 {
		this.Command = NewPopulatedCheckInfo_Command(r, easy)
	}
	if r.Intn(10) != 0 {
		this.HTTP = NewPopulatedCheckInfo_Http(r, easy)
	}
	if r.Intn(10) != 0 {
		v22 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v22 *= -1
		}
		this.DelaySeconds = &v22
	}
	if r.Intn(10) != 0 {
		v23 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v23 *= -1
		}
		this.IntervalSeconds = &v23
	}
	if r.Intn(10) != 0 {
		v24 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v24 *= -1
		}
		this.TimeoutSeconds = &v24
	}
	if r.Intn(10) != 0 {
		this.TCP = NewPopulatedCheckInfo_Tcp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckInfo_Command(r randyMesos, easy bool) *CheckInfo_Command {
	this := &CheckInfo_Command{}
	v25 := NewPopulatedCommandInfo(r, easy)
	this.Command = *v25
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckInfo_Http(r randyMesos, easy bool) *CheckInfo_Http {
	this := &CheckInfo_Http{}
	this.Port = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v26 := string(randStringMesos(r))
		this.Path = &v26
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckInfo_Tcp(r randyMesos, easy bool) *CheckInfo_Tcp {
	this := &CheckInfo_Tcp{}
	this.Port = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHealthCheck(r randyMesos, easy bool) *HealthCheck {
	this := &HealthCheck{}
	if r.Intn(10) != 0 {
		this.HTTP = NewPopulatedHealthCheck_HTTPCheckInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v27 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v27 *= -1
		}
		this.DelaySeconds = &v27
	}
	if r.Intn(10) != 0 {
		v28 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v28 *= -1
		}
		this.IntervalSeconds = &v28
	}
	if r.Intn(10) != 0 {
		v29 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v29 *= -1
		}
		this.TimeoutSeconds = &v29
	}
	if r.Intn(10) != 0 {
		v30 := uint32(r.Uint32())
		this.ConsecutiveFailures = &v30
	}
	if r.Intn(10) != 0 {
		v31 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v31 *= -1
		}
		this.GracePeriodSeconds = &v31
	}
	if r.Intn(10) != 0 {
		this.Command = NewPopulatedCommandInfo(r, easy)
	}
	this.Type = HealthCheck_Type([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(10) != 0 {
		this.TCP = NewPopulatedHealthCheck_TCPCheckInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHealthCheck_HTTPCheckInfo(r randyMesos, easy bool) *HealthCheck_HTTPCheckInfo {
	this := &HealthCheck_HTTPCheckInfo{}
	this.Port = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v32 := string(randStringMesos(r))
		this.Path = &v32
	}
	if r.Intn(10) != 0 {
		v33 := string(randStringMesos(r))
		this.Scheme = &v33
	}
	if r.Intn(10) != 0 {
		v34 := r.Intn(10)
		this.Statuses = make([]uint32, v34)
		for i := 0; i < v34; i++ {
			this.Statuses[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v35 := NetworkInfo_Protocol([]int32{1, 2}[r.Intn(2)])
		this.Protocol = &v35
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHealthCheck_TCPCheckInfo(r randyMesos, easy bool) *HealthCheck_TCPCheckInfo {
	this := &HealthCheck_TCPCheckInfo{}
	this.Port = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v36 := NetworkInfo_Protocol([]int32{1, 2}[r.Intn(2)])
		this.Protocol = &v36
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedKillPolicy(r randyMesos, easy bool) *KillPolicy {
	this := &KillPolicy{}
	if r.Intn(10) != 0 {
		this.GracePeriod = NewPopulatedDurationInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCommandInfo(r randyMesos, easy bool) *CommandInfo {
	this := &CommandInfo{}
	if r.Intn(10) != 0 {
		v37 := r.Intn(5)
		this.URIs = make([]CommandInfo_URI, v37)
		for i := 0; i < v37; i++ {
			v38 := NewPopulatedCommandInfo_URI(r, easy)
			this.URIs[i] = *v38
		}
	}
	if r.Intn(10) != 0 {
		this.Environment = NewPopulatedEnvironment(r, easy)
	}
	if r.Intn(10) != 0 {
		v39 := string(randStringMesos(r))
		this.Value = &v39
	}
	if r.Intn(10) != 0 {
		v40 := string(randStringMesos(r))
		this.User = &v40
	}
	if r.Intn(10) != 0 {
		v41 := bool(bool(r.Intn(2) == 0))
		this.Shell = &v41
	}
	if r.Intn(10) != 0 {
		v42 := r.Intn(10)
		this.Arguments = make([]string, v42)
		for i := 0; i < v42; i++ {
			this.Arguments[i] = string(randStringMesos(r))
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCommandInfo_URI(r randyMesos, easy bool) *CommandInfo_URI {
	this := &CommandInfo_URI{}
	this.Value = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v43 := bool(bool(r.Intn(2) == 0))
		this.Executable = &v43
	}
	if r.Intn(10) != 0 {
		v44 := bool(bool(r.Intn(2) == 0))
		this.Extract = &v44
	}
	if r.Intn(10) != 0 {
		v45 := bool(bool(r.Intn(2) == 0))
		this.Cache = &v45
	}
	if r.Intn(10) != 0 {
		v46 := string(randStringMesos(r))
		this.OutputFile = &v46
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedExecutorInfo(r randyMesos, easy bool) *ExecutorInfo {
	this := &ExecutorInfo{}
	v47 := NewPopulatedExecutorID(r, easy)
	this.ExecutorID = *v47
	if r.Intn(10) != 0 {
		v48 := r.Intn(100)
		this.Data = make([]byte, v48)
		for i := 0; i < v48; i++ {
			this.Data[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		v49 := r.Intn(5)
		this.Resources = make([]Resource, v49)
		for i := 0; i < v49; i++ {
			v50 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v50
		}
	}
	if r.Intn(10) != 0 {
		this.Command = NewPopulatedCommandInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.FrameworkID = NewPopulatedFrameworkID(r, easy)
	}
	if r.Intn(10) != 0 {
		v51 := string(randStringMesos(r))
		this.Name = &v51
	}
	if r.Intn(10) != 0 {
		v52 := string(randStringMesos(r))
		this.Source = &v52
	}
	if r.Intn(10) != 0 {
		this.Container = NewPopulatedContainerInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Discovery = NewPopulatedDiscoveryInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ShutdownGracePeriod = NewPopulatedDurationInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	this.Type = ExecutorInfo_Type([]int32{0, 1, 2}[r.Intn(3)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDomainInfo(r randyMesos, easy bool) *DomainInfo {
	this := &DomainInfo{}
	if r.Intn(10) != 0 {
		this.FaultDomain = NewPopulatedDomainInfo_FaultDomain(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDomainInfo_FaultDomain(r randyMesos, easy bool) *DomainInfo_FaultDomain {
	this := &DomainInfo_FaultDomain{}
	v53 := NewPopulatedDomainInfo_FaultDomain_RegionInfo(r, easy)
	this.Region = *v53
	v54 := NewPopulatedDomainInfo_FaultDomain_ZoneInfo(r, easy)
	this.Zone = *v54
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDomainInfo_FaultDomain_RegionInfo(r randyMesos, easy bool) *DomainInfo_FaultDomain_RegionInfo {
	this := &DomainInfo_FaultDomain_RegionInfo{}
	this.Name = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDomainInfo_FaultDomain_ZoneInfo(r randyMesos, easy bool) *DomainInfo_FaultDomain_ZoneInfo {
	this := &DomainInfo_FaultDomain_ZoneInfo{}
	this.Name = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMasterInfo(r randyMesos, easy bool) *MasterInfo {
	this := &MasterInfo{}
	this.ID = string(randStringMesos(r))
	this.IP = uint32(r.Uint32())
	v55 := uint32(r.Uint32())
	this.Port = &v55
	if r.Intn(10) != 0 {
		v56 := string(randStringMesos(r))
		this.PID = &v56
	}
	if r.Intn(10) != 0 {
		v57 := string(randStringMesos(r))
		this.Hostname = &v57
	}
	if r.Intn(10) != 0 {
		v58 := string(randStringMesos(r))
		this.Version = &v58
	}
	if r.Intn(10) != 0 {
		this.Address = NewPopulatedAddress(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Domain = NewPopulatedDomainInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v59 := r.Intn(5)
		this.Capabilities = make([]MasterInfo_Capability, v59)
		for i := 0; i < v59; i++ {
			v60 := NewPopulatedMasterInfo_Capability(r, easy)
			this.Capabilities[i] = *v60
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMasterInfo_Capability(r randyMesos, easy bool) *MasterInfo_Capability {
	this := &MasterInfo_Capability{}
	this.Type = MasterInfo_Capability_Type([]int32{0, 1}[r.Intn(2)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAgentInfo(r randyMesos, easy bool) *AgentInfo {
	this := &AgentInfo{}
	this.Hostname = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v61 := r.Intn(5)
		this.Resources = make([]Resource, v61)
		for i := 0; i < v61; i++ {
			v62 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v62
		}
	}
	if r.Intn(10) != 0 {
		v63 := r.Intn(5)
		this.Attributes = make([]Attribute, v63)
		for i := 0; i < v63; i++ {
			v64 := NewPopulatedAttribute(r, easy)
			this.Attributes[i] = *v64
		}
	}
	if r.Intn(10) != 0 {
		this.ID = NewPopulatedAgentID(r, easy)
	}
	if r.Intn(10) != 0 {
		v65 := int32(r.Int31())
		if r.Intn(2) == 0 {
			v65 *= -1
		}
		this.Port = &v65
	}
	if r.Intn(10) != 0 {
		this.Domain = NewPopulatedDomainInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAgentInfo_Capability(r randyMesos, easy bool) *AgentInfo_Capability {
	this := &AgentInfo_Capability{}
	this.Type = AgentInfo_Capability_Type([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCSIPluginContainerInfo(r randyMesos, easy bool) *CSIPluginContainerInfo {
	this := &CSIPluginContainerInfo{}
	if r.Intn(10) != 0 {
		v66 := r.Intn(10)
		this.Services = make([]CSIPluginContainerInfo_Service, v66)
		for i := 0; i < v66; i++ {
			this.Services[i] = CSIPluginContainerInfo_Service([]int32{0, 1, 2}[r.Intn(3)])
		}
	}
	if r.Intn(10) != 0 {
		this.Command = NewPopulatedCommandInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v67 := r.Intn(5)
		this.Resources = make([]Resource, v67)
		for i := 0; i < v67; i++ {
			v68 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v68
		}
	}
	if r.Intn(10) != 0 {
		this.Container = NewPopulatedContainerInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCSIPluginInfo(r randyMesos, easy bool) *CSIPluginInfo {
	this := &CSIPluginInfo{}
	this.Type = string(randStringMesos(r))
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v69 := r.Intn(5)
		this.Containers = make([]CSIPluginContainerInfo, v69)
		for i := 0; i < v69; i++ {
			v70 := NewPopulatedCSIPluginContainerInfo(r, easy)
			this.Containers[i] = *v70
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResourceProviderInfo(r randyMesos, easy bool) *ResourceProviderInfo {
	this := &ResourceProviderInfo{}
	if r.Intn(10) != 0 {
		this.ID = NewPopulatedResourceProviderID(r, easy)
	}
	if r.Intn(10) != 0 {
		v71 := r.Intn(5)
		this.Attributes = make([]Attribute, v71)
		for i := 0; i < v71; i++ {
			v72 := NewPopulatedAttribute(r, easy)
			this.Attributes[i] = *v72
		}
	}
	this.Type = string(randStringMesos(r))
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v73 := r.Intn(5)
		this.DefaultReservations = make([]Resource_ReservationInfo, v73)
		for i := 0; i < v73; i++ {
			v74 := NewPopulatedResource_ReservationInfo(r, easy)
			this.DefaultReservations[i] = *v74
		}
	}
	if r.Intn(10) != 0 {
		this.Storage = NewPopulatedResourceProviderInfo_Storage(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResourceProviderInfo_Storage(r randyMesos, easy bool) *ResourceProviderInfo_Storage {
	this := &ResourceProviderInfo_Storage{}
	v75 := NewPopulatedCSIPluginInfo(r, easy)
	this.Plugin = *v75
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedValue(r randyMesos, easy bool) *Value {
	this := &Value{}
	this.Type = Value_Type([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(10) != 0 {
		this.Scalar = NewPopulatedValue_Scalar(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Ranges = NewPopulatedValue_Ranges(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Set = NewPopulatedValue_Set(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Text = NewPopulatedValue_Text(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedValue_Scalar(r randyMesos, easy bool) *Value_Scalar {
	this := &Value_Scalar{}
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedValue_Range(r randyMesos, easy bool) *Value_Range {
	this := &Value_Range{}
	this.Begin = uint64(uint64(r.Uint32()))
	this.End = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedValue_Ranges(r randyMesos, easy bool) *Value_Ranges {
	this := &Value_Ranges{}
	if r.Intn(10) != 0 {
		v76 := r.Intn(5)
		this.Range = make([]Value_Range, v76)
		for i := 0; i < v76; i++ {
			v77 := NewPopulatedValue_Range(r, easy)
			this.Range[i] = *v77
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedValue_Set(r randyMesos, easy bool) *Value_Set {
	this := &Value_Set{}
	if r.Intn(10) != 0 {
		v78 := r.Intn(10)
		this.Item = make([]string, v78)
		for i := 0; i < v78; i++ {
			this.Item[i] = string(randStringMesos(r))
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedValue_Text(r randyMesos, easy bool) *Value_Text {
	this := &Value_Text{}
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAttribute(r randyMesos, easy bool) *Attribute {
	this := &Attribute{}
	this.Name = string(randStringMesos(r))
	this.Type = Value_Type([]int32{0, 1, 2, 3}[r.Intn(4)])
	if r.Intn(10) != 0 {
		this.Scalar = NewPopulatedValue_Scalar(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Ranges = NewPopulatedValue_Ranges(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Text = NewPopulatedValue_Text(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Set = NewPopulatedValue_Set(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource(r randyMesos, easy bool) *Resource {
	this := &Resource{}
	this.Name = string(randStringMesos(r))
	v79 := Value_Type([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.Type = &v79
	if r.Intn(10) != 0 {
		this.Scalar = NewPopulatedValue_Scalar(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Ranges = NewPopulatedValue_Ranges(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Set = NewPopulatedValue_Set(r, easy)
	}
	if r.Intn(10) != 0 {
		v80 := string(randStringMesos(r))
		this.Role = &v80
	}
	if r.Intn(10) != 0 {
		this.Disk = NewPopulatedResource_DiskInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Reservation = NewPopulatedResource_ReservationInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Revocable = NewPopulatedResource_RevocableInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Shared = NewPopulatedResource_SharedInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.AllocationInfo = NewPopulatedResource_AllocationInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ProviderID = NewPopulatedResourceProviderID(r, easy)
	}
	if r.Intn(10) != 0 {
		v81 := r.Intn(5)
		this.Reservations = make([]Resource_ReservationInfo, v81)
		for i := 0; i < v81; i++ {
			v82 := NewPopulatedResource_ReservationInfo(r, easy)
			this.Reservations[i] = *v82
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_AllocationInfo(r randyMesos, easy bool) *Resource_AllocationInfo {
	this := &Resource_AllocationInfo{}
	if r.Intn(10) != 0 {
		v83 := string(randStringMesos(r))
		this.Role = &v83
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_ReservationInfo(r randyMesos, easy bool) *Resource_ReservationInfo {
	this := &Resource_ReservationInfo{}
	if r.Intn(10) != 0 {
		v84 := string(randStringMesos(r))
		this.Principal = &v84
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if r.Intn(10) != 0 {
		v85 := string(randStringMesos(r))
		this.Role = &v85
	}
	if r.Intn(10) != 0 {
		v86 := Resource_ReservationInfo_Type([]int32{0, 1, 2}[r.Intn(3)])
		this.Type = &v86
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_DiskInfo(r randyMesos, easy bool) *Resource_DiskInfo {
	this := &Resource_DiskInfo{}
	if r.Intn(10) != 0 {
		this.Persistence = NewPopulatedResource_DiskInfo_Persistence(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Volume = NewPopulatedVolume(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Source = NewPopulatedResource_DiskInfo_Source(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_DiskInfo_Persistence(r randyMesos, easy bool) *Resource_DiskInfo_Persistence {
	this := &Resource_DiskInfo_Persistence{}
	this.ID = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v87 := string(randStringMesos(r))
		this.Principal = &v87
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_DiskInfo_Source(r randyMesos, easy bool) *Resource_DiskInfo_Source {
	this := &Resource_DiskInfo_Source{}
	this.Type = Resource_DiskInfo_Source_Type([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if r.Intn(10) != 0 {
		this.Path = NewPopulatedResource_DiskInfo_Source_Path(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Mount = NewPopulatedResource_DiskInfo_Source_Mount(r, easy)
	}
	if r.Intn(10) != 0 {
		v88 := string(randStringMesos(r))
		this.ID = &v88
	}
	if r.Intn(10) != 0 {
		this.Metadata = NewPopulatedLabels(r, easy)
	}
	if r.Intn(10) != 0 {
		v89 := string(randStringMesos(r))
		this.Profile = &v89
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_DiskInfo_Source_Path(r randyMesos, easy bool) *Resource_DiskInfo_Source_Path {
	this := &Resource_DiskInfo_Source_Path{}
	if r.Intn(10) != 0 {
		v90 := string(randStringMesos(r))
		this.Root = &v90
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_DiskInfo_Source_Mount(r randyMesos, easy bool) *Resource_DiskInfo_Source_Mount {
	this := &Resource_DiskInfo_Source_Mount{}
	if r.Intn(10) != 0 {
		v91 := string(randStringMesos(r))
		this.Root = &v91
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_RevocableInfo(r randyMesos, easy bool) *Resource_RevocableInfo {
	this := &Resource_RevocableInfo{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResource_SharedInfo(r randyMesos, easy bool) *Resource_SharedInfo {
	this := &Resource_SharedInfo{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTrafficControlStatistics(r randyMesos, easy bool) *TrafficControlStatistics {
	this := &TrafficControlStatistics{}
	this.ID = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v92 := uint64(uint64(r.Uint32()))
		this.Backlog = &v92
	}
	if r.Intn(10) != 0 {
		v93 := uint64(uint64(r.Uint32()))
		this.Bytes = &v93
	}
	if r.Intn(10) != 0 {
		v94 := uint64(uint64(r.Uint32()))
		this.Drops = &v94
	}
	if r.Intn(10) != 0 {
		v95 := uint64(uint64(r.Uint32()))
		this.Overlimits = &v95
	}
	if r.Intn(10) != 0 {
		v96 := uint64(uint64(r.Uint32()))
		this.Packets = &v96
	}
	if r.Intn(10) != 0 {
		v97 := uint64(uint64(r.Uint32()))
		this.Qlen = &v97
	}
	if r.Intn(10) != 0 {
		v98 := uint64(uint64(r.Uint32()))
		this.RateBPS = &v98
	}
	if r.Intn(10) != 0 {
		v99 := uint64(uint64(r.Uint32()))
		this.RatePPS = &v99
	}
	if r.Intn(10) != 0 {
		v100 := uint64(uint64(r.Uint32()))
		this.Requeues = &v100
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIpStatistics(r randyMesos, easy bool) *IpStatistics {
	this := &IpStatistics{}
	if r.Intn(10) != 0 {
		v101 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v101 *= -1
		}
		this.Forwarding = &v101
	}
	if r.Intn(10) != 0 {
		v102 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v102 *= -1
		}
		this.DefaultTTL = &v102
	}
	if r.Intn(10) != 0 {
		v103 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v103 *= -1
		}
		this.InReceives = &v103
	}
	if r.Intn(10) != 0 {
		v104 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v104 *= -1
		}
		this.InHdrErrors = &v104
	}
	if r.Intn(10) != 0 {
		v105 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v105 *= -1
		}
		this.InAddrErrors = &v105
	}
	if r.Intn(10) != 0 {
		v106 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v106 *= -1
		}
		this.ForwDatagrams = &v106
	}
	if r.Intn(10) != 0 {
		v107 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v107 *= -1
		}
		this.InUnknownProtos = &v107
	}
	if r.Intn(10) != 0 {
		v108 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v108 *= -1
		}
		this.InDiscards = &v108
	}
	if r.Intn(10) != 0 {
		v109 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v109 *= -1
		}
		this.InDelivers = &v109
	}
	if r.Intn(10) != 0 {
		v110 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v110 *= -1
		}
		this.OutRequests = &v110
	}
	if r.Intn(10) != 0 {
		v111 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v111 *= -1
		}
		this.OutDiscards = &v111
	}
	if r.Intn(10) != 0 {
		v112 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v112 *= -1
		}
		this.OutNoRoutes = &v112
	}
	if r.Intn(10) != 0 {
		v113 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v113 *= -1
		}
		this.ReasmTimeout = &v113
	}
	if r.Intn(10) != 0 {
		v114 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v114 *= -1
		}
		this.ReasmReqds = &v114
	}
	if r.Intn(10) != 0 {
		v115 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v115 *= -1
		}
		this.ReasmOKs = &v115
	}
	if r.Intn(10) != 0 {
		v116 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v116 *= -1
		}
		this.ReasmFails = &v116
	}
	if r.Intn(10) != 0 {
		v117 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v117 *= -1
		}
		this.FragOKs = &v117
	}
	if r.Intn(10) != 0 {
		v118 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v118 *= -1
		}
		this.FragFails = &v118
	}
	if r.Intn(10) != 0 {
		v119 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v119 *= -1
		}
		this.FragCreates = &v119
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIcmpStatistics(r randyMesos, easy bool) *IcmpStatistics {
	this := &IcmpStatistics{}
	if r.Intn(10) != 0 {
		v120 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v120 *= -1
		}
		this.InMsgs = &v120
	}
	if r.Intn(10) != 0 {
		v121 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v121 *= -1
		}
		this.InErrors = &v121
	}
	if r.Intn(10) != 0 {
		v122 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v122 *= -1
		}
		this.InCsumErrors = &v122
	}
	if r.Intn(10) != 0 {
		v123 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v123 *= -1
		}
		this.InDestUnreachs = &v123
	}
	if r.Intn(10) != 0 {
		v124 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v124 *= -1
		}
		this.InTimeExcds = &v124
	}
	if r.Intn(10) != 0 {
		v125 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v125 *= -1
		}
		this.InParmProbs = &v125
	}
	if r.Intn(10) != 0 {
		v126 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v126 *= -1
		}
		this.InSrcQuenchs = &v126
	}
	if r.Intn(10) != 0 {
		v127 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v127 *= -1
		}
		this.InRedirects = &v127
	}
	if r.Intn(10) != 0 {
		v128 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v128 *= -1
		}
		this.InEchos = &v128
	}
	if r.Intn(10) != 0 {
		v129 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v129 *= -1
		}
		this.InEchoReps = &v129
	}
	if r.Intn(10) != 0 {
		v130 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v130 *= -1
		}
		this.InTimestamps = &v130
	}
	if r.Intn(10) != 0 {
		v131 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v131 *= -1
		}
		this.InTimestampReps = &v131
	}
	if r.Intn(10) != 0 {
		v132 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v132 *= -1
		}
		this.InAddrMasks = &v132
	}
	if r.Intn(10) != 0 {
		v133 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v133 *= -1
		}
		this.InAddrMaskReps = &v133
	}
	if r.Intn(10) != 0 {
		v134 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v134 *= -1
		}
		this.OutMsgs = &v134
	}
	if r.Intn(10) != 0 {
		v135 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v135 *= -1
		}
		this.OutErrors = &v135
	}
	if r.Intn(10) != 0 {
		v136 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v136 *= -1
		}
		this.OutDestUnreachs = &v136
	}
	if r.Intn(10) != 0 {
		v137 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v137 *= -1
		}
		this.OutTimeExcds = &v137
	}
	if r.Intn(10) != 0 {
		v138 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v138 *= -1
		}
		this.OutParmProbs = &v138
	}
	if r.Intn(10) != 0 {
		v139 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v139 *= -1
		}
		this.OutSrcQuenchs = &v139
	}
	if r.Intn(10) != 0 {
		v140 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v140 *= -1
		}
		this.OutRedirects = &v140
	}
	if r.Intn(10) != 0 {
		v141 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v141 *= -1
		}
		this.OutEchos = &v141
	}
	if r.Intn(10) != 0 {
		v142 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v142 *= -1
		}
		this.OutEchoReps = &v142
	}
	if r.Intn(10) != 0 {
		v143 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v143 *= -1
		}
		this.OutTimestamps = &v143
	}
	if r.Intn(10) != 0 {
		v144 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v144 *= -1
		}
		this.OutTimestampReps = &v144
	}
	if r.Intn(10) != 0 {
		v145 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v145 *= -1
		}
		this.OutAddrMasks = &v145
	}
	if r.Intn(10) != 0 {
		v146 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v146 *= -1
		}
		this.OutAddrMaskReps = &v146
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTcpStatistics(r randyMesos, easy bool) *TcpStatistics {
	this := &TcpStatistics{}
	if r.Intn(10) != 0 {
		v147 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v147 *= -1
		}
		this.RtoAlgorithm = &v147
	}
	if r.Intn(10) != 0 {
		v148 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v148 *= -1
		}
		this.RtoMin = &v148
	}
	if r.Intn(10) != 0 {
		v149 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v149 *= -1
		}
		this.RtoMax = &v149
	}
	if r.Intn(10) != 0 {
		v150 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v150 *= -1
		}
		this.MaxConn = &v150
	}
	if r.Intn(10) != 0 {
		v151 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v151 *= -1
		}
		this.ActiveOpens = &v151
	}
	if r.Intn(10) != 0 {
		v152 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v152 *= -1
		}
		this.PassiveOpens = &v152
	}
	if r.Intn(10) != 0 {
		v153 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v153 *= -1
		}
		this.AttemptFails = &v153
	}
	if r.Intn(10) != 0 {
		v154 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v154 *= -1
		}
		this.EstabResets = &v154
	}
	if r.Intn(10) != 0 {
		v155 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v155 *= -1
		}
		this.CurrEstab = &v155
	}
	if r.Intn(10) != 0 {
		v156 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v156 *= -1
		}
		this.InSegs = &v156
	}
	if r.Intn(10) != 0 {
		v157 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v157 *= -1
		}
		this.OutSegs = &v157
	}
	if r.Intn(10) != 0 {
		v158 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v158 *= -1
		}
		this.RetransSegs = &v158
	}
	if r.Intn(10) != 0 {
		v159 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v159 *= -1
		}
		this.InErrs = &v159
	}
	if r.Intn(10) != 0 {
		v160 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v160 *= -1
		}
		this.OutRsts = &v160
	}
	if r.Intn(10) != 0 {
		v161 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v161 *= -1
		}
		this.InCsumErrors = &v161
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUdpStatistics(r randyMesos, easy bool) *UdpStatistics {
	this := &UdpStatistics{}
	if r.Intn(10) != 0 {
		v162 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v162 *= -1
		}
		this.InDatagrams = &v162
	}
	if r.Intn(10) != 0 {
		v163 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v163 *= -1
		}
		this.NoPorts = &v163
	}
	if r.Intn(10) != 0 {
		v164 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v164 *= -1
		}
		this.InErrors = &v164
	}
	if r.Intn(10) != 0 {
		v165 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v165 *= -1
		}
		this.OutDatagrams = &v165
	}
	if r.Intn(10) != 0 {
		v166 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v166 *= -1
		}
		this.RcvbufErrors = &v166
	}
	if r.Intn(10) != 0 {
		v167 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v167 *= -1
		}
		this.SndbufErrors = &v167
	}
	if r.Intn(10) != 0 {
		v168 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v168 *= -1
		}
		this.InCsumErrors = &v168
	}
	if r.Intn(10) != 0 {
		v169 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v169 *= -1
		}
		this.IgnoredMulti = &v169
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSNMPStatistics(r randyMesos, easy bool) *SNMPStatistics {
	this := &SNMPStatistics{}
	if r.Intn(10) != 0 {
		this.IPStats = NewPopulatedIpStatistics(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ICMPStats = NewPopulatedIcmpStatistics(r, easy)
	}
	if r.Intn(10) != 0 {
		this.TCPStats = NewPopulatedTcpStatistics(r, easy)
	}
	if r.Intn(10) != 0 {
		this.UDPStats = NewPopulatedUdpStatistics(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDiskStatistics(r randyMesos, easy bool) *DiskStatistics {
	this := &DiskStatistics{}
	if r.Intn(10) != 0 {
		this.Source = NewPopulatedResource_DiskInfo_Source(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Persistence = NewPopulatedResource_DiskInfo_Persistence(r, easy)
	}
	if r.Intn(10) != 0 {
		v170 := uint64(uint64(r.Uint32()))
		this.LimitBytes = &v170
	}
	if r.Intn(10) != 0 {
		v171 := uint64(uint64(r.Uint32()))
		this.UsedBytes = &v171
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResourceStatistics(r randyMesos, easy bool) *ResourceStatistics {
	this := &ResourceStatistics{}
	this.Timestamp = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	if r.Intn(10) != 0 {
		v172 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v172 *= -1
		}
		this.CPUsUserTimeSecs = &v172
	}
	if r.Intn(10) != 0 {
		v173 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v173 *= -1
		}
		this.CPUsSystemTimeSecs = &v173
	}
	if r.Intn(10) != 0 {
		v174 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v174 *= -1
		}
		this.CPUsLimit = &v174
	}
	if r.Intn(10) != 0 {
		v175 := uint64(uint64(r.Uint32()))
		this.MemRSSBytes = &v175
	}
	if r.Intn(10) != 0 {
		v176 := uint64(uint64(r.Uint32()))
		this.MemLimitBytes = &v176
	}
	if r.Intn(10) != 0 {
		v177 := uint32(r.Uint32())
		this.CPUsNrPeriods = &v177
	}
	if r.Intn(10) != 0 {
		v178 := uint32(r.Uint32())
		this.CPUsNrThrottled = &v178
	}
	if r.Intn(10) != 0 {
		v179 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v179 *= -1
		}
		this.CPUsThrottledTimeSecs = &v179
	}
	if r.Intn(10) != 0 {
		v180 := uint64(uint64(r.Uint32()))
		this.MemFileBytes = &v180
	}
	if r.Intn(10) != 0 {
		v181 := uint64(uint64(r.Uint32()))
		this.MemAnonBytes = &v181
	}
	if r.Intn(10) != 0 {
		v182 := uint64(uint64(r.Uint32()))
		this.MemMappedFileBytes = &v182
	}
	if r.Intn(10) != 0 {
		this.Perf = NewPopulatedPerfStatistics(r, easy)
	}
	if r.Intn(10) != 0 {
		v183 := uint64(uint64(r.Uint32()))
		this.NetRxPackets = &v183
	}
	if r.Intn(10) != 0 {
		v184 := uint64(uint64(r.Uint32()))
		this.NetRxBytes = &v184
	}
	if r.Intn(10) != 0 {
		v185 := uint64(uint64(r.Uint32()))
		this.NetRxErrors = &v185
	}
	if r.Intn(10) != 0 {
		v186 := uint64(uint64(r.Uint32()))
		this.NetRxDropped = &v186
	}
	if r.Intn(10) != 0 {
		v187 := uint64(uint64(r.Uint32()))
		this.NetTxPackets = &v187
	}
	if r.Intn(10) != 0 {
		v188 := uint64(uint64(r.Uint32()))
		this.NetTxBytes = &v188
	}
	if r.Intn(10) != 0 {
		v189 := uint64(uint64(r.Uint32()))
		this.NetTxErrors = &v189
	}
	if r.Intn(10) != 0 {
		v190 := uint64(uint64(r.Uint32()))
		this.NetTxDropped = &v190
	}
	if r.Intn(10) != 0 {
		v191 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v191 *= -1
		}
		this.NetTCPRttMicrosecsP50 = &v191
	}
	if r.Intn(10) != 0 {
		v192 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v192 *= -1
		}
		this.NetTCPRttMicrosecsP90 = &v192
	}
	if r.Intn(10) != 0 {
		v193 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v193 *= -1
		}
		this.NetTCPRttMicrosecsP95 = &v193
	}
	if r.Intn(10) != 0 {
		v194 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v194 *= -1
		}
		this.NetTCPRttMicrosecsP99 = &v194
	}
	if r.Intn(10) != 0 {
		v195 := uint64(uint64(r.Uint32()))
		this.DiskLimitBytes = &v195
	}
	if r.Intn(10) != 0 {
		v196 := uint64(uint64(r.Uint32()))
		this.DiskUsedBytes = &v196
	}
	if r.Intn(10) != 0 {
		v197 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v197 *= -1
		}
		this.NetTCPActiveConnections = &v197
	}
	if r.Intn(10) != 0 {
		v198 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v198 *= -1
		}
		this.NetTCPTimeWaitConnections = &v198
	}
	if r.Intn(10) != 0 {
		v199 := uint32(r.Uint32())
		this.Processes = &v199
	}
	if r.Intn(10) != 0 {
		v200 := uint32(r.Uint32())
		this.Threads = &v200
	}
	if r.Intn(10) != 0 {
		v201 := uint64(uint64(r.Uint32()))
		this.MemLowPressureCounter = &v201
	}
	if r.Intn(10) != 0 {
		v202 := uint64(uint64(r.Uint32()))
		this.MemMediumPressureCounter = &v202
	}
	if r.Intn(10) != 0 {
		v203 := uint64(uint64(r.Uint32()))
		this.MemCriticalPressureCounter = &v203
	}
	if r.Intn(10) != 0 {
		v204 := r.Intn(5)
		this.NetTrafficControlStatistics = make([]TrafficControlStatistics, v204)
		for i := 0; i < v204; i++ {
			v205 := NewPopulatedTrafficControlStatistics(r, easy)
			this.NetTrafficControlStatistics[i] = *v205
		}
	}
	if r.Intn(10) != 0 {
		v206 := uint64(uint64(r.Uint32()))
		this.MemTotalBytes = &v206
	}
	if r.Intn(10) != 0 {
		v207 := uint64(uint64(r.Uint32()))
		this.MemTotalMemswBytes = &v207
	}
	if r.Intn(10) != 0 {
		v208 := uint64(uint64(r.Uint32()))
		this.MemSoftLimitBytes = &v208
	}
	if r.Intn(10) != 0 {
		v209 := uint64(uint64(r.Uint32()))
		this.MemCacheBytes = &v209
	}
	if r.Intn(10) != 0 {
		v210 := uint64(uint64(r.Uint32()))
		this.MemSwapBytes = &v210
	}
	if r.Intn(10) != 0 {
		v211 := uint64(uint64(r.Uint32()))
		this.MemUnevictableBytes = &v211
	}
	if r.Intn(10) != 0 {
		this.NetSNMPStatistics = NewPopulatedSNMPStatistics(r, easy)
	}
	if r.Intn(10) != 0 {
		v212 := r.Intn(5)
		this.DiskStatistics = make([]DiskStatistics, v212)
		for i := 0; i < v212; i++ {
			v213 := NewPopulatedDiskStatistics(r, easy)
			this.DiskStatistics[i] = *v213
		}
	}
	if r.Intn(10) != 0 {
		this.BlkioStatistics = NewPopulatedCgroupInfo_Blkio_Statistics(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResourceUsage(r randyMesos, easy bool) *ResourceUsage {
	this := &ResourceUsage{}
	if r.Intn(10) == 0 {
		v214 := r.Intn(5)
		this.Executors = make([]ResourceUsage_Executor, v214)
		for i := 0; i < v214; i++ {
			v215 := NewPopulatedResourceUsage_Executor(r, easy)
			this.Executors[i] = *v215
		}
	}
	if r.Intn(10) != 0 {
		v216 := r.Intn(5)
		this.Total = make([]Resource, v216)
		for i := 0; i < v216; i++ {
			v217 := NewPopulatedResource(r, easy)
			this.Total[i] = *v217
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResourceUsage_Executor(r randyMesos, easy bool) *ResourceUsage_Executor {
	this := &ResourceUsage_Executor{}
	v218 := NewPopulatedExecutorInfo(r, easy)
	this.ExecutorInfo = *v218
	if r.Intn(10) != 0 {
		v219 := r.Intn(5)
		this.Allocated = make([]Resource, v219)
		for i := 0; i < v219; i++ {
			v220 := NewPopulatedResource(r, easy)
			this.Allocated[i] = *v220
		}
	}
	if r.Intn(10) != 0 {
		this.Statistics = NewPopulatedResourceStatistics(r, easy)
	}
	v221 := NewPopulatedContainerID(r, easy)
	this.ContainerID = *v221
	if r.Intn(10) != 0 {
		v222 := r.Intn(5)
		this.Tasks = make([]ResourceUsage_Executor_Task, v222)
		for i := 0; i < v222; i++ {
			v223 := NewPopulatedResourceUsage_Executor_Task(r, easy)
			this.Tasks[i] = *v223
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResourceUsage_Executor_Task(r randyMesos, easy bool) *ResourceUsage_Executor_Task {
	this := &ResourceUsage_Executor_Task{}
	this.Name = string(randStringMesos(r))
	v224 := NewPopulatedTaskID(r, easy)
	this.ID = *v224
	if r.Intn(10) != 0 {
		v225 := r.Intn(5)
		this.Resources = make([]Resource, v225)
		for i := 0; i < v225; i++ {
			v226 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v226
		}
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPerfStatistics(r randyMesos, easy bool) *PerfStatistics {
	this := &PerfStatistics{}
	this.Timestamp = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Duration = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Duration *= -1
	}
	if r.Intn(10) != 0 {
		v227 := uint64(uint64(r.Uint32()))
		this.Cycles = &v227
	}
	if r.Intn(10) != 0 {
		v228 := uint64(uint64(r.Uint32()))
		this.StalledCyclesFrontend = &v228
	}
	if r.Intn(10) != 0 {
		v229 := uint64(uint64(r.Uint32()))
		this.StalledCyclesBackend = &v229
	}
	if r.Intn(10) != 0 {
		v230 := uint64(uint64(r.Uint32()))
		this.Instructions = &v230
	}
	if r.Intn(10) != 0 {
		v231 := uint64(uint64(r.Uint32()))
		this.CacheReferences = &v231
	}
	if r.Intn(10) != 0 {
		v232 := uint64(uint64(r.Uint32()))
		this.CacheMisses = &v232
	}
	if r.Intn(10) != 0 {
		v233 := uint64(uint64(r.Uint32()))
		this.Branches = &v233
	}
	if r.Intn(10) != 0 {
		v234 := uint64(uint64(r.Uint32()))
		this.BranchMisses = &v234
	}
	if r.Intn(10) != 0 {
		v235 := uint64(uint64(r.Uint32()))
		this.BusCycles = &v235
	}
	if r.Intn(10) != 0 {
		v236 := uint64(uint64(r.Uint32()))
		this.RefCycles = &v236
	}
	if r.Intn(10) != 0 {
		v237 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v237 *= -1
		}
		this.CPUClock = &v237
	}
	if r.Intn(10) != 0 {
		v238 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v238 *= -1
		}
		this.TaskClock = &v238
	}
	if r.Intn(10) != 0 {
		v239 := uint64(uint64(r.Uint32()))
		this.PageFaults = &v239
	}
	if r.Intn(10) != 0 {
		v240 := uint64(uint64(r.Uint32()))
		this.MinorFaults = &v240
	}
	if r.Intn(10) != 0 {
		v241 := uint64(uint64(r.Uint32()))
		this.MajorFaults = &v241
	}
	if r.Intn(10) != 0 {
		v242 := uint64(uint64(r.Uint32()))
		this.ContextSwitches = &v242
	}
	if r.Intn(10) != 0 {
		v243 := uint64(uint64(r.Uint32()))
		this.CPUMigrations = &v243
	}
	if r.Intn(10) != 0 {
		v244 := uint64(uint64(r.Uint32()))
		this.AlignmentFaults = &v244
	}
	if r.Intn(10) != 0 {
		v245 := uint64(uint64(r.Uint32()))
		this.EmulationFaults = &v245
	}
	if r.Intn(10) != 0 {
		v246 := uint64(uint64(r.Uint32()))
		this.L1DcacheLoads = &v246
	}
	if r.Intn(10) != 0 {
		v247 := uint64(uint64(r.Uint32()))
		this.L1DcacheLoadMisses = &v247
	}
	if r.Intn(10) != 0 {
		v248 := uint64(uint64(r.Uint32()))
		this.L1DcacheStores = &v248
	}
	if r.Intn(10) != 0 {
		v249 := uint64(uint64(r.Uint32()))
		this.L1DcacheStoreMisses = &v249
	}
	if r.Intn(10) != 0 {
		v250 := uint64(uint64(r.Uint32()))
		this.L1DcachePrefetches = &v250
	}
	if r.Intn(10) != 0 {
		v251 := uint64(uint64(r.Uint32()))
		this.L1DcachePrefetchMisses = &v251
	}
	if r.Intn(10) != 0 {
		v252 := uint64(uint64(r.Uint32()))
		this.L1IcacheLoads = &v252
	}
	if r.Intn(10) != 0 {
		v253 := uint64(uint64(r.Uint32()))
		this.L1IcacheLoadMisses = &v253
	}
	if r.Intn(10) != 0 {
		v254 := uint64(uint64(r.Uint32()))
		this.L1IcachePrefetches = &v254
	}
	if r.Intn(10) != 0 {
		v255 := uint64(uint64(r.Uint32()))
		this.L1IcachePrefetchMisses = &v255
	}
	if r.Intn(10) != 0 {
		v256 := uint64(uint64(r.Uint32()))
		this.LLCLoads = &v256
	}
	if r.Intn(10) != 0 {
		v257 := uint64(uint64(r.Uint32()))
		this.LLCLoadMisses = &v257
	}
	if r.Intn(10) != 0 {
		v258 := uint64(uint64(r.Uint32()))
		this.LLCStores = &v258
	}
	if r.Intn(10) != 0 {
		v259 := uint64(uint64(r.Uint32()))
		this.LLCStoreMisses = &v259
	}
	if r.Intn(10) != 0 {
		v260 := uint64(uint64(r.Uint32()))
		this.LLCPrefetches = &v260
	}
	if r.Intn(10) != 0 {
		v261 := uint64(uint64(r.Uint32()))
		this.LLCPrefetchMisses = &v261
	}
	if r.Intn(10) != 0 {
		v262 := uint64(uint64(r.Uint32()))
		this.DTLBLoads = &v262
	}
	if r.Intn(10) != 0 {
		v263 := uint64(uint64(r.Uint32()))
		this.DTLBLoadMisses = &v263
	}
	if r.Intn(10) != 0 {
		v264 := uint64(uint64(r.Uint32()))
		this.DTLBStores = &v264
	}
	if r.Intn(10) != 0 {
		v265 := uint64(uint64(r.Uint32()))
		this.DTLBStoreMisses = &v265
	}
	if r.Intn(10) != 0 {
		v266 := uint64(uint64(r.Uint32()))
		this.DTLBPrefetches = &v266
	}
	if r.Intn(10) != 0 {
		v267 := uint64(uint64(r.Uint32()))
		this.DTLBPrefetchMisses = &v267
	}
	if r.Intn(10) != 0 {
		v268 := uint64(uint64(r.Uint32()))
		this.ITLBLoads = &v268
	}
	if r.Intn(10) != 0 {
		v269 := uint64(uint64(r.Uint32()))
		this.ITLBLoadMisses = &v269
	}
	if r.Intn(10) != 0 {
		v270 := uint64(uint64(r.Uint32()))
		this.BranchLoads = &v270
	}
	if r.Intn(10) != 0 {
		v271 := uint64(uint64(r.Uint32()))
		this.BranchLoadMisses = &v271
	}
	if r.Intn(10) != 0 {
		v272 := uint64(uint64(r.Uint32()))
		this.NodeLoads = &v272
	}
	if r.Intn(10) != 0 {
		v273 := uint64(uint64(r.Uint32()))
		this.NodeLoadMisses = &v273
	}
	if r.Intn(10) != 0 {
		v274 := uint64(uint64(r.Uint32()))
		this.NodeStores = &v274
	}
	if r.Intn(10) != 0 {
		v275 := uint64(uint64(r.Uint32()))
		this.NodeStoreMisses = &v275
	}
	if r.Intn(10) != 0 {
		v276 := uint64(uint64(r.Uint32()))
		this.NodePrefetches = &v276
	}
	if r.Intn(10) != 0 {
		v277 := uint64(uint64(r.Uint32()))
		this.NodePrefetchMisses = &v277
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRequest(r randyMesos, easy bool) *Request {
	this := &Request{}
	if r.Intn(10) != 0 {
		this.AgentID = NewPopulatedAgentID(r, easy)
	}
	if r.Intn(10) != 0 {
		v278 := r.Intn(5)
		this.Resources = make([]Resource, v278)
		for i := 0; i < v278; i++ {
			v279 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v279
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer(r randyMesos, easy bool) *Offer {
	this := &Offer{}
	v280 := NewPopulatedOfferID(r, easy)
	this.ID = *v280
	v281 := NewPopulatedFrameworkID(r, easy)
	this.FrameworkID = *v281
	v282 := NewPopulatedAgentID(r, easy)
	this.AgentID = *v282
	this.Hostname = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v283 := r.Intn(5)
		this.Resources = make([]Resource, v283)
		for i := 0; i < v283; i++ {
			v284 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v284
		}
	}
	if r.Intn(10) != 0 {
		v285 := r.Intn(5)
		this.ExecutorIDs = make([]ExecutorID, v285)
		for i := 0; i < v285; i++ {
			v286 := NewPopulatedExecutorID(r, easy)
			this.ExecutorIDs[i] = *v286
		}
	}
	if r.Intn(10) != 0 {
		v287 := r.Intn(5)
		this.Attributes = make([]Attribute, v287)
		for i := 0; i < v287; i++ {
			v288 := NewPopulatedAttribute(r, easy)
			this.Attributes[i] = *v288
		}
	}
	if r.Intn(10) != 0 {
		this.URL = NewPopulatedURL(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Unavailability = NewPopulatedUnavailability(r, easy)
	}
	if r.Intn(10) != 0 {
		this.AllocationInfo = NewPopulatedResource_AllocationInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Domain = NewPopulatedDomainInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation(r randyMesos, easy bool) *Offer_Operation {
	this := &Offer_Operation{}
	this.Type = Offer_Operation_Type([]int32{0, 1, 6, 2, 3, 4, 5, 11, 12, 13, 14}[r.Intn(11)])
	if r.Intn(10) != 0 {
		this.Launch = NewPopulatedOffer_Operation_Launch(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Reserve = NewPopulatedOffer_Operation_Reserve(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Unreserve = NewPopulatedOffer_Operation_Unreserve(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Create = NewPopulatedOffer_Operation_Create(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Destroy = NewPopulatedOffer_Operation_Destroy(r, easy)
	}
	if r.Intn(10) != 0 {
		this.LaunchGroup = NewPopulatedOffer_Operation_LaunchGroup(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ID = NewPopulatedOperationID(r, easy)
	}
	if r.Intn(10) != 0 {
		this.GrowVolume = NewPopulatedOffer_Operation_GrowVolume(r, easy)
	}
	if r.Intn(10) != 0 {
		this.ShrinkVolume = NewPopulatedOffer_Operation_ShrinkVolume(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CreateDisk = NewPopulatedOffer_Operation_CreateDisk(r, easy)
	}
	if r.Intn(10) != 0 {
		this.DestroyDisk = NewPopulatedOffer_Operation_DestroyDisk(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_Launch(r randyMesos, easy bool) *Offer_Operation_Launch {
	this := &Offer_Operation_Launch{}
	if r.Intn(10) != 0 {
		v289 := r.Intn(5)
		this.TaskInfos = make([]TaskInfo, v289)
		for i := 0; i < v289; i++ {
			v290 := NewPopulatedTaskInfo(r, easy)
			this.TaskInfos[i] = *v290
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_LaunchGroup(r randyMesos, easy bool) *Offer_Operation_LaunchGroup {
	this := &Offer_Operation_LaunchGroup{}
	v291 := NewPopulatedExecutorInfo(r, easy)
	this.Executor = *v291
	v292 := NewPopulatedTaskGroupInfo(r, easy)
	this.TaskGroup = *v292
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_Reserve(r randyMesos, easy bool) *Offer_Operation_Reserve {
	this := &Offer_Operation_Reserve{}
	if r.Intn(10) != 0 {
		v293 := r.Intn(5)
		this.Resources = make([]Resource, v293)
		for i := 0; i < v293; i++ {
			v294 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v294
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_Unreserve(r randyMesos, easy bool) *Offer_Operation_Unreserve {
	this := &Offer_Operation_Unreserve{}
	if r.Intn(10) != 0 {
		v295 := r.Intn(5)
		this.Resources = make([]Resource, v295)
		for i := 0; i < v295; i++ {
			v296 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v296
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_Create(r randyMesos, easy bool) *Offer_Operation_Create {
	this := &Offer_Operation_Create{}
	if r.Intn(10) != 0 {
		v297 := r.Intn(5)
		this.Volumes = make([]Resource, v297)
		for i := 0; i < v297; i++ {
			v298 := NewPopulatedResource(r, easy)
			this.Volumes[i] = *v298
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_Destroy(r randyMesos, easy bool) *Offer_Operation_Destroy {
	this := &Offer_Operation_Destroy{}
	if r.Intn(10) != 0 {
		v299 := r.Intn(5)
		this.Volumes = make([]Resource, v299)
		for i := 0; i < v299; i++ {
			v300 := NewPopulatedResource(r, easy)
			this.Volumes[i] = *v300
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_GrowVolume(r randyMesos, easy bool) *Offer_Operation_GrowVolume {
	this := &Offer_Operation_GrowVolume{}
	v301 := NewPopulatedResource(r, easy)
	this.Volume = *v301
	v302 := NewPopulatedResource(r, easy)
	this.Addition = *v302
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_ShrinkVolume(r randyMesos, easy bool) *Offer_Operation_ShrinkVolume {
	this := &Offer_Operation_ShrinkVolume{}
	v303 := NewPopulatedResource(r, easy)
	this.Volume = *v303
	v304 := NewPopulatedValue_Scalar(r, easy)
	this.Subtract = *v304
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_CreateDisk(r randyMesos, easy bool) *Offer_Operation_CreateDisk {
	this := &Offer_Operation_CreateDisk{}
	v305 := NewPopulatedResource(r, easy)
	this.Source = *v305
	this.TargetType = Resource_DiskInfo_Source_Type([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOffer_Operation_DestroyDisk(r randyMesos, easy bool) *Offer_Operation_DestroyDisk {
	this := &Offer_Operation_DestroyDisk{}
	v306 := NewPopulatedResource(r, easy)
	this.Source = *v306
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedInverseOffer(r randyMesos, easy bool) *InverseOffer {
	this := &InverseOffer{}
	v307 := NewPopulatedOfferID(r, easy)
	this.OfferID = *v307
	if r.Intn(10) != 0 {
		this.URL = NewPopulatedURL(r, easy)
	}
	v308 := NewPopulatedFrameworkID(r, easy)
	this.FrameworkID = *v308
	if r.Intn(10) != 0 {
		this.AgentID = NewPopulatedAgentID(r, easy)
	}
	v309 := NewPopulatedUnavailability(r, easy)
	this.Unavailability = *v309
	if r.Intn(10) != 0 {
		v310 := r.Intn(5)
		this.Resources = make([]Resource, v310)
		for i := 0; i < v310; i++ {
			v311 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v311
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTaskInfo(r randyMesos, easy bool) *TaskInfo {
	this := &TaskInfo{}
	this.Name = string(randStringMesos(r))
	v312 := NewPopulatedTaskID(r, easy)
	this.TaskID = *v312
	v313 := NewPopulatedAgentID(r, easy)
	this.AgentID = *v313
	if r.Intn(10) != 0 {
		v314 := r.Intn(5)
		this.Resources = make([]Resource, v314)
		for i := 0; i < v314; i++ {
			v315 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v315
		}
	}
	if r.Intn(10) != 0 {
		this.Executor = NewPopulatedExecutorInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v316 := r.Intn(100)
		this.Data = make([]byte, v316)
		for i := 0; i < v316; i++ {
			this.Data[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		this.Command = NewPopulatedCommandInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.HealthCheck = NewPopulatedHealthCheck(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Container = NewPopulatedContainerInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Discovery = NewPopulatedDiscoveryInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.KillPolicy = NewPopulatedKillPolicy(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Check = NewPopulatedCheckInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.MaxCompletionTime = NewPopulatedDurationInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTaskGroupInfo(r randyMesos, easy bool) *TaskGroupInfo {
	this := &TaskGroupInfo{}
	if r.Intn(10) != 0 {
		v317 := r.Intn(5)
		this.Tasks = make([]TaskInfo, v317)
		for i := 0; i < v317; i++ {
			v318 := NewPopulatedTaskInfo(r, easy)
			this.Tasks[i] = *v318
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTask(r randyMesos, easy bool) *Task {
	this := &Task{}
	this.Name = string(randStringMesos(r))
	v319 := NewPopulatedTaskID(r, easy)
	this.TaskID = *v319
	v320 := NewPopulatedFrameworkID(r, easy)
	this.FrameworkID = *v320
	if r.Intn(10) != 0 {
		this.ExecutorID = NewPopulatedExecutorID(r, easy)
	}
	v321 := NewPopulatedAgentID(r, easy)
	this.AgentID = *v321
	v322 := TaskState([]int32{6, 0, 1, 8, 2, 3, 4, 7, 5, 9, 10, 11, 12, 13}[r.Intn(14)])
	this.State = &v322
	if r.Intn(10) != 0 {
		v323 := r.Intn(5)
		this.Resources = make([]Resource, v323)
		for i := 0; i < v323; i++ {
			v324 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v324
		}
	}
	if r.Intn(10) == 0 {
		v325 := r.Intn(5)
		this.Statuses = make([]TaskStatus, v325)
		for i := 0; i < v325; i++ {
			v326 := NewPopulatedTaskStatus(r, easy)
			this.Statuses[i] = *v326
		}
	}
	if r.Intn(10) != 0 {
		v327 := TaskState([]int32{6, 0, 1, 8, 2, 3, 4, 7, 5, 9, 10, 11, 12, 13}[r.Intn(14)])
		this.StatusUpdateState = &v327
	}
	if r.Intn(10) != 0 {
		v328 := r.Intn(100)
		this.StatusUpdateUUID = make([]byte, v328)
		for i := 0; i < v328; i++ {
			this.StatusUpdateUUID[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Discovery = NewPopulatedDiscoveryInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Container = NewPopulatedContainerInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v329 := string(randStringMesos(r))
		this.User = &v329
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTaskResourceLimitation(r randyMesos, easy bool) *TaskResourceLimitation {
	this := &TaskResourceLimitation{}
	if r.Intn(10) != 0 {
		v330 := r.Intn(5)
		this.Resources = make([]Resource, v330)
		for i := 0; i < v330; i++ {
			v331 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v331
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUUID(r randyMesos, easy bool) *UUID {
	this := &UUID{}
	v332 := r.Intn(100)
	this.Value = make([]byte, v332)
	for i := 0; i < v332; i++ {
		this.Value[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOperation(r randyMesos, easy bool) *Operation {
	this := &Operation{}
	if r.Intn(10) != 0 {
		this.FrameworkID = NewPopulatedFrameworkID(r, easy)
	}
	if r.Intn(10) != 0 {
		this.AgentID = NewPopulatedAgentID(r, easy)
	}
	v333 := NewPopulatedOffer_Operation(r, easy)
	this.Info = *v333
	v334 := NewPopulatedOperationStatus(r, easy)
	this.LatestStatus = *v334
	if r.Intn(10) != 0 {
		v335 := r.Intn(5)
		this.Statuses = make([]OperationStatus, v335)
		for i := 0; i < v335; i++ {
			v336 := NewPopulatedOperationStatus(r, easy)
			this.Statuses[i] = *v336
		}
	}
	v337 := NewPopulatedUUID(r, easy)
	this.UUID = *v337
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedOperationStatus(r randyMesos, easy bool) *OperationStatus {
	this := &OperationStatus{}
	if r.Intn(10) != 0 {
		this.OperationID = NewPopulatedOperationID(r, easy)
	}
	this.State = OperationState([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}[r.Intn(10)])
	if r.Intn(10) != 0 {
		v338 := string(randStringMesos(r))
		this.Message = &v338
	}
	if r.Intn(10) != 0 {
		v339 := r.Intn(5)
		this.ConvertedResources = make([]Resource, v339)
		for i := 0; i < v339; i++ {
			v340 := NewPopulatedResource(r, easy)
			this.ConvertedResources[i] = *v340
		}
	}
	if r.Intn(10) != 0 {
		this.UUID = NewPopulatedUUID(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckStatusInfo(r randyMesos, easy bool) *CheckStatusInfo {
	this := &CheckStatusInfo{}
	if r.Intn(10) != 0 {
		v341 := CheckInfo_Type([]int32{0, 1, 2, 3}[r.Intn(4)])
		this.Type = &v341
	}
	if r.Intn(10) != 0 {
		this.Command = NewPopulatedCheckStatusInfo_Command(r, easy)
	}
	if r.Intn(10) != 0 {
		this.HTTP = NewPopulatedCheckStatusInfo_Http(r, easy)
	}
	if r.Intn(10) != 0 {
		this.TCP = NewPopulatedCheckStatusInfo_Tcp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckStatusInfo_Command(r randyMesos, easy bool) *CheckStatusInfo_Command {
	this := &CheckStatusInfo_Command{}
	if r.Intn(10) != 0 {
		v342 := int32(r.Int31())
		if r.Intn(2) == 0 {
			v342 *= -1
		}
		this.ExitCode = &v342
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckStatusInfo_Http(r randyMesos, easy bool) *CheckStatusInfo_Http {
	this := &CheckStatusInfo_Http{}
	if r.Intn(10) != 0 {
		v343 := uint32(r.Uint32())
		this.StatusCode = &v343
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckStatusInfo_Tcp(r randyMesos, easy bool) *CheckStatusInfo_Tcp {
	this := &CheckStatusInfo_Tcp{}
	if r.Intn(10) != 0 {
		v344 := bool(bool(r.Intn(2) == 0))
		this.Succeeded = &v344
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTaskStatus(r randyMesos, easy bool) *TaskStatus {
	this := &TaskStatus{}
	v345 := NewPopulatedTaskID(r, easy)
	this.TaskID = *v345
	v346 := TaskState([]int32{6, 0, 1, 8, 2, 3, 4, 7, 5, 9, 10, 11, 12, 13}[r.Intn(14)])
	this.State = &v346
	if r.Intn(10) != 0 {
		v347 := r.Intn(100)
		this.Data = make([]byte, v347)
		for i := 0; i < v347; i++ {
			this.Data[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		v348 := string(randStringMesos(r))
		this.Message = &v348
	}
	if r.Intn(10) != 0 {
		this.AgentID = NewPopulatedAgentID(r, easy)
	}
	if r.Intn(10) != 0 {
		v349 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v349 *= -1
		}
		this.Timestamp = &v349
	}
	if r.Intn(10) != 0 {
		this.ExecutorID = NewPopulatedExecutorID(r, easy)
	}
	if r.Intn(10) != 0 {
		v350 := bool(bool(r.Intn(2) == 0))
		this.Healthy = &v350
	}
	if r.Intn(10) != 0 {
		v351 := TaskStatus_Source([]int32{0, 1, 2}[r.Intn(3)])
		this.Source = &v351
	}
	if r.Intn(10) != 0 {
		v352 := TaskStatus_Reason([]int32{0, 21, 19, 20, 8, 17, 22, 33, 23, 24, 1, 2, 3, 4, 5, 6, 27, 7, 9, 18, 10, 11, 31, 32, 12, 13, 30, 28, 29, 25, 26, 14, 15, 16}[r.Intn(34)])
		this.Reason = &v352
	}
	if r.Intn(10) != 0 {
		v353 := r.Intn(100)
		this.UUID = make([]byte, v353)
		for i := 0; i < v353; i++ {
			this.UUID[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if r.Intn(10) == 0 {
		this.ContainerStatus = NewPopulatedContainerStatus(r, easy)
	}
	if r.Intn(10) != 0 {
		this.UnreachableTime = NewPopulatedTimeInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CheckStatus = NewPopulatedCheckStatusInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Limitation = NewPopulatedTaskResourceLimitation(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFilters(r randyMesos, easy bool) *Filters {
	this := &Filters{}
	if r.Intn(10) != 0 {
		v354 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v354 *= -1
		}
		this.RefuseSeconds = &v354
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEnvironment(r randyMesos, easy bool) *Environment {
	this := &Environment{}
	if r.Intn(10) != 0 {
		v355 := r.Intn(5)
		this.Variables = make([]Environment_Variable, v355)
		for i := 0; i < v355; i++ {
			v356 := NewPopulatedEnvironment_Variable(r, easy)
			this.Variables[i] = *v356
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEnvironment_Variable(r randyMesos, easy bool) *Environment_Variable {
	this := &Environment_Variable{}
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v357 := string(randStringMesos(r))
		this.Value = &v357
	}
	if r.Intn(10) != 0 {
		v358 := Environment_Variable_Type([]int32{0, 1, 2}[r.Intn(3)])
		this.Type = &v358
	}
	if r.Intn(10) != 0 {
		this.Secret = NewPopulatedSecret(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedParameter(r randyMesos, easy bool) *Parameter {
	this := &Parameter{}
	this.Key = string(randStringMesos(r))
	this.Value = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedParameters(r randyMesos, easy bool) *Parameters {
	this := &Parameters{}
	if r.Intn(10) != 0 {
		v359 := r.Intn(5)
		this.Parameter = make([]Parameter, v359)
		for i := 0; i < v359; i++ {
			v360 := NewPopulatedParameter(r, easy)
			this.Parameter[i] = *v360
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCredential(r randyMesos, easy bool) *Credential {
	this := &Credential{}
	this.Principal = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v361 := string(randStringMesos(r))
		this.Secret = &v361
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCredentials(r randyMesos, easy bool) *Credentials {
	this := &Credentials{}
	if r.Intn(10) != 0 {
		v362 := r.Intn(5)
		this.Credentials = make([]Credential, v362)
		for i := 0; i < v362; i++ {
			v363 := NewPopulatedCredential(r, easy)
			this.Credentials[i] = *v363
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSecret(r randyMesos, easy bool) *Secret {
	this := &Secret{}
	this.Type = Secret_Type([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(10) != 0 {
		this.Reference = NewPopulatedSecret_Reference(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Value = NewPopulatedSecret_Value(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSecret_Reference(r randyMesos, easy bool) *Secret_Reference {
	this := &Secret_Reference{}
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v364 := string(randStringMesos(r))
		this.Key = &v364
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSecret_Value(r randyMesos, easy bool) *Secret_Value {
	this := &Secret_Value{}
	v365 := r.Intn(100)
	this.Data = make([]byte, v365)
	for i := 0; i < v365; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRateLimit(r randyMesos, easy bool) *RateLimit {
	this := &RateLimit{}
	if r.Intn(10) != 0 {
		v366 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v366 *= -1
		}
		this.QPS = &v366
	}
	this.Principal = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v367 := uint64(uint64(r.Uint32()))
		this.Capacity = &v367
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRateLimits(r randyMesos, easy bool) *RateLimits {
	this := &RateLimits{}
	if r.Intn(10) != 0 {
		v368 := r.Intn(5)
		this.Limits = make([]RateLimit, v368)
		for i := 0; i < v368; i++ {
			v369 := NewPopulatedRateLimit(r, easy)
			this.Limits[i] = *v369
		}
	}
	if r.Intn(10) != 0 {
		v370 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v370 *= -1
		}
		this.AggregateDefaultQPS = &v370
	}
	if r.Intn(10) != 0 {
		v371 := uint64(uint64(r.Uint32()))
		this.AggregateDefaultCapacity = &v371
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedImage(r randyMesos, easy bool) *Image {
	this := &Image{}
	v372 := Image_Type([]int32{1, 2}[r.Intn(2)])
	this.Type = &v372
	if r.Intn(10) != 0 {
		this.Appc = NewPopulatedImage_Appc(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Docker = NewPopulatedImage_Docker(r, easy)
	}
	if r.Intn(10) != 0 {
		v373 := bool(bool(r.Intn(2) == 0))
		this.Cached = &v373
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedImage_Appc(r randyMesos, easy bool) *Image_Appc {
	this := &Image_Appc{}
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v374 := string(randStringMesos(r))
		this.ID = &v374
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedImage_Docker(r randyMesos, easy bool) *Image_Docker {
	this := &Image_Docker{}
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		this.Credential = NewPopulatedCredential(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Config = NewPopulatedSecret(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMountPropagation(r randyMesos, easy bool) *MountPropagation {
	this := &MountPropagation{}
	if r.Intn(10) != 0 {
		v375 := MountPropagation_Mode([]int32{0, 1, 2}[r.Intn(3)])
		this.Mode = &v375
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolume(r randyMesos, easy bool) *Volume {
	this := &Volume{}
	this.ContainerPath = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v376 := string(randStringMesos(r))
		this.HostPath = &v376
	}
	v377 := Volume_Mode([]int32{1, 2}[r.Intn(2)])
	this.Mode = &v377
	if r.Intn(10) != 0 {
		this.Image = NewPopulatedImage(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Source = NewPopulatedVolume_Source(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolume_Source(r randyMesos, easy bool) *Volume_Source {
	this := &Volume_Source{}
	this.Type = Volume_Source_Type([]int32{0, 1, 4, 2, 3}[r.Intn(5)])
	if r.Intn(10) != 0 {
		this.DockerVolume = NewPopulatedVolume_Source_DockerVolume(r, easy)
	}
	if r.Intn(10) != 0 {
		this.SandboxPath = NewPopulatedVolume_Source_SandboxPath(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Secret = NewPopulatedSecret(r, easy)
	}
	if r.Intn(10) != 0 {
		this.HostPath = NewPopulatedVolume_Source_HostPath(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolume_Source_DockerVolume(r randyMesos, easy bool) *Volume_Source_DockerVolume {
	this := &Volume_Source_DockerVolume{}
	if r.Intn(10) != 0 {
		v378 := string(randStringMesos(r))
		this.Driver = &v378
	}
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		this.DriverOptions = NewPopulatedParameters(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolume_Source_HostPath(r randyMesos, easy bool) *Volume_Source_HostPath {
	this := &Volume_Source_HostPath{}
	this.Path = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		this.MountPropagation = NewPopulatedMountPropagation(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolume_Source_SandboxPath(r randyMesos, easy bool) *Volume_Source_SandboxPath {
	this := &Volume_Source_SandboxPath{}
	this.Type = Volume_Source_SandboxPath_Type([]int32{0, 1, 2}[r.Intn(3)])
	this.Path = string(randStringMesos(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkInfo(r randyMesos, easy bool) *NetworkInfo {
	this := &NetworkInfo{}
	if r.Intn(10) != 0 {
		v379 := r.Intn(10)
		this.Groups = make([]string, v379)
		for i := 0; i < v379; i++ {
			this.Groups[i] = string(randStringMesos(r))
		}
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if r.Intn(10) != 0 {
		v380 := r.Intn(5)
		this.IPAddresses = make([]NetworkInfo_IPAddress, v380)
		for i := 0; i < v380; i++ {
			v381 := NewPopulatedNetworkInfo_IPAddress(r, easy)
			this.IPAddresses[i] = *v381
		}
	}
	if r.Intn(10) != 0 {
		v382 := string(randStringMesos(r))
		this.Name = &v382
	}
	if r.Intn(10) != 0 {
		v383 := r.Intn(5)
		this.PortMappings = make([]NetworkInfo_PortMapping, v383)
		for i := 0; i < v383; i++ {
			v384 := NewPopulatedNetworkInfo_PortMapping(r, easy)
			this.PortMappings[i] = *v384
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkInfo_IPAddress(r randyMesos, easy bool) *NetworkInfo_IPAddress {
	this := &NetworkInfo_IPAddress{}
	if r.Intn(10) != 0 {
		v385 := NetworkInfo_Protocol([]int32{1, 2}[r.Intn(2)])
		this.Protocol = &v385
	}
	if r.Intn(10) != 0 {
		v386 := string(randStringMesos(r))
		this.IPAddress = &v386
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNetworkInfo_PortMapping(r randyMesos, easy bool) *NetworkInfo_PortMapping {
	this := &NetworkInfo_PortMapping{}
	this.HostPort = uint32(r.Uint32())
	this.ContainerPort = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v387 := string(randStringMesos(r))
		this.Protocol = &v387
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCapabilityInfo(r randyMesos, easy bool) *CapabilityInfo {
	this := &CapabilityInfo{}
	if r.Intn(10) != 0 {
		v388 := r.Intn(10)
		this.Capabilities = make([]CapabilityInfo_Capability, v388)
		for i := 0; i < v388; i++ {
			this.Capabilities[i] = CapabilityInfo_Capability([]int32{0, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037}[r.Intn(39)])
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLinuxInfo(r randyMesos, easy bool) *LinuxInfo {
	this := &LinuxInfo{}
	if r.Intn(10) != 0 {
		this.CapabilityInfo = NewPopulatedCapabilityInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.BoundingCapabilities = NewPopulatedCapabilityInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.EffectiveCapabilities = NewPopulatedCapabilityInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v389 := bool(bool(r.Intn(2) == 0))
		this.SharePIDNamespace = &v389
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRLimitInfo(r randyMesos, easy bool) *RLimitInfo {
	this := &RLimitInfo{}
	if r.Intn(10) != 0 {
		v390 := r.Intn(5)
		this.Rlimits = make([]RLimitInfo_RLimit, v390)
		for i := 0; i < v390; i++ {
			v391 := NewPopulatedRLimitInfo_RLimit(r, easy)
			this.Rlimits[i] = *v391
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRLimitInfo_RLimit(r randyMesos, easy bool) *RLimitInfo_RLimit {
	this := &RLimitInfo_RLimit{}
	this.Type = RLimitInfo_RLimit_Type([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}[r.Intn(17)])
	if r.Intn(10) != 0 {
		v392 := uint64(uint64(r.Uint32()))
		this.Hard = &v392
	}
	if r.Intn(10) != 0 {
		v393 := uint64(uint64(r.Uint32()))
		this.Soft = &v393
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTTYInfo(r randyMesos, easy bool) *TTYInfo {
	this := &TTYInfo{}
	if r.Intn(10) != 0 {
		this.WindowSize = NewPopulatedTTYInfo_WindowSize(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTTYInfo_WindowSize(r randyMesos, easy bool) *TTYInfo_WindowSize {
	this := &TTYInfo_WindowSize{}
	this.Rows = uint32(r.Uint32())
	this.Columns = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainerInfo(r randyMesos, easy bool) *ContainerInfo {
	this := &ContainerInfo{}
	v394 := ContainerInfo_Type([]int32{1, 2}[r.Intn(2)])
	this.Type = &v394
	if r.Intn(10) != 0 {
		v395 := r.Intn(5)
		this.Volumes = make([]Volume, v395)
		for i := 0; i < v395; i++ {
			v396 := NewPopulatedVolume(r, easy)
			this.Volumes[i] = *v396
		}
	}
	if r.Intn(10) != 0 {
		this.Docker = NewPopulatedContainerInfo_DockerInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v397 := string(randStringMesos(r))
		this.Hostname = &v397
	}
	if r.Intn(10) != 0 {
		this.Mesos = NewPopulatedContainerInfo_MesosInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v398 := r.Intn(5)
		this.NetworkInfos = make([]NetworkInfo, v398)
		for i := 0; i < v398; i++ {
			v399 := NewPopulatedNetworkInfo(r, easy)
			this.NetworkInfos[i] = *v399
		}
	}
	if r.Intn(10) != 0 {
		this.LinuxInfo = NewPopulatedLinuxInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.RlimitInfo = NewPopulatedRLimitInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		this.TTYInfo = NewPopulatedTTYInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainerInfo_DockerInfo(r randyMesos, easy bool) *ContainerInfo_DockerInfo {
	this := &ContainerInfo_DockerInfo{}
	this.Image = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v400 := ContainerInfo_DockerInfo_Network([]int32{1, 2, 3, 4}[r.Intn(4)])
		this.Network = &v400
	}
	if r.Intn(10) != 0 {
		v401 := r.Intn(5)
		this.PortMappings = make([]ContainerInfo_DockerInfo_PortMapping, v401)
		for i := 0; i < v401; i++ {
			v402 := NewPopulatedContainerInfo_DockerInfo_PortMapping(r, easy)
			this.PortMappings[i] = *v402
		}
	}
	if r.Intn(10) != 0 {
		v403 := bool(bool(r.Intn(2) == 0))
		this.Privileged = &v403
	}
	if r.Intn(10) != 0 {
		v404 := r.Intn(5)
		this.Parameters = make([]Parameter, v404)
		for i := 0; i < v404; i++ {
			v405 := NewPopulatedParameter(r, easy)
			this.Parameters[i] = *v405
		}
	}
	if r.Intn(10) != 0 {
		v406 := bool(bool(r.Intn(2) == 0))
		this.ForcePullImage = &v406
	}
	if r.Intn(10) != 0 {
		v407 := string(randStringMesos(r))
		this.VolumeDriver = &v407
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainerInfo_DockerInfo_PortMapping(r randyMesos, easy bool) *ContainerInfo_DockerInfo_PortMapping {
	this := &ContainerInfo_DockerInfo_PortMapping{}
	this.HostPort = uint32(r.Uint32())
	this.ContainerPort = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v408 := string(randStringMesos(r))
		this.Protocol = &v408
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainerInfo_MesosInfo(r randyMesos, easy bool) *ContainerInfo_MesosInfo {
	this := &ContainerInfo_MesosInfo{}
	if r.Intn(10) != 0 {
		this.Image = NewPopulatedImage(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainerStatus(r randyMesos, easy bool) *ContainerStatus {
	this := &ContainerStatus{}
	if r.Intn(10) != 0 {
		v409 := r.Intn(5)
		this.NetworkInfos = make([]NetworkInfo, v409)
		for i := 0; i < v409; i++ {
			v410 := NewPopulatedNetworkInfo(r, easy)
			this.NetworkInfos[i] = *v410
		}
	}
	if r.Intn(10) != 0 {
		this.CgroupInfo = NewPopulatedCgroupInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v411 := uint32(r.Uint32())
		this.ExecutorPID = &v411
	}
	if r.Intn(10) == 0 {
		this.ContainerID = NewPopulatedContainerID(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo(r randyMesos, easy bool) *CgroupInfo {
	this := &CgroupInfo{}
	if r.Intn(10) != 0 {
		this.NetCLS = NewPopulatedCgroupInfo_NetCls(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo_Blkio(r randyMesos, easy bool) *CgroupInfo_Blkio {
	this := &CgroupInfo_Blkio{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo_Blkio_Value(r randyMesos, easy bool) *CgroupInfo_Blkio_Value {
	this := &CgroupInfo_Blkio_Value{}
	if r.Intn(10) != 0 {
		v412 := CgroupInfo_Blkio_Operation([]int32{0, 1, 2, 3, 4, 5}[r.Intn(6)])
		this.Op = &v412
	}
	if r.Intn(10) != 0 {
		v413 := uint64(uint64(r.Uint32()))
		this.Value = &v413
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo_Blkio_CFQ(r randyMesos, easy bool) *CgroupInfo_Blkio_CFQ {
	this := &CgroupInfo_Blkio_CFQ{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo_Blkio_CFQ_Statistics(r randyMesos, easy bool) *CgroupInfo_Blkio_CFQ_Statistics {
	this := &CgroupInfo_Blkio_CFQ_Statistics{}
	if r.Intn(10) != 0 {
		this.Device = NewPopulatedDevice_Number(r, easy)
	}
	if r.Intn(10) != 0 {
		v414 := uint64(uint64(r.Uint32()))
		this.Sectors = &v414
	}
	if r.Intn(10) != 0 {
		v415 := uint64(uint64(r.Uint32()))
		this.Time = &v415
	}
	if r.Intn(10) != 0 {
		v416 := r.Intn(5)
		this.IOServiced = make([]CgroupInfo_Blkio_Value, v416)
		for i := 0; i < v416; i++ {
			v417 := NewPopulatedCgroupInfo_Blkio_Value(r, easy)
			this.IOServiced[i] = *v417
		}
	}
	if r.Intn(10) != 0 {
		v418 := r.Intn(5)
		this.IOServiceBytes = make([]CgroupInfo_Blkio_Value, v418)
		for i := 0; i < v418; i++ {
			v419 := NewPopulatedCgroupInfo_Blkio_Value(r, easy)
			this.IOServiceBytes[i] = *v419
		}
	}
	if r.Intn(10) != 0 {
		v420 := r.Intn(5)
		this.IOServiceTime = make([]CgroupInfo_Blkio_Value, v420)
		for i := 0; i < v420; i++ {
			v421 := NewPopulatedCgroupInfo_Blkio_Value(r, easy)
			this.IOServiceTime[i] = *v421
		}
	}
	if r.Intn(10) != 0 {
		v422 := r.Intn(5)
		this.IOWaitTime = make([]CgroupInfo_Blkio_Value, v422)
		for i := 0; i < v422; i++ {
			v423 := NewPopulatedCgroupInfo_Blkio_Value(r, easy)
			this.IOWaitTime[i] = *v423
		}
	}
	if r.Intn(10) != 0 {
		v424 := r.Intn(5)
		this.IOMerged = make([]CgroupInfo_Blkio_Value, v424)
		for i := 0; i < v424; i++ {
			v425 := NewPopulatedCgroupInfo_Blkio_Value(r, easy)
			this.IOMerged[i] = *v425
		}
	}
	if r.Intn(10) != 0 {
		v426 := r.Intn(5)
		this.IOQueued = make([]CgroupInfo_Blkio_Value, v426)
		for i := 0; i < v426; i++ {
			v427 := NewPopulatedCgroupInfo_Blkio_Value(r, easy)
			this.IOQueued[i] = *v427
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo_Blkio_Throttling(r randyMesos, easy bool) *CgroupInfo_Blkio_Throttling {
	this := &CgroupInfo_Blkio_Throttling{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo_Blkio_Throttling_Statistics(r randyMesos, easy bool) *CgroupInfo_Blkio_Throttling_Statistics {
	this := &CgroupInfo_Blkio_Throttling_Statistics{}
	if r.Intn(10) != 0 {
		this.Device = NewPopulatedDevice_Number(r, easy)
	}
	if r.Intn(10) != 0 {
		v428 := r.Intn(5)
		this.IOServiced = make([]CgroupInfo_Blkio_Value, v428)
		for i := 0; i < v428; i++ {
			v429 := NewPopulatedCgroupInfo_Blkio_Value(r, easy)
			this.IOServiced[i] = *v429
		}
	}
	if r.Intn(10) != 0 {
		v430 := r.Intn(5)
		this.IOServiceBytes = make([]CgroupInfo_Blkio_Value, v430)
		for i := 0; i < v430; i++ {
			v431 := NewPopulatedCgroupInfo_Blkio_Value(r, easy)
			this.IOServiceBytes[i] = *v431
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo_Blkio_Statistics(r randyMesos, easy bool) *CgroupInfo_Blkio_Statistics {
	this := &CgroupInfo_Blkio_Statistics{}
	if r.Intn(10) != 0 {
		v432 := r.Intn(5)
		this.CFQ = make([]CgroupInfo_Blkio_CFQ_Statistics, v432)
		for i := 0; i < v432; i++ {
			v433 := NewPopulatedCgroupInfo_Blkio_CFQ_Statistics(r, easy)
			this.CFQ[i] = *v433
		}
	}
	if r.Intn(10) != 0 {
		v434 := r.Intn(5)
		this.CFQRecursive = make([]CgroupInfo_Blkio_CFQ_Statistics, v434)
		for i := 0; i < v434; i++ {
			v435 := NewPopulatedCgroupInfo_Blkio_CFQ_Statistics(r, easy)
			this.CFQRecursive[i] = *v435
		}
	}
	if r.Intn(10) != 0 {
		v436 := r.Intn(5)
		this.Throttling = make([]*CgroupInfo_Blkio_Throttling_Statistics, v436)
		for i := 0; i < v436; i++ {
			this.Throttling[i] = NewPopulatedCgroupInfo_Blkio_Throttling_Statistics(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCgroupInfo_NetCls(r randyMesos, easy bool) *CgroupInfo_NetCls {
	this := &CgroupInfo_NetCls{}
	if r.Intn(10) != 0 {
		v437 := uint32(r.Uint32())
		this.ClassID = &v437
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLabels(r randyMesos, easy bool) *Labels {
	this := &Labels{}
	if r.Intn(10) != 0 {
		v438 := r.Intn(5)
		this.Labels = make([]Label, v438)
		for i := 0; i < v438; i++ {
			v439 := NewPopulatedLabel(r, easy)
			this.Labels[i] = *v439
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLabel(r randyMesos, easy bool) *Label {
	this := &Label{}
	this.Key = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v440 := string(randStringMesos(r))
		this.Value = &v440
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPort(r randyMesos, easy bool) *Port {
	this := &Port{}
	this.Number = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v441 := string(randStringMesos(r))
		this.Name = &v441
	}
	if r.Intn(10) != 0 {
		v442 := string(randStringMesos(r))
		this.Protocol = &v442
	}
	if r.Intn(10) != 0 {
		v443 := DiscoveryInfo_Visibility([]int32{0, 1, 2}[r.Intn(3)])
		this.Visibility = &v443
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPorts(r randyMesos, easy bool) *Ports {
	this := &Ports{}
	if r.Intn(10) != 0 {
		v444 := r.Intn(5)
		this.Ports = make([]Port, v444)
		for i := 0; i < v444; i++ {
			v445 := NewPopulatedPort(r, easy)
			this.Ports[i] = *v445
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDiscoveryInfo(r randyMesos, easy bool) *DiscoveryInfo {
	this := &DiscoveryInfo{}
	this.Visibility = DiscoveryInfo_Visibility([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(10) != 0 {
		v446 := string(randStringMesos(r))
		this.Name = &v446
	}
	if r.Intn(10) != 0 {
		v447 := string(randStringMesos(r))
		this.Environment = &v447
	}
	if r.Intn(10) != 0 {
		v448 := string(randStringMesos(r))
		this.Location = &v448
	}
	if r.Intn(10) != 0 {
		v449 := string(randStringMesos(r))
		this.Version = &v449
	}
	if r.Intn(10) != 0 {
		this.Ports = NewPopulatedPorts(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Labels = NewPopulatedLabels(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedWeightInfo(r randyMesos, easy bool) *WeightInfo {
	this := &WeightInfo{}
	this.Weight = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Weight *= -1
	}
	if r.Intn(10) != 0 {
		v450 := string(randStringMesos(r))
		this.Role = &v450
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVersionInfo(r randyMesos, easy bool) *VersionInfo {
	this := &VersionInfo{}
	this.Version = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v451 := string(randStringMesos(r))
		this.BuildDate = &v451
	}
	if r.Intn(10) != 0 {
		v452 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v452 *= -1
		}
		this.BuildTime = &v452
	}
	if r.Intn(10) != 0 {
		v453 := string(randStringMesos(r))
		this.BuildUser = &v453
	}
	if r.Intn(10) != 0 {
		v454 := string(randStringMesos(r))
		this.GitSHA = &v454
	}
	if r.Intn(10) != 0 {
		v455 := string(randStringMesos(r))
		this.GitBranch = &v455
	}
	if r.Intn(10) != 0 {
		v456 := string(randStringMesos(r))
		this.GitTag = &v456
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFlag(r randyMesos, easy bool) *Flag {
	this := &Flag{}
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v457 := string(randStringMesos(r))
		this.Value = &v457
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRole(r randyMesos, easy bool) *Role {
	this := &Role{}
	this.Name = string(randStringMesos(r))
	this.Weight = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Weight *= -1
	}
	if r.Intn(10) != 0 {
		v458 := r.Intn(5)
		this.Frameworks = make([]FrameworkID, v458)
		for i := 0; i < v458; i++ {
			v459 := NewPopulatedFrameworkID(r, easy)
			this.Frameworks[i] = *v459
		}
	}
	if r.Intn(10) != 0 {
		v460 := r.Intn(5)
		this.Resources = make([]Resource, v460)
		for i := 0; i < v460; i++ {
			v461 := NewPopulatedResource(r, easy)
			this.Resources[i] = *v461
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMetric(r randyMesos, easy bool) *Metric {
	this := &Metric{}
	this.Name = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v462 := float64(r.Float64())
		if r.Intn(2) == 0 {
			v462 *= -1
		}
		this.Value = &v462
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFileInfo(r randyMesos, easy bool) *FileInfo {
	this := &FileInfo{}
	this.Path = string(randStringMesos(r))
	if r.Intn(10) != 0 {
		v463 := int32(r.Int31())
		if r.Intn(2) == 0 {
			v463 *= -1
		}
		this.Nlink = &v463
	}
	if r.Intn(10) != 0 {
		v464 := uint64(uint64(r.Uint32()))
		this.Size = &v464
	}
	if r.Intn(10) != 0 {
		this.Mtime = NewPopulatedTimeInfo(r, easy)
	}
	if r.Intn(10) != 0 {
		v465 := uint32(r.Uint32())
		this.Mode = &v465
	}
	if r.Intn(10) != 0 {
		v466 := string(randStringMesos(r))
		this.UID = &v466
	}
	if r.Intn(10) != 0 {
		v467 := string(randStringMesos(r))
		this.GID = &v467
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDevice(r randyMesos, easy bool) *Device {
	this := &Device{}
	if r.Intn(10) != 0 {
		v468 := string(randStringMesos(r))
		this.Path = &v468
	}
	if r.Intn(10) != 0 {
		this.Number = NewPopulatedDevice_Number(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDevice_Number(r randyMesos, easy bool) *Device_Number {
	this := &Device_Number{}
	v469 := uint64(uint64(r.Uint32()))
	this.MajorNumber = &v469
	v470 := uint64(uint64(r.Uint32()))
	this.MinorNumber = &v470
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeviceAccess(r randyMesos, easy bool) *DeviceAccess {
	this := &DeviceAccess{}
	v471 := NewPopulatedDevice(r, easy)
	this.Device = *v471
	v472 := NewPopulatedDeviceAccess_Access(r, easy)
	this.Access = *v472
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeviceAccess_Access(r randyMesos, easy bool) *DeviceAccess_Access {
	this := &DeviceAccess_Access{}
	if r.Intn(10) != 0 {
		v473 := bool(bool(r.Intn(2) == 0))
		this.Read = &v473
	}
	if r.Intn(10) != 0 {
		v474 := bool(bool(r.Intn(2) == 0))
		this.Write = &v474
	}
	if r.Intn(10) != 0 {
		v475 := bool(bool(r.Intn(2) == 0))
		this.Mknod = &v475
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedDeviceWhitelist(r randyMesos, easy bool) *DeviceWhitelist {
	this := &DeviceWhitelist{}
	if r.Intn(10) != 0 {
		v476 := r.Intn(5)
		this.AllowedDevices = make([]DeviceAccess, v476)
		for i := 0; i < v476; i++ {
			v477 := NewPopulatedDeviceAccess(r, easy)
			this.AllowedDevices[i] = *v477
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyMesos interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneMesos(r randyMesos) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringMesos(r randyMesos) string {
	v478 := r.Intn(100)
	tmps := make([]rune, v478)
	for i := 0; i < v478; i++ {
		tmps[i] = randUTF8RuneMesos(r)
	}
	return string(tmps)
}
func randUnrecognizedMesos(r randyMesos, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldMesos(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldMesos(dAtA []byte, r randyMesos, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateMesos(dAtA, uint64(key))
		v479 := r.Int63()
		if r.Intn(2) == 0 {
			v479 *= -1
		}
		dAtA = encodeVarintPopulateMesos(dAtA, uint64(v479))
	case 1:
		dAtA = encodeVarintPopulateMesos(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateMesos(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateMesos(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateMesos(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateMesos(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *FrameworkID) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *OfferID) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *AgentID) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *TaskID) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *ExecutorID) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *ContainerID) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	if m.Parent != nil {
		l = m.Parent.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *ResourceProviderID) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *OperationID) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *TimeInfo) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Nanoseconds))
	return n
}

func (m *DurationInfo) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Nanoseconds))
	return n
}

func (m *Address) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.IP != nil {
		l = len(*m.IP)
		n += 1 + l + sovMesos(uint64(l))
	}
	n += 1 + sovMesos(uint64(m.Port))
	return n
}

func (m *URL) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Scheme)
	n += 1 + l + sovMesos(uint64(l))
	l = m.Address.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Query) > 0 {
		for _, e := range m.Query {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Fragment != nil {
		l = len(*m.Fragment)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Unavailability) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Start.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.Duration != nil {
		l = m.Duration.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *MachineID) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.IP != nil {
		l = len(*m.IP)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *MachineInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.ID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.Mode != nil {
		n += 1 + sovMesos(uint64(*m.Mode))
	}
	if m.Unavailability != nil {
		l = m.Unavailability.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *FrameworkInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.User)
	n += 1 + l + sovMesos(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.ID != nil {
		l = m.ID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.FailoverTimeout != nil {
		n += 9
	}
	if m.Checkpoint != nil {
		n += 2
	}
	if m.Role != nil {
		l = len(*m.Role)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Principal != nil {
		l = len(*m.Principal)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.WebUiURL != nil {
		l = len(*m.WebUiURL)
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Capabilities) > 0 {
		for _, e := range m.Capabilities {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *FrameworkInfo_Capability) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	return n
}

func (m *CheckInfo) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	if m.Command != nil {
		l = m.Command.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.HTTP != nil {
		l = m.HTTP.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.DelaySeconds != nil {
		n += 9
	}
	if m.IntervalSeconds != nil {
		n += 9
	}
	if m.TimeoutSeconds != nil {
		n += 9
	}
	if m.TCP != nil {
		l = m.TCP.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CheckInfo_Command) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Command.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *CheckInfo_Http) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Port))
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CheckInfo_Tcp) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Port))
	return n
}

func (m *HealthCheck) ProtoSize() (n int) {
	var l int
	_ = l
	if m.HTTP != nil {
		l = m.HTTP.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.DelaySeconds != nil {
		n += 9
	}
	if m.IntervalSeconds != nil {
		n += 9
	}
	if m.TimeoutSeconds != nil {
		n += 9
	}
	if m.ConsecutiveFailures != nil {
		n += 1 + sovMesos(uint64(*m.ConsecutiveFailures))
	}
	if m.GracePeriodSeconds != nil {
		n += 9
	}
	if m.Command != nil {
		l = m.Command.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	n += 1 + sovMesos(uint64(m.Type))
	if m.TCP != nil {
		l = m.TCP.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *HealthCheck_HTTPCheckInfo) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Port))
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Scheme != nil {
		l = len(*m.Scheme)
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Statuses) > 0 {
		for _, e := range m.Statuses {
			n += 1 + sovMesos(uint64(e))
		}
	}
	if m.Protocol != nil {
		n += 1 + sovMesos(uint64(*m.Protocol))
	}
	return n
}

func (m *HealthCheck_TCPCheckInfo) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Port))
	if m.Protocol != nil {
		n += 1 + sovMesos(uint64(*m.Protocol))
	}
	return n
}

func (m *KillPolicy) ProtoSize() (n int) {
	var l int
	_ = l
	if m.GracePeriod != nil {
		l = m.GracePeriod.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CommandInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.URIs) > 0 {
		for _, e := range m.URIs {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Environment != nil {
		l = m.Environment.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.User != nil {
		l = len(*m.User)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Shell != nil {
		n += 2
	}
	if len(m.Arguments) > 0 {
		for _, s := range m.Arguments {
			l = len(s)
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *CommandInfo_URI) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	if m.Executable != nil {
		n += 2
	}
	if m.Extract != nil {
		n += 2
	}
	if m.Cache != nil {
		n += 2
	}
	if m.OutputFile != nil {
		l = len(*m.OutputFile)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *ExecutorInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.ExecutorID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Command != nil {
		l = m.Command.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.FrameworkID != nil {
		l = m.FrameworkID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Source != nil {
		l = len(*m.Source)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Container != nil {
		l = m.Container.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Discovery != nil {
		l = m.Discovery.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.ShutdownGracePeriod != nil {
		l = m.ShutdownGracePeriod.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	n += 1 + sovMesos(uint64(m.Type))
	return n
}

func (m *DomainInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.FaultDomain != nil {
		l = m.FaultDomain.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *DomainInfo_FaultDomain) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Region.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.Zone.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *DomainInfo_FaultDomain_RegionInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *DomainInfo_FaultDomain_ZoneInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *MasterInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	n += 1 + l + sovMesos(uint64(l))
	n += 1 + sovMesos(uint64(m.IP))
	if m.Port != nil {
		n += 1 + sovMesos(uint64(*m.Port))
	}
	if m.PID != nil {
		l = len(*m.PID)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Domain != nil {
		l = m.Domain.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Capabilities) > 0 {
		for _, e := range m.Capabilities {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *MasterInfo_Capability) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	return n
}

func (m *AgentInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.ID != nil {
		l = m.ID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Port != nil {
		n += 1 + sovMesos(uint64(*m.Port))
	}
	if m.Domain != nil {
		l = m.Domain.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *AgentInfo_Capability) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	return n
}

func (m *CSIPluginContainerInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			n += 1 + sovMesos(uint64(e))
		}
	}
	if m.Command != nil {
		l = m.Command.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Container != nil {
		l = m.Container.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CSIPluginInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovMesos(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *ResourceProviderInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	l = len(m.Type)
	n += 1 + l + sovMesos(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if len(m.DefaultReservations) > 0 {
		for _, e := range m.DefaultReservations {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Storage != nil {
		l = m.Storage.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *ResourceProviderInfo_Storage) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Plugin.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *Value) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	if m.Scalar != nil {
		l = m.Scalar.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Ranges != nil {
		l = m.Ranges.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Set != nil {
		l = m.Set.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Text != nil {
		l = m.Text.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Value_Scalar) ProtoSize() (n int) {
	var l int
	_ = l
	n += 9
	return n
}

func (m *Value_Range) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Begin))
	n += 1 + sovMesos(uint64(m.End))
	return n
}

func (m *Value_Ranges) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Range) > 0 {
		for _, e := range m.Range {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Value_Set) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, s := range m.Item {
			l = len(s)
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Value_Text) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *Attribute) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	n += 1 + sovMesos(uint64(m.Type))
	if m.Scalar != nil {
		l = m.Scalar.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Ranges != nil {
		l = m.Ranges.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Text != nil {
		l = m.Text.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Set != nil {
		l = m.Set.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Resource) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.Type != nil {
		n += 1 + sovMesos(uint64(*m.Type))
	}
	if m.Scalar != nil {
		l = m.Scalar.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Ranges != nil {
		l = m.Ranges.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Set != nil {
		l = m.Set.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Role != nil {
		l = len(*m.Role)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Disk != nil {
		l = m.Disk.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Reservation != nil {
		l = m.Reservation.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Revocable != nil {
		l = m.Revocable.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Shared != nil {
		l = m.Shared.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.AllocationInfo != nil {
		l = m.AllocationInfo.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.ProviderID != nil {
		l = m.ProviderID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Reservations) > 0 {
		for _, e := range m.Reservations {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Resource_AllocationInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Role != nil {
		l = len(*m.Role)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Resource_ReservationInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Principal != nil {
		l = len(*m.Principal)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Role != nil {
		l = len(*m.Role)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovMesos(uint64(*m.Type))
	}
	return n
}

func (m *Resource_DiskInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Persistence != nil {
		l = m.Persistence.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Volume != nil {
		l = m.Volume.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Resource_DiskInfo_Persistence) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	n += 1 + l + sovMesos(uint64(l))
	if m.Principal != nil {
		l = len(*m.Principal)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Resource_DiskInfo_Source) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	if m.Path != nil {
		l = m.Path.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Mount != nil {
		l = m.Mount.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.ID != nil {
		l = len(*m.ID)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Profile != nil {
		l = len(*m.Profile)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Resource_DiskInfo_Source_Path) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Root != nil {
		l = len(*m.Root)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Resource_DiskInfo_Source_Mount) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Root != nil {
		l = len(*m.Root)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Resource_RevocableInfo) ProtoSize() (n int) {
	var l int
	_ = l
	return n
}

func (m *Resource_SharedInfo) ProtoSize() (n int) {
	var l int
	_ = l
	return n
}

func (m *TrafficControlStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	n += 1 + l + sovMesos(uint64(l))
	if m.Backlog != nil {
		n += 1 + sovMesos(uint64(*m.Backlog))
	}
	if m.Bytes != nil {
		n += 1 + sovMesos(uint64(*m.Bytes))
	}
	if m.Drops != nil {
		n += 1 + sovMesos(uint64(*m.Drops))
	}
	if m.Overlimits != nil {
		n += 1 + sovMesos(uint64(*m.Overlimits))
	}
	if m.Packets != nil {
		n += 1 + sovMesos(uint64(*m.Packets))
	}
	if m.Qlen != nil {
		n += 1 + sovMesos(uint64(*m.Qlen))
	}
	if m.RateBPS != nil {
		n += 1 + sovMesos(uint64(*m.RateBPS))
	}
	if m.RatePPS != nil {
		n += 1 + sovMesos(uint64(*m.RatePPS))
	}
	if m.Requeues != nil {
		n += 1 + sovMesos(uint64(*m.Requeues))
	}
	return n
}

func (m *IpStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Forwarding != nil {
		n += 1 + sovMesos(uint64(*m.Forwarding))
	}
	if m.DefaultTTL != nil {
		n += 1 + sovMesos(uint64(*m.DefaultTTL))
	}
	if m.InReceives != nil {
		n += 1 + sovMesos(uint64(*m.InReceives))
	}
	if m.InHdrErrors != nil {
		n += 1 + sovMesos(uint64(*m.InHdrErrors))
	}
	if m.InAddrErrors != nil {
		n += 1 + sovMesos(uint64(*m.InAddrErrors))
	}
	if m.ForwDatagrams != nil {
		n += 1 + sovMesos(uint64(*m.ForwDatagrams))
	}
	if m.InUnknownProtos != nil {
		n += 1 + sovMesos(uint64(*m.InUnknownProtos))
	}
	if m.InDiscards != nil {
		n += 1 + sovMesos(uint64(*m.InDiscards))
	}
	if m.InDelivers != nil {
		n += 1 + sovMesos(uint64(*m.InDelivers))
	}
	if m.OutRequests != nil {
		n += 1 + sovMesos(uint64(*m.OutRequests))
	}
	if m.OutDiscards != nil {
		n += 1 + sovMesos(uint64(*m.OutDiscards))
	}
	if m.OutNoRoutes != nil {
		n += 1 + sovMesos(uint64(*m.OutNoRoutes))
	}
	if m.ReasmTimeout != nil {
		n += 1 + sovMesos(uint64(*m.ReasmTimeout))
	}
	if m.ReasmReqds != nil {
		n += 1 + sovMesos(uint64(*m.ReasmReqds))
	}
	if m.ReasmOKs != nil {
		n += 1 + sovMesos(uint64(*m.ReasmOKs))
	}
	if m.ReasmFails != nil {
		n += 2 + sovMesos(uint64(*m.ReasmFails))
	}
	if m.FragOKs != nil {
		n += 2 + sovMesos(uint64(*m.FragOKs))
	}
	if m.FragFails != nil {
		n += 2 + sovMesos(uint64(*m.FragFails))
	}
	if m.FragCreates != nil {
		n += 2 + sovMesos(uint64(*m.FragCreates))
	}
	return n
}

func (m *IcmpStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	if m.InMsgs != nil {
		n += 1 + sovMesos(uint64(*m.InMsgs))
	}
	if m.InErrors != nil {
		n += 1 + sovMesos(uint64(*m.InErrors))
	}
	if m.InCsumErrors != nil {
		n += 1 + sovMesos(uint64(*m.InCsumErrors))
	}
	if m.InDestUnreachs != nil {
		n += 1 + sovMesos(uint64(*m.InDestUnreachs))
	}
	if m.InTimeExcds != nil {
		n += 1 + sovMesos(uint64(*m.InTimeExcds))
	}
	if m.InParmProbs != nil {
		n += 1 + sovMesos(uint64(*m.InParmProbs))
	}
	if m.InSrcQuenchs != nil {
		n += 1 + sovMesos(uint64(*m.InSrcQuenchs))
	}
	if m.InRedirects != nil {
		n += 1 + sovMesos(uint64(*m.InRedirects))
	}
	if m.InEchos != nil {
		n += 1 + sovMesos(uint64(*m.InEchos))
	}
	if m.InEchoReps != nil {
		n += 1 + sovMesos(uint64(*m.InEchoReps))
	}
	if m.InTimestamps != nil {
		n += 1 + sovMesos(uint64(*m.InTimestamps))
	}
	if m.InTimestampReps != nil {
		n += 1 + sovMesos(uint64(*m.InTimestampReps))
	}
	if m.InAddrMasks != nil {
		n += 1 + sovMesos(uint64(*m.InAddrMasks))
	}
	if m.InAddrMaskReps != nil {
		n += 1 + sovMesos(uint64(*m.InAddrMaskReps))
	}
	if m.OutMsgs != nil {
		n += 1 + sovMesos(uint64(*m.OutMsgs))
	}
	if m.OutErrors != nil {
		n += 2 + sovMesos(uint64(*m.OutErrors))
	}
	if m.OutDestUnreachs != nil {
		n += 2 + sovMesos(uint64(*m.OutDestUnreachs))
	}
	if m.OutTimeExcds != nil {
		n += 2 + sovMesos(uint64(*m.OutTimeExcds))
	}
	if m.OutParmProbs != nil {
		n += 2 + sovMesos(uint64(*m.OutParmProbs))
	}
	if m.OutSrcQuenchs != nil {
		n += 2 + sovMesos(uint64(*m.OutSrcQuenchs))
	}
	if m.OutRedirects != nil {
		n += 2 + sovMesos(uint64(*m.OutRedirects))
	}
	if m.OutEchos != nil {
		n += 2 + sovMesos(uint64(*m.OutEchos))
	}
	if m.OutEchoReps != nil {
		n += 2 + sovMesos(uint64(*m.OutEchoReps))
	}
	if m.OutTimestamps != nil {
		n += 2 + sovMesos(uint64(*m.OutTimestamps))
	}
	if m.OutTimestampReps != nil {
		n += 2 + sovMesos(uint64(*m.OutTimestampReps))
	}
	if m.OutAddrMasks != nil {
		n += 2 + sovMesos(uint64(*m.OutAddrMasks))
	}
	if m.OutAddrMaskReps != nil {
		n += 2 + sovMesos(uint64(*m.OutAddrMaskReps))
	}
	return n
}

func (m *TcpStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	if m.RtoAlgorithm != nil {
		n += 1 + sovMesos(uint64(*m.RtoAlgorithm))
	}
	if m.RtoMin != nil {
		n += 1 + sovMesos(uint64(*m.RtoMin))
	}
	if m.RtoMax != nil {
		n += 1 + sovMesos(uint64(*m.RtoMax))
	}
	if m.MaxConn != nil {
		n += 1 + sovMesos(uint64(*m.MaxConn))
	}
	if m.ActiveOpens != nil {
		n += 1 + sovMesos(uint64(*m.ActiveOpens))
	}
	if m.PassiveOpens != nil {
		n += 1 + sovMesos(uint64(*m.PassiveOpens))
	}
	if m.AttemptFails != nil {
		n += 1 + sovMesos(uint64(*m.AttemptFails))
	}
	if m.EstabResets != nil {
		n += 1 + sovMesos(uint64(*m.EstabResets))
	}
	if m.CurrEstab != nil {
		n += 1 + sovMesos(uint64(*m.CurrEstab))
	}
	if m.InSegs != nil {
		n += 1 + sovMesos(uint64(*m.InSegs))
	}
	if m.OutSegs != nil {
		n += 1 + sovMesos(uint64(*m.OutSegs))
	}
	if m.RetransSegs != nil {
		n += 1 + sovMesos(uint64(*m.RetransSegs))
	}
	if m.InErrs != nil {
		n += 1 + sovMesos(uint64(*m.InErrs))
	}
	if m.OutRsts != nil {
		n += 1 + sovMesos(uint64(*m.OutRsts))
	}
	if m.InCsumErrors != nil {
		n += 1 + sovMesos(uint64(*m.InCsumErrors))
	}
	return n
}

func (m *UdpStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	if m.InDatagrams != nil {
		n += 1 + sovMesos(uint64(*m.InDatagrams))
	}
	if m.NoPorts != nil {
		n += 1 + sovMesos(uint64(*m.NoPorts))
	}
	if m.InErrors != nil {
		n += 1 + sovMesos(uint64(*m.InErrors))
	}
	if m.OutDatagrams != nil {
		n += 1 + sovMesos(uint64(*m.OutDatagrams))
	}
	if m.RcvbufErrors != nil {
		n += 1 + sovMesos(uint64(*m.RcvbufErrors))
	}
	if m.SndbufErrors != nil {
		n += 1 + sovMesos(uint64(*m.SndbufErrors))
	}
	if m.InCsumErrors != nil {
		n += 1 + sovMesos(uint64(*m.InCsumErrors))
	}
	if m.IgnoredMulti != nil {
		n += 1 + sovMesos(uint64(*m.IgnoredMulti))
	}
	return n
}

func (m *SNMPStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	if m.IPStats != nil {
		l = m.IPStats.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.ICMPStats != nil {
		l = m.ICMPStats.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.TCPStats != nil {
		l = m.TCPStats.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.UDPStats != nil {
		l = m.UDPStats.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *DiskStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Persistence != nil {
		l = m.Persistence.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.LimitBytes != nil {
		n += 1 + sovMesos(uint64(*m.LimitBytes))
	}
	if m.UsedBytes != nil {
		n += 1 + sovMesos(uint64(*m.UsedBytes))
	}
	return n
}

func (m *ResourceStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	n += 9
	if m.CPUsUserTimeSecs != nil {
		n += 9
	}
	if m.CPUsSystemTimeSecs != nil {
		n += 9
	}
	if m.CPUsLimit != nil {
		n += 9
	}
	if m.MemRSSBytes != nil {
		n += 1 + sovMesos(uint64(*m.MemRSSBytes))
	}
	if m.MemLimitBytes != nil {
		n += 1 + sovMesos(uint64(*m.MemLimitBytes))
	}
	if m.CPUsNrPeriods != nil {
		n += 1 + sovMesos(uint64(*m.CPUsNrPeriods))
	}
	if m.CPUsNrThrottled != nil {
		n += 1 + sovMesos(uint64(*m.CPUsNrThrottled))
	}
	if m.CPUsThrottledTimeSecs != nil {
		n += 9
	}
	if m.MemFileBytes != nil {
		n += 1 + sovMesos(uint64(*m.MemFileBytes))
	}
	if m.MemAnonBytes != nil {
		n += 1 + sovMesos(uint64(*m.MemAnonBytes))
	}
	if m.MemMappedFileBytes != nil {
		n += 1 + sovMesos(uint64(*m.MemMappedFileBytes))
	}
	if m.Perf != nil {
		l = m.Perf.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.NetRxPackets != nil {
		n += 1 + sovMesos(uint64(*m.NetRxPackets))
	}
	if m.NetRxBytes != nil {
		n += 1 + sovMesos(uint64(*m.NetRxBytes))
	}
	if m.NetRxErrors != nil {
		n += 2 + sovMesos(uint64(*m.NetRxErrors))
	}
	if m.NetRxDropped != nil {
		n += 2 + sovMesos(uint64(*m.NetRxDropped))
	}
	if m.NetTxPackets != nil {
		n += 2 + sovMesos(uint64(*m.NetTxPackets))
	}
	if m.NetTxBytes != nil {
		n += 2 + sovMesos(uint64(*m.NetTxBytes))
	}
	if m.NetTxErrors != nil {
		n += 2 + sovMesos(uint64(*m.NetTxErrors))
	}
	if m.NetTxDropped != nil {
		n += 2 + sovMesos(uint64(*m.NetTxDropped))
	}
	if m.NetTCPRttMicrosecsP50 != nil {
		n += 10
	}
	if m.NetTCPRttMicrosecsP90 != nil {
		n += 10
	}
	if m.NetTCPRttMicrosecsP95 != nil {
		n += 10
	}
	if m.NetTCPRttMicrosecsP99 != nil {
		n += 10
	}
	if m.DiskLimitBytes != nil {
		n += 2 + sovMesos(uint64(*m.DiskLimitBytes))
	}
	if m.DiskUsedBytes != nil {
		n += 2 + sovMesos(uint64(*m.DiskUsedBytes))
	}
	if m.NetTCPActiveConnections != nil {
		n += 10
	}
	if m.NetTCPTimeWaitConnections != nil {
		n += 10
	}
	if m.Processes != nil {
		n += 2 + sovMesos(uint64(*m.Processes))
	}
	if m.Threads != nil {
		n += 2 + sovMesos(uint64(*m.Threads))
	}
	if m.MemLowPressureCounter != nil {
		n += 2 + sovMesos(uint64(*m.MemLowPressureCounter))
	}
	if m.MemMediumPressureCounter != nil {
		n += 2 + sovMesos(uint64(*m.MemMediumPressureCounter))
	}
	if m.MemCriticalPressureCounter != nil {
		n += 2 + sovMesos(uint64(*m.MemCriticalPressureCounter))
	}
	if len(m.NetTrafficControlStatistics) > 0 {
		for _, e := range m.NetTrafficControlStatistics {
			l = e.ProtoSize()
			n += 2 + l + sovMesos(uint64(l))
		}
	}
	if m.MemTotalBytes != nil {
		n += 2 + sovMesos(uint64(*m.MemTotalBytes))
	}
	if m.MemTotalMemswBytes != nil {
		n += 2 + sovMesos(uint64(*m.MemTotalMemswBytes))
	}
	if m.MemSoftLimitBytes != nil {
		n += 2 + sovMesos(uint64(*m.MemSoftLimitBytes))
	}
	if m.MemCacheBytes != nil {
		n += 2 + sovMesos(uint64(*m.MemCacheBytes))
	}
	if m.MemSwapBytes != nil {
		n += 2 + sovMesos(uint64(*m.MemSwapBytes))
	}
	if m.MemUnevictableBytes != nil {
		n += 2 + sovMesos(uint64(*m.MemUnevictableBytes))
	}
	if m.NetSNMPStatistics != nil {
		l = m.NetSNMPStatistics.ProtoSize()
		n += 2 + l + sovMesos(uint64(l))
	}
	if len(m.DiskStatistics) > 0 {
		for _, e := range m.DiskStatistics {
			l = e.ProtoSize()
			n += 2 + l + sovMesos(uint64(l))
		}
	}
	if m.BlkioStatistics != nil {
		l = m.BlkioStatistics.ProtoSize()
		n += 2 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *ResourceUsage) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Executors) > 0 {
		for _, e := range m.Executors {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.Total) > 0 {
		for _, e := range m.Total {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *ResourceUsage_Executor) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.ExecutorInfo.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Allocated) > 0 {
		for _, e := range m.Allocated {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Statistics != nil {
		l = m.Statistics.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	l = m.ContainerID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *ResourceUsage_Executor_Task) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	l = m.ID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *PerfStatistics) ProtoSize() (n int) {
	var l int
	_ = l
	n += 9
	n += 9
	if m.Cycles != nil {
		n += 1 + sovMesos(uint64(*m.Cycles))
	}
	if m.StalledCyclesFrontend != nil {
		n += 1 + sovMesos(uint64(*m.StalledCyclesFrontend))
	}
	if m.StalledCyclesBackend != nil {
		n += 1 + sovMesos(uint64(*m.StalledCyclesBackend))
	}
	if m.Instructions != nil {
		n += 1 + sovMesos(uint64(*m.Instructions))
	}
	if m.CacheReferences != nil {
		n += 1 + sovMesos(uint64(*m.CacheReferences))
	}
	if m.CacheMisses != nil {
		n += 1 + sovMesos(uint64(*m.CacheMisses))
	}
	if m.Branches != nil {
		n += 1 + sovMesos(uint64(*m.Branches))
	}
	if m.BranchMisses != nil {
		n += 1 + sovMesos(uint64(*m.BranchMisses))
	}
	if m.BusCycles != nil {
		n += 1 + sovMesos(uint64(*m.BusCycles))
	}
	if m.RefCycles != nil {
		n += 1 + sovMesos(uint64(*m.RefCycles))
	}
	if m.CPUClock != nil {
		n += 9
	}
	if m.TaskClock != nil {
		n += 9
	}
	if m.PageFaults != nil {
		n += 1 + sovMesos(uint64(*m.PageFaults))
	}
	if m.MinorFaults != nil {
		n += 2 + sovMesos(uint64(*m.MinorFaults))
	}
	if m.MajorFaults != nil {
		n += 2 + sovMesos(uint64(*m.MajorFaults))
	}
	if m.ContextSwitches != nil {
		n += 2 + sovMesos(uint64(*m.ContextSwitches))
	}
	if m.CPUMigrations != nil {
		n += 2 + sovMesos(uint64(*m.CPUMigrations))
	}
	if m.AlignmentFaults != nil {
		n += 2 + sovMesos(uint64(*m.AlignmentFaults))
	}
	if m.EmulationFaults != nil {
		n += 2 + sovMesos(uint64(*m.EmulationFaults))
	}
	if m.L1DcacheLoads != nil {
		n += 2 + sovMesos(uint64(*m.L1DcacheLoads))
	}
	if m.L1DcacheLoadMisses != nil {
		n += 2 + sovMesos(uint64(*m.L1DcacheLoadMisses))
	}
	if m.L1DcacheStores != nil {
		n += 2 + sovMesos(uint64(*m.L1DcacheStores))
	}
	if m.L1DcacheStoreMisses != nil {
		n += 2 + sovMesos(uint64(*m.L1DcacheStoreMisses))
	}
	if m.L1DcachePrefetches != nil {
		n += 2 + sovMesos(uint64(*m.L1DcachePrefetches))
	}
	if m.L1DcachePrefetchMisses != nil {
		n += 2 + sovMesos(uint64(*m.L1DcachePrefetchMisses))
	}
	if m.L1IcacheLoads != nil {
		n += 2 + sovMesos(uint64(*m.L1IcacheLoads))
	}
	if m.L1IcacheLoadMisses != nil {
		n += 2 + sovMesos(uint64(*m.L1IcacheLoadMisses))
	}
	if m.L1IcachePrefetches != nil {
		n += 2 + sovMesos(uint64(*m.L1IcachePrefetches))
	}
	if m.L1IcachePrefetchMisses != nil {
		n += 2 + sovMesos(uint64(*m.L1IcachePrefetchMisses))
	}
	if m.LLCLoads != nil {
		n += 2 + sovMesos(uint64(*m.LLCLoads))
	}
	if m.LLCLoadMisses != nil {
		n += 2 + sovMesos(uint64(*m.LLCLoadMisses))
	}
	if m.LLCStores != nil {
		n += 2 + sovMesos(uint64(*m.LLCStores))
	}
	if m.LLCStoreMisses != nil {
		n += 2 + sovMesos(uint64(*m.LLCStoreMisses))
	}
	if m.LLCPrefetches != nil {
		n += 2 + sovMesos(uint64(*m.LLCPrefetches))
	}
	if m.LLCPrefetchMisses != nil {
		n += 2 + sovMesos(uint64(*m.LLCPrefetchMisses))
	}
	if m.DTLBLoads != nil {
		n += 2 + sovMesos(uint64(*m.DTLBLoads))
	}
	if m.DTLBLoadMisses != nil {
		n += 2 + sovMesos(uint64(*m.DTLBLoadMisses))
	}
	if m.DTLBStores != nil {
		n += 2 + sovMesos(uint64(*m.DTLBStores))
	}
	if m.DTLBStoreMisses != nil {
		n += 2 + sovMesos(uint64(*m.DTLBStoreMisses))
	}
	if m.DTLBPrefetches != nil {
		n += 2 + sovMesos(uint64(*m.DTLBPrefetches))
	}
	if m.DTLBPrefetchMisses != nil {
		n += 2 + sovMesos(uint64(*m.DTLBPrefetchMisses))
	}
	if m.ITLBLoads != nil {
		n += 2 + sovMesos(uint64(*m.ITLBLoads))
	}
	if m.ITLBLoadMisses != nil {
		n += 2 + sovMesos(uint64(*m.ITLBLoadMisses))
	}
	if m.BranchLoads != nil {
		n += 2 + sovMesos(uint64(*m.BranchLoads))
	}
	if m.BranchLoadMisses != nil {
		n += 2 + sovMesos(uint64(*m.BranchLoadMisses))
	}
	if m.NodeLoads != nil {
		n += 2 + sovMesos(uint64(*m.NodeLoads))
	}
	if m.NodeLoadMisses != nil {
		n += 2 + sovMesos(uint64(*m.NodeLoadMisses))
	}
	if m.NodeStores != nil {
		n += 2 + sovMesos(uint64(*m.NodeStores))
	}
	if m.NodeStoreMisses != nil {
		n += 2 + sovMesos(uint64(*m.NodeStoreMisses))
	}
	if m.NodePrefetches != nil {
		n += 2 + sovMesos(uint64(*m.NodePrefetches))
	}
	if m.NodePrefetchMisses != nil {
		n += 2 + sovMesos(uint64(*m.NodePrefetchMisses))
	}
	return n
}

func (m *Request) ProtoSize() (n int) {
	var l int
	_ = l
	if m.AgentID != nil {
		l = m.AgentID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Offer) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.ID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.FrameworkID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.AgentID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = len(m.Hostname)
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.ExecutorIDs) > 0 {
		for _, e := range m.ExecutorIDs {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.URL != nil {
		l = m.URL.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Unavailability != nil {
		l = m.Unavailability.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.AllocationInfo != nil {
		l = m.AllocationInfo.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Domain != nil {
		l = m.Domain.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Offer_Operation) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	if m.Launch != nil {
		l = m.Launch.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Reserve != nil {
		l = m.Reserve.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Unreserve != nil {
		l = m.Unreserve.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Create != nil {
		l = m.Create.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Destroy != nil {
		l = m.Destroy.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.LaunchGroup != nil {
		l = m.LaunchGroup.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.ID != nil {
		l = m.ID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.GrowVolume != nil {
		l = m.GrowVolume.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.ShrinkVolume != nil {
		l = m.ShrinkVolume.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.CreateDisk != nil {
		l = m.CreateDisk.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.DestroyDisk != nil {
		l = m.DestroyDisk.ProtoSize()
		n += 2 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Offer_Operation_Launch) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.TaskInfos) > 0 {
		for _, e := range m.TaskInfos {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Offer_Operation_LaunchGroup) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Executor.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.TaskGroup.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *Offer_Operation_Reserve) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Offer_Operation_Unreserve) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Offer_Operation_Create) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Offer_Operation_Destroy) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Offer_Operation_GrowVolume) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Volume.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.Addition.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *Offer_Operation_ShrinkVolume) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Volume.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.Subtract.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *Offer_Operation_CreateDisk) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Source.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	n += 1 + sovMesos(uint64(m.TargetType))
	return n
}

func (m *Offer_Operation_DestroyDisk) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Source.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *InverseOffer) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.OfferID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.URL != nil {
		l = m.URL.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	l = m.FrameworkID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.AgentID != nil {
		l = m.AgentID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	l = m.Unavailability.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *TaskInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	l = m.TaskID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.AgentID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Executor != nil {
		l = m.Executor.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Command != nil {
		l = m.Command.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.HealthCheck != nil {
		l = m.HealthCheck.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Container != nil {
		l = m.Container.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Discovery != nil {
		l = m.Discovery.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.KillPolicy != nil {
		l = m.KillPolicy.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Check != nil {
		l = m.Check.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.MaxCompletionTime != nil {
		l = m.MaxCompletionTime.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *TaskGroupInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Task) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	l = m.TaskID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.FrameworkID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.ExecutorID != nil {
		l = m.ExecutorID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	l = m.AgentID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.State != nil {
		n += 1 + sovMesos(uint64(*m.State))
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.Statuses) > 0 {
		for _, e := range m.Statuses {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.StatusUpdateState != nil {
		n += 1 + sovMesos(uint64(*m.StatusUpdateState))
	}
	if m.StatusUpdateUUID != nil {
		l = len(m.StatusUpdateUUID)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Discovery != nil {
		l = m.Discovery.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Container != nil {
		l = m.Container.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.User != nil {
		l = len(*m.User)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *TaskResourceLimitation) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *UUID) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Operation) ProtoSize() (n int) {
	var l int
	_ = l
	if m.FrameworkID != nil {
		l = m.FrameworkID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.AgentID != nil {
		l = m.AgentID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	l = m.Info.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.LatestStatus.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if len(m.Statuses) > 0 {
		for _, e := range m.Statuses {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	l = m.UUID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *OperationStatus) ProtoSize() (n int) {
	var l int
	_ = l
	if m.OperationID != nil {
		l = m.OperationID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	n += 1 + sovMesos(uint64(m.State))
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.ConvertedResources) > 0 {
		for _, e := range m.ConvertedResources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.UUID != nil {
		l = m.UUID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CheckStatusInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMesos(uint64(*m.Type))
	}
	if m.Command != nil {
		l = m.Command.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.HTTP != nil {
		l = m.HTTP.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.TCP != nil {
		l = m.TCP.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CheckStatusInfo_Command) ProtoSize() (n int) {
	var l int
	_ = l
	if m.ExitCode != nil {
		n += 1 + sovMesos(uint64(*m.ExitCode))
	}
	return n
}

func (m *CheckStatusInfo_Http) ProtoSize() (n int) {
	var l int
	_ = l
	if m.StatusCode != nil {
		n += 1 + sovMesos(uint64(*m.StatusCode))
	}
	return n
}

func (m *CheckStatusInfo_Tcp) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Succeeded != nil {
		n += 2
	}
	return n
}

func (m *TaskStatus) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.TaskID.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	if m.State != nil {
		n += 1 + sovMesos(uint64(*m.State))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.AgentID != nil {
		l = m.AgentID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Timestamp != nil {
		n += 9
	}
	if m.ExecutorID != nil {
		l = m.ExecutorID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Healthy != nil {
		n += 2
	}
	if m.Source != nil {
		n += 1 + sovMesos(uint64(*m.Source))
	}
	if m.Reason != nil {
		n += 1 + sovMesos(uint64(*m.Reason))
	}
	if m.UUID != nil {
		l = len(m.UUID)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.ContainerStatus != nil {
		l = m.ContainerStatus.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.UnreachableTime != nil {
		l = m.UnreachableTime.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.CheckStatus != nil {
		l = m.CheckStatus.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Limitation != nil {
		l = m.Limitation.ProtoSize()
		n += 2 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Filters) ProtoSize() (n int) {
	var l int
	_ = l
	if m.RefuseSeconds != nil {
		n += 9
	}
	return n
}

func (m *Environment) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Variables) > 0 {
		for _, e := range m.Variables {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Environment_Variable) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovMesos(uint64(*m.Type))
	}
	if m.Secret != nil {
		l = m.Secret.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Parameter) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	n += 1 + l + sovMesos(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *Parameters) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Parameter) > 0 {
		for _, e := range m.Parameter {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Credential) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Principal)
	n += 1 + l + sovMesos(uint64(l))
	if m.Secret != nil {
		l = len(*m.Secret)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Credentials) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Credentials) > 0 {
		for _, e := range m.Credentials {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Secret) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	if m.Reference != nil {
		l = m.Reference.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Secret_Reference) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Secret_Value) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *RateLimit) ProtoSize() (n int) {
	var l int
	_ = l
	if m.QPS != nil {
		n += 9
	}
	l = len(m.Principal)
	n += 1 + l + sovMesos(uint64(l))
	if m.Capacity != nil {
		n += 1 + sovMesos(uint64(*m.Capacity))
	}
	return n
}

func (m *RateLimits) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for _, e := range m.Limits {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.AggregateDefaultQPS != nil {
		n += 9
	}
	if m.AggregateDefaultCapacity != nil {
		n += 1 + sovMesos(uint64(*m.AggregateDefaultCapacity))
	}
	return n
}

func (m *Image) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMesos(uint64(*m.Type))
	}
	if m.Appc != nil {
		l = m.Appc.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Docker != nil {
		l = m.Docker.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Cached != nil {
		n += 2
	}
	return n
}

func (m *Image_Appc) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.ID != nil {
		l = len(*m.ID)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Image_Docker) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.Credential != nil {
		l = m.Credential.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *MountPropagation) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Mode != nil {
		n += 1 + sovMesos(uint64(*m.Mode))
	}
	return n
}

func (m *Volume) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.ContainerPath)
	n += 1 + l + sovMesos(uint64(l))
	if m.HostPath != nil {
		l = len(*m.HostPath)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Mode != nil {
		n += 1 + sovMesos(uint64(*m.Mode))
	}
	if m.Image != nil {
		l = m.Image.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Volume_Source) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	if m.DockerVolume != nil {
		l = m.DockerVolume.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.SandboxPath != nil {
		l = m.SandboxPath.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Secret != nil {
		l = m.Secret.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.HostPath != nil {
		l = m.HostPath.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Volume_Source_DockerVolume) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Driver != nil {
		l = len(*m.Driver)
		n += 1 + l + sovMesos(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.DriverOptions != nil {
		l = m.DriverOptions.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Volume_Source_HostPath) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovMesos(uint64(l))
	if m.MountPropagation != nil {
		l = m.MountPropagation.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Volume_Source_SandboxPath) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	l = len(m.Path)
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *NetworkInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			l = len(s)
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.IPAddresses) > 0 {
		for _, e := range m.IPAddresses {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.PortMappings) > 0 {
		for _, e := range m.PortMappings {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *NetworkInfo_IPAddress) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Protocol != nil {
		n += 1 + sovMesos(uint64(*m.Protocol))
	}
	if m.IPAddress != nil {
		l = len(*m.IPAddress)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *NetworkInfo_PortMapping) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.HostPort))
	n += 1 + sovMesos(uint64(m.ContainerPort))
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CapabilityInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, e := range m.Capabilities {
			n += 1 + sovMesos(uint64(e))
		}
	}
	return n
}

func (m *LinuxInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.CapabilityInfo != nil {
		l = m.CapabilityInfo.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.BoundingCapabilities != nil {
		l = m.BoundingCapabilities.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.EffectiveCapabilities != nil {
		l = m.EffectiveCapabilities.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.SharePIDNamespace != nil {
		n += 2
	}
	return n
}

func (m *RLimitInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Rlimits) > 0 {
		for _, e := range m.Rlimits {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *RLimitInfo_RLimit) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Type))
	if m.Hard != nil {
		n += 1 + sovMesos(uint64(*m.Hard))
	}
	if m.Soft != nil {
		n += 1 + sovMesos(uint64(*m.Soft))
	}
	return n
}

func (m *TTYInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.WindowSize != nil {
		l = m.WindowSize.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *TTYInfo_WindowSize) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Rows))
	n += 1 + sovMesos(uint64(m.Columns))
	return n
}

func (m *ContainerInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovMesos(uint64(*m.Type))
	}
	if len(m.Volumes) > 0 {
		for _, e := range m.Volumes {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Docker != nil {
		l = m.Docker.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Mesos != nil {
		l = m.Mesos.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.NetworkInfos) > 0 {
		for _, e := range m.NetworkInfos {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.LinuxInfo != nil {
		l = m.LinuxInfo.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.RlimitInfo != nil {
		l = m.RlimitInfo.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.TTYInfo != nil {
		l = m.TTYInfo.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *ContainerInfo_DockerInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Image)
	n += 1 + l + sovMesos(uint64(l))
	if m.Network != nil {
		n += 1 + sovMesos(uint64(*m.Network))
	}
	if len(m.PortMappings) > 0 {
		for _, e := range m.PortMappings {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.Privileged != nil {
		n += 2
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.ForcePullImage != nil {
		n += 2
	}
	if m.VolumeDriver != nil {
		l = len(*m.VolumeDriver)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *ContainerInfo_DockerInfo_PortMapping) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.HostPort))
	n += 1 + sovMesos(uint64(m.ContainerPort))
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *ContainerInfo_MesosInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *ContainerStatus) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.NetworkInfos) > 0 {
		for _, e := range m.NetworkInfos {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if m.CgroupInfo != nil {
		l = m.CgroupInfo.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.ExecutorPID != nil {
		n += 1 + sovMesos(uint64(*m.ExecutorPID))
	}
	if m.ContainerID != nil {
		l = m.ContainerID.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CgroupInfo) ProtoSize() (n int) {
	var l int
	_ = l
	if m.NetCLS != nil {
		l = m.NetCLS.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *CgroupInfo_Blkio) ProtoSize() (n int) {
	var l int
	_ = l
	return n
}

func (m *CgroupInfo_Blkio_Value) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Op != nil {
		n += 1 + sovMesos(uint64(*m.Op))
	}
	if m.Value != nil {
		n += 1 + sovMesos(uint64(*m.Value))
	}
	return n
}

func (m *CgroupInfo_Blkio_CFQ) ProtoSize() (n int) {
	var l int
	_ = l
	return n
}

func (m *CgroupInfo_Blkio_CFQ_Statistics) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Device != nil {
		l = m.Device.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Sectors != nil {
		n += 1 + sovMesos(uint64(*m.Sectors))
	}
	if m.Time != nil {
		n += 1 + sovMesos(uint64(*m.Time))
	}
	if len(m.IOServiced) > 0 {
		for _, e := range m.IOServiced {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.IOServiceBytes) > 0 {
		for _, e := range m.IOServiceBytes {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.IOServiceTime) > 0 {
		for _, e := range m.IOServiceTime {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.IOWaitTime) > 0 {
		for _, e := range m.IOWaitTime {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.IOMerged) > 0 {
		for _, e := range m.IOMerged {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.IOQueued) > 0 {
		for _, e := range m.IOQueued {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *CgroupInfo_Blkio_Throttling) ProtoSize() (n int) {
	var l int
	_ = l
	return n
}

func (m *CgroupInfo_Blkio_Throttling_Statistics) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Device != nil {
		l = m.Device.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if len(m.IOServiced) > 0 {
		for _, e := range m.IOServiced {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.IOServiceBytes) > 0 {
		for _, e := range m.IOServiceBytes {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *CgroupInfo_Blkio_Statistics) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.CFQ) > 0 {
		for _, e := range m.CFQ {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.CFQRecursive) > 0 {
		for _, e := range m.CFQRecursive {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.Throttling) > 0 {
		for _, e := range m.Throttling {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *CgroupInfo_NetCls) ProtoSize() (n int) {
	var l int
	_ = l
	if m.ClassID != nil {
		n += 1 + sovMesos(uint64(*m.ClassID))
	}
	return n
}

func (m *Labels) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Label) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	n += 1 + l + sovMesos(uint64(l))
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Port) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Number))
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Protocol != nil {
		l = len(*m.Protocol)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Visibility != nil {
		n += 1 + sovMesos(uint64(*m.Visibility))
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Ports) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *DiscoveryInfo) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovMesos(uint64(m.Visibility))
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Environment != nil {
		l = len(*m.Environment)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Location != nil {
		l = len(*m.Location)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Ports != nil {
		l = m.Ports.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *WeightInfo) ProtoSize() (n int) {
	var l int
	_ = l
	n += 9
	if m.Role != nil {
		l = len(*m.Role)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *VersionInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	n += 1 + l + sovMesos(uint64(l))
	if m.BuildDate != nil {
		l = len(*m.BuildDate)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.BuildTime != nil {
		n += 9
	}
	if m.BuildUser != nil {
		l = len(*m.BuildUser)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.GitSHA != nil {
		l = len(*m.GitSHA)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.GitBranch != nil {
		l = len(*m.GitBranch)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.GitTag != nil {
		l = len(*m.GitTag)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Flag) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Role) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	n += 9
	if len(m.Frameworks) > 0 {
		for _, e := range m.Frameworks {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func (m *Metric) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovMesos(uint64(l))
	if m.Value != nil {
		n += 9
	}
	return n
}

func (m *FileInfo) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovMesos(uint64(l))
	if m.Nlink != nil {
		n += 1 + sovMesos(uint64(*m.Nlink))
	}
	if m.Size != nil {
		n += 1 + sovMesos(uint64(*m.Size))
	}
	if m.Mtime != nil {
		l = m.Mtime.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Mode != nil {
		n += 1 + sovMesos(uint64(*m.Mode))
	}
	if m.UID != nil {
		l = len(*m.UID)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.GID != nil {
		l = len(*m.GID)
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Device) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovMesos(uint64(l))
	}
	if m.Number != nil {
		l = m.Number.ProtoSize()
		n += 1 + l + sovMesos(uint64(l))
	}
	return n
}

func (m *Device_Number) ProtoSize() (n int) {
	var l int
	_ = l
	if m.MajorNumber != nil {
		n += 1 + sovMesos(uint64(*m.MajorNumber))
	}
	if m.MinorNumber != nil {
		n += 1 + sovMesos(uint64(*m.MinorNumber))
	}
	return n
}

func (m *DeviceAccess) ProtoSize() (n int) {
	var l int
	_ = l
	l = m.Device.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	l = m.Access.ProtoSize()
	n += 1 + l + sovMesos(uint64(l))
	return n
}

func (m *DeviceAccess_Access) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Read != nil {
		n += 2
	}
	if m.Write != nil {
		n += 2
	}
	if m.Mknod != nil {
		n += 2
	}
	return n
}

func (m *DeviceWhitelist) ProtoSize() (n int) {
	var l int
	_ = l
	if len(m.AllowedDevices) > 0 {
		for _, e := range m.AllowedDevices {
			l = e.ProtoSize()
			n += 1 + l + sovMesos(uint64(l))
		}
	}
	return n
}

func sovMesos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMesos(x uint64) (n int) {
	return sovMesos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *FrameworkID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FrameworkID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OfferID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OfferID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AgentID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AgentID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutorID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutorID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Parent:` + strings.Replace(fmt.Sprintf("%v", this.Parent), "ContainerID", "ContainerID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceProviderID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceProviderID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OperationID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OperationID{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimeInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimeInfo{`,
		`Nanoseconds:` + fmt.Sprintf("%v", this.Nanoseconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DurationInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DurationInfo{`,
		`Nanoseconds:` + fmt.Sprintf("%v", this.Nanoseconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Address{`,
		`Hostname:` + valueToStringMesos(this.Hostname) + `,`,
		`IP:` + valueToStringMesos(this.IP) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *URL) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&URL{`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`Address:` + strings.Replace(strings.Replace(this.Address.String(), "Address", "Address", 1), `&`, ``, 1) + `,`,
		`Path:` + valueToStringMesos(this.Path) + `,`,
		`Query:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Query), "Parameter", "Parameter", 1), `&`, ``, 1) + `,`,
		`Fragment:` + valueToStringMesos(this.Fragment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Unavailability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Unavailability{`,
		`Start:` + strings.Replace(strings.Replace(this.Start.String(), "TimeInfo", "TimeInfo", 1), `&`, ``, 1) + `,`,
		`Duration:` + strings.Replace(fmt.Sprintf("%v", this.Duration), "DurationInfo", "DurationInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MachineID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MachineID{`,
		`Hostname:` + valueToStringMesos(this.Hostname) + `,`,
		`IP:` + valueToStringMesos(this.IP) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MachineInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MachineInfo{`,
		`ID:` + strings.Replace(strings.Replace(this.ID.String(), "MachineID", "MachineID", 1), `&`, ``, 1) + `,`,
		`Mode:` + valueToStringMesos(this.Mode) + `,`,
		`Unavailability:` + strings.Replace(fmt.Sprintf("%v", this.Unavailability), "Unavailability", "Unavailability", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FrameworkInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FrameworkInfo{`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "FrameworkID", "FrameworkID", 1) + `,`,
		`FailoverTimeout:` + valueToStringMesos(this.FailoverTimeout) + `,`,
		`Checkpoint:` + valueToStringMesos(this.Checkpoint) + `,`,
		`Role:` + valueToStringMesos(this.Role) + `,`,
		`Hostname:` + valueToStringMesos(this.Hostname) + `,`,
		`Principal:` + valueToStringMesos(this.Principal) + `,`,
		`WebUiURL:` + valueToStringMesos(this.WebUiURL) + `,`,
		`Capabilities:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Capabilities), "FrameworkInfo_Capability", "FrameworkInfo_Capability", 1), `&`, ``, 1) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`Roles:` + fmt.Sprintf("%v", this.Roles) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FrameworkInfo_Capability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FrameworkInfo_Capability{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckInfo{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Command:` + strings.Replace(fmt.Sprintf("%v", this.Command), "CheckInfo_Command", "CheckInfo_Command", 1) + `,`,
		`HTTP:` + strings.Replace(fmt.Sprintf("%v", this.HTTP), "CheckInfo_Http", "CheckInfo_Http", 1) + `,`,
		`DelaySeconds:` + valueToStringMesos(this.DelaySeconds) + `,`,
		`IntervalSeconds:` + valueToStringMesos(this.IntervalSeconds) + `,`,
		`TimeoutSeconds:` + valueToStringMesos(this.TimeoutSeconds) + `,`,
		`TCP:` + strings.Replace(fmt.Sprintf("%v", this.TCP), "CheckInfo_Tcp", "CheckInfo_Tcp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckInfo_Command) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckInfo_Command{`,
		`Command:` + strings.Replace(strings.Replace(this.Command.String(), "CommandInfo", "CommandInfo", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckInfo_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckInfo_Http{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Path:` + valueToStringMesos(this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckInfo_Tcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckInfo_Tcp{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HealthCheck) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HealthCheck{`,
		`HTTP:` + strings.Replace(fmt.Sprintf("%v", this.HTTP), "HealthCheck_HTTPCheckInfo", "HealthCheck_HTTPCheckInfo", 1) + `,`,
		`DelaySeconds:` + valueToStringMesos(this.DelaySeconds) + `,`,
		`IntervalSeconds:` + valueToStringMesos(this.IntervalSeconds) + `,`,
		`TimeoutSeconds:` + valueToStringMesos(this.TimeoutSeconds) + `,`,
		`ConsecutiveFailures:` + valueToStringMesos(this.ConsecutiveFailures) + `,`,
		`GracePeriodSeconds:` + valueToStringMesos(this.GracePeriodSeconds) + `,`,
		`Command:` + strings.Replace(fmt.Sprintf("%v", this.Command), "CommandInfo", "CommandInfo", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`TCP:` + strings.Replace(fmt.Sprintf("%v", this.TCP), "HealthCheck_TCPCheckInfo", "HealthCheck_TCPCheckInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HealthCheck_HTTPCheckInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HealthCheck_HTTPCheckInfo{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Path:` + valueToStringMesos(this.Path) + `,`,
		`Scheme:` + valueToStringMesos(this.Scheme) + `,`,
		`Statuses:` + fmt.Sprintf("%v", this.Statuses) + `,`,
		`Protocol:` + valueToStringMesos(this.Protocol) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HealthCheck_TCPCheckInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HealthCheck_TCPCheckInfo{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Protocol:` + valueToStringMesos(this.Protocol) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KillPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KillPolicy{`,
		`GracePeriod:` + strings.Replace(fmt.Sprintf("%v", this.GracePeriod), "DurationInfo", "DurationInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CommandInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CommandInfo{`,
		`URIs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.URIs), "CommandInfo_URI", "CommandInfo_URI", 1), `&`, ``, 1) + `,`,
		`Environment:` + strings.Replace(fmt.Sprintf("%v", this.Environment), "Environment", "Environment", 1) + `,`,
		`Value:` + valueToStringMesos(this.Value) + `,`,
		`User:` + valueToStringMesos(this.User) + `,`,
		`Shell:` + valueToStringMesos(this.Shell) + `,`,
		`Arguments:` + fmt.Sprintf("%v", this.Arguments) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CommandInfo_URI) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CommandInfo_URI{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Executable:` + valueToStringMesos(this.Executable) + `,`,
		`Extract:` + valueToStringMesos(this.Extract) + `,`,
		`Cache:` + valueToStringMesos(this.Cache) + `,`,
		`OutputFile:` + valueToStringMesos(this.OutputFile) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecutorInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecutorInfo{`,
		`ExecutorID:` + strings.Replace(strings.Replace(this.ExecutorID.String(), "ExecutorID", "ExecutorID", 1), `&`, ``, 1) + `,`,
		`Data:` + valueToStringMesos(this.Data) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Command:` + strings.Replace(fmt.Sprintf("%v", this.Command), "CommandInfo", "CommandInfo", 1) + `,`,
		`FrameworkID:` + strings.Replace(fmt.Sprintf("%v", this.FrameworkID), "FrameworkID", "FrameworkID", 1) + `,`,
		`Name:` + valueToStringMesos(this.Name) + `,`,
		`Source:` + valueToStringMesos(this.Source) + `,`,
		`Container:` + strings.Replace(fmt.Sprintf("%v", this.Container), "ContainerInfo", "ContainerInfo", 1) + `,`,
		`Discovery:` + strings.Replace(fmt.Sprintf("%v", this.Discovery), "DiscoveryInfo", "DiscoveryInfo", 1) + `,`,
		`ShutdownGracePeriod:` + strings.Replace(fmt.Sprintf("%v", this.ShutdownGracePeriod), "DurationInfo", "DurationInfo", 1) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainInfo{`,
		`FaultDomain:` + strings.Replace(fmt.Sprintf("%v", this.FaultDomain), "DomainInfo_FaultDomain", "DomainInfo_FaultDomain", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainInfo_FaultDomain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainInfo_FaultDomain{`,
		`Region:` + strings.Replace(strings.Replace(this.Region.String(), "DomainInfo_FaultDomain_RegionInfo", "DomainInfo_FaultDomain_RegionInfo", 1), `&`, ``, 1) + `,`,
		`Zone:` + strings.Replace(strings.Replace(this.Zone.String(), "DomainInfo_FaultDomain_ZoneInfo", "DomainInfo_FaultDomain_ZoneInfo", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainInfo_FaultDomain_RegionInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainInfo_FaultDomain_RegionInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainInfo_FaultDomain_ZoneInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainInfo_FaultDomain_ZoneInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MasterInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MasterInfo{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`IP:` + fmt.Sprintf("%v", this.IP) + `,`,
		`Port:` + valueToStringMesos(this.Port) + `,`,
		`PID:` + valueToStringMesos(this.PID) + `,`,
		`Hostname:` + valueToStringMesos(this.Hostname) + `,`,
		`Version:` + valueToStringMesos(this.Version) + `,`,
		`Address:` + strings.Replace(fmt.Sprintf("%v", this.Address), "Address", "Address", 1) + `,`,
		`Domain:` + strings.Replace(fmt.Sprintf("%v", this.Domain), "DomainInfo", "DomainInfo", 1) + `,`,
		`Capabilities:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Capabilities), "MasterInfo_Capability", "MasterInfo_Capability", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MasterInfo_Capability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MasterInfo_Capability{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AgentInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AgentInfo{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Attributes:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Attributes), "Attribute", "Attribute", 1), `&`, ``, 1) + `,`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "AgentID", "AgentID", 1) + `,`,
		`Port:` + valueToStringMesos(this.Port) + `,`,
		`Domain:` + strings.Replace(fmt.Sprintf("%v", this.Domain), "DomainInfo", "DomainInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AgentInfo_Capability) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AgentInfo_Capability{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CSIPluginContainerInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CSIPluginContainerInfo{`,
		`Services:` + fmt.Sprintf("%v", this.Services) + `,`,
		`Command:` + strings.Replace(fmt.Sprintf("%v", this.Command), "CommandInfo", "CommandInfo", 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Container:` + strings.Replace(fmt.Sprintf("%v", this.Container), "ContainerInfo", "ContainerInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CSIPluginInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CSIPluginInfo{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Containers:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Containers), "CSIPluginContainerInfo", "CSIPluginContainerInfo", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceProviderInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceProviderInfo{`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "ResourceProviderID", "ResourceProviderID", 1) + `,`,
		`Attributes:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Attributes), "Attribute", "Attribute", 1), `&`, ``, 1) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DefaultReservations:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.DefaultReservations), "Resource_ReservationInfo", "Resource_ReservationInfo", 1), `&`, ``, 1) + `,`,
		`Storage:` + strings.Replace(fmt.Sprintf("%v", this.Storage), "ResourceProviderInfo_Storage", "ResourceProviderInfo_Storage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceProviderInfo_Storage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceProviderInfo_Storage{`,
		`Plugin:` + strings.Replace(strings.Replace(this.Plugin.String(), "CSIPluginInfo", "CSIPluginInfo", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Scalar:` + strings.Replace(fmt.Sprintf("%v", this.Scalar), "Value_Scalar", "Value_Scalar", 1) + `,`,
		`Ranges:` + strings.Replace(fmt.Sprintf("%v", this.Ranges), "Value_Ranges", "Value_Ranges", 1) + `,`,
		`Set:` + strings.Replace(fmt.Sprintf("%v", this.Set), "Value_Set", "Value_Set", 1) + `,`,
		`Text:` + strings.Replace(fmt.Sprintf("%v", this.Text), "Value_Text", "Value_Text", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Scalar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Scalar{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Range) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Range{`,
		`Begin:` + fmt.Sprintf("%v", this.Begin) + `,`,
		`End:` + fmt.Sprintf("%v", this.End) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Ranges) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Ranges{`,
		`Range:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Range), "Value_Range", "Value_Range", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Set) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Set{`,
		`Item:` + fmt.Sprintf("%v", this.Item) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value_Text) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value_Text{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Attribute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Attribute{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Scalar:` + strings.Replace(fmt.Sprintf("%v", this.Scalar), "Value_Scalar", "Value_Scalar", 1) + `,`,
		`Ranges:` + strings.Replace(fmt.Sprintf("%v", this.Ranges), "Value_Ranges", "Value_Ranges", 1) + `,`,
		`Text:` + strings.Replace(fmt.Sprintf("%v", this.Text), "Value_Text", "Value_Text", 1) + `,`,
		`Set:` + strings.Replace(fmt.Sprintf("%v", this.Set), "Value_Set", "Value_Set", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + valueToStringMesos(this.Type) + `,`,
		`Scalar:` + strings.Replace(fmt.Sprintf("%v", this.Scalar), "Value_Scalar", "Value_Scalar", 1) + `,`,
		`Ranges:` + strings.Replace(fmt.Sprintf("%v", this.Ranges), "Value_Ranges", "Value_Ranges", 1) + `,`,
		`Set:` + strings.Replace(fmt.Sprintf("%v", this.Set), "Value_Set", "Value_Set", 1) + `,`,
		`Role:` + valueToStringMesos(this.Role) + `,`,
		`Disk:` + strings.Replace(fmt.Sprintf("%v", this.Disk), "Resource_DiskInfo", "Resource_DiskInfo", 1) + `,`,
		`Reservation:` + strings.Replace(fmt.Sprintf("%v", this.Reservation), "Resource_ReservationInfo", "Resource_ReservationInfo", 1) + `,`,
		`Revocable:` + strings.Replace(fmt.Sprintf("%v", this.Revocable), "Resource_RevocableInfo", "Resource_RevocableInfo", 1) + `,`,
		`Shared:` + strings.Replace(fmt.Sprintf("%v", this.Shared), "Resource_SharedInfo", "Resource_SharedInfo", 1) + `,`,
		`AllocationInfo:` + strings.Replace(fmt.Sprintf("%v", this.AllocationInfo), "Resource_AllocationInfo", "Resource_AllocationInfo", 1) + `,`,
		`ProviderID:` + strings.Replace(fmt.Sprintf("%v", this.ProviderID), "ResourceProviderID", "ResourceProviderID", 1) + `,`,
		`Reservations:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Reservations), "Resource_ReservationInfo", "Resource_ReservationInfo", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_AllocationInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_AllocationInfo{`,
		`Role:` + valueToStringMesos(this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_ReservationInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_ReservationInfo{`,
		`Principal:` + valueToStringMesos(this.Principal) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`Role:` + valueToStringMesos(this.Role) + `,`,
		`Type:` + valueToStringMesos(this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_DiskInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_DiskInfo{`,
		`Persistence:` + strings.Replace(fmt.Sprintf("%v", this.Persistence), "Resource_DiskInfo_Persistence", "Resource_DiskInfo_Persistence", 1) + `,`,
		`Volume:` + strings.Replace(fmt.Sprintf("%v", this.Volume), "Volume", "Volume", 1) + `,`,
		`Source:` + strings.Replace(fmt.Sprintf("%v", this.Source), "Resource_DiskInfo_Source", "Resource_DiskInfo_Source", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_DiskInfo_Persistence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_DiskInfo_Persistence{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Principal:` + valueToStringMesos(this.Principal) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_DiskInfo_Source) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_DiskInfo_Source{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Path:` + strings.Replace(fmt.Sprintf("%v", this.Path), "Resource_DiskInfo_Source_Path", "Resource_DiskInfo_Source_Path", 1) + `,`,
		`Mount:` + strings.Replace(fmt.Sprintf("%v", this.Mount), "Resource_DiskInfo_Source_Mount", "Resource_DiskInfo_Source_Mount", 1) + `,`,
		`ID:` + valueToStringMesos(this.ID) + `,`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "Labels", "Labels", 1) + `,`,
		`Profile:` + valueToStringMesos(this.Profile) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_DiskInfo_Source_Path) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_DiskInfo_Source_Path{`,
		`Root:` + valueToStringMesos(this.Root) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_DiskInfo_Source_Mount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_DiskInfo_Source_Mount{`,
		`Root:` + valueToStringMesos(this.Root) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Resource_RevocableInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_RevocableInfo{`,
		`}`,
	}, "")
	return s
}
func (this *Resource_SharedInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Resource_SharedInfo{`,
		`}`,
	}, "")
	return s
}
func (this *TrafficControlStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrafficControlStatistics{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Backlog:` + valueToStringMesos(this.Backlog) + `,`,
		`Bytes:` + valueToStringMesos(this.Bytes) + `,`,
		`Drops:` + valueToStringMesos(this.Drops) + `,`,
		`Overlimits:` + valueToStringMesos(this.Overlimits) + `,`,
		`Packets:` + valueToStringMesos(this.Packets) + `,`,
		`Qlen:` + valueToStringMesos(this.Qlen) + `,`,
		`RateBPS:` + valueToStringMesos(this.RateBPS) + `,`,
		`RatePPS:` + valueToStringMesos(this.RatePPS) + `,`,
		`Requeues:` + valueToStringMesos(this.Requeues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpStatistics{`,
		`Forwarding:` + valueToStringMesos(this.Forwarding) + `,`,
		`DefaultTTL:` + valueToStringMesos(this.DefaultTTL) + `,`,
		`InReceives:` + valueToStringMesos(this.InReceives) + `,`,
		`InHdrErrors:` + valueToStringMesos(this.InHdrErrors) + `,`,
		`InAddrErrors:` + valueToStringMesos(this.InAddrErrors) + `,`,
		`ForwDatagrams:` + valueToStringMesos(this.ForwDatagrams) + `,`,
		`InUnknownProtos:` + valueToStringMesos(this.InUnknownProtos) + `,`,
		`InDiscards:` + valueToStringMesos(this.InDiscards) + `,`,
		`InDelivers:` + valueToStringMesos(this.InDelivers) + `,`,
		`OutRequests:` + valueToStringMesos(this.OutRequests) + `,`,
		`OutDiscards:` + valueToStringMesos(this.OutDiscards) + `,`,
		`OutNoRoutes:` + valueToStringMesos(this.OutNoRoutes) + `,`,
		`ReasmTimeout:` + valueToStringMesos(this.ReasmTimeout) + `,`,
		`ReasmReqds:` + valueToStringMesos(this.ReasmReqds) + `,`,
		`ReasmOKs:` + valueToStringMesos(this.ReasmOKs) + `,`,
		`ReasmFails:` + valueToStringMesos(this.ReasmFails) + `,`,
		`FragOKs:` + valueToStringMesos(this.FragOKs) + `,`,
		`FragFails:` + valueToStringMesos(this.FragFails) + `,`,
		`FragCreates:` + valueToStringMesos(this.FragCreates) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IcmpStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IcmpStatistics{`,
		`InMsgs:` + valueToStringMesos(this.InMsgs) + `,`,
		`InErrors:` + valueToStringMesos(this.InErrors) + `,`,
		`InCsumErrors:` + valueToStringMesos(this.InCsumErrors) + `,`,
		`InDestUnreachs:` + valueToStringMesos(this.InDestUnreachs) + `,`,
		`InTimeExcds:` + valueToStringMesos(this.InTimeExcds) + `,`,
		`InParmProbs:` + valueToStringMesos(this.InParmProbs) + `,`,
		`InSrcQuenchs:` + valueToStringMesos(this.InSrcQuenchs) + `,`,
		`InRedirects:` + valueToStringMesos(this.InRedirects) + `,`,
		`InEchos:` + valueToStringMesos(this.InEchos) + `,`,
		`InEchoReps:` + valueToStringMesos(this.InEchoReps) + `,`,
		`InTimestamps:` + valueToStringMesos(this.InTimestamps) + `,`,
		`InTimestampReps:` + valueToStringMesos(this.InTimestampReps) + `,`,
		`InAddrMasks:` + valueToStringMesos(this.InAddrMasks) + `,`,
		`InAddrMaskReps:` + valueToStringMesos(this.InAddrMaskReps) + `,`,
		`OutMsgs:` + valueToStringMesos(this.OutMsgs) + `,`,
		`OutErrors:` + valueToStringMesos(this.OutErrors) + `,`,
		`OutDestUnreachs:` + valueToStringMesos(this.OutDestUnreachs) + `,`,
		`OutTimeExcds:` + valueToStringMesos(this.OutTimeExcds) + `,`,
		`OutParmProbs:` + valueToStringMesos(this.OutParmProbs) + `,`,
		`OutSrcQuenchs:` + valueToStringMesos(this.OutSrcQuenchs) + `,`,
		`OutRedirects:` + valueToStringMesos(this.OutRedirects) + `,`,
		`OutEchos:` + valueToStringMesos(this.OutEchos) + `,`,
		`OutEchoReps:` + valueToStringMesos(this.OutEchoReps) + `,`,
		`OutTimestamps:` + valueToStringMesos(this.OutTimestamps) + `,`,
		`OutTimestampReps:` + valueToStringMesos(this.OutTimestampReps) + `,`,
		`OutAddrMasks:` + valueToStringMesos(this.OutAddrMasks) + `,`,
		`OutAddrMaskReps:` + valueToStringMesos(this.OutAddrMaskReps) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TcpStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TcpStatistics{`,
		`RtoAlgorithm:` + valueToStringMesos(this.RtoAlgorithm) + `,`,
		`RtoMin:` + valueToStringMesos(this.RtoMin) + `,`,
		`RtoMax:` + valueToStringMesos(this.RtoMax) + `,`,
		`MaxConn:` + valueToStringMesos(this.MaxConn) + `,`,
		`ActiveOpens:` + valueToStringMesos(this.ActiveOpens) + `,`,
		`PassiveOpens:` + valueToStringMesos(this.PassiveOpens) + `,`,
		`AttemptFails:` + valueToStringMesos(this.AttemptFails) + `,`,
		`EstabResets:` + valueToStringMesos(this.EstabResets) + `,`,
		`CurrEstab:` + valueToStringMesos(this.CurrEstab) + `,`,
		`InSegs:` + valueToStringMesos(this.InSegs) + `,`,
		`OutSegs:` + valueToStringMesos(this.OutSegs) + `,`,
		`RetransSegs:` + valueToStringMesos(this.RetransSegs) + `,`,
		`InErrs:` + valueToStringMesos(this.InErrs) + `,`,
		`OutRsts:` + valueToStringMesos(this.OutRsts) + `,`,
		`InCsumErrors:` + valueToStringMesos(this.InCsumErrors) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UdpStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UdpStatistics{`,
		`InDatagrams:` + valueToStringMesos(this.InDatagrams) + `,`,
		`NoPorts:` + valueToStringMesos(this.NoPorts) + `,`,
		`InErrors:` + valueToStringMesos(this.InErrors) + `,`,
		`OutDatagrams:` + valueToStringMesos(this.OutDatagrams) + `,`,
		`RcvbufErrors:` + valueToStringMesos(this.RcvbufErrors) + `,`,
		`SndbufErrors:` + valueToStringMesos(this.SndbufErrors) + `,`,
		`InCsumErrors:` + valueToStringMesos(this.InCsumErrors) + `,`,
		`IgnoredMulti:` + valueToStringMesos(this.IgnoredMulti) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SNMPStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SNMPStatistics{`,
		`IPStats:` + strings.Replace(fmt.Sprintf("%v", this.IPStats), "IpStatistics", "IpStatistics", 1) + `,`,
		`ICMPStats:` + strings.Replace(fmt.Sprintf("%v", this.ICMPStats), "IcmpStatistics", "IcmpStatistics", 1) + `,`,
		`TCPStats:` + strings.Replace(fmt.Sprintf("%v", this.TCPStats), "TcpStatistics", "TcpStatistics", 1) + `,`,
		`UDPStats:` + strings.Replace(fmt.Sprintf("%v", this.UDPStats), "UdpStatistics", "UdpStatistics", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiskStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiskStatistics{`,
		`Source:` + strings.Replace(fmt.Sprintf("%v", this.Source), "Resource_DiskInfo_Source", "Resource_DiskInfo_Source", 1) + `,`,
		`Persistence:` + strings.Replace(fmt.Sprintf("%v", this.Persistence), "Resource_DiskInfo_Persistence", "Resource_DiskInfo_Persistence", 1) + `,`,
		`LimitBytes:` + valueToStringMesos(this.LimitBytes) + `,`,
		`UsedBytes:` + valueToStringMesos(this.UsedBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceStatistics{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`CPUsUserTimeSecs:` + valueToStringMesos(this.CPUsUserTimeSecs) + `,`,
		`CPUsSystemTimeSecs:` + valueToStringMesos(this.CPUsSystemTimeSecs) + `,`,
		`CPUsLimit:` + valueToStringMesos(this.CPUsLimit) + `,`,
		`MemRSSBytes:` + valueToStringMesos(this.MemRSSBytes) + `,`,
		`MemLimitBytes:` + valueToStringMesos(this.MemLimitBytes) + `,`,
		`CPUsNrPeriods:` + valueToStringMesos(this.CPUsNrPeriods) + `,`,
		`CPUsNrThrottled:` + valueToStringMesos(this.CPUsNrThrottled) + `,`,
		`CPUsThrottledTimeSecs:` + valueToStringMesos(this.CPUsThrottledTimeSecs) + `,`,
		`MemFileBytes:` + valueToStringMesos(this.MemFileBytes) + `,`,
		`MemAnonBytes:` + valueToStringMesos(this.MemAnonBytes) + `,`,
		`MemMappedFileBytes:` + valueToStringMesos(this.MemMappedFileBytes) + `,`,
		`Perf:` + strings.Replace(fmt.Sprintf("%v", this.Perf), "PerfStatistics", "PerfStatistics", 1) + `,`,
		`NetRxPackets:` + valueToStringMesos(this.NetRxPackets) + `,`,
		`NetRxBytes:` + valueToStringMesos(this.NetRxBytes) + `,`,
		`NetRxErrors:` + valueToStringMesos(this.NetRxErrors) + `,`,
		`NetRxDropped:` + valueToStringMesos(this.NetRxDropped) + `,`,
		`NetTxPackets:` + valueToStringMesos(this.NetTxPackets) + `,`,
		`NetTxBytes:` + valueToStringMesos(this.NetTxBytes) + `,`,
		`NetTxErrors:` + valueToStringMesos(this.NetTxErrors) + `,`,
		`NetTxDropped:` + valueToStringMesos(this.NetTxDropped) + `,`,
		`NetTCPRttMicrosecsP50:` + valueToStringMesos(this.NetTCPRttMicrosecsP50) + `,`,
		`NetTCPRttMicrosecsP90:` + valueToStringMesos(this.NetTCPRttMicrosecsP90) + `,`,
		`NetTCPRttMicrosecsP95:` + valueToStringMesos(this.NetTCPRttMicrosecsP95) + `,`,
		`NetTCPRttMicrosecsP99:` + valueToStringMesos(this.NetTCPRttMicrosecsP99) + `,`,
		`DiskLimitBytes:` + valueToStringMesos(this.DiskLimitBytes) + `,`,
		`DiskUsedBytes:` + valueToStringMesos(this.DiskUsedBytes) + `,`,
		`NetTCPActiveConnections:` + valueToStringMesos(this.NetTCPActiveConnections) + `,`,
		`NetTCPTimeWaitConnections:` + valueToStringMesos(this.NetTCPTimeWaitConnections) + `,`,
		`Processes:` + valueToStringMesos(this.Processes) + `,`,
		`Threads:` + valueToStringMesos(this.Threads) + `,`,
		`MemLowPressureCounter:` + valueToStringMesos(this.MemLowPressureCounter) + `,`,
		`MemMediumPressureCounter:` + valueToStringMesos(this.MemMediumPressureCounter) + `,`,
		`MemCriticalPressureCounter:` + valueToStringMesos(this.MemCriticalPressureCounter) + `,`,
		`NetTrafficControlStatistics:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.NetTrafficControlStatistics), "TrafficControlStatistics", "TrafficControlStatistics", 1), `&`, ``, 1) + `,`,
		`MemTotalBytes:` + valueToStringMesos(this.MemTotalBytes) + `,`,
		`MemTotalMemswBytes:` + valueToStringMesos(this.MemTotalMemswBytes) + `,`,
		`MemSoftLimitBytes:` + valueToStringMesos(this.MemSoftLimitBytes) + `,`,
		`MemCacheBytes:` + valueToStringMesos(this.MemCacheBytes) + `,`,
		`MemSwapBytes:` + valueToStringMesos(this.MemSwapBytes) + `,`,
		`MemUnevictableBytes:` + valueToStringMesos(this.MemUnevictableBytes) + `,`,
		`NetSNMPStatistics:` + strings.Replace(fmt.Sprintf("%v", this.NetSNMPStatistics), "SNMPStatistics", "SNMPStatistics", 1) + `,`,
		`DiskStatistics:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.DiskStatistics), "DiskStatistics", "DiskStatistics", 1), `&`, ``, 1) + `,`,
		`BlkioStatistics:` + strings.Replace(fmt.Sprintf("%v", this.BlkioStatistics), "CgroupInfo_Blkio_Statistics", "CgroupInfo_Blkio_Statistics", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceUsage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceUsage{`,
		`Executors:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Executors), "ResourceUsage_Executor", "ResourceUsage_Executor", 1), `&`, ``, 1) + `,`,
		`Total:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Total), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceUsage_Executor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceUsage_Executor{`,
		`ExecutorInfo:` + strings.Replace(strings.Replace(this.ExecutorInfo.String(), "ExecutorInfo", "ExecutorInfo", 1), `&`, ``, 1) + `,`,
		`Allocated:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Allocated), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Statistics:` + strings.Replace(fmt.Sprintf("%v", this.Statistics), "ResourceStatistics", "ResourceStatistics", 1) + `,`,
		`ContainerID:` + strings.Replace(strings.Replace(this.ContainerID.String(), "ContainerID", "ContainerID", 1), `&`, ``, 1) + `,`,
		`Tasks:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Tasks), "ResourceUsage_Executor_Task", "ResourceUsage_Executor_Task", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceUsage_Executor_Task) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceUsage_Executor_Task{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ID:` + strings.Replace(strings.Replace(this.ID.String(), "TaskID", "TaskID", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PerfStatistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PerfStatistics{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`Cycles:` + valueToStringMesos(this.Cycles) + `,`,
		`StalledCyclesFrontend:` + valueToStringMesos(this.StalledCyclesFrontend) + `,`,
		`StalledCyclesBackend:` + valueToStringMesos(this.StalledCyclesBackend) + `,`,
		`Instructions:` + valueToStringMesos(this.Instructions) + `,`,
		`CacheReferences:` + valueToStringMesos(this.CacheReferences) + `,`,
		`CacheMisses:` + valueToStringMesos(this.CacheMisses) + `,`,
		`Branches:` + valueToStringMesos(this.Branches) + `,`,
		`BranchMisses:` + valueToStringMesos(this.BranchMisses) + `,`,
		`BusCycles:` + valueToStringMesos(this.BusCycles) + `,`,
		`RefCycles:` + valueToStringMesos(this.RefCycles) + `,`,
		`CPUClock:` + valueToStringMesos(this.CPUClock) + `,`,
		`TaskClock:` + valueToStringMesos(this.TaskClock) + `,`,
		`PageFaults:` + valueToStringMesos(this.PageFaults) + `,`,
		`MinorFaults:` + valueToStringMesos(this.MinorFaults) + `,`,
		`MajorFaults:` + valueToStringMesos(this.MajorFaults) + `,`,
		`ContextSwitches:` + valueToStringMesos(this.ContextSwitches) + `,`,
		`CPUMigrations:` + valueToStringMesos(this.CPUMigrations) + `,`,
		`AlignmentFaults:` + valueToStringMesos(this.AlignmentFaults) + `,`,
		`EmulationFaults:` + valueToStringMesos(this.EmulationFaults) + `,`,
		`L1DcacheLoads:` + valueToStringMesos(this.L1DcacheLoads) + `,`,
		`L1DcacheLoadMisses:` + valueToStringMesos(this.L1DcacheLoadMisses) + `,`,
		`L1DcacheStores:` + valueToStringMesos(this.L1DcacheStores) + `,`,
		`L1DcacheStoreMisses:` + valueToStringMesos(this.L1DcacheStoreMisses) + `,`,
		`L1DcachePrefetches:` + valueToStringMesos(this.L1DcachePrefetches) + `,`,
		`L1DcachePrefetchMisses:` + valueToStringMesos(this.L1DcachePrefetchMisses) + `,`,
		`L1IcacheLoads:` + valueToStringMesos(this.L1IcacheLoads) + `,`,
		`L1IcacheLoadMisses:` + valueToStringMesos(this.L1IcacheLoadMisses) + `,`,
		`L1IcachePrefetches:` + valueToStringMesos(this.L1IcachePrefetches) + `,`,
		`L1IcachePrefetchMisses:` + valueToStringMesos(this.L1IcachePrefetchMisses) + `,`,
		`LLCLoads:` + valueToStringMesos(this.LLCLoads) + `,`,
		`LLCLoadMisses:` + valueToStringMesos(this.LLCLoadMisses) + `,`,
		`LLCStores:` + valueToStringMesos(this.LLCStores) + `,`,
		`LLCStoreMisses:` + valueToStringMesos(this.LLCStoreMisses) + `,`,
		`LLCPrefetches:` + valueToStringMesos(this.LLCPrefetches) + `,`,
		`LLCPrefetchMisses:` + valueToStringMesos(this.LLCPrefetchMisses) + `,`,
		`DTLBLoads:` + valueToStringMesos(this.DTLBLoads) + `,`,
		`DTLBLoadMisses:` + valueToStringMesos(this.DTLBLoadMisses) + `,`,
		`DTLBStores:` + valueToStringMesos(this.DTLBStores) + `,`,
		`DTLBStoreMisses:` + valueToStringMesos(this.DTLBStoreMisses) + `,`,
		`DTLBPrefetches:` + valueToStringMesos(this.DTLBPrefetches) + `,`,
		`DTLBPrefetchMisses:` + valueToStringMesos(this.DTLBPrefetchMisses) + `,`,
		`ITLBLoads:` + valueToStringMesos(this.ITLBLoads) + `,`,
		`ITLBLoadMisses:` + valueToStringMesos(this.ITLBLoadMisses) + `,`,
		`BranchLoads:` + valueToStringMesos(this.BranchLoads) + `,`,
		`BranchLoadMisses:` + valueToStringMesos(this.BranchLoadMisses) + `,`,
		`NodeLoads:` + valueToStringMesos(this.NodeLoads) + `,`,
		`NodeLoadMisses:` + valueToStringMesos(this.NodeLoadMisses) + `,`,
		`NodeStores:` + valueToStringMesos(this.NodeStores) + `,`,
		`NodeStoreMisses:` + valueToStringMesos(this.NodeStoreMisses) + `,`,
		`NodePrefetches:` + valueToStringMesos(this.NodePrefetches) + `,`,
		`NodePrefetchMisses:` + valueToStringMesos(this.NodePrefetchMisses) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request{`,
		`AgentID:` + strings.Replace(fmt.Sprintf("%v", this.AgentID), "AgentID", "AgentID", 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer{`,
		`ID:` + strings.Replace(strings.Replace(this.ID.String(), "OfferID", "OfferID", 1), `&`, ``, 1) + `,`,
		`FrameworkID:` + strings.Replace(strings.Replace(this.FrameworkID.String(), "FrameworkID", "FrameworkID", 1), `&`, ``, 1) + `,`,
		`AgentID:` + strings.Replace(strings.Replace(this.AgentID.String(), "AgentID", "AgentID", 1), `&`, ``, 1) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`ExecutorIDs:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ExecutorIDs), "ExecutorID", "ExecutorID", 1), `&`, ``, 1) + `,`,
		`Attributes:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Attributes), "Attribute", "Attribute", 1), `&`, ``, 1) + `,`,
		`URL:` + strings.Replace(fmt.Sprintf("%v", this.URL), "URL", "URL", 1) + `,`,
		`Unavailability:` + strings.Replace(fmt.Sprintf("%v", this.Unavailability), "Unavailability", "Unavailability", 1) + `,`,
		`AllocationInfo:` + strings.Replace(fmt.Sprintf("%v", this.AllocationInfo), "Resource_AllocationInfo", "Resource_AllocationInfo", 1) + `,`,
		`Domain:` + strings.Replace(fmt.Sprintf("%v", this.Domain), "DomainInfo", "DomainInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Launch:` + strings.Replace(fmt.Sprintf("%v", this.Launch), "Offer_Operation_Launch", "Offer_Operation_Launch", 1) + `,`,
		`Reserve:` + strings.Replace(fmt.Sprintf("%v", this.Reserve), "Offer_Operation_Reserve", "Offer_Operation_Reserve", 1) + `,`,
		`Unreserve:` + strings.Replace(fmt.Sprintf("%v", this.Unreserve), "Offer_Operation_Unreserve", "Offer_Operation_Unreserve", 1) + `,`,
		`Create:` + strings.Replace(fmt.Sprintf("%v", this.Create), "Offer_Operation_Create", "Offer_Operation_Create", 1) + `,`,
		`Destroy:` + strings.Replace(fmt.Sprintf("%v", this.Destroy), "Offer_Operation_Destroy", "Offer_Operation_Destroy", 1) + `,`,
		`LaunchGroup:` + strings.Replace(fmt.Sprintf("%v", this.LaunchGroup), "Offer_Operation_LaunchGroup", "Offer_Operation_LaunchGroup", 1) + `,`,
		`ID:` + strings.Replace(fmt.Sprintf("%v", this.ID), "OperationID", "OperationID", 1) + `,`,
		`GrowVolume:` + strings.Replace(fmt.Sprintf("%v", this.GrowVolume), "Offer_Operation_GrowVolume", "Offer_Operation_GrowVolume", 1) + `,`,
		`ShrinkVolume:` + strings.Replace(fmt.Sprintf("%v", this.ShrinkVolume), "Offer_Operation_ShrinkVolume", "Offer_Operation_ShrinkVolume", 1) + `,`,
		`CreateDisk:` + strings.Replace(fmt.Sprintf("%v", this.CreateDisk), "Offer_Operation_CreateDisk", "Offer_Operation_CreateDisk", 1) + `,`,
		`DestroyDisk:` + strings.Replace(fmt.Sprintf("%v", this.DestroyDisk), "Offer_Operation_DestroyDisk", "Offer_Operation_DestroyDisk", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_Launch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_Launch{`,
		`TaskInfos:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TaskInfos), "TaskInfo", "TaskInfo", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_LaunchGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_LaunchGroup{`,
		`Executor:` + strings.Replace(strings.Replace(this.Executor.String(), "ExecutorInfo", "ExecutorInfo", 1), `&`, ``, 1) + `,`,
		`TaskGroup:` + strings.Replace(strings.Replace(this.TaskGroup.String(), "TaskGroupInfo", "TaskGroupInfo", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_Reserve) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_Reserve{`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_Unreserve) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_Unreserve{`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_Create) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_Create{`,
		`Volumes:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Volumes), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_Destroy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_Destroy{`,
		`Volumes:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Volumes), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_GrowVolume) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_GrowVolume{`,
		`Volume:` + strings.Replace(strings.Replace(this.Volume.String(), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Addition:` + strings.Replace(strings.Replace(this.Addition.String(), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_ShrinkVolume) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_ShrinkVolume{`,
		`Volume:` + strings.Replace(strings.Replace(this.Volume.String(), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Subtract:` + strings.Replace(strings.Replace(this.Subtract.String(), "Value_Scalar", "Value_Scalar", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_CreateDisk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_CreateDisk{`,
		`Source:` + strings.Replace(strings.Replace(this.Source.String(), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`TargetType:` + fmt.Sprintf("%v", this.TargetType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Offer_Operation_DestroyDisk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Offer_Operation_DestroyDisk{`,
		`Source:` + strings.Replace(strings.Replace(this.Source.String(), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InverseOffer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InverseOffer{`,
		`OfferID:` + strings.Replace(strings.Replace(this.OfferID.String(), "OfferID", "OfferID", 1), `&`, ``, 1) + `,`,
		`URL:` + strings.Replace(fmt.Sprintf("%v", this.URL), "URL", "URL", 1) + `,`,
		`FrameworkID:` + strings.Replace(strings.Replace(this.FrameworkID.String(), "FrameworkID", "FrameworkID", 1), `&`, ``, 1) + `,`,
		`AgentID:` + strings.Replace(fmt.Sprintf("%v", this.AgentID), "AgentID", "AgentID", 1) + `,`,
		`Unavailability:` + strings.Replace(strings.Replace(this.Unavailability.String(), "Unavailability", "Unavailability", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`TaskID:` + strings.Replace(strings.Replace(this.TaskID.String(), "TaskID", "TaskID", 1), `&`, ``, 1) + `,`,
		`AgentID:` + strings.Replace(strings.Replace(this.AgentID.String(), "AgentID", "AgentID", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Executor:` + strings.Replace(fmt.Sprintf("%v", this.Executor), "ExecutorInfo", "ExecutorInfo", 1) + `,`,
		`Data:` + valueToStringMesos(this.Data) + `,`,
		`Command:` + strings.Replace(fmt.Sprintf("%v", this.Command), "CommandInfo", "CommandInfo", 1) + `,`,
		`HealthCheck:` + strings.Replace(fmt.Sprintf("%v", this.HealthCheck), "HealthCheck", "HealthCheck", 1) + `,`,
		`Container:` + strings.Replace(fmt.Sprintf("%v", this.Container), "ContainerInfo", "ContainerInfo", 1) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`Discovery:` + strings.Replace(fmt.Sprintf("%v", this.Discovery), "DiscoveryInfo", "DiscoveryInfo", 1) + `,`,
		`KillPolicy:` + strings.Replace(fmt.Sprintf("%v", this.KillPolicy), "KillPolicy", "KillPolicy", 1) + `,`,
		`Check:` + strings.Replace(fmt.Sprintf("%v", this.Check), "CheckInfo", "CheckInfo", 1) + `,`,
		`MaxCompletionTime:` + strings.Replace(fmt.Sprintf("%v", this.MaxCompletionTime), "DurationInfo", "DurationInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskGroupInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskGroupInfo{`,
		`Tasks:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Tasks), "TaskInfo", "TaskInfo", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Task) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Task{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`TaskID:` + strings.Replace(strings.Replace(this.TaskID.String(), "TaskID", "TaskID", 1), `&`, ``, 1) + `,`,
		`FrameworkID:` + strings.Replace(strings.Replace(this.FrameworkID.String(), "FrameworkID", "FrameworkID", 1), `&`, ``, 1) + `,`,
		`ExecutorID:` + strings.Replace(fmt.Sprintf("%v", this.ExecutorID), "ExecutorID", "ExecutorID", 1) + `,`,
		`AgentID:` + strings.Replace(strings.Replace(this.AgentID.String(), "AgentID", "AgentID", 1), `&`, ``, 1) + `,`,
		`State:` + valueToStringMesos(this.State) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`Statuses:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Statuses), "TaskStatus", "TaskStatus", 1), `&`, ``, 1) + `,`,
		`StatusUpdateState:` + valueToStringMesos(this.StatusUpdateState) + `,`,
		`StatusUpdateUUID:` + valueToStringMesos(this.StatusUpdateUUID) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`Discovery:` + strings.Replace(fmt.Sprintf("%v", this.Discovery), "DiscoveryInfo", "DiscoveryInfo", 1) + `,`,
		`Container:` + strings.Replace(fmt.Sprintf("%v", this.Container), "ContainerInfo", "ContainerInfo", 1) + `,`,
		`User:` + valueToStringMesos(this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskResourceLimitation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskResourceLimitation{`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UUID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UUID{`,
		`Value:` + valueToStringMesos(this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Operation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Operation{`,
		`FrameworkID:` + strings.Replace(fmt.Sprintf("%v", this.FrameworkID), "FrameworkID", "FrameworkID", 1) + `,`,
		`AgentID:` + strings.Replace(fmt.Sprintf("%v", this.AgentID), "AgentID", "AgentID", 1) + `,`,
		`Info:` + strings.Replace(strings.Replace(this.Info.String(), "Offer_Operation", "Offer_Operation", 1), `&`, ``, 1) + `,`,
		`LatestStatus:` + strings.Replace(strings.Replace(this.LatestStatus.String(), "OperationStatus", "OperationStatus", 1), `&`, ``, 1) + `,`,
		`Statuses:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Statuses), "OperationStatus", "OperationStatus", 1), `&`, ``, 1) + `,`,
		`UUID:` + strings.Replace(strings.Replace(this.UUID.String(), "UUID", "UUID", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OperationStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OperationStatus{`,
		`OperationID:` + strings.Replace(fmt.Sprintf("%v", this.OperationID), "OperationID", "OperationID", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Message:` + valueToStringMesos(this.Message) + `,`,
		`ConvertedResources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ConvertedResources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`UUID:` + strings.Replace(fmt.Sprintf("%v", this.UUID), "UUID", "UUID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckStatusInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckStatusInfo{`,
		`Type:` + valueToStringMesos(this.Type) + `,`,
		`Command:` + strings.Replace(fmt.Sprintf("%v", this.Command), "CheckStatusInfo_Command", "CheckStatusInfo_Command", 1) + `,`,
		`HTTP:` + strings.Replace(fmt.Sprintf("%v", this.HTTP), "CheckStatusInfo_Http", "CheckStatusInfo_Http", 1) + `,`,
		`TCP:` + strings.Replace(fmt.Sprintf("%v", this.TCP), "CheckStatusInfo_Tcp", "CheckStatusInfo_Tcp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckStatusInfo_Command) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckStatusInfo_Command{`,
		`ExitCode:` + valueToStringMesos(this.ExitCode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckStatusInfo_Http) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckStatusInfo_Http{`,
		`StatusCode:` + valueToStringMesos(this.StatusCode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckStatusInfo_Tcp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckStatusInfo_Tcp{`,
		`Succeeded:` + valueToStringMesos(this.Succeeded) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TaskStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TaskStatus{`,
		`TaskID:` + strings.Replace(strings.Replace(this.TaskID.String(), "TaskID", "TaskID", 1), `&`, ``, 1) + `,`,
		`State:` + valueToStringMesos(this.State) + `,`,
		`Data:` + valueToStringMesos(this.Data) + `,`,
		`Message:` + valueToStringMesos(this.Message) + `,`,
		`AgentID:` + strings.Replace(fmt.Sprintf("%v", this.AgentID), "AgentID", "AgentID", 1) + `,`,
		`Timestamp:` + valueToStringMesos(this.Timestamp) + `,`,
		`ExecutorID:` + strings.Replace(fmt.Sprintf("%v", this.ExecutorID), "ExecutorID", "ExecutorID", 1) + `,`,
		`Healthy:` + valueToStringMesos(this.Healthy) + `,`,
		`Source:` + valueToStringMesos(this.Source) + `,`,
		`Reason:` + valueToStringMesos(this.Reason) + `,`,
		`UUID:` + valueToStringMesos(this.UUID) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`ContainerStatus:` + strings.Replace(fmt.Sprintf("%v", this.ContainerStatus), "ContainerStatus", "ContainerStatus", 1) + `,`,
		`UnreachableTime:` + strings.Replace(fmt.Sprintf("%v", this.UnreachableTime), "TimeInfo", "TimeInfo", 1) + `,`,
		`CheckStatus:` + strings.Replace(fmt.Sprintf("%v", this.CheckStatus), "CheckStatusInfo", "CheckStatusInfo", 1) + `,`,
		`Limitation:` + strings.Replace(fmt.Sprintf("%v", this.Limitation), "TaskResourceLimitation", "TaskResourceLimitation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Filters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Filters{`,
		`RefuseSeconds:` + valueToStringMesos(this.RefuseSeconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Environment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Environment{`,
		`Variables:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Variables), "Environment_Variable", "Environment_Variable", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Environment_Variable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Environment_Variable{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + valueToStringMesos(this.Value) + `,`,
		`Type:` + valueToStringMesos(this.Type) + `,`,
		`Secret:` + strings.Replace(fmt.Sprintf("%v", this.Secret), "Secret", "Secret", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Parameter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Parameter{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Parameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Parameters{`,
		`Parameter:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Parameter), "Parameter", "Parameter", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Credential) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Credential{`,
		`Principal:` + fmt.Sprintf("%v", this.Principal) + `,`,
		`Secret:` + valueToStringMesos(this.Secret) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Credentials) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Credentials{`,
		`Credentials:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Credentials), "Credential", "Credential", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Secret) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Secret{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Reference:` + strings.Replace(fmt.Sprintf("%v", this.Reference), "Secret_Reference", "Secret_Reference", 1) + `,`,
		`Value:` + strings.Replace(fmt.Sprintf("%v", this.Value), "Secret_Value", "Secret_Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Secret_Reference) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Secret_Reference{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Key:` + valueToStringMesos(this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Secret_Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Secret_Value{`,
		`Data:` + valueToStringMesos(this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimit{`,
		`QPS:` + valueToStringMesos(this.QPS) + `,`,
		`Principal:` + fmt.Sprintf("%v", this.Principal) + `,`,
		`Capacity:` + valueToStringMesos(this.Capacity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RateLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RateLimits{`,
		`Limits:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Limits), "RateLimit", "RateLimit", 1), `&`, ``, 1) + `,`,
		`AggregateDefaultQPS:` + valueToStringMesos(this.AggregateDefaultQPS) + `,`,
		`AggregateDefaultCapacity:` + valueToStringMesos(this.AggregateDefaultCapacity) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Image) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Image{`,
		`Type:` + valueToStringMesos(this.Type) + `,`,
		`Appc:` + strings.Replace(fmt.Sprintf("%v", this.Appc), "Image_Appc", "Image_Appc", 1) + `,`,
		`Docker:` + strings.Replace(fmt.Sprintf("%v", this.Docker), "Image_Docker", "Image_Docker", 1) + `,`,
		`Cached:` + valueToStringMesos(this.Cached) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Image_Appc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Image_Appc{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ID:` + valueToStringMesos(this.ID) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Image_Docker) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Image_Docker{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Credential:` + strings.Replace(fmt.Sprintf("%v", this.Credential), "Credential", "Credential", 1) + `,`,
		`Config:` + strings.Replace(fmt.Sprintf("%v", this.Config), "Secret", "Secret", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MountPropagation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MountPropagation{`,
		`Mode:` + valueToStringMesos(this.Mode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Volume) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Volume{`,
		`ContainerPath:` + fmt.Sprintf("%v", this.ContainerPath) + `,`,
		`HostPath:` + valueToStringMesos(this.HostPath) + `,`,
		`Mode:` + valueToStringMesos(this.Mode) + `,`,
		`Image:` + strings.Replace(fmt.Sprintf("%v", this.Image), "Image", "Image", 1) + `,`,
		`Source:` + strings.Replace(fmt.Sprintf("%v", this.Source), "Volume_Source", "Volume_Source", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Volume_Source) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Volume_Source{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`DockerVolume:` + strings.Replace(fmt.Sprintf("%v", this.DockerVolume), "Volume_Source_DockerVolume", "Volume_Source_DockerVolume", 1) + `,`,
		`SandboxPath:` + strings.Replace(fmt.Sprintf("%v", this.SandboxPath), "Volume_Source_SandboxPath", "Volume_Source_SandboxPath", 1) + `,`,
		`Secret:` + strings.Replace(fmt.Sprintf("%v", this.Secret), "Secret", "Secret", 1) + `,`,
		`HostPath:` + strings.Replace(fmt.Sprintf("%v", this.HostPath), "Volume_Source_HostPath", "Volume_Source_HostPath", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Volume_Source_DockerVolume) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Volume_Source_DockerVolume{`,
		`Driver:` + valueToStringMesos(this.Driver) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DriverOptions:` + strings.Replace(fmt.Sprintf("%v", this.DriverOptions), "Parameters", "Parameters", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Volume_Source_HostPath) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Volume_Source_HostPath{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`MountPropagation:` + strings.Replace(fmt.Sprintf("%v", this.MountPropagation), "MountPropagation", "MountPropagation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Volume_Source_SandboxPath) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Volume_Source_SandboxPath{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInfo{`,
		`Groups:` + fmt.Sprintf("%v", this.Groups) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`IPAddresses:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IPAddresses), "NetworkInfo_IPAddress", "NetworkInfo_IPAddress", 1), `&`, ``, 1) + `,`,
		`Name:` + valueToStringMesos(this.Name) + `,`,
		`PortMappings:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.PortMappings), "NetworkInfo_PortMapping", "NetworkInfo_PortMapping", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInfo_IPAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInfo_IPAddress{`,
		`Protocol:` + valueToStringMesos(this.Protocol) + `,`,
		`IPAddress:` + valueToStringMesos(this.IPAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInfo_PortMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInfo_PortMapping{`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`Protocol:` + valueToStringMesos(this.Protocol) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CapabilityInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapabilityInfo{`,
		`Capabilities:` + fmt.Sprintf("%v", this.Capabilities) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinuxInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinuxInfo{`,
		`CapabilityInfo:` + strings.Replace(fmt.Sprintf("%v", this.CapabilityInfo), "CapabilityInfo", "CapabilityInfo", 1) + `,`,
		`BoundingCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.BoundingCapabilities), "CapabilityInfo", "CapabilityInfo", 1) + `,`,
		`EffectiveCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.EffectiveCapabilities), "CapabilityInfo", "CapabilityInfo", 1) + `,`,
		`SharePIDNamespace:` + valueToStringMesos(this.SharePIDNamespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RLimitInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RLimitInfo{`,
		`Rlimits:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Rlimits), "RLimitInfo_RLimit", "RLimitInfo_RLimit", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RLimitInfo_RLimit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RLimitInfo_RLimit{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Hard:` + valueToStringMesos(this.Hard) + `,`,
		`Soft:` + valueToStringMesos(this.Soft) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TTYInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TTYInfo{`,
		`WindowSize:` + strings.Replace(fmt.Sprintf("%v", this.WindowSize), "TTYInfo_WindowSize", "TTYInfo_WindowSize", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TTYInfo_WindowSize) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TTYInfo_WindowSize{`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`Columns:` + fmt.Sprintf("%v", this.Columns) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerInfo{`,
		`Type:` + valueToStringMesos(this.Type) + `,`,
		`Volumes:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Volumes), "Volume", "Volume", 1), `&`, ``, 1) + `,`,
		`Docker:` + strings.Replace(fmt.Sprintf("%v", this.Docker), "ContainerInfo_DockerInfo", "ContainerInfo_DockerInfo", 1) + `,`,
		`Hostname:` + valueToStringMesos(this.Hostname) + `,`,
		`Mesos:` + strings.Replace(fmt.Sprintf("%v", this.Mesos), "ContainerInfo_MesosInfo", "ContainerInfo_MesosInfo", 1) + `,`,
		`NetworkInfos:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.NetworkInfos), "NetworkInfo", "NetworkInfo", 1), `&`, ``, 1) + `,`,
		`LinuxInfo:` + strings.Replace(fmt.Sprintf("%v", this.LinuxInfo), "LinuxInfo", "LinuxInfo", 1) + `,`,
		`RlimitInfo:` + strings.Replace(fmt.Sprintf("%v", this.RlimitInfo), "RLimitInfo", "RLimitInfo", 1) + `,`,
		`TTYInfo:` + strings.Replace(fmt.Sprintf("%v", this.TTYInfo), "TTYInfo", "TTYInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerInfo_DockerInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerInfo_DockerInfo{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`Network:` + valueToStringMesos(this.Network) + `,`,
		`PortMappings:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.PortMappings), "ContainerInfo_DockerInfo_PortMapping", "ContainerInfo_DockerInfo_PortMapping", 1), `&`, ``, 1) + `,`,
		`Privileged:` + valueToStringMesos(this.Privileged) + `,`,
		`Parameters:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Parameters), "Parameter", "Parameter", 1), `&`, ``, 1) + `,`,
		`ForcePullImage:` + valueToStringMesos(this.ForcePullImage) + `,`,
		`VolumeDriver:` + valueToStringMesos(this.VolumeDriver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerInfo_DockerInfo_PortMapping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerInfo_DockerInfo_PortMapping{`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`Protocol:` + valueToStringMesos(this.Protocol) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerInfo_MesosInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerInfo_MesosInfo{`,
		`Image:` + strings.Replace(fmt.Sprintf("%v", this.Image), "Image", "Image", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerStatus{`,
		`NetworkInfos:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.NetworkInfos), "NetworkInfo", "NetworkInfo", 1), `&`, ``, 1) + `,`,
		`CgroupInfo:` + strings.Replace(fmt.Sprintf("%v", this.CgroupInfo), "CgroupInfo", "CgroupInfo", 1) + `,`,
		`ExecutorPID:` + valueToStringMesos(this.ExecutorPID) + `,`,
		`ContainerID:` + strings.Replace(fmt.Sprintf("%v", this.ContainerID), "ContainerID", "ContainerID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo{`,
		`NetCLS:` + strings.Replace(fmt.Sprintf("%v", this.NetCLS), "CgroupInfo_NetCls", "CgroupInfo_NetCls", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo_Blkio) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo_Blkio{`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo_Blkio_Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo_Blkio_Value{`,
		`Op:` + valueToStringMesos(this.Op) + `,`,
		`Value:` + valueToStringMesos(this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo_Blkio_CFQ) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo_Blkio_CFQ{`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo_Blkio_CFQ_Statistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo_Blkio_CFQ_Statistics{`,
		`Device:` + strings.Replace(fmt.Sprintf("%v", this.Device), "Device_Number", "Device_Number", 1) + `,`,
		`Sectors:` + valueToStringMesos(this.Sectors) + `,`,
		`Time:` + valueToStringMesos(this.Time) + `,`,
		`IOServiced:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IOServiced), "CgroupInfo_Blkio_Value", "CgroupInfo_Blkio_Value", 1), `&`, ``, 1) + `,`,
		`IOServiceBytes:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IOServiceBytes), "CgroupInfo_Blkio_Value", "CgroupInfo_Blkio_Value", 1), `&`, ``, 1) + `,`,
		`IOServiceTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IOServiceTime), "CgroupInfo_Blkio_Value", "CgroupInfo_Blkio_Value", 1), `&`, ``, 1) + `,`,
		`IOWaitTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IOWaitTime), "CgroupInfo_Blkio_Value", "CgroupInfo_Blkio_Value", 1), `&`, ``, 1) + `,`,
		`IOMerged:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IOMerged), "CgroupInfo_Blkio_Value", "CgroupInfo_Blkio_Value", 1), `&`, ``, 1) + `,`,
		`IOQueued:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IOQueued), "CgroupInfo_Blkio_Value", "CgroupInfo_Blkio_Value", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo_Blkio_Throttling) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo_Blkio_Throttling{`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo_Blkio_Throttling_Statistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo_Blkio_Throttling_Statistics{`,
		`Device:` + strings.Replace(fmt.Sprintf("%v", this.Device), "Device_Number", "Device_Number", 1) + `,`,
		`IOServiced:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IOServiced), "CgroupInfo_Blkio_Value", "CgroupInfo_Blkio_Value", 1), `&`, ``, 1) + `,`,
		`IOServiceBytes:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.IOServiceBytes), "CgroupInfo_Blkio_Value", "CgroupInfo_Blkio_Value", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo_Blkio_Statistics) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo_Blkio_Statistics{`,
		`CFQ:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.CFQ), "CgroupInfo_Blkio_CFQ_Statistics", "CgroupInfo_Blkio_CFQ_Statistics", 1), `&`, ``, 1) + `,`,
		`CFQRecursive:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.CFQRecursive), "CgroupInfo_Blkio_CFQ_Statistics", "CgroupInfo_Blkio_CFQ_Statistics", 1), `&`, ``, 1) + `,`,
		`Throttling:` + strings.Replace(fmt.Sprintf("%v", this.Throttling), "CgroupInfo_Blkio_Throttling_Statistics", "CgroupInfo_Blkio_Throttling_Statistics", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CgroupInfo_NetCls) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CgroupInfo_NetCls{`,
		`ClassID:` + valueToStringMesos(this.ClassID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Labels) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Labels{`,
		`Labels:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Labels), "Label", "Label", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Label) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Label{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + valueToStringMesos(this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Port) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Port{`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`Name:` + valueToStringMesos(this.Name) + `,`,
		`Protocol:` + valueToStringMesos(this.Protocol) + `,`,
		`Visibility:` + valueToStringMesos(this.Visibility) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ports) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ports{`,
		`Ports:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Ports), "Port", "Port", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DiscoveryInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DiscoveryInfo{`,
		`Visibility:` + fmt.Sprintf("%v", this.Visibility) + `,`,
		`Name:` + valueToStringMesos(this.Name) + `,`,
		`Environment:` + valueToStringMesos(this.Environment) + `,`,
		`Location:` + valueToStringMesos(this.Location) + `,`,
		`Version:` + valueToStringMesos(this.Version) + `,`,
		`Ports:` + strings.Replace(fmt.Sprintf("%v", this.Ports), "Ports", "Ports", 1) + `,`,
		`Labels:` + strings.Replace(fmt.Sprintf("%v", this.Labels), "Labels", "Labels", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WeightInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WeightInfo{`,
		`Weight:` + fmt.Sprintf("%v", this.Weight) + `,`,
		`Role:` + valueToStringMesos(this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VersionInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VersionInfo{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`BuildDate:` + valueToStringMesos(this.BuildDate) + `,`,
		`BuildTime:` + valueToStringMesos(this.BuildTime) + `,`,
		`BuildUser:` + valueToStringMesos(this.BuildUser) + `,`,
		`GitSHA:` + valueToStringMesos(this.GitSHA) + `,`,
		`GitBranch:` + valueToStringMesos(this.GitBranch) + `,`,
		`GitTag:` + valueToStringMesos(this.GitTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Flag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Flag{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + valueToStringMesos(this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Role) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Role{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Weight:` + fmt.Sprintf("%v", this.Weight) + `,`,
		`Frameworks:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Frameworks), "FrameworkID", "FrameworkID", 1), `&`, ``, 1) + `,`,
		`Resources:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Resources), "Resource", "Resource", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Metric) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Metric{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + valueToStringMesos(this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileInfo{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Nlink:` + valueToStringMesos(this.Nlink) + `,`,
		`Size:` + valueToStringMesos(this.Size) + `,`,
		`Mtime:` + strings.Replace(fmt.Sprintf("%v", this.Mtime), "TimeInfo", "TimeInfo", 1) + `,`,
		`Mode:` + valueToStringMesos(this.Mode) + `,`,
		`UID:` + valueToStringMesos(this.UID) + `,`,
		`GID:` + valueToStringMesos(this.GID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Device) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Device{`,
		`Path:` + valueToStringMesos(this.Path) + `,`,
		`Number:` + strings.Replace(fmt.Sprintf("%v", this.Number), "Device_Number", "Device_Number", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Device_Number) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Device_Number{`,
		`MajorNumber:` + valueToStringMesos(this.MajorNumber) + `,`,
		`MinorNumber:` + valueToStringMesos(this.MinorNumber) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceAccess) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceAccess{`,
		`Device:` + strings.Replace(strings.Replace(this.Device.String(), "Device", "Device", 1), `&`, ``, 1) + `,`,
		`Access:` + strings.Replace(strings.Replace(this.Access.String(), "DeviceAccess_Access", "DeviceAccess_Access", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceAccess_Access) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceAccess_Access{`,
		`Read:` + valueToStringMesos(this.Read) + `,`,
		`Write:` + valueToStringMesos(this.Write) + `,`,
		`Mknod:` + valueToStringMesos(this.Mknod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeviceWhitelist) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeviceWhitelist{`,
		`AllowedDevices:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.AllowedDevices), "DeviceAccess", "DeviceAccess", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMesos(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *FrameworkID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrameworkID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrameworkID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfferID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfferID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfferID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &ContainerID{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceProviderID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceProviderID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceProviderID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanoseconds", wireType)
			}
			m.Nanoseconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanoseconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("nanoseconds")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DurationInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DurationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DurationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanoseconds", wireType)
			}
			m.Nanoseconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanoseconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("nanoseconds")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IP = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URL) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = append(m.Query, Parameter{})
			if err := m.Query[len(m.Query)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fragment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Fragment = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("scheme")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("address")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Unavailability) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unavailability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unavailability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &DurationInfo{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("start")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MachineID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MachineID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IP = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MachineInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MachineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MachineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v MachineInfo_Mode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (MachineInfo_Mode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unavailability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unavailability == nil {
				m.Unavailability = &Unavailability{}
			}
			if err := m.Unavailability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrameworkInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrameworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrameworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &FrameworkID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailoverTimeout", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.FailoverTimeout = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Checkpoint = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Role = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Principal = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebUiURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WebUiURL = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capabilities = append(m.Capabilities, FrameworkInfo_Capability{})
			if err := m.Capabilities[len(m.Capabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("user")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrameworkInfo_Capability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Capability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Capability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FrameworkInfo_Capability_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (CheckInfo_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &CheckInfo_Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HTTP == nil {
				m.HTTP = &CheckInfo_Http{}
			}
			if err := m.HTTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelaySeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.DelaySeconds = &v2
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.IntervalSeconds = &v2
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.TimeoutSeconds = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TCP == nil {
				m.TCP = &CheckInfo_Tcp{}
			}
			if err := m.TCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckInfo_Command) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("command")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckInfo_Http) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Http: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Http: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckInfo_Tcp) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tcp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tcp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HTTP == nil {
				m.HTTP = &HealthCheck_HTTPCheckInfo{}
			}
			if err := m.HTTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelaySeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.DelaySeconds = &v2
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.IntervalSeconds = &v2
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.TimeoutSeconds = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveFailures", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsecutiveFailures = &v
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriodSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.GracePeriodSeconds = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &CommandInfo{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (HealthCheck_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TCP == nil {
				m.TCP = &HealthCheck_TCPCheckInfo{}
			}
			if err := m.TCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck_HTTPCheckInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPCheckInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPCheckInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Scheme = &s
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMesos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Statuses = append(m.Statuses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMesos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMesos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMesos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Statuses = append(m.Statuses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var v NetworkInfo_Protocol
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (NetworkInfo_Protocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protocol = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheck_TCPCheckInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TCPCheckInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TCPCheckInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var v NetworkInfo_Protocol
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (NetworkInfo_Protocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protocol = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KillPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KillPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KillPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GracePeriod == nil {
				m.GracePeriod = &DurationInfo{}
			}
			if err := m.GracePeriod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, CommandInfo_URI{})
			if err := m.URIs[len(m.URIs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Environment == nil {
				m.Environment = &Environment{}
			}
			if err := m.Environment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.User = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shell", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Shell = &b
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandInfo_URI) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Executable = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extract", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Extract = &b
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Cache = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OutputFile = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecutorID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &CommandInfo{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameworkID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FrameworkID == nil {
				m.FrameworkID = &FrameworkID{}
			}
			if err := m.FrameworkID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Source = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &ContainerInfo{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discovery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Discovery == nil {
				m.Discovery = &DiscoveryInfo{}
			}
			if err := m.Discovery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShutdownGracePeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShutdownGracePeriod == nil {
				m.ShutdownGracePeriod = &DurationInfo{}
			}
			if err := m.ShutdownGracePeriod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ExecutorInfo_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("executor_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FaultDomain == nil {
				m.FaultDomain = &DomainInfo_FaultDomain{}
			}
			if err := m.FaultDomain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainInfo_FaultDomain) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FaultDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FaultDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Zone.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("region")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("zone")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainInfo_FaultDomain_RegionInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainInfo_FaultDomain_ZoneInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZoneInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZoneInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MasterInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MasterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MasterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			m.IP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IP |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PID = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &DomainInfo{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capabilities = append(m.Capabilities, MasterInfo_Capability{})
			if err := m.Capabilities[len(m.Capabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ip")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MasterInfo_Capability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Capability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Capability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MasterInfo_Capability_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &AgentID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &DomainInfo{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("hostname")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentInfo_Capability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Capability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Capability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (AgentInfo_Capability_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSIPluginContainerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSIPluginContainerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSIPluginContainerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v CSIPluginContainerInfo_Service
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMesos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CSIPluginContainerInfo_Service(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Services = append(m.Services, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMesos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMesos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CSIPluginContainerInfo_Service
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMesos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CSIPluginContainerInfo_Service(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Services = append(m.Services, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &CommandInfo{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &ContainerInfo{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSIPluginInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSIPluginInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSIPluginInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, CSIPluginContainerInfo{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceProviderInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceProviderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceProviderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &ResourceProviderID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultReservations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultReservations = append(m.DefaultReservations, Resource_ReservationInfo{})
			if err := m.DefaultReservations[len(m.DefaultReservations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Storage == nil {
				m.Storage = &ResourceProviderInfo_Storage{}
			}
			if err := m.Storage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceProviderInfo_Storage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Storage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Storage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Plugin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("plugin")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Value_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scalar == nil {
				m.Scalar = &Value_Scalar{}
			}
			if err := m.Scalar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ranges == nil {
				m.Ranges = &Value_Ranges{}
			}
			if err := m.Ranges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = &Value_Set{}
			}
			if err := m.Set.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Text == nil {
				m.Text = &Value_Text{}
			}
			if err := m.Text.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_Scalar) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Scalar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Scalar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_Range) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("begin")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("end")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_Ranges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ranges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ranges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Range = append(m.Range, Value_Range{})
			if err := m.Range[len(m.Range)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_Set) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Set: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Set: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value_Text) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Text: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Text: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attribute) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Value_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scalar == nil {
				m.Scalar = &Value_Scalar{}
			}
			if err := m.Scalar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ranges == nil {
				m.Ranges = &Value_Ranges{}
			}
			if err := m.Ranges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Text == nil {
				m.Text = &Value_Text{}
			}
			if err := m.Text.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = &Value_Set{}
			}
			if err := m.Set.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Value_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Value_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scalar == nil {
				m.Scalar = &Value_Scalar{}
			}
			if err := m.Scalar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ranges == nil {
				m.Ranges = &Value_Ranges{}
			}
			if err := m.Ranges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = &Value_Set{}
			}
			if err := m.Set.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Role = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disk == nil {
				m.Disk = &Resource_DiskInfo{}
			}
			if err := m.Disk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reservation == nil {
				m.Reservation = &Resource_ReservationInfo{}
			}
			if err := m.Reservation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revocable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Revocable == nil {
				m.Revocable = &Resource_RevocableInfo{}
			}
			if err := m.Revocable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shared == nil {
				m.Shared = &Resource_SharedInfo{}
			}
			if err := m.Shared.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllocationInfo == nil {
				m.AllocationInfo = &Resource_AllocationInfo{}
			}
			if err := m.AllocationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProviderID == nil {
				m.ProviderID = &ResourceProviderID{}
			}
			if err := m.ProviderID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reservations = append(m.Reservations, Resource_ReservationInfo{})
			if err := m.Reservations[len(m.Reservations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_AllocationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Role = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_ReservationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReservationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReservationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Principal = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Role = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Resource_ReservationInfo_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Resource_ReservationInfo_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_DiskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Persistence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Persistence == nil {
				m.Persistence = &Resource_DiskInfo_Persistence{}
			}
			if err := m.Persistence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Volume == nil {
				m.Volume = &Volume{}
			}
			if err := m.Volume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Resource_DiskInfo_Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_DiskInfo_Persistence) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Persistence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Persistence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Principal = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_DiskInfo_Source) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Resource_DiskInfo_Source_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Resource_DiskInfo_Source_Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mount == nil {
				m.Mount = &Resource_DiskInfo_Source_Mount{}
			}
			if err := m.Mount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ID = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Labels{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Profile = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_DiskInfo_Source_Path) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Path: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Path: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Root = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_DiskInfo_Source_Mount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Root = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_RevocableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevocableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevocableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource_SharedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SharedInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SharedInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficControlStatistics) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficControlStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficControlStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backlog", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Backlog = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bytes = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drops", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drops = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overlimits", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overlimits = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Packets = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qlen", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Qlen = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateBPS", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RateBPS = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatePPS", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RatePPS = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requeues", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Requeues = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forwarding", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Forwarding = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTTL", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultTTL = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InReceives", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InReceives = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InHdrErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InHdrErrors = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InAddrErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InAddrErrors = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwDatagrams", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForwDatagrams = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUnknownProtos", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InUnknownProtos = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InDiscards", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InDiscards = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InDelivers", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InDelivers = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutRequests", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutRequests = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutDiscards", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutDiscards = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutNoRoutes", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutNoRoutes = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasmTimeout", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReasmTimeout = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasmReqds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReasmReqds = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasmOKs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReasmOKs = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasmFails", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReasmFails = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragOKs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FragOKs = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragFails", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FragFails = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragCreates", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FragCreates = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcmpStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcmpStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcmpStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InMsgs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InMsgs = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InErrors = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InCsumErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InCsumErrors = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InDestUnreachs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InDestUnreachs = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTimeExcds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InTimeExcds = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InParmProbs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InParmProbs = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InSrcQuenchs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InSrcQuenchs = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InRedirects", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InRedirects = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InEchos", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InEchos = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InEchoReps", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InEchoReps = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTimestamps", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InTimestamps = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTimestampReps", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InTimestampReps = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InAddrMasks", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InAddrMasks = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InAddrMaskReps", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InAddrMaskReps = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutMsgs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutMsgs = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutErrors = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutDestUnreachs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutDestUnreachs = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTimeExcds", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutTimeExcds = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutParmProbs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutParmProbs = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutSrcQuenchs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutSrcQuenchs = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutRedirects", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutRedirects = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutEchos", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutEchos = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutEchoReps", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutEchoReps = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTimestamps", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutTimestamps = &v
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTimestampReps", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutTimestampReps = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutAddrMasks", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutAddrMasks = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutAddrMaskReps", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutAddrMaskReps = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtoAlgorithm", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RtoAlgorithm = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtoMin", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RtoMin = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtoMax", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RtoMax = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConn", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxConn = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveOpens", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveOpens = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassiveOpens", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PassiveOpens = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttemptFails", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttemptFails = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstabResets", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EstabResets = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrEstab", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurrEstab = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InSegs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InSegs = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutSegs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutSegs = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetransSegs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetransSegs = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InErrs", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InErrs = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutRsts", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutRsts = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InCsumErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InCsumErrors = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UdpStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UdpStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UdpStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InDatagrams", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InDatagrams = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPorts", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoPorts = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InErrors = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutDatagrams", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutDatagrams = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvbufErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RcvbufErrors = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SndbufErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SndbufErrors = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InCsumErrors", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InCsumErrors = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoredMulti", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoredMulti = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNMPStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNMPStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNMPStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPStats == nil {
				m.IPStats = &IpStatistics{}
			}
			if err := m.IPStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMPStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ICMPStats == nil {
				m.ICMPStats = &IcmpStatistics{}
			}
			if err := m.ICMPStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCPStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TCPStats == nil {
				m.TCPStats = &TcpStatistics{}
			}
			if err := m.TCPStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UDPStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UDPStats == nil {
				m.UDPStats = &UdpStatistics{}
			}
			if err := m.UDPStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Resource_DiskInfo_Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Persistence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Persistence == nil {
				m.Persistence = &Resource_DiskInfo_Persistence{}
			}
			if err := m.Persistence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LimitBytes = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsedBytes = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceStatistics) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Timestamp = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUsUserTimeSecs", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.CPUsUserTimeSecs = &v2
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUsSystemTimeSecs", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.CPUsSystemTimeSecs = &v2
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUsLimit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.CPUsLimit = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemRSSBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemRSSBytes = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemLimitBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemLimitBytes = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUsNrPeriods", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CPUsNrPeriods = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUsNrThrottled", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CPUsNrThrottled = &v
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUsThrottledTimeSecs", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.CPUsThrottledTimeSecs = &v2
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemFileBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemFileBytes = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemAnonBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemAnonBytes = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemMappedFileBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemMappedFileBytes = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Perf == nil {
				m.Perf = &PerfStatistics{}
			}
			if err := m.Perf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRxPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetRxPackets = &v
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRxBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetRxBytes = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRxErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetRxErrors = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRxDropped", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetRxDropped = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTxPackets", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetTxPackets = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTxBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetTxBytes = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTxErrors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetTxErrors = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTxDropped", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetTxDropped = &v
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTCPRttMicrosecsP50", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.NetTCPRttMicrosecsP50 = &v2
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTCPRttMicrosecsP90", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.NetTCPRttMicrosecsP90 = &v2
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTCPRttMicrosecsP95", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.NetTCPRttMicrosecsP95 = &v2
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTCPRttMicrosecsP99", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.NetTCPRttMicrosecsP99 = &v2
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskLimitBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DiskLimitBytes = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUsedBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DiskUsedBytes = &v
		case 28:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTCPActiveConnections", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.NetTCPActiveConnections = &v2
		case 29:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTCPTimeWaitConnections", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.NetTCPTimeWaitConnections = &v2
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Processes = &v
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Threads = &v
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemLowPressureCounter", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemLowPressureCounter = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemMediumPressureCounter", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemMediumPressureCounter = &v
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCriticalPressureCounter", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemCriticalPressureCounter = &v
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTrafficControlStatistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetTrafficControlStatistics = append(m.NetTrafficControlStatistics, TrafficControlStatistics{})
			if err := m.NetTrafficControlStatistics[len(m.NetTrafficControlStatistics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotalBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemTotalBytes = &v
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotalMemswBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemTotalMemswBytes = &v
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemSoftLimitBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemSoftLimitBytes = &v
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCacheBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemCacheBytes = &v
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemSwapBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemSwapBytes = &v
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUnevictableBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemUnevictableBytes = &v
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSNMPStatistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetSNMPStatistics == nil {
				m.NetSNMPStatistics = &SNMPStatistics{}
			}
			if err := m.NetSNMPStatistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskStatistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskStatistics = append(m.DiskStatistics, DiskStatistics{})
			if err := m.DiskStatistics[len(m.DiskStatistics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlkioStatistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlkioStatistics == nil {
				m.BlkioStatistics = &CgroupInfo_Blkio_Statistics{}
			}
			if err := m.BlkioStatistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("timestamp")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executors = append(m.Executors, ResourceUsage_Executor{})
			if err := m.Executors[len(m.Executors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Total = append(m.Total, Resource{})
			if err := m.Total[len(m.Total)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceUsage_Executor) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Executor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Executor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecutorInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocated = append(m.Allocated, Resource{})
			if err := m.Allocated[len(m.Allocated)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Statistics == nil {
				m.Statistics = &ResourceStatistics{}
			}
			if err := m.Statistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContainerID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, ResourceUsage_Executor_Task{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("executor_info")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("container_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceUsage_Executor_Task) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerfStatistics) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerfStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerfStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Timestamp = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Duration = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cycles", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cycles = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalledCyclesFrontend", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StalledCyclesFrontend = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalledCyclesBackend", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StalledCyclesBackend = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instructions", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Instructions = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheReferences", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheReferences = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheMisses = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Branches = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BranchMisses = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusCycles", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BusCycles = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCycles", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefCycles = &v
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUClock", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.CPUClock = &v2
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskClock", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.TaskClock = &v2
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageFaults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PageFaults = &v
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorFaults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinorFaults = &v
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorFaults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MajorFaults = &v
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextSwitches", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContextSwitches = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUMigrations", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CPUMigrations = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlignmentFaults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlignmentFaults = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmulationFaults", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmulationFaults = &v
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1DcacheLoads", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1DcacheLoads = &v
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1DcacheLoadMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1DcacheLoadMisses = &v
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1DcacheStores", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1DcacheStores = &v
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1DcacheStoreMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1DcacheStoreMisses = &v
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1DcachePrefetches", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1DcachePrefetches = &v
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1DcachePrefetchMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1DcachePrefetchMisses = &v
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1IcacheLoads", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1IcacheLoads = &v
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1IcacheLoadMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1IcacheLoadMisses = &v
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1IcachePrefetches", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1IcachePrefetches = &v
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1IcachePrefetchMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L1IcachePrefetchMisses = &v
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLCLoads", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LLCLoads = &v
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLCLoadMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LLCLoadMisses = &v
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLCStores", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LLCStores = &v
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLCStoreMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LLCStoreMisses = &v
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLCPrefetches", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LLCPrefetches = &v
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLCPrefetchMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LLCPrefetchMisses = &v
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DTLBLoads", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DTLBLoads = &v
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DTLBLoadMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DTLBLoadMisses = &v
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DTLBStores", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DTLBStores = &v
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DTLBStoreMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DTLBStoreMisses = &v
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DTLBPrefetches", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DTLBPrefetches = &v
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DTLBPrefetchMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DTLBPrefetchMisses = &v
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ITLBLoads", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ITLBLoads = &v
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ITLBLoadMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ITLBLoadMisses = &v
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchLoads", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BranchLoads = &v
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchLoadMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BranchLoadMisses = &v
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLoads", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeLoads = &v
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLoadMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeLoadMisses = &v
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeStores", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeStores = &v
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeStoreMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeStoreMisses = &v
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePrefetches", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodePrefetches = &v
		case 53:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePrefetchMisses", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodePrefetchMisses = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("timestamp")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("duration")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AgentID == nil {
				m.AgentID = &AgentID{}
			}
			if err := m.AgentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Offer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Offer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameworkID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FrameworkID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AgentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutorIDs = append(m.ExecutorIDs, ExecutorID{})
			if err := m.ExecutorIDs[len(m.ExecutorIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URL == nil {
				m.URL = &URL{}
			}
			if err := m.URL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unavailability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unavailability == nil {
				m.Unavailability = &Unavailability{}
			}
			if err := m.Unavailability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllocationInfo == nil {
				m.AllocationInfo = &Resource_AllocationInfo{}
			}
			if err := m.AllocationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &DomainInfo{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("framework_id")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("agent_id")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("hostname")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Offer_Operation_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Launch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Launch == nil {
				m.Launch = &Offer_Operation_Launch{}
			}
			if err := m.Launch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reserve == nil {
				m.Reserve = &Offer_Operation_Reserve{}
			}
			if err := m.Reserve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unreserve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unreserve == nil {
				m.Unreserve = &Offer_Operation_Unreserve{}
			}
			if err := m.Unreserve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &Offer_Operation_Create{}
			}
			if err := m.Create.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Destroy == nil {
				m.Destroy = &Offer_Operation_Destroy{}
			}
			if err := m.Destroy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaunchGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LaunchGroup == nil {
				m.LaunchGroup = &Offer_Operation_LaunchGroup{}
			}
			if err := m.LaunchGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ID == nil {
				m.ID = &OperationID{}
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrowVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GrowVolume == nil {
				m.GrowVolume = &Offer_Operation_GrowVolume{}
			}
			if err := m.GrowVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShrinkVolume == nil {
				m.ShrinkVolume = &Offer_Operation_ShrinkVolume{}
			}
			if err := m.ShrinkVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateDisk == nil {
				m.CreateDisk = &Offer_Operation_CreateDisk{}
			}
			if err := m.CreateDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyDisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestroyDisk == nil {
				m.DestroyDisk = &Offer_Operation_DestroyDisk{}
			}
			if err := m.DestroyDisk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_Launch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Launch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Launch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskInfos = append(m.TaskInfos, TaskInfo{})
			if err := m.TaskInfos[len(m.TaskInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_LaunchGroup) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LaunchGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LaunchGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Executor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("executor")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("task_group")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_Reserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_Unreserve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unreserve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unreserve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_Create) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Create: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Create: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, Resource{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_Destroy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Destroy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Destroy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, Resource{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_GrowVolume) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GrowVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GrowVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Volume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Addition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("volume")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("addition")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_ShrinkVolume) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShrinkVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShrinkVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Volume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtract", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subtract.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("volume")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("subtract")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_CreateDisk) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDisk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDisk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetType", wireType)
			}
			m.TargetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetType |= (Resource_DiskInfo_Source_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("source")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("target_type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offer_Operation_DestroyDisk) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestroyDisk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestroyDisk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("source")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InverseOffer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InverseOffer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InverseOffer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OfferID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.URL == nil {
				m.URL = &URL{}
			}
			if err := m.URL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameworkID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FrameworkID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AgentID == nil {
				m.AgentID = &AgentID{}
			}
			if err := m.AgentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unavailability", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Unavailability.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("framework_id")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("unavailability")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AgentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Executor == nil {
				m.Executor = &ExecutorInfo{}
			}
			if err := m.Executor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &CommandInfo{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthCheck == nil {
				m.HealthCheck = &HealthCheck{}
			}
			if err := m.HealthCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &ContainerInfo{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discovery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Discovery == nil {
				m.Discovery = &DiscoveryInfo{}
			}
			if err := m.Discovery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KillPolicy == nil {
				m.KillPolicy = &KillPolicy{}
			}
			if err := m.KillPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Check == nil {
				m.Check = &CheckInfo{}
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxCompletionTime == nil {
				m.MaxCompletionTime = &DurationInfo{}
			}
			if err := m.MaxCompletionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("task_id")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("agent_id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskGroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskGroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskGroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, TaskInfo{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Task) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameworkID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FrameworkID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutorID == nil {
				m.ExecutorID = &ExecutorID{}
			}
			if err := m.ExecutorID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AgentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v TaskState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TaskState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = &v
			hasFields[0] |= uint64(0x00000010)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statuses = append(m.Statuses, TaskStatus{})
			if err := m.Statuses[len(m.Statuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusUpdateState", wireType)
			}
			var v TaskState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TaskState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatusUpdateState = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusUpdateUUID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusUpdateUUID = append(m.StatusUpdateUUID[:0], dAtA[iNdEx:postIndex]...)
			if m.StatusUpdateUUID == nil {
				m.StatusUpdateUUID = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discovery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Discovery == nil {
				m.Discovery = &DiscoveryInfo{}
			}
			if err := m.Discovery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &ContainerInfo{}
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.User = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("task_id")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("framework_id")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("agent_id")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskResourceLimitation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskResourceLimitation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskResourceLimitation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUID) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Operation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Operation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Operation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameworkID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FrameworkID == nil {
				m.FrameworkID = &FrameworkID{}
			}
			if err := m.FrameworkID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AgentID == nil {
				m.AgentID = &AgentID{}
			}
			if err := m.AgentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatestStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statuses = append(m.Statuses, OperationStatus{})
			if err := m.Statuses[len(m.Statuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UUID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("info")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("latest_status")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("uuid")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperationStatus) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OperationID == nil {
				m.OperationID = &OperationID{}
			}
			if err := m.OperationID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (OperationState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvertedResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvertedResources = append(m.ConvertedResources, Resource{})
			if err := m.ConvertedResources[len(m.ConvertedResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UUID == nil {
				m.UUID = &UUID{}
			}
			if err := m.UUID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckStatusInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckStatusInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckStatusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v CheckInfo_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CheckInfo_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &CheckStatusInfo_Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HTTP == nil {
				m.HTTP = &CheckStatusInfo_Http{}
			}
			if err := m.HTTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TCP == nil {
				m.TCP = &CheckStatusInfo_Tcp{}
			}
			if err := m.TCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckStatusInfo_Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExitCode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckStatusInfo_Http) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Http: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Http: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StatusCode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckStatusInfo_Tcp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tcp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tcp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succeeded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Succeeded = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskStatus) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v TaskState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TaskState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AgentID == nil {
				m.AgentID = &AgentID{}
			}
			if err := m.AgentID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Timestamp = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutorID == nil {
				m.ExecutorID = &ExecutorID{}
			}
			if err := m.ExecutorID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Healthy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Healthy = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var v TaskStatus_Source
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TaskStatus_Source(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Source = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var v TaskStatus_Reason
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (TaskStatus_Reason(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reason = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UUID = append(m.UUID[:0], dAtA[iNdEx:postIndex]...)
			if m.UUID == nil {
				m.UUID = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerStatus == nil {
				m.ContainerStatus = &ContainerStatus{}
			}
			if err := m.ContainerStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreachableTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnreachableTime == nil {
				m.UnreachableTime = &TimeInfo{}
			}
			if err := m.UnreachableTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckStatus == nil {
				m.CheckStatus = &CheckStatusInfo{}
			}
			if err := m.CheckStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limitation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limitation == nil {
				m.Limitation = &TaskResourceLimitation{}
			}
			if err := m.Limitation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("task_id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("state")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefuseSeconds", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.RefuseSeconds = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Environment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Environment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Environment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = append(m.Variables, Environment_Variable{})
			if err := m.Variables[len(m.Variables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Environment_Variable) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Environment_Variable_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Environment_Variable_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &Secret{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parameter) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("key")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("value")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Parameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameter = append(m.Parameter, Parameter{})
			if err := m.Parameter[len(m.Parameter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Credential) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Principal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Secret = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("principal")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Credentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credentials = append(m.Credentials, Credential{})
			if err := m.Credentials[len(m.Credentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Secret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Secret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Secret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Secret_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reference == nil {
				m.Reference = &Secret_Reference{}
			}
			if err := m.Reference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Secret_Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Secret_Reference) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Secret_Value) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("data")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimit) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QPS", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.QPS = &v2
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Principal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Principal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Capacity = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("principal")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Limits = append(m.Limits, RateLimit{})
			if err := m.Limits[len(m.Limits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateDefaultQPS", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.AggregateDefaultQPS = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateDefaultCapacity", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AggregateDefaultCapacity = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Image_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Image_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Appc == nil {
				m.Appc = &Image_Appc{}
			}
			if err := m.Appc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Docker == nil {
				m.Docker = &Image_Docker{}
			}
			if err := m.Docker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cached", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Cached = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image_Appc) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Appc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Appc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ID = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image_Docker) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Docker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Docker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credential", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credential == nil {
				m.Credential = &Credential{}
			}
			if err := m.Credential.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &Secret{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountPropagation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountPropagation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountPropagation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v MountPropagation_Mode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (MountPropagation_Mode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Volume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Volume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HostPath = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v Volume_Mode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Volume_Mode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &Image{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Volume_Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("container_path")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("mode")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume_Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Volume_Source_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerVolume", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DockerVolume == nil {
				m.DockerVolume = &Volume_Source_DockerVolume{}
			}
			if err := m.DockerVolume.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SandboxPath == nil {
				m.SandboxPath = &Volume_Source_SandboxPath{}
			}
			if err := m.SandboxPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &Secret{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostPath == nil {
				m.HostPath = &Volume_Source_HostPath{}
			}
			if err := m.HostPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume_Source_DockerVolume) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Driver = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DriverOptions == nil {
				m.DriverOptions = &Parameters{}
			}
			if err := m.DriverOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume_Source_HostPath) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPropagation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MountPropagation == nil {
				m.MountPropagation = &MountPropagation{}
			}
			if err := m.MountPropagation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("path")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume_Source_SandboxPath) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SandboxPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SandboxPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Volume_Source_SandboxPath_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("path")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddresses = append(m.IPAddresses, NetworkInfo_IPAddress{})
			if err := m.IPAddresses[len(m.IPAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortMappings = append(m.PortMappings, NetworkInfo_PortMapping{})
			if err := m.PortMappings[len(m.PortMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo_IPAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var v NetworkInfo_Protocol
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (NetworkInfo_Protocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protocol = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IPAddress = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo_PortMapping) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("host_port")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("container_port")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapabilityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapabilityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapabilityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v CapabilityInfo_Capability
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMesos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CapabilityInfo_Capability(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Capabilities = append(m.Capabilities, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMesos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMesos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CapabilityInfo_Capability
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMesos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CapabilityInfo_Capability(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Capabilities = append(m.Capabilities, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapabilityInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CapabilityInfo == nil {
				m.CapabilityInfo = &CapabilityInfo{}
			}
			if err := m.CapabilityInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundingCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoundingCapabilities == nil {
				m.BoundingCapabilities = &CapabilityInfo{}
			}
			if err := m.BoundingCapabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectiveCapabilities == nil {
				m.EffectiveCapabilities = &CapabilityInfo{}
			}
			if err := m.EffectiveCapabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharePIDNamespace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SharePIDNamespace = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RLimitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RLimitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RLimitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rlimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rlimits = append(m.Rlimits, RLimitInfo_RLimit{})
			if err := m.Rlimits[len(m.Rlimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RLimitInfo_RLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (RLimitInfo_RLimit_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hard", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hard = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soft", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Soft = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TTYInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TTYInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TTYInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WindowSize == nil {
				m.WindowSize = &TTYInfo_WindowSize{}
			}
			if err := m.WindowSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TTYInfo_WindowSize) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			m.Columns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Columns |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("rows")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("columns")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v ContainerInfo_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ContainerInfo_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, Volume{})
			if err := m.Volumes[len(m.Volumes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Docker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Docker == nil {
				m.Docker = &ContainerInfo_DockerInfo{}
			}
			if err := m.Docker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mesos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mesos == nil {
				m.Mesos = &ContainerInfo_MesosInfo{}
			}
			if err := m.Mesos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInfos = append(m.NetworkInfos, NetworkInfo{})
			if err := m.NetworkInfos[len(m.NetworkInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinuxInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinuxInfo == nil {
				m.LinuxInfo = &LinuxInfo{}
			}
			if err := m.LinuxInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RlimitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RlimitInfo == nil {
				m.RlimitInfo = &RLimitInfo{}
			}
			if err := m.RlimitInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTYInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TTYInfo == nil {
				m.TTYInfo = &TTYInfo{}
			}
			if err := m.TTYInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInfo_DockerInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var v ContainerInfo_DockerInfo_Network
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ContainerInfo_DockerInfo_Network(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Network = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortMappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortMappings = append(m.PortMappings, ContainerInfo_DockerInfo_PortMapping{})
			if err := m.PortMappings[len(m.PortMappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Privileged = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, Parameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePullImage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ForcePullImage = &b
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeDriver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.VolumeDriver = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("image")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInfo_DockerInfo_PortMapping) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("host_port")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("container_port")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerInfo_MesosInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MesosInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MesosInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &Image{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInfos = append(m.NetworkInfos, NetworkInfo{})
			if err := m.NetworkInfos[len(m.NetworkInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CgroupInfo == nil {
				m.CgroupInfo = &CgroupInfo{}
			}
			if err := m.CgroupInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorPID", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExecutorPID = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerID == nil {
				m.ContainerID = &ContainerID{}
			}
			if err := m.ContainerID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CgroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CgroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetCLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetCLS == nil {
				m.NetCLS = &CgroupInfo_NetCls{}
			}
			if err := m.NetCLS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo_Blkio) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Blkio: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Blkio: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo_Blkio_Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var v CgroupInfo_Blkio_Operation
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CgroupInfo_Blkio_Operation(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo_Blkio_CFQ) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CFQ: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CFQ: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo_Blkio_CFQ_Statistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &Device_Number{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sectors", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sectors = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IOServiced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IOServiced = append(m.IOServiced, CgroupInfo_Blkio_Value{})
			if err := m.IOServiced[len(m.IOServiced)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IOServiceBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IOServiceBytes = append(m.IOServiceBytes, CgroupInfo_Blkio_Value{})
			if err := m.IOServiceBytes[len(m.IOServiceBytes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IOServiceTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IOServiceTime = append(m.IOServiceTime, CgroupInfo_Blkio_Value{})
			if err := m.IOServiceTime[len(m.IOServiceTime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IOWaitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IOWaitTime = append(m.IOWaitTime, CgroupInfo_Blkio_Value{})
			if err := m.IOWaitTime[len(m.IOWaitTime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IOMerged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IOMerged = append(m.IOMerged, CgroupInfo_Blkio_Value{})
			if err := m.IOMerged[len(m.IOMerged)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IOQueued", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IOQueued = append(m.IOQueued, CgroupInfo_Blkio_Value{})
			if err := m.IOQueued[len(m.IOQueued)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo_Blkio_Throttling) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Throttling: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Throttling: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo_Blkio_Throttling_Statistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &Device_Number{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IOServiced", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IOServiced = append(m.IOServiced, CgroupInfo_Blkio_Value{})
			if err := m.IOServiced[len(m.IOServiced)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IOServiceBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IOServiceBytes = append(m.IOServiceBytes, CgroupInfo_Blkio_Value{})
			if err := m.IOServiceBytes[len(m.IOServiceBytes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo_Blkio_Statistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CFQ", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CFQ = append(m.CFQ, CgroupInfo_Blkio_CFQ_Statistics{})
			if err := m.CFQ[len(m.CFQ)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CFQRecursive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CFQRecursive = append(m.CFQRecursive, CgroupInfo_Blkio_CFQ_Statistics{})
			if err := m.CFQRecursive[len(m.CFQRecursive)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Throttling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Throttling = append(m.Throttling, &CgroupInfo_Blkio_Throttling_Statistics{})
			if err := m.Throttling[len(m.Throttling)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CgroupInfo_NetCls) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetCls: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetCls: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassID", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClassID = &v
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Labels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Labels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Labels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("key")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Protocol = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			var v DiscoveryInfo_Visibility
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (DiscoveryInfo_Visibility(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Visibility = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("number")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ports) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ports: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ports: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, Port{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscoveryInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscoveryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscoveryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visibility", wireType)
			}
			m.Visibility = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visibility |= (DiscoveryInfo_Visibility(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Environment = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Location = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = &Ports{}
			}
			if err := m.Ports.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("visibility")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WeightInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WeightInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WeightInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Weight = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Role = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("weight")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BuildDate = &s
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.BuildTime = &v2
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BuildUser = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitSHA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GitSHA = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GitBranch = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GitTag = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("version")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Flag) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Weight = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frameworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Frameworks = append(m.Frameworks, FrameworkID{})
			if err := m.Frameworks[len(m.Frameworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("weight")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metric) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Value = &v2
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("name")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nlink", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nlink = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Size = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mtime == nil {
				m.Mtime = &TimeInfo{}
			}
			if err := m.Mtime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UID = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GID = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("path")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Number == nil {
				m.Number = &Device_Number{}
			}
			if err := m.Number.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device_Number) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Number: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Number: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorNumber", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MajorNumber = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorNumber", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinorNumber = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("major_number")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("minor_number")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceAccess) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceAccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceAccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Access.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("device")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("access")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceAccess_Access) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Access: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Access: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Read = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Write = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mknod", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Mknod = &b
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceWhitelist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceWhitelist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceWhitelist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedDevices = append(m.AllowedDevices, DeviceAccess{})
			if err := m.AllowedDevices[len(m.AllowedDevices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMesos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMesos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMesos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMesos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMesos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMesos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMesos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMesos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mesos.proto", fileDescriptorMesos) }

var fileDescriptorMesos = []byte{
	// 12024 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0xbd, 0x5d, 0x90, 0x1b, 0x49,
	0x72, 0x18, 0xbc, 0xf8, 0x07, 0x12, 0xc0, 0x4c, 0xb3, 0x66, 0x38, 0x3b, 0x04, 0xc9, 0x19, 0x2e,
	0x76, 0xc9, 0x25, 0x97, 0x5c, 0xfe, 0xed, 0x72, 0x6f, 0xc9, 0xbd, 0xdd, 0x3d, 0x0c, 0xd0, 0x33,
	0xd3, 0x47, 0xfc, 0x5d, 0x01, 0x20, 0x77, 0x2f, 0x14, 0x81, 0x68, 0x02, 0x3d, 0x33, 0x2d, 0x02,
	0x68, 0x6c, 0x77, 0x63, 0x48, 0xde, 0xcb, 0x77, 0xfa, 0x2c, 0xc9, 0x27, 0x5b, 0xb2, 0xfd, 0xe0,
	0x3f, 0xd9, 0x7e, 0xb0, 0x43, 0x0f, 0xd2, 0x83, 0xe5, 0x90, 0x64, 0x87, 0xc3, 0xe1, 0x70, 0xd8,
	0x7e, 0xf0, 0x8f, 0xde, 0xac, 0x7b, 0x53, 0x84, 0x23, 0x68, 0xdd, 0x48, 0x0e, 0x4b, 0xb6, 0x6c,
	0x9d, 0x25, 0xd9, 0x92, 0x6d, 0x59, 0x76, 0xd4, 0x6f, 0x57, 0x03, 0x18, 0xcc, 0x70, 0x4f, 0x0a,
	0x3f, 0x01, 0x95, 0x95, 0x99, 0x55, 0x95, 0x95, 0x55, 0x95, 0x59, 0x55, 0x9d, 0x05, 0xd9, 0xa1,
	0xe5, 0x39, 0xde, 0xcd, 0xb1, 0xeb, 0xf8, 0x0e, 0x4a, 0xd0, 0x44, 0xe1, 0xdd, 0x7d, 0xdb, 0x3f,
	0x98, 0x3c, 0xb9, 0xd9, 0x73, 0x86, 0xb7, 0xf6, 0x9d, 0x7d, 0xe7, 0x16, 0xcd, 0x7d, 0x32, 0xd9,
	0xa3, 0x29, 0x9a, 0xa0, 0xff, 0x18, 0x55, 0xf1, 0x1a, 0x64, 0xb7, 0x5d, 0x73, 0x68, 0x3d, 0x73,
	0xdc, 0xa7, 0x46, 0x05, 0x15, 0x20, 0x71, 0x68, 0x0e, 0x26, 0xd6, 0x7a, 0xe4, 0x52, 0xf4, 0x6a,
	0x66, 0x2b, 0xfe, 0xcb, 0x2f, 0x37, 0x5f, 0xc3, 0x0c, 0x54, 0xbc, 0x0c, 0xa9, 0xc6, 0xde, 0x9e,
	0xe5, 0x9e, 0x8c, 0x56, 0xda, 0xb7, 0x46, 0xfe, 0x09, 0x68, 0x6f, 0x41, 0xb2, 0x6d, 0x7a, 0x27,
	0x95, 0x79, 0x15, 0x40, 0x7f, 0x6e, 0xf5, 0x26, 0xbe, 0x73, 0x52, 0xb1, 0x1d, 0xc8, 0x96, 0x9d,
	0x91, 0x6f, 0xda, 0xa3, 0x93, 0x6a, 0x88, 0xde, 0x81, 0xe4, 0xd8, 0x74, 0xad, 0x91, 0xbf, 0x1e,
	0xbd, 0x14, 0xb9, 0x9a, 0xbd, 0x8b, 0x6e, 0x32, 0x39, 0x2a, 0xf4, 0x98, 0x63, 0x14, 0x6f, 0x03,
	0xc2, 0x96, 0xe7, 0x4c, 0xdc, 0x9e, 0xd5, 0x74, 0x9d, 0x43, 0xbb, 0x7f, 0x62, 0xfb, 0xaf, 0x41,
	0xb6, 0x31, 0xb6, 0x5c, 0xd3, 0xb7, 0x9d, 0xd1, 0x09, 0xa8, 0x77, 0x21, 0xdd, 0xb6, 0x87, 0x96,
	0x31, 0xda, 0x73, 0xd0, 0x15, 0xc8, 0x8e, 0xcc, 0x91, 0xe3, 0x59, 0x3d, 0x67, 0xd4, 0xf7, 0x28,
	0x76, 0x8c, 0x63, 0xab, 0x19, 0xc5, 0x0f, 0x20, 0x57, 0x99, 0x70, 0xee, 0xaf, 0x42, 0xf7, 0x18,
	0x52, 0xa5, 0x7e, 0xdf, 0xb5, 0x3c, 0x0f, 0x15, 0x20, 0x7d, 0xe0, 0x78, 0xfe, 0xc8, 0x1c, 0x92,
	0x5a, 0x45, 0xae, 0x66, 0xb0, 0x4c, 0xa3, 0x35, 0x88, 0xda, 0x63, 0x2a, 0x97, 0xcc, 0x56, 0xf2,
	0xe8, 0xe5, 0x66, 0xd4, 0x68, 0xe2, 0xa8, 0x3d, 0x46, 0xeb, 0x10, 0x1f, 0x3b, 0xae, 0xbf, 0x1e,
	0xbb, 0x14, 0xbd, 0x9a, 0xe0, 0xfc, 0x29, 0xa4, 0xf8, 0x8b, 0x11, 0x88, 0x75, 0x70, 0x15, 0x5d,
	0x80, 0xa4, 0xd7, 0x3b, 0xb0, 0x86, 0xe1, 0x96, 0x72, 0x18, 0xba, 0x09, 0x29, 0x93, 0x15, 0xbf,
	0x1e, 0xbd, 0x14, 0xbd, 0x9a, 0xbd, 0xbb, 0xc4, 0x85, 0xce, 0x2b, 0xc5, 0xd1, 0x05, 0x12, 0x42,
	0x10, 0x1f, 0x9b, 0xfe, 0xc1, 0x7a, 0x8c, 0xd6, 0x8f, 0xfe, 0x47, 0x37, 0x20, 0xf1, 0xc5, 0xc4,
	0x72, 0x5f, 0xac, 0xc7, 0x2f, 0xc5, 0xae, 0x66, 0xef, 0x6a, 0x9c, 0x43, 0xd3, 0x24, 0x0a, 0xec,
	0x5b, 0xae, 0x10, 0x2e, 0x45, 0x22, 0xad, 0xdc, 0x73, 0xcd, 0xfd, 0x21, 0xe9, 0xe7, 0x04, 0x6b,
	0xa5, 0x48, 0x17, 0x47, 0xb0, 0xd4, 0x19, 0x99, 0x87, 0xa6, 0x3d, 0x30, 0x9f, 0xd8, 0x03, 0xdb,
	0x7f, 0x81, 0xae, 0x43, 0xc2, 0xf3, 0x4d, 0xd7, 0xa7, 0x95, 0xcf, 0xde, 0x5d, 0xe6, 0xbc, 0x45,
	0xf7, 0x08, 0xd6, 0x14, 0x07, 0xdd, 0x82, 0x74, 0x9f, 0xf7, 0x01, 0x57, 0xa1, 0x15, 0x8e, 0xaf,
	0x76, 0x0d, 0x96, 0x48, 0xc5, 0x4f, 0x21, 0x53, 0x33, 0x7b, 0x07, 0xf6, 0xc8, 0xa2, 0x1a, 0xf1,
	0xca, 0xe2, 0x2f, 0xfe, 0x9b, 0x08, 0x64, 0x05, 0x07, 0xd2, 0xeb, 0x37, 0x20, 0x6a, 0xf7, 0x79,
	0x5d, 0x85, 0x1c, 0x64, 0x09, 0x5b, 0x40, 0x2a, 0x4b, 0xa9, 0x2b, 0x38, 0x6a, 0xf7, 0xd1, 0x75,
	0x88, 0x0f, 0x9d, 0xbe, 0x45, 0xf9, 0x2e, 0xdd, 0x7d, 0x7d, 0x0a, 0x7f, 0xb4, 0xe7, 0xdc, 0xac,
	0x39, 0x7d, 0x0b, 0x53, 0x24, 0xf4, 0x31, 0x2c, 0x4d, 0x42, 0xb2, 0xa1, 0x7d, 0x90, 0xbd, 0x7b,
	0x96, 0x93, 0x85, 0x05, 0x87, 0xa7, 0x90, 0x8b, 0x57, 0x20, 0x4e, 0x98, 0xa1, 0x24, 0x44, 0x3b,
	0x4d, 0x2d, 0x82, 0x72, 0x90, 0xae, 0xe0, 0x92, 0x51, 0x37, 0xea, 0x3b, 0x5a, 0x14, 0xa5, 0x21,
	0x5e, 0x69, 0x3c, 0xae, 0x6b, 0xb1, 0xe2, 0x6f, 0x24, 0x20, 0x1f, 0xcc, 0x3c, 0xa4, 0x4d, 0xeb,
	0x10, 0x9f, 0x78, 0x96, 0x1b, 0x52, 0x1f, 0x0a, 0x21, 0x39, 0x54, 0x5a, 0x51, 0x35, 0x87, 0xca,
	0xeb, 0x1d, 0x2a, 0x87, 0x58, 0x68, 0x18, 0x2b, 0xf3, 0x19, 0x97, 0x21, 0x93, 0xc2, 0x0d, 0xd0,
	0xf6, 0x4c, 0x7b, 0xe0, 0x1c, 0x5a, 0x6e, 0xd7, 0xb7, 0x87, 0x96, 0x33, 0xf1, 0xd7, 0xe3, 0x97,
	0x22, 0x57, 0x23, 0x0f, 0x22, 0xb7, 0xf1, 0xb2, 0xc8, 0x6a, 0xb3, 0x1c, 0x74, 0x19, 0xa0, 0x77,
	0x60, 0xf5, 0x9e, 0x8e, 0x1d, 0x9b, 0x2b, 0x50, 0xfa, 0x41, 0x62, 0xcf, 0x1c, 0x78, 0x16, 0x56,
	0x32, 0xd0, 0x39, 0x88, 0xbb, 0xce, 0xc0, 0x5a, 0x4f, 0x92, 0x2e, 0x7b, 0x10, 0x79, 0x67, 0x2b,
	0xba, 0x1e, 0xc1, 0x14, 0x14, 0xea, 0xe7, 0xd4, 0x54, 0x3f, 0x5f, 0x80, 0xcc, 0xd8, 0xb5, 0x47,
	0x3d, 0x7b, 0x6c, 0x0e, 0xd6, 0xd3, 0x34, 0x33, 0x00, 0xa0, 0x6b, 0x90, 0x79, 0x66, 0x3d, 0x99,
	0xd8, 0xdd, 0x89, 0x3b, 0x58, 0xcf, 0x50, 0x65, 0xc8, 0x1d, 0xbd, 0xdc, 0x4c, 0x3f, 0xb6, 0x9e,
	0x74, 0xec, 0x0e, 0xae, 0xe2, 0x34, 0xcd, 0xee, 0xb8, 0x03, 0x64, 0x40, 0xae, 0x67, 0x8e, 0x99,
	0xf0, 0x6d, 0xcb, 0x5b, 0x07, 0x3a, 0x34, 0x36, 0x67, 0x44, 0x41, 0x3a, 0xb9, 0x2c, 0x10, 0x5f,
	0x70, 0x19, 0x86, 0x48, 0xd1, 0x65, 0x48, 0x0e, 0xcc, 0x27, 0xd6, 0xc0, 0x5b, 0xcf, 0x52, 0x79,
	0xe6, 0x39, 0x93, 0x2a, 0x05, 0x62, 0x9e, 0x89, 0x56, 0x21, 0x41, 0x9a, 0xe7, 0xad, 0xe7, 0x2e,
	0xc5, 0xae, 0x66, 0x30, 0x4b, 0x14, 0xfe, 0x4a, 0x14, 0x20, 0xe0, 0x8f, 0x3e, 0x81, 0xb8, 0xff,
	0x62, 0xcc, 0xf4, 0x7b, 0xe9, 0xee, 0x5b, 0x27, 0x54, 0xe7, 0x66, 0xfb, 0xc5, 0xd8, 0x12, 0xfd,
	0x4a, 0xe8, 0x8a, 0xff, 0x2a, 0x02, 0x71, 0x02, 0x44, 0x59, 0x48, 0x75, 0xea, 0x0f, 0xeb, 0x44,
	0x67, 0x5e, 0x43, 0xaf, 0xc3, 0x0a, 0xd6, 0x1f, 0x35, 0xca, 0xa5, 0xad, 0xaa, 0xde, 0xc5, 0x7a,
	0xab, 0xd1, 0xc1, 0x65, 0xbd, 0xa5, 0x45, 0xd0, 0x1a, 0xa0, 0x76, 0xa9, 0xf5, 0xb0, 0xfb, 0xd0,
	0xa8, 0x56, 0x8d, 0xfa, 0x4e, 0xb7, 0xd5, 0x2e, 0xb5, 0x75, 0x2d, 0x8a, 0xce, 0x40, 0x7e, 0xa7,
	0xd9, 0x51, 0x50, 0x63, 0x68, 0x15, 0xb4, 0xd6, 0x6e, 0x09, 0xeb, 0x15, 0x05, 0x1a, 0x47, 0x2b,
	0xb0, 0xdc, 0x2c, 0xe1, 0xb6, 0xd1, 0x36, 0x1a, 0xf5, 0x6e, 0xe9, 0x71, 0x09, 0xeb, 0x5a, 0x02,
	0x2d, 0x01, 0xd4, 0x3a, 0xd5, 0xb6, 0xd1, 0xc5, 0x8d, 0xaa, 0xae, 0x25, 0x51, 0x01, 0xd6, 0xb0,
	0xde, 0xd2, 0xf1, 0xa3, 0x12, 0x45, 0xc3, 0xfa, 0xb6, 0x51, 0xd7, 0x6b, 0x7a, 0xbd, 0xad, 0xa5,
	0x90, 0x06, 0x39, 0xac, 0xef, 0x04, 0xd4, 0xe9, 0x42, 0xfc, 0x3b, 0x3f, 0xb3, 0x11, 0x29, 0xfe,
	0xdd, 0x38, 0x64, 0xca, 0x44, 0x5d, 0xa8, 0x8a, 0xdf, 0x0a, 0x89, 0x45, 0x8c, 0x28, 0x99, 0x3f,
	0x23, 0x07, 0x74, 0x17, 0x52, 0x3d, 0x67, 0x38, 0x34, 0x47, 0x7d, 0x3e, 0xd1, 0xac, 0xcf, 0xd0,
	0x94, 0x59, 0x3e, 0x16, 0x88, 0xe8, 0x3d, 0x88, 0x1f, 0xf8, 0xfe, 0x78, 0x6a, 0xd8, 0x06, 0x04,
	0xbb, 0xbe, 0x3f, 0xde, 0x4a, 0x1f, 0xbd, 0xdc, 0x8c, 0xef, 0xb6, 0xdb, 0x4d, 0x4c, 0x91, 0xd1,
	0xdb, 0x90, 0xef, 0x5b, 0x03, 0xf3, 0x45, 0x57, 0x2c, 0x24, 0x6c, 0x64, 0x44, 0xef, 0xdc, 0xc3,
	0x39, 0x9a, 0xd1, 0x62, 0x70, 0xf4, 0x2e, 0x68, 0xf6, 0xc8, 0xb7, 0xdc, 0x43, 0x73, 0x20, 0x71,
	0x13, 0x1c, 0xf7, 0x36, 0x5e, 0x16, 0x79, 0x02, 0xfd, 0x3a, 0x2c, 0xf3, 0xb1, 0x26, 0xb1, 0x93,
	0x0c, 0xfb, 0xee, 0x6d, 0xbc, 0xc4, 0xb3, 0x04, 0xf2, 0x2d, 0x88, 0xf9, 0xbd, 0x31, 0x1d, 0x2c,
	0xd9, 0xbb, 0xab, 0xb3, 0xd2, 0xe9, 0x8d, 0xb7, 0x52, 0x47, 0x2f, 0x37, 0x63, 0xed, 0x72, 0x13,
	0x13, 0xcc, 0xc2, 0xc7, 0x90, 0xe2, 0xcd, 0x57, 0x25, 0xc5, 0xa6, 0xc5, 0x60, 0x55, 0xa7, 0x50,
	0x65, 0x16, 0x17, 0x88, 0x85, 0xf7, 0x21, 0x4e, 0x84, 0x21, 0x17, 0x37, 0x42, 0x98, 0x57, 0x17,
	0x37, 0xb9, 0x0c, 0x45, 0x83, 0x65, 0xa8, 0xb0, 0x09, 0xb1, 0x76, 0x6f, 0x01, 0x51, 0xf1, 0xfe,
	0x3c, 0xdd, 0xcd, 0x42, 0xaa, 0xdc, 0xa8, 0xd5, 0x4a, 0xf5, 0x8a, 0x16, 0x21, 0xd3, 0x20, 0x91,
	0xbd, 0x16, 0x45, 0x29, 0x20, 0xad, 0xd1, 0x62, 0x5c, 0x5d, 0x7e, 0x29, 0x09, 0xd9, 0x5d, 0xcb,
	0x1c, 0xf8, 0x07, 0xb4, 0xd9, 0x64, 0x1c, 0xd1, 0xbe, 0x8c, 0x50, 0x91, 0x5c, 0xe2, 0x4d, 0x52,
	0x30, 0x6e, 0x12, 0x3e, 0x52, 0x44, 0x27, 0x77, 0x6b, 0xf4, 0x15, 0xba, 0x35, 0xf6, 0x4a, 0xdd,
	0x1a, 0x3f, 0xb6, 0x5b, 0xdf, 0x87, 0xd5, 0x9e, 0x33, 0xf2, 0x88, 0x19, 0x67, 0x1f, 0x5a, 0x5d,
	0x32, 0xd3, 0x4e, 0x5c, 0x8b, 0xa9, 0x4d, 0xfe, 0x41, 0xe4, 0x3d, 0xbc, 0xa2, 0x64, 0x6f, 0xf3,
	0x5c, 0x42, 0xb5, 0xef, 0x9a, 0x3d, 0xab, 0x3b, 0xb6, 0x5c, 0xdb, 0xe9, 0x4f, 0xab, 0xcf, 0x9d,
	0xdb, 0x18, 0xd1, 0xfc, 0x26, 0xcd, 0x16, 0x65, 0xdd, 0x08, 0xd4, 0x20, 0x35, 0x65, 0xdc, 0x49,
	0x35, 0x08, 0x86, 0xca, 0x1d, 0x3e, 0x1e, 0xd3, 0xa1, 0x85, 0x51, 0x15, 0xef, 0xcc, 0x88, 0x7c,
	0xc0, 0x74, 0x34, 0x43, 0x99, 0x6f, 0xce, 0xa3, 0x28, 0x2b, 0xfd, 0x11, 0x56, 0xd7, 0x5f, 0x88,
	0x40, 0x3e, 0xd4, 0x5f, 0xaf, 0xa6, 0x79, 0x68, 0x4d, 0x9a, 0x58, 0xcc, 0x2c, 0x12, 0xc6, 0x55,
	0x01, 0xd2, 0x9e, 0x6f, 0xfa, 0x13, 0xcf, 0xf2, 0xa8, 0x6d, 0x94, 0xc7, 0x32, 0x8d, 0x3e, 0x86,
	0x34, 0xb5, 0xf4, 0x7b, 0xce, 0x80, 0x0a, 0x7c, 0xe9, 0xee, 0x79, 0x5e, 0xe9, 0xba, 0xe5, 0xcb,
	0xb9, 0xb8, 0xc9, 0x51, 0x1e, 0xc4, 0x8d, 0xe6, 0xe1, 0xfb, 0x58, 0x92, 0x14, 0xf6, 0x21, 0xa7,
	0x36, 0x68, 0x41, 0x85, 0xd5, 0x82, 0xa2, 0xaf, 0x5c, 0xd0, 0x0f, 0x32, 0x68, 0x2a, 0x00, 0x0f,
	0xed, 0xc1, 0xa0, 0xe9, 0x0c, 0xec, 0xde, 0x0b, 0xf4, 0x01, 0xe4, 0x54, 0xbd, 0xe1, 0x43, 0x67,
	0xae, 0x81, 0x96, 0x55, 0x14, 0xa8, 0xf8, 0x47, 0x51, 0xe2, 0x41, 0x48, 0x25, 0x41, 0x1f, 0x42,
	0x7c, 0xe2, 0xda, 0xc4, 0xa2, 0x26, 0x2b, 0xea, 0xda, 0xac, 0x1a, 0xdd, 0xec, 0x60, 0x63, 0x2b,
	0xc7, 0x4d, 0xad, 0x78, 0x07, 0x1b, 0x1e, 0xa6, 0x14, 0xe8, 0x7d, 0xc8, 0x5a, 0xa3, 0x43, 0xdb,
	0x75, 0x46, 0xc3, 0x59, 0x27, 0x43, 0x0f, 0x72, 0xb0, 0x8a, 0x46, 0xd6, 0x55, 0xe6, 0x28, 0xb0,
	0xbe, 0xe5, 0xbe, 0x0a, 0xe2, 0x46, 0x11, 0xb3, 0x60, 0x99, 0x39, 0x54, 0x80, 0x84, 0x77, 0x60,
	0x0d, 0x06, 0x74, 0x28, 0xa4, 0x1f, 0xc4, 0x7d, 0x77, 0x62, 0x61, 0x06, 0x22, 0x86, 0x85, 0xe9,
	0xee, 0x4f, 0x08, 0x47, 0x6f, 0x3d, 0x45, 0x57, 0xe8, 0x00, 0x50, 0xf8, 0xeb, 0xd4, 0x56, 0x37,
	0x16, 0x7a, 0x47, 0x1b, 0x00, 0x16, 0x75, 0xb9, 0xcc, 0x27, 0x03, 0x66, 0x32, 0xa6, 0xb1, 0x02,
	0x41, 0x1b, 0x90, 0xb2, 0x9e, 0xfb, 0xae, 0xd9, 0xf3, 0x69, 0x4d, 0x45, 0xf9, 0x02, 0x48, 0xda,
	0xd1, 0x33, 0x7b, 0x07, 0x16, 0x9d, 0x10, 0xd2, 0x98, 0x25, 0xd0, 0x26, 0x64, 0x9d, 0x89, 0x3f,
	0x9e, 0xf8, 0xdd, 0x3d, 0x7b, 0x60, 0xf1, 0xe6, 0x00, 0x03, 0x6d, 0xdb, 0x03, 0xab, 0xf8, 0x63,
	0x09, 0xc8, 0x49, 0x57, 0x8f, 0xc8, 0x7f, 0x1b, 0xb2, 0x16, 0x4f, 0x77, 0xa5, 0xad, 0x7b, 0x46,
	0x48, 0x51, 0x3a, 0x85, 0x5b, 0x88, 0xf7, 0x80, 0xe2, 0x28, 0x8a, 0xfa, 0x3a, 0xae, 0xd1, 0x27,
	0x12, 0xec, 0x9b, 0xbe, 0x49, 0xab, 0x93, 0xc3, 0xf4, 0x3f, 0x7a, 0x0f, 0x32, 0x2e, 0xf7, 0xea,
	0xc8, 0x34, 0x14, 0x53, 0x2c, 0x7e, 0xe1, 0xed, 0x71, 0xa1, 0x04, 0x78, 0xaf, 0x38, 0xb5, 0x6c,
	0x43, 0x6e, 0x4f, 0x98, 0x3b, 0xa4, 0xfe, 0xe9, 0x63, 0x6d, 0xd4, 0xe5, 0xa3, 0x97, 0x9b, 0xaa,
	0x13, 0x8e, 0xb3, 0x92, 0x90, 0x55, 0x9f, 0x5a, 0x90, 0x19, 0xa6, 0x00, 0xd4, 0x7a, 0x2c, 0x40,
	0x92, 0x55, 0x6a, 0x1d, 0xa8, 0x71, 0x48, 0x6c, 0x4e, 0x0e, 0x41, 0x77, 0x21, 0xd3, 0x13, 0x7e,
	0x2c, 0x37, 0xe4, 0x56, 0x67, 0xfc, 0x5b, 0x52, 0xd3, 0x00, 0x8d, 0xd0, 0xf4, 0x6d, 0xaf, 0x47,
	0xcc, 0xdf, 0x17, 0xeb, 0xb9, 0x10, 0x4d, 0x45, 0xc0, 0x19, 0x8d, 0x44, 0x43, 0x3b, 0x70, 0xd6,
	0x3b, 0x98, 0xf8, 0x7d, 0xe7, 0xd9, 0xa8, 0x1b, 0x1a, 0x6f, 0xf9, 0xe3, 0xc7, 0xdb, 0x8a, 0xa0,
	0xd8, 0x09, 0xc6, 0x9d, 0x62, 0x76, 0x2e, 0x2d, 0x32, 0x3b, 0xef, 0xf2, 0xa9, 0x7a, 0x99, 0x4e,
	0x2d, 0xeb, 0xd3, 0x7a, 0x30, 0xcf, 0x7a, 0x2a, 0xde, 0x3d, 0x66, 0x4e, 0xa9, 0xe8, 0xdb, 0xa5,
	0x4e, 0xb5, 0xad, 0x45, 0x10, 0x40, 0xb2, 0xdc, 0x69, 0xb5, 0x1b, 0x35, 0x2d, 0xca, 0x27, 0x93,
	0x7f, 0x18, 0x05, 0xa8, 0x38, 0x43, 0xd3, 0x66, 0xee, 0xf5, 0xd7, 0x20, 0xb7, 0x67, 0x4e, 0x06,
	0x7e, 0xb7, 0x4f, 0x61, 0x7c, 0x36, 0xb9, 0x28, 0x5a, 0x27, 0x11, 0x6f, 0x6e, 0x13, 0x2c, 0x96,
	0xc6, 0xd9, 0xbd, 0x20, 0x51, 0xf8, 0xf7, 0x11, 0xc8, 0x2a, 0x99, 0x68, 0x1b, 0x92, 0xae, 0xb5,
	0x4f, 0x5c, 0x47, 0xa6, 0xd2, 0x57, 0x17, 0xf2, 0xba, 0x89, 0x29, 0xae, 0x62, 0xbd, 0x70, 0x6a,
	0xf4, 0x35, 0x88, 0x7f, 0xcb, 0x19, 0x59, 0xdc, 0x9d, 0xbe, 0xb2, 0x98, 0xcb, 0x37, 0x9d, 0x91,
	0xea, 0xc7, 0x52, 0xca, 0xc2, 0x15, 0x80, 0x80, 0xbb, 0x74, 0xb2, 0x22, 0xd3, 0x4e, 0x56, 0xe1,
	0x2d, 0x48, 0x0b, 0xfa, 0xe3, 0xb1, 0x8a, 0xff, 0x22, 0x06, 0x50, 0x33, 0x3d, 0x9f, 0xa9, 0x17,
	0x2a, 0x48, 0x0f, 0x35, 0x33, 0xe3, 0x8f, 0x16, 0xb8, 0x97, 0x4b, 0x96, 0x90, 0x20, 0x6f, 0x76,
	0xa3, 0x21, 0xff, 0x20, 0x7e, 0xef, 0xf6, 0xbd, 0xdb, 0x7c, 0x81, 0x39, 0x07, 0xb1, 0xb1, 0xdd,
	0xa7, 0xe3, 0x38, 0xc3, 0x16, 0xd6, 0xa6, 0x51, 0xc1, 0x04, 0x16, 0x72, 0xb5, 0x12, 0x53, 0xae,
	0xd6, 0x3a, 0xa4, 0x0e, 0x2d, 0xd7, 0x23, 0x02, 0xa7, 0x4e, 0x1a, 0x16, 0x49, 0x74, 0x35, 0xd8,
	0x93, 0x60, 0x03, 0x7a, 0x6a, 0x4f, 0x22, 0xd8, 0x8d, 0xb8, 0x06, 0x49, 0xde, 0xff, 0x6c, 0x18,
	0x9f, 0x99, 0x91, 0x36, 0xe6, 0x08, 0x64, 0xdc, 0x87, 0x1c, 0xb2, 0x0c, 0x9d, 0x5d, 0x2e, 0x48,
	0x9f, 0x5b, 0x08, 0xe8, 0x04, 0x6f, 0xac, 0x70, 0x18, 0xf2, 0xa7, 0x3e, 0x0a, 0x39, 0x0e, 0x6f,
	0x2c, 0xe2, 0x36, 0x3b, 0x0c, 0xae, 0xcf, 0x1b, 0x06, 0x1a, 0xe4, 0x4a, 0x3b, 0x7a, 0xbd, 0xdd,
	0xed, 0x34, 0x2b, 0xc4, 0x59, 0x8a, 0x70, 0xfd, 0xff, 0xb7, 0x31, 0xc8, 0xb0, 0xfd, 0x3b, 0xd2,
	0x8b, 0x97, 0x42, 0x7b, 0x15, 0x41, 0x97, 0x07, 0xe2, 0x0d, 0x4d, 0xa5, 0xb1, 0x53, 0x4e, 0xa5,
	0x1f, 0x00, 0x98, 0xbe, 0xef, 0xda, 0x4f, 0x26, 0xbe, 0x9c, 0x80, 0xc5, 0x36, 0x46, 0x49, 0x64,
	0x70, 0x32, 0x05, 0x13, 0x5d, 0xa1, 0x4a, 0x95, 0x0c, 0x77, 0x16, 0xdb, 0x6c, 0x0c, 0xb9, 0xfa,
	0x42, 0x89, 0x48, 0x6f, 0x25, 0xa8, 0x12, 0xdd, 0xe1, 0x4a, 0x14, 0xf4, 0x24, 0x9c, 0xd0, 0x93,
	0x85, 0xef, 0x46, 0x42, 0x5d, 0xf0, 0x20, 0xd4, 0x05, 0x97, 0x42, 0xa5, 0x9f, 0xd4, 0x03, 0x3f,
	0x3e, 0xd7, 0x9d, 0x0d, 0xfb, 0x97, 0x11, 0x74, 0x16, 0xce, 0xec, 0x1a, 0x3a, 0x2e, 0xe1, 0xf2,
	0xae, 0x51, 0x2e, 0x55, 0x19, 0x38, 0xba, 0xc0, 0xed, 0x8c, 0x11, 0x12, 0xe1, 0xc6, 0x76, 0x9b,
	0xb8, 0xf1, 0xc8, 0xa8, 0xe8, 0x58, 0x8b, 0x13, 0xbf, 0x17, 0xeb, 0x2d, 0xe3, 0x9b, 0x7a, 0xf7,
	0x51, 0xa3, 0xda, 0xa9, 0xe9, 0x5a, 0x82, 0xf7, 0xee, 0x3f, 0x8e, 0xc2, 0x5a, 0xb9, 0x65, 0x34,
	0x07, 0x93, 0x7d, 0x7b, 0x14, 0x5a, 0x0f, 0x50, 0x09, 0xd2, 0x9e, 0xe5, 0x1e, 0xda, 0xa4, 0x1f,
	0x89, 0xcd, 0xb3, 0x74, 0xf7, 0xb2, 0x58, 0x37, 0xe6, 0x12, 0xdc, 0x6c, 0x31, 0x6c, 0x2c, 0xc9,
	0xd4, 0x15, 0x32, 0x7a, 0xf2, 0x0a, 0xf9, 0xa5, 0x34, 0x27, 0xb4, 0xbc, 0xc5, 0x4f, 0xb5, 0xbc,
	0x15, 0xb7, 0x21, 0xc5, 0xeb, 0x1a, 0x96, 0xff, 0x1a, 0xa0, 0x72, 0xa3, 0xde, 0xc6, 0x8d, 0x6a,
	0x55, 0xc7, 0x5d, 0x22, 0x61, 0xa3, 0x4c, 0xfa, 0x41, 0x83, 0x5c, 0xbd, 0x51, 0xd1, 0x25, 0x44,
	0x2c, 0x0d, 0xdf, 0x89, 0x40, 0x5e, 0xca, 0x42, 0xcc, 0x86, 0x5c, 0x27, 0x94, 0xd9, 0x90, 0xba,
	0x09, 0xc7, 0x6f, 0x59, 0x95, 0x01, 0x64, 0xd5, 0x44, 0xbb, 0x2f, 0x2e, 0x94, 0xb4, 0x18, 0x08,
	0x01, 0x59, 0xf1, 0xa7, 0x62, 0xb0, 0x3a, 0xb3, 0x2f, 0x4d, 0x6a, 0x74, 0x87, 0x4f, 0xbb, 0x44,
	0x30, 0xe7, 0xa6, 0xa4, 0x19, 0x6c, 0x60, 0x87, 0x06, 0x4b, 0x78, 0x30, 0x46, 0x4f, 0x3d, 0x18,
	0x45, 0xe3, 0x63, 0xc7, 0x36, 0x3e, 0x3e, 0xd3, 0xf8, 0xcf, 0x60, 0xb5, 0x6f, 0xb1, 0x05, 0xd5,
	0xb5, 0x88, 0xde, 0x50, 0xe3, 0x40, 0x4c, 0x01, 0x9b, 0x53, 0x15, 0x26, 0x7f, 0x04, 0x8e, 0x22,
	0x88, 0x15, 0xce, 0x42, 0xc9, 0x25, 0x7e, 0x4e, 0xca, 0xf3, 0x1d, 0xd7, 0xdc, 0xb7, 0xf8, 0xfc,
	0xf0, 0xe6, 0x71, 0xad, 0xa7, 0xba, 0xcb, 0x50, 0xb1, 0xa0, 0x29, 0x7c, 0x0c, 0x29, 0x0e, 0x43,
	0x77, 0x21, 0x39, 0xa6, 0x9d, 0xc0, 0x17, 0xe8, 0xd5, 0xe9, 0xce, 0x51, 0x17, 0x63, 0x86, 0x59,
	0xfc, 0xcd, 0x18, 0x24, 0x1e, 0x51, 0xf3, 0xf9, 0xba, 0xa2, 0x12, 0x4b, 0x72, 0x7a, 0xa1, 0x79,
	0xb3, 0xce, 0xe4, 0x75, 0xe2, 0xd0, 0x99, 0x03, 0xd3, 0x9d, 0xda, 0x46, 0x66, 0xe8, 0x2d, 0x9a,
	0x85, 0x39, 0x0a, 0x41, 0x76, 0xcd, 0xd1, 0xbe, 0xe5, 0xf1, 0x9d, 0x9d, 0x30, 0x32, 0xa6, 0x59,
	0x98, 0xa3, 0xa0, 0x22, 0xc4, 0x3c, 0xcb, 0xe7, 0x23, 0x44, 0x0b, 0xb3, 0xb5, 0x7c, 0x4c, 0x32,
	0xd1, 0x65, 0x88, 0xfb, 0xd6, 0x73, 0xb6, 0xb9, 0x99, 0x9d, 0xae, 0xaa, 0xf5, 0xdc, 0xc7, 0x34,
	0xbb, 0xf0, 0x16, 0x24, 0x59, 0x4d, 0xc2, 0x6e, 0x43, 0x24, 0xe4, 0x36, 0x14, 0x3e, 0x82, 0x04,
	0xad, 0x02, 0x41, 0x7a, 0x62, 0x09, 0xe9, 0xc5, 0x05, 0x12, 0x05, 0xa1, 0x35, 0x88, 0x59, 0x74,
	0x72, 0x08, 0x72, 0x08, 0xa0, 0xf0, 0x21, 0x24, 0x59, 0xfd, 0xd1, 0x4d, 0x48, 0xd0, 0x16, 0x70,
	0xb7, 0x0b, 0xcd, 0xb6, 0x51, 0x70, 0xa4, 0x68, 0x85, 0x73, 0x10, 0x6b, 0x59, 0xd4, 0x5b, 0xb6,
	0x7d, 0x6b, 0x48, 0xa9, 0x32, 0x98, 0xfe, 0x2f, 0x14, 0x21, 0x4e, 0x5a, 0xb1, 0xf0, 0x04, 0xe6,
	0x0e, 0x9f, 0x97, 0x01, 0x92, 0xad, 0x72, 0xa9, 0x5a, 0xc2, 0xda, 0x6b, 0xe4, 0x3f, 0x2e, 0xd5,
	0x77, 0xe8, 0xc6, 0x62, 0x0a, 0x62, 0x2d, 0xbd, 0xcd, 0x36, 0xae, 0xdb, 0xfa, 0x67, 0x6d, 0x2d,
	0x56, 0xfc, 0x83, 0x08, 0x64, 0xe4, 0xb0, 0x38, 0xde, 0x1e, 0x92, 0x8a, 0x10, 0x7d, 0x35, 0x45,
	0x88, 0xbd, 0x8a, 0x22, 0xc4, 0x4f, 0x56, 0x84, 0xd3, 0x75, 0xb2, 0xd0, 0x97, 0xe4, 0x02, 0x7d,
	0x29, 0xfe, 0x5a, 0x0e, 0xd2, 0x62, 0x34, 0x2d, 0x68, 0xf8, 0xe5, 0x13, 0x1a, 0xfe, 0xa7, 0xde,
	0x64, 0xde, 0x96, 0xc4, 0x22, 0xdd, 0x5f, 0xb0, 0x6f, 0x7f, 0x03, 0xe2, 0x7d, 0xdb, 0x7b, 0xca,
	0x6d, 0xc2, 0xf5, 0xe9, 0x39, 0xa9, 0x62, 0x7b, 0x74, 0x2b, 0x03, 0x53, 0x2c, 0x54, 0x82, 0xac,
	0x32, 0x93, 0x71, 0xfb, 0xf0, 0xa4, 0x89, 0x0c, 0xab, 0x34, 0xe8, 0x23, 0xb2, 0x10, 0x1e, 0x3a,
	0x3d, 0xea, 0x70, 0x67, 0x42, 0x0e, 0x86, 0xc2, 0x80, 0x23, 0xb0, 0xc5, 0x4d, 0xe2, 0x93, 0xd9,
	0xca, 0x3b, 0x30, 0x5d, 0xab, 0xcf, 0x0d, 0x9a, 0xc2, 0x34, 0x65, 0x8b, 0xe6, 0x32, 0xcb, 0x86,
	0x61, 0xa2, 0x1d, 0x58, 0x36, 0x07, 0x03, 0xa7, 0x47, 0x8b, 0xef, 0xda, 0xa3, 0x3d, 0x87, 0x7b,
	0x8a, 0x1b, 0xd3, 0xc4, 0x25, 0x89, 0x46, 0x19, 0x2c, 0x99, 0xa1, 0x34, 0xfa, 0x3a, 0x64, 0xc7,
	0x7c, 0x5a, 0x25, 0x3e, 0x6e, 0xee, 0xa4, 0x65, 0x67, 0x89, 0xf8, 0xe9, 0x41, 0x1a, 0x83, 0xa0,
	0x36, 0xfa, 0xc8, 0x80, 0x5c, 0x68, 0x49, 0xc8, 0xbf, 0xca, 0x92, 0x10, 0x22, 0x2d, 0xbc, 0x05,
	0x4b, 0xe1, 0x8a, 0x93, 0xf9, 0x81, 0x76, 0x37, 0x3b, 0x6f, 0xa3, 0xff, 0x0b, 0xbf, 0x1a, 0x81,
	0xe5, 0x29, 0x6e, 0xe1, 0x73, 0x99, 0xc8, 0xf4, 0xb9, 0x4c, 0xe0, 0xaa, 0x46, 0x17, 0xb9, 0xaa,
	0xa2, 0xb0, 0x58, 0x50, 0x18, 0xfa, 0x90, 0x0f, 0x8a, 0x78, 0xe8, 0x40, 0xe4, 0xb8, 0x56, 0x29,
	0xe3, 0x64, 0xbe, 0x13, 0x4b, 0xe6, 0xab, 0x76, 0xa9, 0x6d, 0x94, 0xb5, 0x08, 0x75, 0x68, 0x3f,
	0xaf, 0x97, 0x6a, 0x46, 0x59, 0x58, 0x2a, 0x85, 0xbf, 0x96, 0x80, 0xb4, 0xd0, 0x53, 0xb4, 0x0d,
	0xd9, 0x31, 0xf1, 0x78, 0x3c, 0xdf, 0x1a, 0xf5, 0x2c, 0x6e, 0x1b, 0xbc, 0x75, 0x9c, 0x5a, 0xdf,
	0x6c, 0x06, 0xb8, 0x58, 0x25, 0x24, 0xad, 0x3f, 0x74, 0x06, 0x93, 0xa1, 0x35, 0xd5, 0xfa, 0x47,
	0x14, 0x88, 0x79, 0x26, 0xfa, 0x8a, 0xdc, 0x9c, 0x88, 0xcd, 0x1f, 0x0b, 0xb2, 0xa4, 0x16, 0x4d,
	0x8b, 0x9d, 0x8b, 0xc2, 0x0e, 0x64, 0x95, 0xb2, 0x17, 0x3a, 0x90, 0xa1, 0x6e, 0x8a, 0x4e, 0x75,
	0x53, 0xe1, 0xa7, 0x63, 0x90, 0x64, 0xbc, 0x95, 0x73, 0xa8, 0xe8, 0x3c, 0xb1, 0x4f, 0x55, 0x65,
	0x76, 0x5e, 0xfe, 0x50, 0xd9, 0x85, 0xcd, 0x9e, 0x4c, 0xdf, 0x34, 0xfd, 0x03, 0xbe, 0x57, 0xfb,
	0x11, 0x24, 0x86, 0xce, 0x64, 0xe4, 0x73, 0x29, 0x5c, 0x3e, 0x89, 0xb4, 0x46, 0x90, 0x31, 0xa3,
	0xa1, 0xc7, 0xc0, 0xc2, 0xd3, 0x55, 0x4d, 0xb5, 0x6b, 0x90, 0x1e, 0x5a, 0xbe, 0x49, 0xf7, 0xb3,
	0x12, 0xf3, 0x54, 0x50, 0x66, 0x13, 0xb7, 0x77, 0xec, 0x3a, 0x74, 0xb3, 0x8d, 0xbb, 0xbd, 0x3c,
	0x59, 0x28, 0x40, 0x9c, 0xd4, 0x93, 0xa9, 0xa9, 0xe3, 0x07, 0x63, 0xc2, 0xf1, 0x0b, 0xe7, 0x21,
	0x41, 0x2b, 0x32, 0x2f, 0xb3, 0xb8, 0x35, 0x4f, 0x13, 0xd3, 0x10, 0x6f, 0x96, 0xda, 0xbb, 0x5a,
	0x04, 0x65, 0x20, 0x51, 0x6b, 0x74, 0xea, 0x64, 0xb5, 0xcc, 0x40, 0x62, 0xab, 0xda, 0x28, 0x3f,
	0xd4, 0x62, 0x64, 0x05, 0xc5, 0xa5, 0xc7, 0x5a, 0x9c, 0x6b, 0xe6, 0x32, 0xe4, 0x43, 0x53, 0x59,
	0x21, 0x07, 0x10, 0xcc, 0x50, 0xc5, 0x7f, 0x10, 0x85, 0xf5, 0xb6, 0x6b, 0xee, 0xed, 0xd9, 0x3d,
	0x62, 0x02, 0xbb, 0xce, 0xa0, 0xe5, 0x9b, 0xbe, 0xed, 0xf9, 0x76, 0xcf, 0x5b, 0xa8, 0x11, 0xeb,
	0x90, 0x7a, 0x62, 0xf6, 0x9e, 0x0e, 0x9c, 0x7d, 0xda, 0x57, 0x71, 0x2c, 0x92, 0x68, 0x15, 0x12,
	0x4f, 0x5e, 0xf8, 0xdc, 0x6a, 0x8a, 0x63, 0x96, 0x20, 0xd0, 0xbe, 0xeb, 0x8c, 0xd9, 0x7a, 0x12,
	0xc7, 0x2c, 0x81, 0x36, 0x00, 0x9c, 0x43, 0xcb, 0x1d, 0xd8, 0x43, 0xdb, 0x67, 0xe7, 0x13, 0x71,
	0xac, 0x40, 0xa8, 0x50, 0xcd, 0xde, 0x53, 0xcb, 0x67, 0xc7, 0x10, 0x71, 0x2c, 0x92, 0x44, 0x5e,
	0x5f, 0x0c, 0xac, 0x11, 0x5d, 0x34, 0xe2, 0x98, 0xfe, 0x47, 0x97, 0x21, 0xe5, 0x9a, 0xbe, 0xf5,
	0x64, 0xec, 0xd1, 0x65, 0x21, 0xbe, 0x95, 0x3d, 0x7a, 0xb9, 0x99, 0xc2, 0xa6, 0x6f, 0x6d, 0x35,
	0x5b, 0x58, 0xe4, 0x09, 0xb4, 0xf1, 0xd8, 0xa3, 0x93, 0xbf, 0x82, 0xd6, 0x14, 0x68, 0xe3, 0x31,
	0xbd, 0xb5, 0xe1, 0x5a, 0x5f, 0x4c, 0xac, 0x09, 0x3d, 0xe5, 0x25, 0xa5, 0xc8, 0x74, 0xf1, 0x47,
	0x13, 0x90, 0x33, 0xc6, 0x8a, 0xa8, 0x36, 0x00, 0xb6, 0x1d, 0xf7, 0x99, 0xe9, 0xf6, 0xed, 0xd1,
	0x3e, 0xed, 0xc4, 0x18, 0x56, 0x20, 0x24, 0xbf, 0xc2, 0x8c, 0xe8, 0x76, 0xbb, 0x4a, 0x25, 0x16,
	0xc3, 0x0a, 0x84, 0xe4, 0x1b, 0x23, 0x6c, 0xf5, 0x2c, 0xfb, 0x90, 0x4b, 0x2e, 0x86, 0x15, 0x08,
	0xba, 0x04, 0x59, 0x63, 0xb4, 0xdb, 0x77, 0x75, 0xd7, 0x75, 0x5c, 0x26, 0xc4, 0x18, 0x56, 0x41,
	0xa8, 0x08, 0x39, 0x63, 0x54, 0xea, 0x4b, 0x94, 0x04, 0x45, 0x09, 0xc1, 0xd0, 0x5b, 0x90, 0x27,
	0x75, 0xaa, 0x98, 0xbe, 0xb9, 0xef, 0x9a, 0x43, 0x26, 0xd4, 0x18, 0x0e, 0x03, 0xd1, 0x55, 0x58,
	0x36, 0x46, 0x9d, 0xd1, 0xd3, 0x91, 0xf3, 0x6c, 0x44, 0x8f, 0x0f, 0xd8, 0x76, 0x4d, 0x0c, 0x4f,
	0x83, 0x59, 0xad, 0x2b, 0xb6, 0xd7, 0x33, 0xdd, 0x3e, 0x93, 0x39, 0xad, 0xb5, 0x80, 0xf0, 0x7c,
	0x6b, 0x60, 0x1f, 0x12, 0xd7, 0x2b, 0x23, 0xf3, 0x39, 0x84, 0xb4, 0xaa, 0x31, 0xf1, 0x31, 0x91,
	0xaa, 0xe7, 0x33, 0x29, 0xc7, 0xb0, 0x0a, 0xe2, 0x18, 0xb2, 0x88, 0xac, 0xc4, 0x90, 0x65, 0x30,
	0x8c, 0xba, 0x83, 0x1d, 0xea, 0x4e, 0xe5, 0x24, 0x86, 0x00, 0x11, 0xc9, 0x60, 0xcb, 0xf4, 0x86,
	0xfc, 0xa6, 0x01, 0xdd, 0x30, 0x8d, 0xe1, 0x10, 0x8c, 0xd4, 0x94, 0xa6, 0xb1, 0xf5, 0x45, 0x9f,
	0x6d, 0x8c, 0xc6, 0xb0, 0x02, 0x21, 0xca, 0x40, 0x53, 0x8d, 0x87, 0x1e, 0xdd, 0x11, 0x8d, 0x61,
	0x99, 0x96, 0xb4, 0xdb, 0xa6, 0x3d, 0xf0, 0xd6, 0x35, 0x85, 0x96, 0x42, 0x88, 0x12, 0x6f, 0xbb,
	0xe6, 0x3e, 0x21, 0x3d, 0x43, 0x33, 0x45, 0x92, 0x4c, 0xab, 0xe4, 0x2f, 0x23, 0x44, 0x34, 0x2f,
	0x00, 0x90, 0x96, 0x91, 0x44, 0xd9, 0xb5, 0x4c, 0xd2, 0xb2, 0x15, 0xd6, 0x32, 0x05, 0x54, 0xfc,
	0xa7, 0x29, 0x58, 0x32, 0x7a, 0x43, 0x55, 0x11, 0xd7, 0x20, 0x69, 0x8c, 0x6a, 0xde, 0xbe, 0xc7,
	0x95, 0x90, 0xa7, 0x48, 0x03, 0x8c, 0x11, 0x57, 0x0d, 0xa6, 0x7e, 0x32, 0xcd, 0x54, 0xa7, 0xec,
	0x4d, 0x86, 0x3c, 0x3f, 0x26, 0x54, 0x27, 0x80, 0xa1, 0x2b, 0xb0, 0x44, 0x3a, 0xce, 0xf3, 0x3b,
	0x23, 0xd7, 0x32, 0x7b, 0x07, 0x42, 0x07, 0xa7, 0xa0, 0x4c, 0x51, 0x89, 0x54, 0xf5, 0xe7, 0xbd,
	0xbe, 0xd0, 0x42, 0x15, 0xc4, 0x30, 0x9a, 0xa6, 0x3b, 0x6c, 0xba, 0xce, 0x13, 0xa1, 0x82, 0x2a,
	0x88, 0xd5, 0xa7, 0xe5, 0xf6, 0xbe, 0x31, 0xb1, 0x46, 0xa4, 0xa4, 0x94, 0xa8, 0x4f, 0x00, 0x63,
	0x5c, 0xb0, 0xd5, 0xb7, 0x5d, 0xab, 0xe7, 0x0b, 0xdd, 0x53, 0x41, 0x44, 0xec, 0xc6, 0x48, 0xef,
	0x1d, 0x38, 0x42, 0xf3, 0x44, 0x92, 0xa9, 0x25, 0xf9, 0x8b, 0xad, 0xb1, 0xd0, 0x3a, 0x05, 0xc2,
	0xca, 0x27, 0x15, 0xf6, 0x7c, 0x73, 0x38, 0x16, 0x5a, 0x17, 0x82, 0xb1, 0x41, 0x22, 0xd3, 0x94,
	0x51, 0x4e, 0x0c, 0x92, 0x10, 0x98, 0xd5, 0x94, 0x0c, 0xc2, 0x9a, 0xe9, 0x3d, 0xf5, 0xb8, 0xf6,
	0xa9, 0x20, 0x26, 0x5b, 0x91, 0xa4, 0xac, 0x96, 0x84, 0x6c, 0x55, 0x28, 0x69, 0x51, 0x63, 0xe2,
	0xd3, 0xce, 0x65, 0x3a, 0x28, 0x92, 0x44, 0x91, 0x1a, 0x13, 0x9f, 0x77, 0x1f, 0xd3, 0xc0, 0x00,
	0x40, 0xea, 0x4a, 0x46, 0x8c, 0xda, 0x79, 0x4c, 0x11, 0xa7, 0xc1, 0xa4, 0xe5, 0x8d, 0x89, 0x1f,
	0x74, 0x1f, 0xd3, 0xc9, 0x10, 0x8c, 0xe3, 0x04, 0x1d, 0xb8, 0x22, 0x71, 0x82, 0x1e, 0x7c, 0x0b,
	0xf2, 0x8d, 0x89, 0xaf, 0x74, 0xe1, 0x2a, 0x9b, 0x68, 0x42, 0x40, 0xce, 0x29, 0xe8, 0xc4, 0xb3,
	0x92, 0x53, 0xd0, 0x8b, 0x05, 0x48, 0x93, 0x86, 0xd0, 0x6e, 0x5c, 0x63, 0x7a, 0x2b, 0xd2, 0x7c,
	0xe8, 0xcb, 0x8e, 0x7c, 0x5d, 0x0e, 0x7d, 0xd9, 0x93, 0xac, 0x1e, 0x4a, 0x57, 0xae, 0xcb, 0x7a,
	0x28, 0x7d, 0xf9, 0x0e, 0x68, 0x2a, 0x80, 0x32, 0x3b, 0x47, 0x11, 0x67, 0xe0, 0xbc, 0xce, 0x41,
	0x77, 0x16, 0x64, 0x9d, 0x83, 0xfe, 0x64, 0xf2, 0x0e, 0x75, 0xe8, 0x79, 0x29, 0x6f, 0x15, 0x5c,
	0xfc, 0x6e, 0x0c, 0xf2, 0xed, 0x9e, 0x3a, 0x7e, 0xc9, 0x64, 0xe5, 0x3b, 0xa5, 0xc1, 0xbe, 0xe3,
	0xda, 0xfe, 0xc1, 0x90, 0x8f, 0xe2, 0x10, 0x8c, 0x8c, 0x71, 0xec, 0x3b, 0x35, 0x7b, 0xc4, 0x47,
	0x32, 0x4f, 0x09, 0xb8, 0xf9, 0x9c, 0x8f, 0x60, 0x9e, 0x22, 0x7a, 0x53, 0x33, 0x9f, 0x97, 0x9d,
	0xd1, 0x88, 0x0f, 0x5a, 0x91, 0x24, 0x12, 0x2c, 0xf5, 0x7c, 0xfb, 0xd0, 0x6a, 0x8c, 0xad, 0x91,
	0x1c, 0xad, 0x0a, 0x88, 0xd4, 0xa7, 0x69, 0x7a, 0x9e, 0x44, 0x61, 0xc3, 0x35, 0x04, 0x23, 0x38,
	0x25, 0xdf, 0xb7, 0x86, 0x63, 0x9f, 0xcd, 0x64, 0x7c, 0xbc, 0xaa, 0x30, 0x52, 0x92, 0xee, 0xf9,
	0xe6, 0x13, 0x62, 0x78, 0x07, 0xe3, 0x55, 0x01, 0x11, 0x1d, 0x2e, 0x4f, 0x5c, 0x97, 0x82, 0xf8,
	0x88, 0x0d, 0x00, 0x6c, 0x5e, 0x6b, 0x59, 0xfb, 0x62, 0xbc, 0xf2, 0x14, 0x1f, 0x13, 0x34, 0x23,
	0x2b, 0xc7, 0x04, 0xcd, 0xb9, 0x04, 0x59, 0x6c, 0xf9, 0xae, 0x39, 0xf2, 0x68, 0x2e, 0x5f, 0x18,
	0x14, 0x10, 0xe3, 0xa9, 0xbb, 0xae, 0x18, 0x94, 0x3c, 0xc5, 0x79, 0x62, 0xb2, 0x24, 0x2d, 0x49,
	0x9e, 0x24, 0x39, 0x33, 0x53, 0x2e, 0xcf, 0xce, 0x94, 0xc5, 0xbf, 0x19, 0x85, 0x7c, 0xa7, 0xaf,
	0xf6, 0x29, 0x9d, 0x01, 0x82, 0x45, 0x37, 0x22, 0x66, 0x80, 0x60, 0xc9, 0x5d, 0x87, 0x54, 0xdd,
	0x69, 0x3a, 0xae, 0x2f, 0x26, 0x67, 0x91, 0x0c, 0xcd, 0xdb, 0xb1, 0xd9, 0x79, 0x9b, 0x0c, 0x60,
	0xc9, 0x38, 0x2e, 0x75, 0x31, 0xe0, 0x4c, 0xf4, 0xa9, 0x77, 0xf8, 0x64, 0xb2, 0x17, 0x36, 0x0b,
	0x54, 0x18, 0xc1, 0x69, 0x8d, 0xfa, 0x01, 0x0e, 0xef, 0x63, 0x15, 0x36, 0xd3, 0xf2, 0xd4, 0x9c,
	0x35, 0x82, 0xe0, 0xec, 0x8f, 0x1c, 0xd7, 0xea, 0xd7, 0x26, 0x03, 0xdf, 0xe6, 0x9d, 0x1c, 0x82,
	0x15, 0xff, 0x72, 0x14, 0x96, 0x5a, 0xf5, 0x5a, 0x53, 0x11, 0xcf, 0x47, 0x90, 0xb6, 0xc7, 0x5d,
	0xcf, 0x37, 0x7d, 0x6f, 0xea, 0xf2, 0x80, 0x6a, 0x62, 0x31, 0x2b, 0xcd, 0xa0, 0x84, 0x1e, 0x4e,
	0xd9, 0x34, 0xcb, 0x43, 0x65, 0x00, 0xbb, 0x37, 0x14, 0xe4, 0xd1, 0xd0, 0x15, 0xac, 0xf0, 0xd2,
	0xb8, 0x95, 0x3f, 0x7a, 0xb9, 0x99, 0x31, 0xca, 0x35, 0xce, 0x22, 0x63, 0xf3, 0x6c, 0x0f, 0x7d,
	0x0a, 0x19, 0xbf, 0x27, 0x78, 0xc4, 0x42, 0x9b, 0xdc, 0xa1, 0xd1, 0xc9, 0x6e, 0x05, 0xb6, 0xcb,
	0x9c, 0x43, 0xda, 0xef, 0x05, 0x0c, 0x26, 0x7d, 0xc1, 0x20, 0xbc, 0x4b, 0x1e, 0x52, 0x05, 0xc6,
	0xa0, 0x53, 0x11, 0x0c, 0x26, 0x2c, 0xd3, 0x2b, 0x7e, 0x37, 0x02, 0x4b, 0xc4, 0x43, 0x51, 0xc4,
	0x12, 0xf8, 0x75, 0x91, 0x57, 0xf2, 0xeb, 0xa6, 0xfd, 0xcf, 0xe8, 0x97, 0xf5, 0x3f, 0x37, 0x21,
	0x4b, 0xcd, 0xf0, 0xae, 0x6a, 0xce, 0x03, 0x05, 0x6d, 0x51, 0x9b, 0xfe, 0x22, 0xc0, 0xc4, 0xb3,
	0xfa, 0x3c, 0x9f, 0x19, 0xf6, 0x19, 0x02, 0xa1, 0xd9, 0xc5, 0x5f, 0x5a, 0x09, 0xee, 0x72, 0x87,
	0x66, 0xb8, 0x8c, 0x2f, 0xa6, 0xd4, 0xd0, 0xc6, 0x66, 0x00, 0x46, 0x65, 0x58, 0xe9, 0x8d, 0x27,
	0x5e, 0x77, 0xe2, 0xf1, 0xbb, 0xa3, 0x5d, 0xcf, 0xea, 0xf1, 0xcb, 0x54, 0x5b, 0xab, 0x47, 0x2f,
	0x37, 0xb5, 0x72, 0xb3, 0xe3, 0x75, 0x3c, 0x76, 0x7d, 0xb4, 0x65, 0xf5, 0x3c, 0xac, 0x11, 0x02,
	0x15, 0x82, 0x0c, 0x38, 0x4b, 0x99, 0x78, 0x2f, 0x3c, 0xdf, 0x1a, 0x2a, 0x6c, 0xe8, 0x3d, 0xab,
	0xad, 0xb5, 0xa3, 0x97, 0x9b, 0x88, 0xb0, 0x69, 0xd1, 0x7c, 0xc9, 0x08, 0x11, 0xa2, 0x30, 0x0c,
	0xdd, 0x00, 0xa0, 0xac, 0x68, 0xe3, 0xd9, 0xcd, 0x2b, 0xa6, 0x4e, 0x84, 0xbe, 0x4a, 0x80, 0x38,
	0x43, 0x10, 0xe8, 0x5f, 0xf4, 0x1e, 0xe4, 0x87, 0xd6, 0xb0, 0xeb, 0x7a, 0x1e, 0x17, 0x0d, 0x75,
	0x6c, 0xd8, 0xbd, 0x83, 0x9a, 0x35, 0xc4, 0xad, 0x16, 0x15, 0x10, 0xce, 0x0e, 0xad, 0x21, 0xf6,
	0x3c, 0x26, 0xcc, 0x2b, 0xb0, 0x4c, 0x88, 0x54, 0x89, 0x33, 0x97, 0x87, 0xf0, 0xaa, 0x06, 0x42,
	0xbf, 0x0f, 0xcb, 0xb4, 0x2a, 0x23, 0x97, 0x5f, 0x00, 0x60, 0x63, 0x31, 0xbf, 0x75, 0xe6, 0xe8,
	0xe5, 0x66, 0x9e, 0xd4, 0xa7, 0xee, 0xb2, 0x93, 0x7e, 0x0f, 0xe7, 0x09, 0xa6, 0x4c, 0xa2, 0x4f,
	0xe1, 0x8c, 0x20, 0xf5, 0x0f, 0x5c, 0xc7, 0xf7, 0x07, 0x16, 0xbb, 0x27, 0x91, 0xdf, 0x5a, 0x39,
	0x7a, 0xb9, 0xb9, 0xcc, 0x88, 0xdb, 0x22, 0x0b, 0x2f, 0x33, 0x72, 0x09, 0x40, 0x18, 0xd6, 0x29,
	0x03, 0x49, 0xad, 0x08, 0x35, 0x43, 0x85, 0x72, 0xee, 0xe8, 0xe5, 0xe6, 0x59, 0xc2, 0x47, 0x12,
	0x49, 0xb9, 0xd2, 0xce, 0x98, 0x01, 0xa3, 0xb7, 0x60, 0x89, 0xb4, 0x9b, 0x78, 0xca, 0xbc, 0xd9,
	0xcc, 0xd9, 0xca, 0x0d, 0xad, 0xe1, 0xb6, 0x3d, 0xb0, 0x58, 0xab, 0x39, 0x96, 0x39, 0x72, 0x46,
	0x1c, 0x2b, 0x2b, 0xb1, 0x4a, 0x23, 0x67, 0xc4, 0xb0, 0xee, 0xc0, 0x59, 0x82, 0x35, 0x34, 0xc7,
	0x63, 0xab, 0xaf, 0xb2, 0xcc, 0x51, 0x64, 0x34, 0xb4, 0x86, 0x35, 0x9a, 0x17, 0x30, 0xbe, 0x06,
	0xf1, 0xb1, 0xe5, 0xee, 0xf1, 0x5b, 0x14, 0x62, 0xe6, 0x68, 0x5a, 0xee, 0x5e, 0xa0, 0xb2, 0x98,
	0xa2, 0x90, 0x3a, 0x8c, 0x2c, 0xbf, 0xeb, 0x3e, 0xef, 0x0a, 0x9f, 0x74, 0x89, 0xd5, 0x61, 0x64,
	0xf9, 0xf8, 0x79, 0x93, 0x3b, 0xa6, 0x97, 0x20, 0xc7, 0xb1, 0x58, 0xd1, 0xcb, 0x6c, 0xd8, 0x50,
	0x1c, 0x56, 0x64, 0x11, 0xf2, 0x1c, 0xc3, 0x0a, 0x0c, 0xb6, 0x38, 0xce, 0x52, 0x14, 0xe9, 0xa9,
	0x89, 0xb2, 0x88, 0xa3, 0x3c, 0xb6, 0xfa, 0xd4, 0x62, 0x13, 0x65, 0x55, 0x18, 0x4c, 0x60, 0xf9,
	0x41, 0x8d, 0x90, 0xc4, 0x6a, 0x4f, 0xd7, 0xc8, 0x17, 0x35, 0x5a, 0x91, 0x35, 0x6a, 0x87, 0x6b,
	0xe4, 0xcb, 0x1a, 0xad, 0xca, 0x1a, 0xb5, 0xa7, 0x6a, 0xe4, 0x07, 0x35, 0x3a, 0xab, 0x94, 0x25,
	0x6a, 0xd4, 0x82, 0x73, 0x14, 0xab, 0x37, 0xee, 0xba, 0xbe, 0xdf, 0x1d, 0xda, 0x3d, 0xd7, 0x21,
	0xea, 0xd1, 0x1d, 0xdf, 0xbb, 0x4d, 0xed, 0x37, 0xae, 0x22, 0x75, 0xcb, 0x6f, 0x97, 0x9b, 0xd8,
	0xf7, 0x6b, 0x02, 0xa3, 0x79, 0xef, 0x36, 0x3e, 0x4b, 0x78, 0xf5, 0xc6, 0x53, 0xe0, 0x05, 0x4c,
	0xef, 0xdf, 0xa6, 0x56, 0xdf, 0xf1, 0x4c, 0xef, 0xcf, 0x67, 0x7a, 0x7f, 0x21, 0xd3, 0x7b, 0xd4,
	0x4c, 0x5c, 0xc0, 0xf4, 0xde, 0x7c, 0xa6, 0xf7, 0x16, 0x31, 0xbd, 0x4f, 0x4d, 0xca, 0x05, 0x4c,
	0xef, 0xcf, 0x67, 0x7a, 0x1f, 0x5d, 0x05, 0xad, 0x6f, 0x7b, 0x4f, 0x43, 0x53, 0x43, 0x81, 0xca,
	0x7e, 0x89, 0xc0, 0x95, 0xb9, 0xe1, 0x0a, 0x2c, 0x53, 0x4c, 0x65, 0x56, 0x3e, 0xcf, 0xe6, 0x10,
	0x02, 0xee, 0x88, 0x99, 0x19, 0x7d, 0x06, 0x05, 0x51, 0x4d, 0x93, 0xda, 0x7a, 0xdd, 0x9e, 0x33,
	0x1a, 0x59, 0x3d, 0xb6, 0x11, 0x7c, 0x81, 0xd6, 0xf3, 0xfc, 0xd1, 0xcb, 0xcd, 0xd7, 0x59, 0x3d,
	0x99, 0x3d, 0x58, 0x0e, 0x50, 0xf0, 0xeb, 0xac, 0xa6, 0x33, 0x19, 0xa8, 0x0b, 0x17, 0x05, 0x67,
	0x3a, 0x35, 0x3c, 0x33, 0x6d, 0x3f, 0xc4, 0xfc, 0x22, 0x65, 0x7e, 0xf1, 0xe8, 0xe5, 0xe6, 0x39,
	0xc6, 0x9c, 0x4c, 0x04, 0x8f, 0x4d, 0xdb, 0x57, 0xd9, 0x9f, 0x63, 0xec, 0xe7, 0x64, 0xb1, 0x9d,
	0x48, 0xa7, 0x67, 0x79, 0x9e, 0xe5, 0xad, 0x6f, 0x90, 0xb9, 0x0b, 0x07, 0x00, 0x62, 0x47, 0xf9,
	0x07, 0xae, 0x65, 0xf6, 0xbd, 0xf5, 0x4d, 0x9a, 0x27, 0x92, 0xe8, 0x2b, 0xb0, 0x4e, 0xa7, 0x57,
	0xe7, 0x59, 0x77, 0xec, 0x5a, 0x9e, 0x37, 0x71, 0x49, 0xa3, 0x27, 0x23, 0xdf, 0x72, 0xd7, 0x2f,
	0x51, 0x19, 0x91, 0xa9, 0xa3, 0xea, 0x3c, 0x6b, 0xf2, 0xdc, 0x32, 0xcb, 0x44, 0x1f, 0xc3, 0x79,
	0x3a, 0xa7, 0x58, 0x7d, 0x7b, 0x32, 0x9c, 0xa5, 0x7d, 0x83, 0xd2, 0x12, 0xde, 0x35, 0x8a, 0x31,
	0x4d, 0x5e, 0x82, 0x8b, 0x84, 0xbc, 0xe7, 0xda, 0xbe, 0xdd, 0x33, 0x07, 0xb3, 0x0c, 0x8a, 0x94,
	0x41, 0x61, 0x68, 0x0d, 0xcb, 0x1c, 0x67, 0x9a, 0xc5, 0x0f, 0xc3, 0x06, 0x95, 0x29, 0xdb, 0xa6,
	0x23, 0xd2, 0xf4, 0x5d, 0x67, 0x40, 0x8d, 0x0d, 0x36, 0x3f, 0xad, 0xbf, 0x19, 0xda, 0xba, 0x3f,
	0x6e, 0x3f, 0x8f, 0x2f, 0xb3, 0xe7, 0x89, 0x70, 0x8f, 0xdb, 0xf2, 0xe3, 0xab, 0x90, 0xef, 0xf8,
	0xe6, 0x80, 0x6b, 0xd0, 0x5b, 0x72, 0x15, 0x6a, 0x13, 0x68, 0x68, 0xa6, 0x65, 0x78, 0x43, 0x6b,
	0xe8, 0x3d, 0xe3, 0xd8, 0x97, 0xe5, 0x4c, 0x4b, 0xb1, 0x6b, 0x24, 0x8b, 0x91, 0xdc, 0x82, 0x55,
	0x42, 0xe2, 0x39, 0x7b, 0x7e, 0x48, 0x95, 0xaf, 0x50, 0x8a, 0x33, 0x43, 0x6b, 0xd8, 0x72, 0xf6,
	0xfc, 0xb0, 0x36, 0x53, 0xd1, 0x99, 0xbd, 0x03, 0x31, 0x8f, 0xbf, 0x2d, 0xeb, 0x52, 0x26, 0xd0,
	0xd0, 0xda, 0xe0, 0x3d, 0x33, 0xc7, 0x1c, 0xed, 0xaa, 0x5c, 0x1b, 0x5a, 0xcf, 0xcc, 0x31, 0xc3,
	0xba, 0xcb, 0x6a, 0x3c, 0x19, 0x59, 0x87, 0x76, 0x8f, 0xde, 0xac, 0xe4, 0xc8, 0xd7, 0x28, 0xf2,
	0xca, 0xd0, 0x1a, 0x76, 0x82, 0x3c, 0x46, 0xf3, 0x43, 0xb0, 0x42, 0x24, 0xef, 0x8d, 0xb8, 0x81,
	0xc9, 0xc5, 0xfd, 0x4e, 0x68, 0xad, 0x08, 0x5b, 0xb3, 0x5b, 0x67, 0x8f, 0x5e, 0x6e, 0x9e, 0xa9,
	0x5b, 0x7e, 0x18, 0x8c, 0xcf, 0x8c, 0x2c, 0xbf, 0x35, 0x0a, 0x6d, 0xd5, 0x54, 0xf8, 0x68, 0x55,
	0x38, 0x5f, 0xa7, 0x1d, 0x79, 0x36, 0xb8, 0x0b, 0xf8, 0x74, 0xa6, 0xfb, 0xe8, 0x98, 0x57, 0xb8,
	0xd4, 0x40, 0x7b, 0x32, 0x78, 0x6a, 0x3b, 0x2a, 0x9b, 0x1b, 0xb4, 0x82, 0x45, 0x71, 0x8e, 0xbe,
	0xef, 0x3a, 0x93, 0x31, 0xb5, 0xf5, 0xb6, 0x08, 0xe6, 0x4d, 0xa5, 0x5a, 0xcb, 0x94, 0x36, 0x00,
	0x14, 0x7f, 0x37, 0x0e, 0x79, 0x61, 0xb4, 0x75, 0x3c, 0x73, 0xdf, 0x42, 0x25, 0xc8, 0x88, 0xdb,
	0x9d, 0xe2, 0x72, 0xee, 0xf4, 0x69, 0x19, 0x45, 0x94, 0x77, 0x03, 0x85, 0x39, 0x27, 0xa9, 0xd0,
	0x75, 0x48, 0x50, 0x4d, 0xe1, 0x97, 0x1d, 0x8e, 0xb9, 0x75, 0xc2, 0x70, 0x0a, 0xdf, 0x8f, 0x41,
	0x5a, 0xb0, 0x42, 0x9f, 0x40, 0x3e, 0xb8, 0x94, 0x3a, 0xda, 0x73, 0xf8, 0x15, 0x81, 0x95, 0x39,
	0xd7, 0x11, 0xc5, 0xc9, 0x94, 0xa5, 0x5e, 0x6a, 0x7d, 0x0f, 0x32, 0xfc, 0x08, 0xcd, 0xea, 0x2f,
	0x2e, 0x3d, 0xc0, 0x43, 0xf7, 0x01, 0x14, 0x61, 0xc6, 0xe6, 0x1e, 0xb2, 0x29, 0x32, 0x54, 0x90,
	0xd1, 0xd7, 0x21, 0x27, 0x6f, 0x8d, 0x74, 0xe9, 0x91, 0x42, 0x74, 0xfe, 0x07, 0x8f, 0x5b, 0x2b,
	0x7c, 0x43, 0x5d, 0xfd, 0x8a, 0x12, 0x67, 0x25, 0xb1, 0xd1, 0x47, 0x9f, 0x40, 0xc2, 0xa7, 0x7b,
	0x0c, 0xec, 0xb2, 0x46, 0x71, 0xa1, 0xd0, 0x6f, 0xb6, 0x4d, 0xef, 0xa9, 0x14, 0x24, 0x21, 0x2b,
	0xfc, 0x6c, 0x04, 0xe2, 0x04, 0xba, 0xe0, 0xe8, 0xf8, 0x1a, 0xdd, 0xe1, 0x67, 0x37, 0x1a, 0xc5,
	0xc9, 0x06, 0xfb, 0x4a, 0x74, 0x66, 0xc3, 0xff, 0x4b, 0xdd, 0x1e, 0x0a, 0x0e, 0xf0, 0xe2, 0x0b,
	0x0e, 0xf0, 0x8a, 0x7f, 0x61, 0x05, 0x96, 0xc2, 0x26, 0xd7, 0xa9, 0xbc, 0x84, 0x4b, 0xa1, 0xcf,
	0x02, 0x03, 0x14, 0x09, 0x25, 0x1e, 0x7e, 0xef, 0x45, 0x6f, 0x20, 0xbd, 0x17, 0x9e, 0x42, 0x1f,
	0xc0, 0xeb, 0x9e, 0x6f, 0x0e, 0x88, 0x05, 0xcb, 0x20, 0xdd, 0x3d, 0xd7, 0x19, 0xf9, 0xd6, 0xa8,
	0xcf, 0xdd, 0x98, 0xb3, 0x3c, 0xbb, 0x4c, 0x73, 0xb7, 0x79, 0x26, 0x7a, 0x1f, 0xd6, 0xa6, 0xe8,
	0x9e, 0x10, 0x23, 0x6b, 0xd4, 0xe7, 0x67, 0x17, 0xab, 0x21, 0xb2, 0x2d, 0x96, 0x47, 0xfc, 0x62,
	0x7b, 0xe4, 0xf9, 0xee, 0x84, 0xaf, 0x81, 0xcc, 0xae, 0x0f, 0xc1, 0xd0, 0x35, 0xd0, 0xd8, 0x44,
	0xe7, 0x5a, 0x7b, 0x96, 0x4b, 0xfc, 0x2f, 0x8f, 0x9f, 0x6d, 0x2c, 0x53, 0x38, 0x96, 0x60, 0xf4,
	0x06, 0xe4, 0x18, 0xea, 0xd0, 0xa6, 0xab, 0x60, 0x9a, 0x19, 0x6b, 0x14, 0x56, 0xa3, 0x20, 0x54,
	0x80, 0xf4, 0x13, 0xd7, 0x1c, 0xf5, 0x0e, 0x2c, 0x7e, 0xc6, 0x81, 0x65, 0x1a, 0xbd, 0x09, 0x79,
	0xf6, 0x5f, 0xd0, 0x73, 0x7b, 0x9b, 0x01, 0x39, 0x83, 0x8b, 0x00, 0x4f, 0x26, 0x1e, 0x6f, 0x24,
	0xb7, 0xb5, 0x33, 0x4f, 0x26, 0x1e, 0x6b, 0x18, 0xc9, 0x76, 0xad, 0x3d, 0x91, 0xcd, 0xac, 0xeb,
	0x8c, 0x6b, 0xed, 0xf1, 0xec, 0x6b, 0x40, 0xbc, 0xa1, 0x6e, 0x6f, 0xe0, 0xf4, 0x9e, 0x52, 0xcb,
	0x3a, 0xc2, 0x1c, 0xdf, 0x72, 0xb3, 0x53, 0x26, 0x30, 0x9c, 0xee, 0x8d, 0x27, 0xf4, 0x1f, 0xe1,
	0x44, 0xb4, 0x95, 0xe3, 0x12, 0x83, 0x3a, 0x82, 0x33, 0x04, 0xc2, 0xb2, 0x37, 0x21, 0x3b, 0x36,
	0xf7, 0xad, 0x2e, 0x3d, 0x28, 0x91, 0xc6, 0x34, 0x01, 0xd1, 0xdb, 0xb6, 0x54, 0x18, 0x43, 0x7b,
	0xe4, 0xb8, 0x02, 0x83, 0xdb, 0xd2, 0x14, 0xa6, 0xa0, 0x98, 0x3f, 0x1c, 0xa0, 0x9c, 0xe1, 0x28,
	0x04, 0xc6, 0x51, 0x88, 0xf4, 0x49, 0x17, 0x3f, 0xf7, 0xbb, 0xde, 0x33, 0xdb, 0xa7, 0x72, 0x43,
	0x5c, 0xfa, 0x0c, 0xde, 0xe2, 0x60, 0xf4, 0x21, 0x2c, 0x91, 0xb6, 0x0d, 0xed, 0x7d, 0x97, 0x1f,
	0x9c, 0x53, 0x7b, 0x5a, 0xba, 0x5f, 0x35, 0x99, 0x41, 0xdd, 0xaf, 0x20, 0x49, 0x0a, 0x31, 0x07,
	0xf6, 0x3e, 0xfd, 0xfa, 0x40, 0xd4, 0x85, 0x19, 0xda, 0xcb, 0x12, 0x1e, 0xd4, 0xc7, 0x1a, 0x4e,
	0x06, 0xec, 0xbe, 0x00, 0x47, 0x65, 0xe6, 0xf6, 0xb2, 0x84, 0x73, 0xd4, 0x2b, 0xb0, 0x3c, 0xb8,
	0xd3, 0xed, 0x33, 0x8d, 0x18, 0x38, 0xc4, 0xf4, 0x59, 0x63, 0xab, 0xe4, 0xe0, 0x4e, 0x85, 0x42,
	0xab, 0x04, 0x48, 0x56, 0xec, 0x30, 0x9e, 0xe8, 0xfe, 0xd7, 0xd9, 0x8a, 0xad, 0x62, 0x73, 0x25,
	0xb8, 0x0a, 0x5a, 0x40, 0xe2, 0xf9, 0x8e, 0x6b, 0xb1, 0x0d, 0xd4, 0x38, 0x5e, 0x12, 0xd8, 0x2d,
	0x0a, 0x45, 0xef, 0xc1, 0xda, 0x14, 0xa6, 0xe0, 0x7e, 0x8e, 0xad, 0xae, 0x21, 0x7c, 0xce, 0xfe,
	0x36, 0xac, 0x06, 0x44, 0x63, 0xa2, 0xf7, 0x4c, 0xf0, 0x85, 0x70, 0x85, 0x9a, 0x32, 0x07, 0xdd,
	0x87, 0x73, 0xb3, 0x14, 0xa2, 0x24, 0x66, 0xe9, 0xae, 0x4d, 0x93, 0xf1, 0xc2, 0x98, 0x98, 0x6c,
	0x55, 0x4c, 0x17, 0x84, 0x98, 0x8c, 0x19, 0x31, 0xd9, 0xb3, 0x62, 0xba, 0x28, 0x6a, 0x65, 0x4c,
	0x8b, 0x89, 0xb5, 0xc3, 0x9e, 0x69, 0xc7, 0x46, 0x98, 0x62, 0xa6, 0x1d, 0xf6, 0xfc, 0x76, 0x6c,
	0x8a, 0x76, 0x18, 0xf3, 0xda, 0x71, 0x0d, 0x32, 0x83, 0x41, 0x8f, 0xb7, 0x80, 0x1a, 0xae, 0x6c,
	0x68, 0x55, 0xab, 0x65, 0xda, 0x00, 0x9c, 0x1e, 0x0c, 0x7a, 0xac, 0x29, 0xf7, 0x61, 0x59, 0xa0,
	0x0a, 0xde, 0x6f, 0x04, 0xaa, 0xca, 0x09, 0x18, 0x5b, 0x9c, 0xe7, 0x54, 0xbc, 0x94, 0x1b, 0x00,
	0x84, 0x94, 0xf7, 0x39, 0x35, 0x51, 0xd9, 0x7e, 0x47, 0xb5, 0x5a, 0x66, 0x5d, 0x8e, 0x49, 0x35,
	0x78, 0xef, 0x7f, 0x15, 0x34, 0x89, 0x2d, 0x4a, 0x7a, 0x93, 0xd2, 0xa0, 0xa3, 0x97, 0x9b, 0x4b,
	0x82, 0x86, 0x17, 0xb5, 0x24, 0x08, 0x79, 0x59, 0x1f, 0x02, 0x81, 0xa8, 0x82, 0x7b, 0x2b, 0x54,
	0xcb, 0x40, 0x6e, 0xb4, 0x96, 0x8a, 0x18, 0x75, 0x58, 0x51, 0x29, 0x45, 0xd1, 0xd4, 0x04, 0x65,
	0x76, 0x98, 0x42, 0xce, 0x4b, 0x3f, 0xa3, 0xb0, 0x08, 0x1a, 0xdb, 0xf7, 0x07, 0x4f, 0xb8, 0x4c,
	0xaf, 0x04, 0x8d, 0xad, 0xb4, 0xab, 0x5b, 0x4c, 0xa8, 0x19, 0x82, 0xc0, 0xa4, 0xfa, 0x55, 0xd0,
	0x24, 0xb6, 0x28, 0xf1, 0xed, 0xa0, 0xb1, 0x82, 0x46, 0x34, 0x56, 0x10, 0xf2, 0xb2, 0x6e, 0x41,
	0x96, 0x52, 0x73, 0xc9, 0x52, 0x43, 0x95, 0xdd, 0xd2, 0x21, 0x84, 0x5c, 0xb4, 0xb4, 0x3a, 0x5c,
	0xb6, 0x9f, 0xc2, 0x99, 0x80, 0x40, 0x94, 0x47, 0x4d, 0x56, 0xb6, 0x67, 0x23, 0xc9, 0x78, 0x81,
	0xcb, 0x92, 0x96, 0x97, 0xf8, 0x11, 0x50, 0x90, 0x2a, 0xdf, 0x77, 0xc2, 0xd5, 0x55, 0x04, 0x4c,
	0xab, 0xab, 0x48, 0x78, 0x17, 0x56, 0x43, 0xc4, 0xa2, 0x02, 0xd7, 0x29, 0x07, 0xba, 0x83, 0xa6,
	0x72, 0xe0, 0x75, 0x40, 0x2a, 0x97, 0x40, 0xc8, 0x76, 0x20, 0xe4, 0x1b, 0x81, 0x90, 0x8d, 0x40,
	0xc8, 0xb6, 0x2a, 0x64, 0x7b, 0x5a, 0xc8, 0xef, 0x06, 0xb5, 0x36, 0xa6, 0x84, 0x6c, 0x87, 0x85,
	0xfc, 0x06, 0xf0, 0xc5, 0x8c, 0x97, 0x76, 0x93, 0x4d, 0xf8, 0x0c, 0xc6, 0x0a, 0xb8, 0x01, 0x48,
	0x41, 0x11, 0x45, 0xdc, 0xa2, 0x88, 0x5a, 0x80, 0x18, 0xac, 0x86, 0x23, 0xa7, 0x2f, 0xe6, 0x8d,
	0xdb, 0x6c, 0xb9, 0x23, 0x10, 0xc6, 0xec, 0x2a, 0x68, 0x32, 0x5b, 0xb0, 0xba, 0xc3, 0xe6, 0x49,
	0x81, 0xc4, 0x19, 0x6d, 0x42, 0x96, 0x62, 0xf2, 0xee, 0xbf, 0xcb, 0x77, 0x62, 0x9c, 0xbe, 0x98,
	0x48, 0xdf, 0x81, 0x33, 0x01, 0x82, 0xe0, 0xf5, 0x1e, 0x9b, 0xf9, 0x25, 0x1a, 0x67, 0xf6, 0x36,
	0x50, 0x90, 0xda, 0xb3, 0xef, 0x07, 0xa5, 0x2a, 0xbd, 0x78, 0x1b, 0x56, 0x43, 0x88, 0x82, 0xef,
	0x3d, 0x36, 0x41, 0xa9, 0xd8, 0x8c, 0x75, 0xf1, 0x10, 0x52, 0xfc, 0x08, 0x1e, 0x7d, 0x00, 0x69,
	0x73, 0x9f, 0xac, 0x58, 0xf2, 0x9a, 0xf3, 0xf4, 0x87, 0x00, 0x74, 0x63, 0x9e, 0x27, 0x70, 0x8a,
	0x22, 0x1b, 0x53, 0xf6, 0x62, 0xf4, 0x74, 0xf6, 0x62, 0xf1, 0x47, 0x56, 0x20, 0x41, 0x63, 0x9e,
	0xf0, 0x40, 0x03, 0x91, 0x50, 0xe8, 0x0a, 0x1e, 0x0d, 0x65, 0xc6, 0x34, 0xfd, 0xfa, 0xd4, 0xa7,
	0x5f, 0xd1, 0x90, 0xd1, 0xad, 0x7e, 0xfa, 0x25, 0x8d, 0xee, 0x63, 0x3f, 0xff, 0x7a, 0xa0, 0x34,
	0x37, 0x16, 0x0e, 0x9c, 0xc1, 0x9b, 0xbb, 0xcc, 0x79, 0xcc, 0x36, 0x59, 0xfd, 0x78, 0x23, 0x7e,
	0xf2, 0xc7, 0x1b, 0xa7, 0xfd, 0x0e, 0xce, 0x80, 0x9c, 0xf2, 0x61, 0x1e, 0x31, 0x1f, 0x63, 0xf3,
	0xbf, 0xcc, 0x93, 0xad, 0x0b, 0x60, 0x1e, 0xce, 0x06, 0x9f, 0xe6, 0x4d, 0x7f, 0x07, 0x92, 0x3a,
	0xf5, 0xd5, 0xf3, 0xcb, 0x10, 0x9b, 0xb8, 0x03, 0x7e, 0xd9, 0x12, 0xc4, 0xc9, 0x06, 0xae, 0xb2,
	0xcf, 0x82, 0x3a, 0xb8, 0x8a, 0x49, 0xfe, 0x9c, 0x50, 0x16, 0x99, 0x57, 0x08, 0x65, 0x31, 0xef,
	0x9a, 0x24, 0x7c, 0xa9, 0x6b, 0x92, 0xc1, 0x47, 0x27, 0xd9, 0x93, 0x3e, 0x3a, 0xf9, 0x8b, 0x4b,
	0x90, 0x91, 0xe1, 0x63, 0xd0, 0xbd, 0xd0, 0x37, 0x27, 0xe7, 0x55, 0xbd, 0xbb, 0x29, 0xb1, 0x66,
	0x6f, 0xad, 0xdd, 0x23, 0x6e, 0xce, 0x64, 0xd4, 0x13, 0xf7, 0xd6, 0x2e, 0x1e, 0x43, 0x58, 0xa5,
	0x48, 0x98, 0x23, 0xa3, 0x0f, 0x21, 0xc5, 0xae, 0x51, 0x8a, 0xab, 0x7b, 0x1b, 0xc7, 0xd0, 0xb1,
	0xdb, 0x8a, 0x16, 0x16, 0xe8, 0xe8, 0x13, 0xc8, 0x4c, 0x46, 0x82, 0x36, 0x1e, 0xfa, 0x56, 0x7d,
	0x9a, 0xb6, 0x23, 0xf0, 0x70, 0x40, 0x42, 0x2a, 0xdc, 0xa3, 0x77, 0x48, 0xf8, 0xad, 0xb6, 0xe3,
	0x2a, 0xcc, 0x2e, 0x9a, 0x60, 0x8e, 0x4c, 0x2a, 0xdc, 0xb7, 0x3c, 0xdf, 0x75, 0x5e, 0xf0, 0x8b,
	0xcb, 0xc7, 0x55, 0xb8, 0xc2, 0xb0, 0xb0, 0x40, 0x47, 0x3a, 0xe4, 0x58, 0xa3, 0xbb, 0x74, 0x33,
	0x82, 0xdf, 0xf5, 0x2d, 0x2e, 0x94, 0xd3, 0x0e, 0xc1, 0xc4, 0xd9, 0x41, 0x90, 0xe0, 0xb3, 0x42,
	0x2e, 0xf4, 0xad, 0x8b, 0x12, 0xfc, 0x27, 0x74, 0x77, 0x6f, 0x0b, 0xb2, 0xfb, 0xae, 0xf3, 0xac,
	0xcb, 0xef, 0x50, 0xb2, 0x0d, 0xfe, 0x37, 0x8e, 0x29, 0x71, 0xc7, 0x75, 0x9e, 0xf1, 0x7b, 0x95,
	0xb0, 0x2f, 0xff, 0xa3, 0x5d, 0xc8, 0x7b, 0x07, 0xae, 0x3d, 0x7a, 0x2a, 0xb8, 0x2c, 0x85, 0x3e,
	0x75, 0x98, 0xe6, 0xd2, 0xa2, 0xb8, 0x9c, 0x4f, 0xce, 0x53, 0x52, 0xa4, 0x36, 0x4c, 0x88, 0x5d,
	0x7a, 0xd7, 0x79, 0x79, 0x61, 0x6d, 0x98, 0xd8, 0x2b, 0xb6, 0xf7, 0x14, 0x43, 0x4f, 0xfe, 0x27,
	0x42, 0xe4, 0xf2, 0x64, 0x4c, 0xb4, 0x85, 0x42, 0xe4, 0x7d, 0x40, 0xb9, 0x64, 0xfb, 0x41, 0xa2,
	0xf0, 0x09, 0x24, 0x99, 0x80, 0xd1, 0xfb, 0xdc, 0xf9, 0x22, 0x43, 0x4d, 0xec, 0xed, 0x2c, 0xab,
	0xdb, 0x00, 0xc1, 0xb6, 0x0a, 0xf5, 0xc9, 0x48, 0xda, 0x2b, 0xfc, 0x7f, 0x90, 0x55, 0x3a, 0x08,
	0xdd, 0x83, 0xb4, 0x98, 0x62, 0x4e, 0xde, 0x9d, 0x91, 0xa8, 0xe8, 0x3e, 0x2f, 0x9b, 0xe9, 0x43,
	0x34, 0xf4, 0xe5, 0x07, 0x29, 0x7b, 0x47, 0x6c, 0x5a, 0xa9, 0x15, 0xa0, 0xc0, 0xc2, 0x27, 0x64,
	0x75, 0x62, 0x8a, 0x1c, 0x9a, 0x50, 0x23, 0xa7, 0x9b, 0x50, 0x0b, 0x5f, 0x83, 0x8c, 0x1c, 0x15,
	0x5f, 0x8e, 0xc3, 0x7d, 0x48, 0xb2, 0x3e, 0x42, 0xb7, 0x20, 0xc5, 0x54, 0xe3, 0x04, 0x62, 0x81,
	0x55, 0x78, 0x00, 0x29, 0xde, 0x33, 0xaf, 0x4e, 0x3b, 0x02, 0x08, 0x14, 0x15, 0xbd, 0x2b, 0xef,
	0x07, 0x87, 0x63, 0x28, 0x4d, 0x51, 0x8b, 0x7b, 0xc2, 0x77, 0x20, 0x6d, 0xf6, 0xfb, 0xb6, 0xdc,
	0x2d, 0x39, 0x96, 0x40, 0xa2, 0x15, 0x7c, 0xc8, 0xa9, 0x2a, 0xfd, 0xaa, 0x25, 0xde, 0x83, 0xb4,
	0x37, 0x79, 0xc2, 0x3e, 0x5d, 0x8f, 0x86, 0x34, 0x43, 0xfd, 0xe6, 0x40, 0x94, 0x2a, 0x50, 0x0b,
	0xdf, 0x89, 0x00, 0x04, 0x23, 0x80, 0x14, 0x2a, 0xcf, 0xc1, 0x17, 0x15, 0xca, 0x4f, 0xbf, 0x1f,
	0x42, 0xd6, 0x37, 0xdd, 0x7d, 0xcb, 0xef, 0x2a, 0x1f, 0x45, 0xbc, 0xca, 0x45, 0x64, 0x60, 0xe4,
	0x04, 0x52, 0xf8, 0x2a, 0x64, 0x95, 0x61, 0xf4, 0x8a, 0x55, 0x29, 0xfe, 0xfd, 0xc8, 0x31, 0x57,
	0xc9, 0xab, 0xa5, 0x4e, 0xbd, 0xbc, 0xcb, 0xbe, 0x7c, 0x63, 0xff, 0xbb, 0x3b, 0xb8, 0xd1, 0x69,
	0x6a, 0x49, 0x82, 0xca, 0x3e, 0x3e, 0xd4, 0xb5, 0x28, 0xca, 0x43, 0xa6, 0x53, 0x17, 0xc9, 0x18,
	0xfd, 0x78, 0x1a, 0xeb, 0xa5, 0xb6, 0xae, 0xc5, 0xd9, 0x57, 0xd5, 0xad, 0x36, 0x6e, 0x7c, 0xae,
	0x25, 0xd0, 0x32, 0x64, 0x77, 0x70, 0xe3, 0xb1, 0xf8, 0xf8, 0x30, 0x8b, 0xce, 0x40, 0xbe, 0xb5,
	0x8b, 0x8d, 0xfa, 0x43, 0x01, 0xca, 0x11, 0x1c, 0x46, 0xdc, 0xad, 0x18, 0xad, 0x87, 0x5a, 0x9e,
	0x94, 0xcd, 0x39, 0x30, 0xc8, 0x12, 0xff, 0xea, 0xee, 0x37, 0xa2, 0x90, 0x33, 0x46, 0x87, 0x96,
	0xeb, 0x59, 0xcc, 0x14, 0xbb, 0xb5, 0xc0, 0x14, 0x93, 0xc6, 0x10, 0x07, 0xd0, 0x99, 0x97, 0x5b,
	0x0b, 0xd1, 0x13, 0xac, 0x85, 0x69, 0xb3, 0x2d, 0xf6, 0x03, 0x98, 0x6d, 0xaa, 0x95, 0x1a, 0x7f,
	0x05, 0x2b, 0xb5, 0x3c, 0x63, 0xb1, 0x24, 0x68, 0x2d, 0xe6, 0x5b, 0x2c, 0x62, 0x0b, 0x7e, 0xca,
	0x6e, 0x09, 0x4d, 0x21, 0xc9, 0x53, 0x9a, 0xba, 0x3f, 0x9b, 0x80, 0xb4, 0x98, 0x63, 0x17, 0xec,
	0xd0, 0x7e, 0x00, 0x29, 0x36, 0x45, 0x1f, 0xb3, 0x4d, 0xbb, 0xc4, 0x45, 0xc3, 0x83, 0xfb, 0xe1,
	0x24, 0x9d, 0xa7, 0x7f, 0x30, 0x3b, 0x36, 0xd4, 0x9e, 0xf8, 0x29, 0xad, 0xd4, 0x5b, 0xca, 0x32,
	0x90, 0x08, 0xdd, 0xe2, 0x51, 0x97, 0x01, 0x65, 0x01, 0x10, 0x71, 0x22, 0x92, 0x4a, 0x9c, 0x88,
	0x57, 0x0b, 0xf9, 0x70, 0x0f, 0x72, 0x07, 0x34, 0x10, 0x4c, 0x97, 0x06, 0x08, 0x9b, 0x0a, 0xf9,
	0xa0, 0xc4, 0x88, 0xc1, 0xd9, 0x03, 0x25, 0xc6, 0x4f, 0xe8, 0x93, 0xd6, 0xcc, 0xe9, 0x22, 0x36,
	0x04, 0x1b, 0xd9, 0xb0, 0x38, 0x68, 0x82, 0x12, 0xd8, 0x21, 0x7b, 0xba, 0xc0, 0x0e, 0x77, 0x21,
	0xfb, 0xd4, 0x1e, 0x0c, 0xba, 0x63, 0x1a, 0x4e, 0x85, 0x1b, 0x37, 0xc2, 0x62, 0x0d, 0xe2, 0xac,
	0x60, 0x78, 0x1a, 0xc4, 0x5c, 0xb9, 0x02, 0x09, 0xd6, 0xe4, 0x7c, 0xe8, 0x9b, 0x2b, 0x19, 0x36,
	0x06, 0xb3, 0x6c, 0x54, 0x86, 0x95, 0xa1, 0xf9, 0xbc, 0xdb, 0x73, 0x86, 0xe3, 0x81, 0x45, 0xad,
	0x6a, 0xdf, 0x96, 0x56, 0xcc, 0xdc, 0x90, 0x11, 0x67, 0x86, 0xe6, 0xf3, 0xb2, 0x44, 0x6f, 0xdb,
	0x43, 0xab, 0xf8, 0x55, 0xc8, 0x87, 0x16, 0x64, 0x7a, 0x9c, 0x43, 0x0f, 0x26, 0x16, 0x5a, 0x0c,
	0x0c, 0xa7, 0xf8, 0xef, 0x12, 0x27, 0x9e, 0x42, 0x7c, 0x59, 0x1d, 0xff, 0x93, 0x9c, 0x40, 0xb6,
	0xc2, 0xd1, 0x4f, 0xe2, 0xa1, 0x5e, 0x50, 0x7c, 0xac, 0xa5, 0x05, 0x91, 0x4f, 0xd4, 0x31, 0x97,
	0x78, 0xc5, 0x31, 0x77, 0x85, 0xc6, 0x43, 0xf4, 0xad, 0xf5, 0x24, 0x5d, 0xb0, 0x34, 0x45, 0x02,
	0x2d, 0x02, 0xc7, 0x2c, 0x3b, 0x3c, 0x36, 0x53, 0xa7, 0x1c, 0x9b, 0xef, 0x29, 0xf1, 0x8a, 0xd2,
	0x21, 0xef, 0x51, 0xf0, 0x9f, 0x78, 0x72, 0x19, 0x16, 0x81, 0x8c, 0xbe, 0x06, 0x2b, 0xec, 0x7f,
	0x77, 0x32, 0xee, 0x13, 0xc3, 0x95, 0xd5, 0x2f, 0x43, 0x5d, 0xa3, 0xd9, 0xfa, 0x9d, 0x61, 0xc8,
	0x1d, 0x8a, 0x4b, 0x41, 0x68, 0x0b, 0x50, 0x98, 0xc3, 0x64, 0x62, 0xb3, 0xcf, 0xe6, 0x72, 0xec,
	0x12, 0x57, 0x4b, 0x21, 0xe9, 0x74, 0x8c, 0x0a, 0xd6, 0x54, 0x26, 0x9d, 0x89, 0xdd, 0x3f, 0x6d,
	0x90, 0xbc, 0x2f, 0x13, 0x51, 0x25, 0x34, 0x0f, 0xe4, 0x4f, 0x37, 0x0f, 0x88, 0xf0, 0x40, 0x4b,
	0x41, 0x78, 0xa0, 0x62, 0x0d, 0xd6, 0xda, 0xf4, 0x42, 0x2f, 0x13, 0x37, 0x3d, 0xc1, 0x66, 0xee,
	0xe4, 0x97, 0xb1, 0x2d, 0x8b, 0x17, 0x20, 0x4e, 0x64, 0x11, 0xc4, 0x27, 0x22, 0x03, 0x26, 0x27,
	0x3e, 0xa0, 0xfd, 0xad, 0xa8, 0xea, 0xaf, 0x4e, 0x07, 0xbd, 0x89, 0x7c, 0xc9, 0xa0, 0x37, 0xea,
	0xf2, 0x19, 0x7d, 0x85, 0xe5, 0xf3, 0x36, 0xc4, 0xa9, 0x9b, 0xce, 0x46, 0xde, 0xda, 0x7c, 0x4f,
	0x44, 0x8c, 0x75, 0x9b, 0x45, 0x3d, 0xc8, 0x0f, 0x4c, 0xdf, 0xf2, 0xfc, 0x2e, 0xeb, 0x6a, 0x7e,
	0x42, 0xba, 0x36, 0xed, 0xcc, 0x85, 0x94, 0x32, 0xc7, 0x48, 0x18, 0x0c, 0x7d, 0xa8, 0x68, 0x73,
	0x22, 0x14, 0x2c, 0x6a, 0x3e, 0x75, 0xa0, 0xd2, 0xef, 0x42, 0x9c, 0xaa, 0x60, 0x92, 0x96, 0x99,
	0x15, 0x6b, 0x7c, 0xc7, 0xa8, 0x28, 0x71, 0xa5, 0x88, 0x1e, 0x52, 0xb4, 0xe2, 0x4f, 0x47, 0x61,
	0x79, 0x8a, 0x25, 0x91, 0xb8, 0x23, 0x40, 0xb3, 0x12, 0x57, 0x7d, 0x51, 0x2a, 0x71, 0x05, 0x80,
	0xb3, 0x92, 0xd0, 0xe8, 0xa3, 0x3b, 0x62, 0xbc, 0x33, 0x03, 0xf5, 0xec, 0xbc, 0x16, 0x58, 0x4a,
	0x14, 0x54, 0xfa, 0xe9, 0x73, 0x6a, 0x68, 0x79, 0x9e, 0xb9, 0x2f, 0xbe, 0x74, 0x14, 0x49, 0xb4,
	0x0d, 0x2b, 0x3d, 0x87, 0x98, 0x6c, 0xbe, 0xd5, 0xef, 0x9e, 0x72, 0xe9, 0x46, 0x92, 0x02, 0xcb,
	0x79, 0xe2, 0x1a, 0x97, 0x0f, 0x5b, 0xbf, 0x43, 0xf2, 0x49, 0x4f, 0xc9, 0xe6, 0x65, 0x14, 0x96,
	0xe9, 0x72, 0xc3, 0xe4, 0xc2, 0xb7, 0x5d, 0x4e, 0x8e, 0xb6, 0x28, 0xbf, 0xf3, 0x9b, 0x8a, 0x5c,
	0xb1, 0xa1, 0x62, 0x07, 0x3c, 0x67, 0xa3, 0x2d, 0xde, 0x0f, 0x45, 0x5b, 0x3c, 0x7f, 0x0c, 0xd9,
	0xdc, 0x98, 0x8b, 0xf7, 0x58, 0x28, 0xb9, 0x78, 0xe8, 0xbb, 0xdd, 0x69, 0xca, 0xd9, 0xa0, 0x87,
	0x57, 0x82, 0xa0, 0x87, 0xe7, 0x21, 0x63, 0x3d, 0xa7, 0x37, 0x9a, 0xfa, 0xac, 0x99, 0x09, 0x62,
	0xd0, 0xd8, 0x7e, 0xd9, 0xe9, 0x5b, 0x85, 0xb7, 0x79, 0x74, 0xc3, 0x4d, 0xc8, 0xf2, 0x69, 0x4f,
	0xa2, 0xe5, 0xd9, 0x25, 0x81, 0x89, 0x47, 0x11, 0xdf, 0x64, 0x01, 0x0d, 0x2f, 0x40, 0xc6, 0x9b,
	0xf4, 0x7a, 0x96, 0xd5, 0xb7, 0x98, 0x1e, 0xa5, 0x71, 0x00, 0x28, 0xfe, 0xcc, 0x32, 0x40, 0x30,
	0x3b, 0xab, 0x6b, 0x64, 0xe4, 0x55, 0xd6, 0xc8, 0x2b, 0x61, 0x3d, 0x3b, 0x76, 0x5d, 0x11, 0xd6,
	0x58, 0x4c, 0xb1, 0xc6, 0x14, 0x85, 0x8b, 0x87, 0x15, 0xee, 0x83, 0xd0, 0x4a, 0x77, 0xfa, 0xf9,
	0xe2, 0x82, 0x7a, 0xaa, 0x9f, 0xe4, 0x87, 0xbd, 0xf2, 0x3c, 0x7f, 0x6a, 0x0d, 0x4e, 0x7d, 0x99,
	0x35, 0x78, 0x1d, 0x52, 0xcc, 0xd6, 0x7b, 0x41, 0xcd, 0xc1, 0x34, 0x16, 0x49, 0x74, 0x5b, 0x3a,
	0x6f, 0x99, 0x50, 0x48, 0xab, 0x40, 0xc8, 0xd3, 0x17, 0xa9, 0x6f, 0x43, 0xd2, 0xb5, 0x4c, 0xcf,
	0x61, 0xb1, 0x6b, 0xe6, 0x52, 0x60, 0x9a, 0x8f, 0x39, 0x1e, 0xba, 0xc0, 0x07, 0x50, 0x96, 0xae,
	0x71, 0x53, 0x63, 0x46, 0x59, 0xcb, 0x72, 0x8b, 0xd6, 0xb2, 0x12, 0x3b, 0x8c, 0x66, 0x77, 0x48,
	0xf8, 0x2c, 0xc9, 0x96, 0xa7, 0xb5, 0xe9, 0xe5, 0x89, 0xd5, 0x82, 0x1d, 0x52, 0x2b, 0x00, 0xf4,
	0x00, 0xb4, 0x09, 0xfb, 0xa6, 0x87, 0x5e, 0x74, 0x52, 0x8c, 0xbe, 0xe9, 0x40, 0xcb, 0x78, 0x59,
	0x41, 0x24, 0x40, 0x74, 0x1f, 0x72, 0xd4, 0x78, 0x14, 0x45, 0x2f, 0x87, 0x8b, 0x0e, 0x0f, 0x17,
	0x9c, 0xed, 0x05, 0x00, 0xf4, 0x31, 0xb0, 0xeb, 0xe1, 0xec, 0x4a, 0x86, 0x16, 0xda, 0x5a, 0x9c,
	0xbf, 0x44, 0x62, 0x85, 0xa0, 0xb8, 0x25, 0x3f, 0x23, 0x26, 0xfe, 0x2b, 0x0b, 0xb2, 0x53, 0x2b,
	0xb5, 0xda, 0x3a, 0x66, 0xf1, 0x93, 0x38, 0x88, 0x86, 0x51, 0xd2, 0x22, 0x68, 0x05, 0x96, 0x39,
	0x44, 0xff, 0x4c, 0x2f, 0x77, 0xda, 0x0d, 0xac, 0x45, 0x8b, 0xbf, 0x9d, 0x86, 0x24, 0xeb, 0x14,
	0x54, 0x84, 0x0d, 0xac, 0x97, 0x5a, 0x8d, 0x7a, 0x97, 0xc7, 0x34, 0x94, 0x78, 0xdd, 0xed, 0x92,
	0x51, 0xd5, 0x2b, 0xda, 0x6b, 0x21, 0x9c, 0x7a, 0xbb, 0x64, 0xd4, 0x75, 0xdc, 0xe5, 0x1e, 0x39,
	0xc7, 0x39, 0x8b, 0x36, 0xe1, 0xfc, 0x2c, 0x8e, 0x51, 0x33, 0xda, 0x34, 0x3e, 0x90, 0xb6, 0x82,
	0xde, 0x82, 0x4b, 0x0b, 0x10, 0x98, 0x77, 0xbd, 0x8a, 0xae, 0x40, 0x71, 0x11, 0x56, 0x4d, 0xaf,
	0x35, 0xf0, 0xe7, 0x5a, 0x1a, 0x6d, 0x40, 0x61, 0x06, 0xaf, 0x89, 0x75, 0xbd, 0xd6, 0x6c, 0xeb,
	0x15, 0xed, 0xcc, 0xdc, 0x2a, 0xb3, 0x98, 0x52, 0xa2, 0xca, 0x6b, 0x4a, 0x59, 0xb5, 0xd2, 0x67,
	0xa4, 0xf9, 0xcd, 0xaa, 0x4e, 0x4b, 0x69, 0x1b, 0x35, 0xbd, 0x8b, 0xf5, 0x52, 0x79, 0x57, 0xaf,
	0x68, 0x6f, 0xa0, 0xab, 0xf0, 0x16, 0xc7, 0x93, 0xa2, 0xc1, 0xfa, 0x8e, 0xd1, 0x6a, 0xe3, 0x92,
	0x44, 0x6f, 0x74, 0xda, 0xda, 0xeb, 0xe8, 0x1d, 0xb8, 0x32, 0x8b, 0x39, 0x17, 0x77, 0x5d, 0x69,
	0x81, 0xc4, 0x6d, 0xeb, 0xb8, 0x66, 0xd4, 0x4b, 0xa4, 0x05, 0x11, 0x74, 0x09, 0x2e, 0x4c, 0xe7,
	0x77, 0xea, 0x8c, 0x97, 0x8e, 0xf5, 0x8a, 0x16, 0x45, 0x17, 0x60, 0x9d, 0x63, 0x6c, 0xe3, 0x52,
	0x4d, 0x7f, 0xdc, 0xc0, 0x0f, 0xbb, 0x58, 0xaf, 0x35, 0x1e, 0xe9, 0x15, 0x2d, 0x46, 0x3a, 0x9e,
	0xe7, 0xee, 0x94, 0xbb, 0x3a, 0xc6, 0x0d, 0xac, 0xc5, 0x95, 0x42, 0x8d, 0xfa, 0xa3, 0x52, 0xd5,
	0xa8, 0x04, 0xa4, 0x46, 0x45, 0x4b, 0xa0, 0x73, 0x70, 0x76, 0x2a, 0xbf, 0xb1, 0xbd, 0xad, 0xe3,
	0x96, 0x96, 0x54, 0xea, 0x63, 0x34, 0xba, 0xad, 0xc7, 0x46, 0xbb, 0xbc, 0xbb, 0xd5, 0x28, 0x61,
	0xa2, 0x2f, 0x06, 0xa9, 0xf1, 0x79, 0x85, 0x39, 0xd3, 0x47, 0xd2, 0xa7, 0xe5, 0x46, 0xbd, 0xae,
	0x97, 0x49, 0x7e, 0x4a, 0x61, 0x8e, 0xf5, 0x72, 0xa3, 0x5e, 0x36, 0xaa, 0x06, 0x53, 0x8e, 0x8c,
	0xd2, 0x14, 0x19, 0xff, 0xb8, 0x2b, 0x36, 0x83, 0x10, 0xba, 0x08, 0xe7, 0x78, 0x2e, 0x0b, 0x0e,
	0x16, 0xe2, 0x0b, 0x68, 0x1d, 0x56, 0x43, 0xd9, 0x42, 0x06, 0x59, 0x45, 0xe7, 0x42, 0x39, 0xdd,
	0xad, 0xcf, 0xbb, 0x8d, 0xa6, 0x8e, 0x4b, 0x64, 0x34, 0x6c, 0xce, 0xb0, 0x17, 0x5d, 0x46, 0xc5,
	0x7c, 0x89, 0x45, 0xba, 0x0a, 0x65, 0xb7, 0xda, 0x25, 0x4c, 0x8a, 0xce, 0xcd, 0x14, 0x2d, 0xea,
	0x9c, 0x57, 0x8a, 0x96, 0x31, 0xa0, 0xf5, 0x4a, 0xb7, 0xd2, 0xc1, 0x46, 0x7d, 0x87, 0x0f, 0x1e,
	0x6d, 0x63, 0x1a, 0xab, 0xbc, 0xab, 0x97, 0x1f, 0xd2, 0x38, 0xd1, 0x9d, 0x16, 0x57, 0xd7, 0x8a,
	0x76, 0x01, 0x5d, 0x87, 0xb7, 0x55, 0xac, 0x5d, 0xbd, 0x54, 0x6d, 0xef, 0xce, 0x47, 0xbe, 0xa8,
	0xb4, 0x86, 0x22, 0xd3, 0x2d, 0x33, 0xd1, 0x9b, 0xda, 0x39, 0x65, 0x60, 0x28, 0xd9, 0x9d, 0x7a,
	0xa9, 0xd3, 0xde, 0x6d, 0x60, 0xe3, 0x9b, 0x7a, 0x45, 0x2b, 0xb0, 0x88, 0xd6, 0x01, 0x8e, 0x20,
	0x5e, 0x52, 0xba, 0x89, 0x66, 0x84, 0xc8, 0x96, 0xa7, 0xc9, 0x84, 0x2c, 0xb4, 0xe2, 0x7b, 0x90,
	0xda, 0xb6, 0x07, 0xbe, 0x45, 0xbf, 0xb2, 0x5c, 0x72, 0xad, 0xbd, 0x89, 0x67, 0x75, 0x83, 0xb7,
	0x01, 0x68, 0xb0, 0xf3, 0x7b, 0x38, 0xcf, 0x32, 0x78, 0xcc, 0xdc, 0xe2, 0xdf, 0x89, 0x42, 0x56,
	0x09, 0x4b, 0x8a, 0x3e, 0x85, 0xcc, 0xa1, 0xe9, 0xda, 0x64, 0x06, 0x16, 0x6e, 0xc2, 0xf9, 0xd9,
	0xe8, 0xa5, 0x37, 0x1f, 0x71, 0x1c, 0xe1, 0x32, 0x48, 0x9a, 0xc2, 0xaf, 0x44, 0x20, 0x2d, 0x72,
	0x17, 0xf8, 0xd9, 0xd2, 0xa3, 0x88, 0xaa, 0x11, 0x4f, 0x3f, 0x92, 0x61, 0xa5, 0xd4, 0x38, 0x6b,
	0xf3, 0x0a, 0xa6, 0x06, 0xdc, 0x83, 0xc4, 0xa3, 0x52, 0xb5, 0xa3, 0x73, 0x3b, 0xee, 0x32, 0x24,
	0x3d, 0xab, 0xe7, 0xca, 0xc8, 0x47, 0x62, 0x49, 0x6b, 0x51, 0x20, 0xe6, 0x99, 0xc5, 0xdb, 0xf3,
	0x36, 0x42, 0x33, 0xc0, 0x58, 0xb1, 0xb0, 0x90, 0x2d, 0xbd, 0x8c, 0xf5, 0xb6, 0x8c, 0xfd, 0xf5,
	0x29, 0x64, 0xe4, 0x3b, 0x03, 0x68, 0x0d, 0x62, 0x4f, 0xad, 0x17, 0xa1, 0x16, 0x11, 0x40, 0x10,
	0x69, 0x28, 0x3a, 0x1b, 0x69, 0x68, 0x0b, 0x40, 0x32, 0xf0, 0xd0, 0xfb, 0x90, 0x19, 0x8b, 0x14,
	0x17, 0xf1, 0x71, 0xcf, 0x19, 0x04, 0x88, 0xc5, 0x5d, 0xba, 0x11, 0xdd, 0xb7, 0x46, 0xbe, 0x6d,
	0x0e, 0x50, 0x31, 0x1c, 0xab, 0x24, 0x28, 0x51, 0x89, 0x58, 0xb2, 0x26, 0xe5, 0x11, 0xe5, 0x11,
	0x83, 0x99, 0x00, 0x76, 0x21, 0x1b, 0x70, 0xf2, 0xd0, 0x7d, 0x7a, 0x1a, 0x24, 0x92, 0xbc, 0x42,
	0xc2, 0xd2, 0x09, 0x10, 0xc5, 0xbb, 0x12, 0x0a, 0x6e, 0xf1, 0x67, 0xa2, 0x90, 0x64, 0xd2, 0x45,
	0x37, 0x42, 0xf6, 0x36, 0x0a, 0x89, 0x7e, 0xde, 0x21, 0x65, 0x46, 0xde, 0x2d, 0xe4, 0x46, 0xf7,
	0xeb, 0x61, 0x12, 0x79, 0xc7, 0x10, 0x07, 0x98, 0xe8, 0x9a, 0x1a, 0x26, 0x37, 0xd8, 0x34, 0xe2,
	0x24, 0x74, 0x23, 0x5f, 0x84, 0xa4, 0xfa, 0x0a, 0x64, 0x24, 0x8b, 0x05, 0x6a, 0xa8, 0xb1, 0xde,
	0x64, 0x02, 0x22, 0x7f, 0x0b, 0xe7, 0x45, 0x30, 0x2f, 0x61, 0x85, 0x32, 0x97, 0x97, 0xfe, 0x2f,
	0xbe, 0x37, 0x4f, 0x77, 0xf2, 0x90, 0xc1, 0xfa, 0xb6, 0x8e, 0xf5, 0x3a, 0x8d, 0x20, 0x27, 0x55,
	0x49, 0xa8, 0xcf, 0x1e, 0x64, 0xb0, 0xe9, 0x33, 0x43, 0x03, 0x9d, 0x83, 0xd8, 0x17, 0x63, 0x3e,
	0x1c, 0x99, 0x6d, 0xff, 0x8d, 0x66, 0x0b, 0x13, 0x58, 0xb8, 0x4f, 0xa3, 0xf3, 0xfb, 0xb4, 0x00,
	0xe9, 0x9e, 0x39, 0x36, 0x7b, 0xe2, 0x69, 0x86, 0x38, 0x96, 0xe9, 0xe2, 0xbf, 0x8e, 0x00, 0xc8,
	0x82, 0x3c, 0x74, 0x13, 0x92, 0x3c, 0x96, 0x45, 0x58, 0xc7, 0x24, 0x8a, 0x38, 0x21, 0xe0, 0xf1,
	0x2d, 0x1e, 0xc2, 0x59, 0x73, 0x7f, 0xdf, 0xb5, 0xf6, 0xe9, 0xc1, 0x20, 0x0f, 0xd4, 0x46, 0xea,
	0xca, 0xbe, 0x74, 0x7b, 0xfd, 0xe8, 0xe5, 0xe6, 0x4a, 0x49, 0x20, 0xf0, 0x70, 0x11, 0xa4, 0xee,
	0x2b, 0xe6, 0x34, 0x70, 0xec, 0xa1, 0xaf, 0x42, 0x61, 0x96, 0xd9, 0x54, 0xcd, 0xd7, 0xa7, 0x09,
	0xcb, 0xa2, 0x25, 0x3f, 0x17, 0x83, 0x84, 0x31, 0x24, 0xc6, 0xfd, 0xe5, 0xb9, 0x11, 0xd5, 0x68,
	0x9e, 0xea, 0xc2, 0x5d, 0x86, 0xb8, 0x39, 0x1e, 0xf7, 0xb8, 0x2a, 0x85, 0xd1, 0x4a, 0xe3, 0x71,
	0x0f, 0xd3, 0x6c, 0x74, 0x1d, 0x92, 0x7d, 0xa7, 0xf7, 0xd4, 0x9a, 0x0e, 0x3b, 0xc5, 0x10, 0x2b,
	0x34, 0x0b, 0x73, 0x14, 0x74, 0x01, 0x92, 0xf4, 0xd2, 0x1b, 0xdb, 0x80, 0x13, 0xa1, 0x8e, 0x39,
	0xac, 0xd0, 0x85, 0x38, 0x61, 0xbc, 0x40, 0xb5, 0xd6, 0xf8, 0x7d, 0xe6, 0xe9, 0x38, 0x2e, 0x81,
	0xe5, 0x1d, 0x5b, 0x60, 0x79, 0x17, 0xbe, 0x1d, 0x81, 0x24, 0xab, 0xd1, 0x82, 0x32, 0xee, 0x01,
	0x04, 0xe3, 0x71, 0xaa, 0xf5, 0xca, 0xd0, 0x8d, 0xae, 0x47, 0xb0, 0x82, 0x48, 0xaa, 0xd0, 0x73,
	0x46, 0x7b, 0xf6, 0xfe, 0x54, 0x15, 0xc4, 0x4c, 0xc9, 0x32, 0x8b, 0x45, 0xae, 0xed, 0x69, 0x88,
	0x97, 0x9a, 0xcd, 0x32, 0x9b, 0x1b, 0x2b, 0x8d, 0xf2, 0x43, 0x1d, 0x4b, 0xe5, 0xfe, 0x89, 0x08,
	0x68, 0x34, 0x6a, 0x4c, 0xd3, 0x75, 0xc6, 0xe6, 0x3e, 0xdb, 0x0a, 0xba, 0xcd, 0xdf, 0x1c, 0x61,
	0x93, 0x81, 0x8c, 0x7f, 0x3a, 0x85, 0xa6, 0x3c, 0x3c, 0x52, 0x2c, 0xf3, 0x97, 0x43, 0x42, 0x03,
	0xeb, 0x2c, 0x9c, 0xd9, 0x6d, 0xb4, 0xda, 0xdd, 0x76, 0x23, 0x30, 0x2f, 0xb5, 0x08, 0x31, 0xc8,
	0xb7, 0x8c, 0x8a, 0x81, 0xf5, 0x32, 0x31, 0x6b, 0x4a, 0x55, 0x59, 0x97, 0xdf, 0x4b, 0x41, 0x92,
	0x9f, 0x0e, 0x5e, 0x87, 0xa5, 0xc0, 0x6f, 0xa1, 0x51, 0x7c, 0x54, 0xe1, 0xe5, 0x65, 0x1e, 0x0d,
	0x86, 0x73, 0x1e, 0x32, 0x07, 0x8e, 0xe7, 0x77, 0x95, 0x98, 0xeb, 0xf4, 0x9a, 0x0c, 0xcd, 0xbc,
	0xc2, 0xdb, 0x12, 0xa3, 0x1a, 0x88, 0x42, 0x71, 0x8f, 0xd4, 0xa7, 0x53, 0x8a, 0x90, 0xb0, 0x87,
	0xc2, 0x3d, 0xcd, 0xde, 0xcd, 0xa9, 0xaa, 0x85, 0x59, 0x16, 0xba, 0x21, 0xdd, 0xbe, 0x44, 0x68,
	0x8b, 0x8f, 0x73, 0x9b, 0x8a, 0x89, 0xf4, 0x93, 0x49, 0xe9, 0x83, 0xbc, 0x17, 0x9a, 0x5d, 0xcf,
	0xcd, 0x23, 0x9b, 0x9d, 0x64, 0xb7, 0x21, 0xcf, 0x54, 0xb9, 0x1b, 0x0a, 0xdd, 0xf4, 0xc6, 0x5c,
	0x6a, 0xa6, 0x6a, 0xe2, 0xba, 0x40, 0x5f, 0x49, 0xa1, 0x32, 0xe4, 0x3c, 0x73, 0xd4, 0x7f, 0xe2,
	0x3c, 0xef, 0xca, 0x67, 0x79, 0x82, 0x3b, 0x1e, 0x61, 0x36, 0x2d, 0x86, 0x48, 0x63, 0x21, 0x65,
	0xbd, 0x20, 0x71, 0xca, 0xc5, 0x19, 0x3d, 0x50, 0xbb, 0x22, 0x7c, 0x1f, 0x24, 0x5c, 0xd0, 0x2e,
	0xef, 0x9f, 0xa0, 0xa7, 0x0a, 0xdf, 0x82, 0x9c, 0xda, 0x0a, 0xb2, 0xfe, 0xf5, 0x5d, 0xfb, 0x90,
	0x2e, 0xb2, 0x74, 0xfd, 0x63, 0xa9, 0x05, 0xe1, 0x39, 0x3f, 0x84, 0x25, 0x86, 0xd3, 0x75, 0xc6,
	0xec, 0x3e, 0x75, 0x2c, 0x34, 0xa4, 0x82, 0x45, 0x1c, 0xe7, 0x19, 0x62, 0x83, 0xe1, 0x15, 0x7e,
	0x18, 0xd2, 0xa2, 0x46, 0x34, 0x00, 0xed, 0xb4, 0xc6, 0xb1, 0xb8, 0x50, 0x15, 0x38, 0x43, 0x63,
	0x3c, 0x75, 0xc7, 0xc1, 0x28, 0x98, 0x5a, 0xfe, 0xa6, 0x07, 0x09, 0xd6, 0x86, 0x53, 0x90, 0xc2,
	0x4f, 0x47, 0x20, 0xab, 0xc8, 0x19, 0x7d, 0x1a, 0x52, 0x8e, 0xcb, 0x27, 0xf5, 0xcb, 0xac, 0xa2,
	0xac, 0xcb, 0x40, 0x57, 0x53, 0x15, 0x2e, 0xde, 0x3a, 0x26, 0xea, 0x53, 0x4b, 0xaf, 0x6e, 0xb3,
	0xe9, 0xa0, 0x59, 0xc2, 0xc4, 0x03, 0x16, 0x43, 0xf0, 0xf3, 0x79, 0x04, 0x67, 0x20, 0xcf, 0x66,
	0x0d, 0x71, 0x02, 0x1c, 0x21, 0x6b, 0x26, 0x1d, 0xda, 0x34, 0x7c, 0x54, 0x9c, 0x3a, 0xd4, 0xa5,
	0x7a, 0x65, 0xab, 0xf1, 0x19, 0x83, 0x44, 0x15, 0x2b, 0x4c, 0x44, 0xfa, 0x5f, 0x0b, 0x1e, 0x17,
	0xc2, 0x8f, 0xb5, 0x08, 0xfd, 0x6d, 0x68, 0xd1, 0xe2, 0x5f, 0x8d, 0x43, 0x56, 0x79, 0x65, 0x80,
	0x74, 0x3b, 0xbd, 0xc7, 0xc1, 0xbe, 0x0c, 0xc9, 0x60, 0x9e, 0x3a, 0xe5, 0xf7, 0x1f, 0xa8, 0x0d,
	0x39, 0x7b, 0xdc, 0xe5, 0xc1, 0x9f, 0xe5, 0xae, 0xee, 0x85, 0x39, 0xcf, 0x19, 0x18, 0x4d, 0xf1,
	0x7e, 0x95, 0x3c, 0xd2, 0x91, 0x20, 0xcb, 0xc3, 0x59, 0x7b, 0x2c, 0x13, 0x32, 0x92, 0x7b, 0x52,
	0x89, 0xe4, 0x6e, 0x40, 0x7e, 0xec, 0xb8, 0x3e, 0xfd, 0x44, 0xd8, 0x1e, 0xed, 0x8b, 0x23, 0x94,
	0x8d, 0x79, 0x2f, 0x27, 0x38, 0xae, 0x5f, 0x63, 0x68, 0x62, 0x1b, 0x7a, 0x1c, 0x80, 0xbc, 0xc2,
	0x73, 0xc8, 0xc8, 0xa2, 0x43, 0x8f, 0x31, 0x44, 0x5e, 0xf9, 0x31, 0x06, 0x7a, 0x3b, 0x56, 0x0a,
	0x80, 0xaf, 0x5f, 0xec, 0x76, 0xac, 0x28, 0x01, 0x67, 0x64, 0xd3, 0x0a, 0x2f, 0x20, 0xab, 0x54,
	0x0e, 0xbd, 0x21, 0xc6, 0xef, 0xf4, 0x3b, 0x11, 0x6c, 0x98, 0x3a, 0xae, 0x3f, 0x35, 0x35, 0x13,
	0xbc, 0xa8, 0x82, 0xa7, 0x4c, 0xcd, 0x04, 0xb9, 0xa0, 0xb4, 0x85, 0x6d, 0x34, 0x07, 0xaf, 0x46,
	0x6c, 0x40, 0x5a, 0x34, 0x82, 0xe8, 0x24, 0x69, 0x06, 0x7b, 0x29, 0xc2, 0x68, 0x1e, 0x7e, 0xa0,
	0x45, 0x8b, 0x47, 0x09, 0x58, 0x0a, 0x02, 0x33, 0x53, 0xdd, 0xa8, 0x4c, 0x05, 0xe8, 0x66, 0xb1,
	0x8e, 0xc5, 0x54, 0x16, 0x46, 0x56, 0x92, 0xe1, 0xf0, 0xdc, 0xc5, 0x9f, 0x48, 0x84, 0x82, 0x43,
	0x4f, 0xdd, 0xa8, 0x48, 0x94, 0x77, 0xc9, 0xdf, 0xdf, 0x4c, 0xa1, 0x33, 0x90, 0xab, 0x94, 0xca,
	0xdd, 0xc6, 0x23, 0x1d, 0x63, 0xa3, 0xa2, 0x6b, 0xbf, 0x95, 0x42, 0xab, 0xb0, 0x4c, 0x40, 0x58,
	0x2f, 0x55, 0xba, 0x2d, 0xbd, 0x84, 0xcb, 0xbb, 0xda, 0x7f, 0x4c, 0xa1, 0x2c, 0x24, 0xb7, 0x1b,
	0x8f, 0xc9, 0xea, 0xf6, 0x9f, 0x58, 0xa2, 0xa5, 0xb7, 0x8d, 0x8a, 0xf6, 0xdb, 0x29, 0x94, 0x81,
	0x38, 0xf1, 0x69, 0xb5, 0xff, 0x4c, 0xe1, 0x2d, 0xbd, 0xbd, 0x63, 0x54, 0xb4, 0xff, 0x22, 0x12,
	0x1d, 0xa3, 0xa2, 0xfd, 0x4e, 0x0a, 0xe5, 0x20, 0xd5, 0xd2, 0xdb, 0xcd, 0x72, 0xa9, 0xa9, 0x7d,
	0x9f, 0x16, 0x51, 0x35, 0xea, 0x9d, 0xcf, 0xba, 0x46, 0xad, 0xd6, 0x69, 0x97, 0xb6, 0xaa, 0xba,
	0xf6, 0x5f, 0x53, 0xe8, 0x2c, 0x68, 0x75, 0xbd, 0xdd, 0xdd, 0x32, 0xea, 0x15, 0x19, 0xdb, 0xf8,
	0x77, 0x53, 0x08, 0x41, 0x9e, 0x82, 0x71, 0xa3, 0x54, 0x29, 0x97, 0x5a, 0x6d, 0xed, 0xf7, 0x52,
	0x68, 0x09, 0x32, 0x04, 0x56, 0xaa, 0xd4, 0x8c, 0xba, 0xf6, 0xfb, 0x94, 0x3d, 0x49, 0xe3, 0xd2,
	0x63, 0xed, 0xbf, 0xa5, 0x50, 0x1e, 0xd2, 0x46, 0xb3, 0xdc, 0xa5, 0x11, 0xde, 0xfe, 0x3b, 0x45,
	0x26, 0x49, 0x56, 0xfb, 0x3f, 0x48, 0xa1, 0x65, 0x80, 0xd6, 0xe7, 0xad, 0x6e, 0xad, 0x51, 0xe9,
	0x54, 0x75, 0xed, 0x0f, 0x29, 0x02, 0x01, 0xe0, 0xd2, 0x63, 0xa3, 0xa1, 0xfd, 0x0f, 0x89, 0x50,
	0xde, 0xc5, 0x8d, 0x46, 0x5b, 0xfb, 0x9f, 0x12, 0xd0, 0x6c, 0xe3, 0x52, 0x59, 0xd7, 0xfe, 0x97,
	0xa4, 0x68, 0x96, 0xca, 0xe5, 0xb6, 0xf6, 0x47, 0x32, 0xcd, 0xea, 0xf3, 0xbf, 0x69, 0x0d, 0x48,
	0x7a, 0x8b, 0xd0, 0xff, 0xb1, 0x4c, 0xd6, 0x49, 0x8b, 0xfe, 0x0f, 0x15, 0x3a, 0x2d, 0x8f, 0x6f,
	0x70, 0x68, 0xdf, 0x4e, 0x0b, 0x8c, 0xb6, 0x51, 0xd3, 0xb5, 0x1f, 0x49, 0xa3, 0x15, 0x58, 0xa2,
	0xc9, 0xf6, 0xe7, 0xc4, 0xac, 0xd8, 0x36, 0x76, 0xb4, 0xff, 0x3f, 0x4d, 0xfa, 0xad, 0xf6, 0xb0,
	0xde, 0xa8, 0x68, 0x7f, 0x86, 0xfe, 0xaf, 0xea, 0xa5, 0x96, 0xae, 0xfd, 0x68, 0x1a, 0x69, 0x90,
	0x2d, 0x75, 0x2a, 0x46, 0xbb, 0xfb, 0x18, 0x1b, 0x6d, 0x5d, 0xfb, 0xb1, 0x34, 0x11, 0x19, 0x83,
	0xf0, 0xf8, 0xd1, 0xda, 0x8f, 0xa7, 0x79, 0x0f, 0x6c, 0x93, 0x1e, 0xf8, 0xb3, 0x69, 0x52, 0x85,
	0x9a, 0xda, 0xef, 0xdf, 0x49, 0x93, 0x36, 0x10, 0x10, 0x6b, 0xc3, 0x4f, 0xa4, 0x69, 0xff, 0x7d,
	0xde, 0xaa, 0x36, 0x76, 0xb4, 0x3f, 0x97, 0x26, 0x12, 0x78, 0x5c, 0x7a, 0xa8, 0x77, 0x4b, 0xd5,
	0x12, 0xae, 0x69, 0x7f, 0x9e, 0x16, 0x41, 0x43, 0xe8, 0x75, 0x5b, 0x9d, 0x56, 0x53, 0xaf, 0x57,
	0xb4, 0x9f, 0xa4, 0x48, 0xac, 0x58, 0xa2, 0x3b, 0xda, 0x4f, 0x89, 0x37, 0xa6, 0x7e, 0x21, 0x0a,
	0x99, 0xaa, 0x3d, 0x9a, 0x3c, 0xa7, 0xfa, 0xbd, 0x05, 0xcb, 0x52, 0x53, 0x5f, 0x88, 0x8f, 0x14,
	0x43, 0x2f, 0x41, 0x85, 0x54, 0x9c, 0x1a, 0x86, 0x4b, 0xbd, 0xf0, 0x18, 0xf9, 0x3a, 0x9c, 0x7d,
	0xe2, 0x4c, 0x46, 0x7d, 0x7b, 0xb4, 0xdf, 0x0d, 0x0d, 0x96, 0xe8, 0x02, 0x4e, 0x78, 0x55, 0xd0,
	0x94, 0xd5, 0x67, 0xc5, 0xaa, 0xb0, 0x66, 0xed, 0xed, 0x59, 0xfc, 0xbb, 0x6e, 0x95, 0x59, 0x6c,
	0x11, 0xb3, 0xb3, 0x92, 0x28, 0xc4, 0x4d, 0x87, 0x15, 0x1a, 0xc4, 0xb4, 0x3b, 0xb6, 0xfb, 0x5d,
	0x32, 0x85, 0x7a, 0x63, 0xb3, 0xc7, 0xdf, 0x1a, 0x61, 0xdf, 0x58, 0xd0, 0x68, 0x82, 0x4d, 0xa3,
	0x52, 0x17, 0x99, 0xf8, 0x0c, 0xa5, 0x68, 0xda, 0x7d, 0x09, 0x2a, 0x7e, 0x37, 0x06, 0x80, 0xa9,
	0x07, 0xc4, 0xdf, 0x7a, 0x49, 0xb9, 0x21, 0x47, 0x49, 0x46, 0x7d, 0x95, 0x38, 0xfc, 0xaf, 0xb8,
	0x02, 0xc7, 0xd1, 0x0b, 0xdf, 0x89, 0x41, 0x92, 0xe5, 0xa0, 0xaf, 0x84, 0xd6, 0xe0, 0x8b, 0xc7,
	0x71, 0x98, 0x5d, 0x7b, 0x11, 0xc4, 0x0f, 0x4c, 0xb7, 0xcf, 0x03, 0x17, 0xd2, 0xff, 0x04, 0xe6,
	0x39, 0x7b, 0x3e, 0x77, 0x93, 0xe8, 0xff, 0xe2, 0xdf, 0x8a, 0x1e, 0xf3, 0x9e, 0x05, 0xae, 0xd6,
	0xda, 0xdd, 0x52, 0x8b, 0xad, 0xa9, 0x34, 0x51, 0x6e, 0x60, 0x5d, 0x8b, 0xa2, 0x1c, 0xa4, 0x59,
	0xb2, 0xd9, 0xd1, 0x62, 0x32, 0xb3, 0x52, 0x6a, 0x97, 0xb4, 0x38, 0x5a, 0x22, 0x22, 0xa8, 0xb5,
	0xbb, 0xdb, 0x2d, 0xe3, 0x9b, 0xfc, 0xb9, 0x33, 0x9a, 0x26, 0x5a, 0xd7, 0xd2, 0x92, 0xf4, 0x49,
	0x33, 0x92, 0xae, 0xe9, 0x35, 0x3a, 0xd2, 0x53, 0x34, 0xac, 0x3c, 0x85, 0xb4, 0x76, 0xbe, 0xd1,
	0xd1, 0x3b, 0xba, 0x96, 0x96, 0x3c, 0xe9, 0xd0, 0xcb, 0xa0, 0x65, 0xc8, 0xb2, 0x64, 0x63, 0xdb,
	0xa8, 0xea, 0x1a, 0x48, 0xa6, 0xf5, 0x26, 0x6e, 0x94, 0xb5, 0xac, 0xac, 0x11, 0x6e, 0xb5, 0xd8,
	0x25, 0x30, 0x96, 0x6a, 0x37, 0xb1, 0xd1, 0xd0, 0xf2, 0x0a, 0x80, 0x8e, 0xd4, 0x25, 0xba, 0xb7,
	0x4a, 0x00, 0x2d, 0x63, 0x87, 0x8c, 0x02, 0xa3, 0xbe, 0xa3, 0x2d, 0x4b, 0xa6, 0xad, 0x76, 0xa9,
	0xfc, 0x50, 0xd3, 0xf8, 0x30, 0xf8, 0xa9, 0x08, 0xa4, 0xda, 0xed, 0xcf, 0x69, 0x87, 0x3e, 0x80,
	0xec, 0x33, 0x7b, 0xd4, 0x77, 0x9e, 0x75, 0x3d, 0xfb, 0x5b, 0xd6, 0x54, 0x3c, 0x74, 0x8e, 0x74,
	0xf3, 0x31, 0xc5, 0x68, 0xd9, 0xdf, 0xb2, 0x30, 0x3c, 0x93, 0xff, 0x0b, 0xdb, 0x00, 0x41, 0x0e,
	0x31, 0x8c, 0x5c, 0xe7, 0x99, 0x17, 0x7e, 0xf0, 0x88, 0x40, 0xd0, 0x06, 0xa4, 0x7a, 0xc4, 0xc0,
	0x1a, 0x79, 0xa1, 0xd5, 0x4b, 0x00, 0x8b, 0x2f, 0xd3, 0x90, 0x0f, 0x87, 0xd8, 0x7f, 0x37, 0xe4,
	0xc9, 0x9e, 0x9b, 0x77, 0xb8, 0xaf, 0x7a, 0xb4, 0xef, 0x06, 0xf7, 0x31, 0xd9, 0x07, 0x0b, 0xe1,
	0x88, 0xab, 0x53, 0xb7, 0x31, 0xd1, 0x57, 0xa6, 0x3c, 0xdb, 0xcd, 0xb9, 0xfc, 0x99, 0x79, 0x2c,
	0xee, 0x9c, 0x53, 0xdf, 0xb2, 0x10, 0xfa, 0x4e, 0x20, 0xfc, 0x7a, 0xc6, 0xfb, 0xc0, 0xde, 0x95,
	0xe5, 0x86, 0xf8, 0xc6, 0x5c, 0x9e, 0x35, 0x02, 0x63, 0xf7, 0x7c, 0x68, 0x36, 0xfa, 0x98, 0x06,
	0xf0, 0x60, 0xb7, 0x00, 0xe8, 0x5d, 0xde, 0x54, 0x28, 0x9a, 0xb7, 0x62, 0x83, 0x08, 0x53, 0x66,
	0x14, 0x80, 0x3c, 0x74, 0x0b, 0x60, 0x40, 0xe6, 0x33, 0x36, 0x7b, 0xa5, 0x43, 0x77, 0x8a, 0xe4,
	0x44, 0x87, 0x33, 0x03, 0x39, 0xe7, 0xdd, 0x85, 0x2c, 0x1b, 0x90, 0x8c, 0x22, 0x13, 0xb2, 0xd8,
	0x83, 0x11, 0x88, 0x81, 0x61, 0x51, 0x9a, 0x0f, 0x20, 0xed, 0x8b, 0x09, 0x12, 0x42, 0x67, 0x86,
	0x5c, 0x3f, 0xd8, 0x99, 0x21, 0x4f, 0xe0, 0x94, 0xcf, 0x26, 0xa6, 0xc2, 0x2f, 0xc6, 0x01, 0x02,
	0x21, 0xa2, 0x82, 0xf0, 0xf9, 0x42, 0xd1, 0xc5, 0x99, 0xaf, 0xb7, 0x03, 0x29, 0xde, 0x2e, 0xfe,
	0x22, 0xd6, 0xdb, 0x27, 0x74, 0x89, 0x90, 0xcc, 0x83, 0x38, 0xb1, 0x8c, 0xb1, 0xa0, 0x46, 0x8f,
	0xa6, 0xcd, 0x44, 0xf6, 0xc1, 0xf3, 0xf5, 0x93, 0xd8, 0x9d, 0x60, 0x33, 0xa2, 0xcb, 0x00, 0x63,
	0xd7, 0x3e, 0xb4, 0x07, 0xd6, 0xbe, 0xdc, 0xe3, 0x10, 0x8f, 0x5c, 0x06, 0x19, 0xe8, 0x03, 0x00,
	0xb9, 0x09, 0x39, 0xfd, 0x5c, 0xc7, 0xf4, 0x76, 0xa5, 0x82, 0x89, 0xae, 0x82, 0xb6, 0xe7, 0xb8,
	0x3d, 0xab, 0x3b, 0x9e, 0x0c, 0x06, 0x5d, 0x26, 0x26, 0xfa, 0x66, 0x15, 0x5e, 0xa2, 0xf0, 0xe6,
	0x64, 0x30, 0x60, 0x7b, 0x3c, 0x6f, 0x43, 0x9e, 0xa9, 0x71, 0x97, 0xbb, 0x6b, 0x29, 0xf9, 0xb0,
	0x51, 0x8e, 0x65, 0x54, 0x28, 0xfc, 0xff, 0xa5, 0xad, 0x79, 0x1f, 0x52, 0xbc, 0x7b, 0xe8, 0x53,
	0x64, 0x8d, 0x16, 0x7f, 0x40, 0x68, 0x0b, 0x1b, 0x95, 0x1d, 0x9d, 0xc5, 0x88, 0xaf, 0x37, 0xea,
	0xba, 0x16, 0x23, 0xff, 0x3a, 0x2d, 0x1d, 0xcb, 0xa8, 0xb7, 0xb7, 0x20, 0x23, 0xc7, 0x48, 0xb0,
	0x4b, 0x10, 0x39, 0x76, 0x97, 0xa0, 0xf8, 0x66, 0x10, 0x97, 0x9e, 0x6f, 0xb6, 0xb0, 0xf8, 0xba,
	0x7a, 0xab, 0xd1, 0x92, 0x8e, 0xd6, 0xb7, 0xa3, 0xb0, 0x3c, 0x75, 0xf4, 0x3a, 0x3b, 0xf2, 0x22,
	0xaf, 0x34, 0xf2, 0xee, 0x42, 0xb6, 0x47, 0x7d, 0x25, 0x36, 0x2e, 0xa6, 0x76, 0x93, 0x64, 0xe0,
	0x06, 0x0c, 0x3d, 0xf9, 0x1f, 0xdd, 0x55, 0xbe, 0x07, 0x1a, 0xf3, 0xd7, 0x58, 0xf3, 0xec, 0xba,
	0x89, 0x38, 0x14, 0x6f, 0x1a, 0x95, 0xe0, 0xc3, 0x9f, 0xa6, 0x4d, 0x5f, 0xc7, 0x9a, 0x8a, 0x4b,
	0x70, 0xcc, 0x43, 0xcc, 0x8c, 0xcf, 0x71, 0x31, 0x09, 0x8a, 0x3f, 0x9f, 0x05, 0x08, 0xaa, 0x85,
	0x3e, 0xa6, 0x03, 0xae, 0xdb, 0x1b, 0x88, 0xc8, 0x6d, 0xeb, 0xb3, 0x31, 0x27, 0xea, 0x96, 0x5f,
	0x1e, 0x78, 0x5b, 0x70, 0xf4, 0x72, 0x33, 0x49, 0xfe, 0x57, 0x5b, 0x38, 0x39, 0xa2, 0xb0, 0xc2,
	0xdf, 0x03, 0x48, 0xd0, 0x90, 0x14, 0x85, 0xa6, 0xd8, 0x01, 0xbe, 0x03, 0x51, 0x67, 0x3c, 0xf5,
	0xec, 0xce, 0x4c, 0x00, 0x0b, 0x79, 0x4b, 0x06, 0x47, 0x9d, 0x71, 0xf8, 0x58, 0x23, 0x2e, 0x36,
	0xa3, 0x7f, 0x3f, 0x0e, 0xb1, 0xf2, 0xf6, 0x37, 0x0a, 0xbf, 0x1d, 0x07, 0x50, 0xe2, 0x0a, 0xdc,
	0x80, 0x64, 0xdf, 0x3a, 0xb4, 0x65, 0x54, 0x35, 0x79, 0x4b, 0x8c, 0x02, 0x6f, 0xd6, 0x27, 0xc3,
	0x27, 0x74, 0x3f, 0x92, 0x26, 0xd1, 0x3a, 0xa4, 0x3c, 0xab, 0xe7, 0x8b, 0xa0, 0xa9, 0x71, 0x2c,
	0x92, 0xc4, 0x5e, 0xa0, 0xa7, 0xea, 0xdc, 0x5e, 0x20, 0xff, 0x11, 0x86, 0xac, 0xed, 0x74, 0xf9,
	0xeb, 0x2c, 0x7d, 0x7e, 0xfd, 0xe6, 0xe2, 0x71, 0x8d, 0xa0, 0xed, 0x0d, 0x5e, 0x53, 0x33, 0x1a,
	0xfc, 0xcd, 0x94, 0x3e, 0x06, 0xdb, 0x11, 0xff, 0x51, 0x17, 0xb4, 0x80, 0xa7, 0x0c, 0x27, 0x76,
	0x0a, 0xc6, 0x6b, 0x9c, 0xf1, 0x92, 0x64, 0xcc, 0x82, 0x8e, 0x2d, 0x49, 0xe6, 0x22, 0xc6, 0xc9,
	0xb2, 0x52, 0x00, 0x6d, 0x53, 0xf2, 0x34, 0xfc, 0xcf, 0x72, 0xfe, 0x79, 0xc9, 0xbf, 0x6d, 0x0f,
	0x2d, 0x9c, 0x97, 0xec, 0xe9, 0x65, 0x82, 0x16, 0xe4, 0x6c, 0x87, 0x45, 0x01, 0xa2, 0xac, 0x53,
	0xaf, 0x28, 0x93, 0xc7, 0xa6, 0x4d, 0x03, 0x70, 0x12, 0x99, 0x88, 0xff, 0xa8, 0x0a, 0x19, 0xdb,
	0xe9, 0x0e, 0x2d, 0x77, 0x9f, 0xc6, 0x2f, 0x3b, 0x05, 0x47, 0x8d, 0x73, 0x4c, 0x1b, 0x8d, 0x1a,
	0x25, 0xc3, 0x69, 0xdb, 0x61, 0xff, 0x38, 0x37, 0x1a, 0xd8, 0xb9, 0xcf, 0x5f, 0x8f, 0x3a, 0x3d,
	0xb7, 0x6f, 0x50, 0x32, 0xc2, 0x8d, 0xfd, 0x2b, 0xfc, 0x71, 0x04, 0x80, 0x07, 0x39, 0xb3, 0x47,
	0xfb, 0x85, 0xdf, 0x89, 0xfc, 0x00, 0xda, 0x37, 0xa5, 0x4f, 0xd1, 0x3f, 0x2d, 0x7d, 0x8a, 0xfd,
	0x09, 0xea, 0x53, 0xe1, 0xc7, 0xa2, 0xa1, 0x16, 0xeb, 0x10, 0xeb, 0xed, 0x7d, 0xc1, 0x67, 0xc5,
	0x2b, 0xc7, 0x15, 0x51, 0xde, 0xfe, 0xc6, 0x4d, 0x35, 0xd4, 0x23, 0x2f, 0x8b, 0x0c, 0x60, 0x4c,
	0xe8, 0x91, 0x09, 0xf9, 0xde, 0xde, 0x17, 0x5d, 0xd7, 0xea, 0x4d, 0x5c, 0xcf, 0x3e, 0xb4, 0xb8,
	0x30, 0x4e, 0xcb, 0x70, 0x95, 0x33, 0xcc, 0x11, 0x86, 0x82, 0x07, 0xce, 0xf5, 0xf6, 0xbe, 0x90,
	0x29, 0x54, 0x03, 0xf0, 0x65, 0xc7, 0x71, 0x99, 0xbc, 0x7b, 0x1c, 0xff, 0xa0, 0x8b, 0xd5, 0x68,
	0x3a, 0x0a, 0x83, 0x62, 0x4b, 0xbd, 0xa7, 0x39, 0x7d, 0xee, 0xd9, 0x6e, 0xb4, 0x4b, 0x55, 0xb6,
	0x71, 0x42, 0x5d, 0x4b, 0x1a, 0xc1, 0x9d, 0x79, 0xbb, 0x74, 0x31, 0x6b, 0x7d, 0x5e, 0x2f, 0x6b,
	0x71, 0x02, 0x2c, 0xd1, 0xbf, 0x09, 0xb9, 0xae, 0x25, 0xd9, 0x74, 0x8a, 0x2e, 0x43, 0xaa, 0x37,
	0x30, 0x3d, 0x8f, 0x5f, 0x41, 0xcc, 0x33, 0xe3, 0xa9, 0x4c, 0x40, 0x46, 0x05, 0x8b, 0xbc, 0xe2,
	0xfb, 0x90, 0x64, 0x7b, 0x6d, 0xe8, 0x1d, 0xb9, 0x15, 0xc7, 0xfa, 0x22, 0xa7, 0x6e, 0xc5, 0xc9,
	0x63, 0x29, 0x16, 0x8f, 0xe5, 0x1e, 0x24, 0x28, 0xf8, 0xd8, 0x83, 0xd7, 0xb9, 0x27, 0xc9, 0xc5,
	0x7f, 0x12, 0x81, 0x38, 0x5d, 0xd5, 0x2f, 0x40, 0x72, 0x44, 0x55, 0x39, 0x64, 0x22, 0x70, 0x98,
	0xdc, 0x97, 0x8b, 0x86, 0x5e, 0x58, 0x3c, 0xd6, 0x0e, 0x40, 0x9f, 0x02, 0x1c, 0xda, 0x9e, 0xcd,
	0xbf, 0xcf, 0x60, 0x0f, 0x3a, 0x6c, 0xce, 0xbb, 0xdc, 0x7b, 0xf3, 0x91, 0x44, 0xc3, 0x0a, 0x89,
	0xb2, 0x0b, 0x99, 0x58, 0x14, 0x85, 0xe6, 0x36, 0x24, 0x58, 0xcc, 0xd5, 0xb7, 0x21, 0x31, 0xa6,
	0xb1, 0x58, 0x99, 0xa4, 0xc4, 0x3d, 0x48, 0x92, 0x29, 0xec, 0x4d, 0x9a, 0x5f, 0xfc, 0x97, 0x51,
	0xc8, 0x87, 0x6a, 0x80, 0xf4, 0x50, 0x5d, 0x99, 0xdf, 0x71, 0x52, 0x5d, 0x85, 0x21, 0xa7, 0xd4,
	0x78, 0x9e, 0x88, 0x2e, 0x85, 0x5f, 0x39, 0x65, 0x52, 0x0a, 0xbd, 0x68, 0x5a, 0x80, 0xb4, 0xf8,
	0x0c, 0x56, 0xf8, 0x15, 0x22, 0xad, 0xbe, 0xca, 0x97, 0x08, 0xbf, 0xca, 0x57, 0x14, 0xad, 0x4d,
	0x86, 0xcc, 0x23, 0x2a, 0x0a, 0xde, 0x50, 0x45, 0x82, 0xa9, 0x45, 0x12, 0xfc, 0x00, 0x20, 0x68,
	0x16, 0x71, 0x55, 0xe5, 0x15, 0x1c, 0xfe, 0xb6, 0x6c, 0xb5, 0x43, 0x6f, 0x73, 0xd1, 0x57, 0xea,
	0xf5, 0xcf, 0xda, 0x3a, 0xa6, 0x47, 0x49, 0xc5, 0x4f, 0x00, 0x1e, 0x5b, 0xf6, 0xfe, 0x81, 0xcf,
	0xdf, 0x04, 0x49, 0x3e, 0xa3, 0xa9, 0x50, 0xdc, 0x1f, 0x0e, 0x93, 0x8f, 0x7d, 0x44, 0x83, 0xc7,
	0x3e, 0x8a, 0xff, 0x21, 0x02, 0xd9, 0x47, 0xac, 0x39, 0x94, 0xc3, 0x46, 0xd0, 0x58, 0x55, 0x75,
	0x65, 0x93, 0x69, 0x74, 0x1b, 0x7b, 0xd0, 0xef, 0xf6, 0xd9, 0xcd, 0x48, 0xfa, 0x9e, 0x05, 0x85,
	0x54, 0x4c, 0xdf, 0x0a, 0xb2, 0xe5, 0x0a, 0x1f, 0xe1, 0xd9, 0x74, 0xf9, 0x91, 0xd9, 0xf4, 0x26,
	0x78, 0x5c, 0xa1, 0xee, 0x78, 0x96, 0x8b, 0xde, 0x84, 0xd4, 0xbe, 0xed, 0x77, 0xbd, 0x03, 0xf6,
	0x64, 0x44, 0x86, 0x59, 0x3e, 0x3b, 0xb6, 0xdf, 0xda, 0x2d, 0xe1, 0xe4, 0xbe, 0xed, 0xb7, 0x0e,
	0x4c, 0xc2, 0x83, 0x20, 0xb1, 0x48, 0x03, 0x7c, 0x87, 0x3a, 0xb3, 0x6f, 0xfb, 0x5b, 0x14, 0x80,
	0x5e, 0x67, 0x3c, 0x7c, 0x73, 0x9f, 0xbf, 0x64, 0x4f, 0xe8, 0xda, 0xe6, 0x7e, 0xf1, 0x03, 0x88,
	0x6f, 0x0f, 0xcc, 0xfd, 0x57, 0xbd, 0xe4, 0x51, 0xfc, 0xf9, 0x08, 0xc4, 0xb1, 0xb3, 0xf0, 0x76,
	0x48, 0x20, 0xf6, 0xe8, 0x1c, 0xb1, 0x7f, 0x08, 0x20, 0x2f, 0x8c, 0x8b, 0x15, 0x63, 0xde, 0x3d,
	0x73, 0xae, 0xcb, 0x01, 0xee, 0x97, 0xfa, 0x9a, 0xa8, 0xf8, 0x21, 0x24, 0x6b, 0x96, 0xef, 0xda,
	0xbd, 0xd3, 0xb6, 0x34, 0x22, 0x5a, 0xfa, 0xcf, 0x22, 0x90, 0xde, 0xb6, 0x07, 0xf2, 0xf5, 0xcc,
	0x63, 0x8e, 0x85, 0x56, 0x21, 0x31, 0x1a, 0xd8, 0x23, 0xe6, 0x28, 0x26, 0x30, 0x4b, 0xd0, 0x5d,
	0x20, 0xfb, 0x5b, 0xd2, 0xaa, 0x23, 0xff, 0xd1, 0x65, 0x48, 0x0c, 0xa9, 0x22, 0xc4, 0xe7, 0x5f,
	0xa0, 0x64, 0xb9, 0x84, 0x94, 0x9e, 0x59, 0xd2, 0x47, 0xb6, 0xf9, 0xf9, 0xe4, 0x39, 0x88, 0x4d,
	0xf8, 0xfb, 0x89, 0xfc, 0x05, 0xcd, 0x8e, 0x51, 0xc1, 0x04, 0x46, 0xb2, 0xf6, 0xf9, 0x1d, 0x57,
	0x9e, 0xb5, 0x43, 0xb2, 0xf6, 0xed, 0x7e, 0xf1, 0x6f, 0x44, 0x20, 0xc9, 0x0c, 0x02, 0xf9, 0x28,
	0x75, 0x44, 0x79, 0x94, 0xfa, 0x86, 0x9c, 0x5c, 0xa3, 0x8b, 0x6c, 0x08, 0x86, 0x53, 0xa8, 0x43,
	0x92, 0x41, 0x82, 0x30, 0x48, 0xca, 0xd4, 0x2c, 0xc2, 0x20, 0x29, 0x28, 0x34, 0x98, 0x92, 0x2c,
	0x20, 0x2a, 0x83, 0x29, 0x31, 0x14, 0x22, 0xde, 0x1c, 0x2b, 0xa9, 0xd4, 0xeb, 0x59, 0x9e, 0x47,
	0xcf, 0xf7, 0x85, 0x49, 0xa3, 0xde, 0x4b, 0x66, 0x48, 0x42, 0x8b, 0xb8, 0x45, 0xf3, 0x21, 0x24,
	0x4d, 0x4a, 0xc6, 0x3f, 0xf4, 0x29, 0x84, 0x90, 0x19, 0xc7, 0x9b, 0xec, 0x47, 0x50, 0x32, 0xfc,
	0xc2, 0x2e, 0x24, 0x79, 0x81, 0x64, 0x02, 0xb0, 0x4c, 0x71, 0x63, 0x9a, 0xfe, 0x27, 0xbd, 0xf9,
	0xcc, 0xb5, 0x7d, 0xf1, 0x7c, 0x32, 0x4b, 0x10, 0xe8, 0xf0, 0xe9, 0xc8, 0x61, 0x1e, 0x52, 0x1a,
	0xb3, 0x44, 0xb1, 0x03, 0xcb, 0xac, 0xb8, 0xc7, 0x07, 0xb6, 0x6f, 0x0d, 0x6c, 0xcf, 0x47, 0x5b,
	0x2c, 0xf0, 0xc0, 0x33, 0xab, 0xdf, 0x65, 0x15, 0x15, 0x53, 0xff, 0xca, 0x9c, 0xfa, 0x89, 0x8f,
	0x00, 0x39, 0x05, 0xcb, 0xf2, 0xde, 0xf9, 0x21, 0x48, 0x72, 0x97, 0x70, 0x0d, 0x50, 0x05, 0x1b,
	0x8f, 0x74, 0xdc, 0xad, 0x37, 0xe8, 0x9e, 0x19, 0x66, 0xd7, 0x1e, 0x11, 0x2c, 0x71, 0x38, 0xee,
	0xd4, 0xeb, 0x46, 0x7d, 0x47, 0x8b, 0x2a, 0xb0, 0xd2, 0x56, 0x83, 0xe2, 0xc5, 0x14, 0x58, 0xab,
	0xdd, 0x68, 0x36, 0xf5, 0x8a, 0x16, 0x7f, 0xe7, 0x27, 0xa3, 0x90, 0x91, 0x77, 0xb6, 0x91, 0x06,
	0x39, 0x7a, 0x0f, 0xad, 0xd5, 0x2e, 0xed, 0x10, 0x3e, 0x49, 0x74, 0x06, 0xf2, 0x02, 0x82, 0xdb,
	0x04, 0xf4, 0x9a, 0x44, 0x12, 0x85, 0x45, 0x24, 0xe4, 0xa1, 0x51, 0xad, 0x12, 0x48, 0x5a, 0x92,
	0x6d, 0x1b, 0x75, 0xa3, 0xb5, 0x4b, 0xaf, 0x5e, 0x2e, 0x43, 0x96, 0x81, 0xd8, 0x5d, 0xd2, 0x98,
	0x04, 0xb0, 0x7b, 0x7e, 0x6c, 0x1f, 0x93, 0x02, 0xd8, 0xcd, 0xcb, 0x14, 0x99, 0xe7, 0x69, 0xba,
	0x4a, 0x3c, 0xf4, 0x84, 0x2c, 0xa5, 0x82, 0x59, 0xe5, 0x33, 0x68, 0x15, 0x34, 0x7e, 0x6d, 0x8e,
	0xde, 0x3c, 0xa5, 0xc7, 0x23, 0x20, 0xc9, 0x76, 0x88, 0x0b, 0x9f, 0x45, 0xe7, 0xe0, 0xac, 0x4c,
	0x86, 0x6e, 0x31, 0xe6, 0x24, 0x47, 0x79, 0x05, 0xf1, 0x9d, 0xef, 0x44, 0x61, 0x29, 0xfc, 0xa9,
	0x04, 0xa1, 0x67, 0x24, 0x46, 0xa3, 0xde, 0xed, 0xd4, 0x5b, 0x9d, 0x66, 0x93, 0x09, 0x94, 0xde,
	0x69, 0x08, 0xb2, 0xc4, 0xae, 0x66, 0x84, 0xf4, 0x53, 0x00, 0x56, 0x24, 0xb0, 0x0a, 0x9a, 0x02,
	0x17, 0x62, 0x58, 0x81, 0xe5, 0x00, 0x2a, 0x2e, 0x9d, 0x86, 0x38, 0x8b, 0x06, 0x27, 0xa6, 0xeb,
	0x12, 0xb4, 0x3a, 0x89, 0x36, 0xa0, 0x10, 0x64, 0xcd, 0xb4, 0x35, 0x85, 0xd6, 0x61, 0x35, 0xc8,
	0xc7, 0x7a, 0xb9, 0xf1, 0x48, 0xc7, 0xac, 0xaf, 0x42, 0x65, 0x09, 0x51, 0x64, 0xb6, 0xca, 0xbf,
	0xf2, 0xbd, 0x8d, 0xd7, 0x7e, 0xf5, 0x7b, 0x1b, 0xaf, 0xfd, 0xda, 0xf7, 0x36, 0x22, 0xdf, 0xff,
	0xde, 0x46, 0xe4, 0x0f, 0xbf, 0xb7, 0x11, 0xf9, 0xf6, 0xd1, 0x46, 0xe4, 0xe7, 0x8e, 0x36, 0x22,
	0xff, 0xe8, 0x68, 0x23, 0xf2, 0xcf, 0x8f, 0x36, 0x22, 0xbf, 0x7c, 0xb4, 0x11, 0xf9, 0x95, 0xa3,
	0x8d, 0xc8, 0x6f, 0x1e, 0x6d, 0xbc, 0xf6, 0xfd, 0xa3, 0x8d, 0xc8, 0x5f, 0xfa, 0xf5, 0x8d, 0xd7,
	0xfe, 0xf6, 0xaf, 0x6f, 0x44, 0xbe, 0xc9, 0xf6, 0x0f, 0xff, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x8b, 0xed, 0x3e, 0xc5, 0xd9, 0x8a, 0x00, 0x00,
}
