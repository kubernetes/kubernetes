// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: agent/agent.pb.go
// DO NOT EDIT!

package agent

import (
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"github.com/mesos/mesos-go/api/v1/lib"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"reflect"
)

func (mj *Call) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)

	{

		obj, err = mj.Type.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if mj.GetMetrics != nil {
		if true {
			buf.WriteString(`"get_metrics":`)

			{

				err = mj.GetMetrics.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.SetLoggingLevel != nil {
		if true {
			buf.WriteString(`"set_logging_level":`)

			{

				err = mj.SetLoggingLevel.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ListFiles != nil {
		if true {
			buf.WriteString(`"list_files":`)

			{

				err = mj.ListFiles.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ReadFile != nil {
		if true {
			buf.WriteString(`"read_file":`)

			{

				err = mj.ReadFile.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetContainers != nil {
		if true {
			buf.WriteString(`"get_containers":`)

			{

				err = mj.GetContainers.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.LaunchNestedContainer != nil {
		if true {
			buf.WriteString(`"launch_nested_container":`)

			{

				err = mj.LaunchNestedContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.WaitNestedContainer != nil {
		if true {
			buf.WriteString(`"wait_nested_container":`)

			{

				err = mj.WaitNestedContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.KillNestedContainer != nil {
		if true {
			buf.WriteString(`"kill_nested_container":`)

			{

				err = mj.KillNestedContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.RemoveNestedContainer != nil {
		if true {
			buf.WriteString(`"remove_nested_container":`)

			{

				err = mj.RemoveNestedContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.LaunchNestedContainerSession != nil {
		if true {
			buf.WriteString(`"launch_nested_container_session":`)

			{

				err = mj.LaunchNestedContainerSession.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.AttachContainerInput != nil {
		if true {
			buf.WriteString(`"attach_container_input":`)

			{

				err = mj.AttachContainerInput.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.AttachContainerOutput != nil {
		if true {
			buf.WriteString(`"attach_container_output":`)

			{

				err = mj.AttachContainerOutput.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.LaunchContainer != nil {
		if true {
			buf.WriteString(`"launch_container":`)

			{

				err = mj.LaunchContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.WaitContainer != nil {
		if true {
			buf.WriteString(`"wait_container":`)

			{

				err = mj.WaitContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.KillContainer != nil {
		if true {
			buf.WriteString(`"kill_container":`)

			{

				err = mj.KillContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.RemoveContainer != nil {
		if true {
			buf.WriteString(`"remove_container":`)

			{

				err = mj.RemoveContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.AddResourceProviderConfig != nil {
		if true {
			buf.WriteString(`"add_resource_provider_config":`)

			{

				err = mj.AddResourceProviderConfig.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.UpdateResourceProviderConfig != nil {
		if true {
			buf.WriteString(`"update_resource_provider_config":`)

			{

				err = mj.UpdateResourceProviderConfig.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.RemoveResourceProviderConfig != nil {
		if true {
			buf.WriteString(`"remove_resource_provider_config":`)

			{

				err = mj.RemoveResourceProviderConfig.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.PruneImages != nil {
		if true {
			buf.WriteString(`"prune_images":`)

			{

				err = mj.PruneImages.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Callbase = iota
	ffj_t_Callno_such_key

	ffj_t_Call_Type

	ffj_t_Call_GetMetrics

	ffj_t_Call_SetLoggingLevel

	ffj_t_Call_ListFiles

	ffj_t_Call_ReadFile

	ffj_t_Call_GetContainers

	ffj_t_Call_LaunchNestedContainer

	ffj_t_Call_WaitNestedContainer

	ffj_t_Call_KillNestedContainer

	ffj_t_Call_RemoveNestedContainer

	ffj_t_Call_LaunchNestedContainerSession

	ffj_t_Call_AttachContainerInput

	ffj_t_Call_AttachContainerOutput

	ffj_t_Call_LaunchContainer

	ffj_t_Call_WaitContainer

	ffj_t_Call_KillContainer

	ffj_t_Call_RemoveContainer

	ffj_t_Call_AddResourceProviderConfig

	ffj_t_Call_UpdateResourceProviderConfig

	ffj_t_Call_RemoveResourceProviderConfig

	ffj_t_Call_PruneImages
)

var ffj_key_Call_Type = []byte("type")

var ffj_key_Call_GetMetrics = []byte("get_metrics")

var ffj_key_Call_SetLoggingLevel = []byte("set_logging_level")

var ffj_key_Call_ListFiles = []byte("list_files")

var ffj_key_Call_ReadFile = []byte("read_file")

var ffj_key_Call_GetContainers = []byte("get_containers")

var ffj_key_Call_LaunchNestedContainer = []byte("launch_nested_container")

var ffj_key_Call_WaitNestedContainer = []byte("wait_nested_container")

var ffj_key_Call_KillNestedContainer = []byte("kill_nested_container")

var ffj_key_Call_RemoveNestedContainer = []byte("remove_nested_container")

var ffj_key_Call_LaunchNestedContainerSession = []byte("launch_nested_container_session")

var ffj_key_Call_AttachContainerInput = []byte("attach_container_input")

var ffj_key_Call_AttachContainerOutput = []byte("attach_container_output")

var ffj_key_Call_LaunchContainer = []byte("launch_container")

var ffj_key_Call_WaitContainer = []byte("wait_container")

var ffj_key_Call_KillContainer = []byte("kill_container")

var ffj_key_Call_RemoveContainer = []byte("remove_container")

var ffj_key_Call_AddResourceProviderConfig = []byte("add_resource_provider_config")

var ffj_key_Call_UpdateResourceProviderConfig = []byte("update_resource_provider_config")

var ffj_key_Call_RemoveResourceProviderConfig = []byte("remove_resource_provider_config")

var ffj_key_Call_PruneImages = []byte("prune_images")

func (uj *Call) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Callbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Callno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Call_AttachContainerInput, kn) {
						currentKey = ffj_t_Call_AttachContainerInput
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_AttachContainerOutput, kn) {
						currentKey = ffj_t_Call_AttachContainerOutput
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_AddResourceProviderConfig, kn) {
						currentKey = ffj_t_Call_AddResourceProviderConfig
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_Call_GetMetrics, kn) {
						currentKey = ffj_t_Call_GetMetrics
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_GetContainers, kn) {
						currentKey = ffj_t_Call_GetContainers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'k':

					if bytes.Equal(ffj_key_Call_KillNestedContainer, kn) {
						currentKey = ffj_t_Call_KillNestedContainer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_KillContainer, kn) {
						currentKey = ffj_t_Call_KillContainer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Call_ListFiles, kn) {
						currentKey = ffj_t_Call_ListFiles
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchNestedContainer, kn) {
						currentKey = ffj_t_Call_LaunchNestedContainer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchNestedContainerSession, kn) {
						currentKey = ffj_t_Call_LaunchNestedContainerSession
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchContainer, kn) {
						currentKey = ffj_t_Call_LaunchContainer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Call_PruneImages, kn) {
						currentKey = ffj_t_Call_PruneImages
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Call_ReadFile, kn) {
						currentKey = ffj_t_Call_ReadFile
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_RemoveNestedContainer, kn) {
						currentKey = ffj_t_Call_RemoveNestedContainer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_RemoveContainer, kn) {
						currentKey = ffj_t_Call_RemoveContainer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_RemoveResourceProviderConfig, kn) {
						currentKey = ffj_t_Call_RemoveResourceProviderConfig
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Call_SetLoggingLevel, kn) {
						currentKey = ffj_t_Call_SetLoggingLevel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Call_Type, kn) {
						currentKey = ffj_t_Call_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_Call_UpdateResourceProviderConfig, kn) {
						currentKey = ffj_t_Call_UpdateResourceProviderConfig
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_Call_WaitNestedContainer, kn) {
						currentKey = ffj_t_Call_WaitNestedContainer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_WaitContainer, kn) {
						currentKey = ffj_t_Call_WaitContainer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Call_PruneImages, kn) {
					currentKey = ffj_t_Call_PruneImages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_RemoveResourceProviderConfig, kn) {
					currentKey = ffj_t_Call_RemoveResourceProviderConfig
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_UpdateResourceProviderConfig, kn) {
					currentKey = ffj_t_Call_UpdateResourceProviderConfig
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_AddResourceProviderConfig, kn) {
					currentKey = ffj_t_Call_AddResourceProviderConfig
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_RemoveContainer, kn) {
					currentKey = ffj_t_Call_RemoveContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_KillContainer, kn) {
					currentKey = ffj_t_Call_KillContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_WaitContainer, kn) {
					currentKey = ffj_t_Call_WaitContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_LaunchContainer, kn) {
					currentKey = ffj_t_Call_LaunchContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_AttachContainerOutput, kn) {
					currentKey = ffj_t_Call_AttachContainerOutput
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_AttachContainerInput, kn) {
					currentKey = ffj_t_Call_AttachContainerInput
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_LaunchNestedContainerSession, kn) {
					currentKey = ffj_t_Call_LaunchNestedContainerSession
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_RemoveNestedContainer, kn) {
					currentKey = ffj_t_Call_RemoveNestedContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_KillNestedContainer, kn) {
					currentKey = ffj_t_Call_KillNestedContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_WaitNestedContainer, kn) {
					currentKey = ffj_t_Call_WaitNestedContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_LaunchNestedContainer, kn) {
					currentKey = ffj_t_Call_LaunchNestedContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_GetContainers, kn) {
					currentKey = ffj_t_Call_GetContainers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_ReadFile, kn) {
					currentKey = ffj_t_Call_ReadFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_ListFiles, kn) {
					currentKey = ffj_t_Call_ListFiles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_SetLoggingLevel, kn) {
					currentKey = ffj_t_Call_SetLoggingLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_GetMetrics, kn) {
					currentKey = ffj_t_Call_GetMetrics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_Type, kn) {
					currentKey = ffj_t_Call_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Callno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_Type:
					goto handle_Type

				case ffj_t_Call_GetMetrics:
					goto handle_GetMetrics

				case ffj_t_Call_SetLoggingLevel:
					goto handle_SetLoggingLevel

				case ffj_t_Call_ListFiles:
					goto handle_ListFiles

				case ffj_t_Call_ReadFile:
					goto handle_ReadFile

				case ffj_t_Call_GetContainers:
					goto handle_GetContainers

				case ffj_t_Call_LaunchNestedContainer:
					goto handle_LaunchNestedContainer

				case ffj_t_Call_WaitNestedContainer:
					goto handle_WaitNestedContainer

				case ffj_t_Call_KillNestedContainer:
					goto handle_KillNestedContainer

				case ffj_t_Call_RemoveNestedContainer:
					goto handle_RemoveNestedContainer

				case ffj_t_Call_LaunchNestedContainerSession:
					goto handle_LaunchNestedContainerSession

				case ffj_t_Call_AttachContainerInput:
					goto handle_AttachContainerInput

				case ffj_t_Call_AttachContainerOutput:
					goto handle_AttachContainerOutput

				case ffj_t_Call_LaunchContainer:
					goto handle_LaunchContainer

				case ffj_t_Call_WaitContainer:
					goto handle_WaitContainer

				case ffj_t_Call_KillContainer:
					goto handle_KillContainer

				case ffj_t_Call_RemoveContainer:
					goto handle_RemoveContainer

				case ffj_t_Call_AddResourceProviderConfig:
					goto handle_AddResourceProviderConfig

				case ffj_t_Call_UpdateResourceProviderConfig:
					goto handle_UpdateResourceProviderConfig

				case ffj_t_Call_RemoveResourceProviderConfig:
					goto handle_RemoveResourceProviderConfig

				case ffj_t_Call_PruneImages:
					goto handle_PruneImages

				case ffj_t_Callno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=agent.Call_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetMetrics:

	/* handler: uj.GetMetrics type=agent.Call_GetMetrics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetMetrics = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetMetrics == nil {
			uj.GetMetrics = new(Call_GetMetrics)
		}

		err = uj.GetMetrics.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SetLoggingLevel:

	/* handler: uj.SetLoggingLevel type=agent.Call_SetLoggingLevel kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.SetLoggingLevel = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.SetLoggingLevel == nil {
			uj.SetLoggingLevel = new(Call_SetLoggingLevel)
		}

		err = uj.SetLoggingLevel.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ListFiles:

	/* handler: uj.ListFiles type=agent.Call_ListFiles kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ListFiles = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ListFiles == nil {
			uj.ListFiles = new(Call_ListFiles)
		}

		err = uj.ListFiles.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadFile:

	/* handler: uj.ReadFile type=agent.Call_ReadFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReadFile = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReadFile == nil {
			uj.ReadFile = new(Call_ReadFile)
		}

		err = uj.ReadFile.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetContainers:

	/* handler: uj.GetContainers type=agent.Call_GetContainers kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetContainers = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetContainers == nil {
			uj.GetContainers = new(Call_GetContainers)
		}

		err = uj.GetContainers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LaunchNestedContainer:

	/* handler: uj.LaunchNestedContainer type=agent.Call_LaunchNestedContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.LaunchNestedContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.LaunchNestedContainer == nil {
			uj.LaunchNestedContainer = new(Call_LaunchNestedContainer)
		}

		err = uj.LaunchNestedContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WaitNestedContainer:

	/* handler: uj.WaitNestedContainer type=agent.Call_WaitNestedContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.WaitNestedContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.WaitNestedContainer == nil {
			uj.WaitNestedContainer = new(Call_WaitNestedContainer)
		}

		err = uj.WaitNestedContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KillNestedContainer:

	/* handler: uj.KillNestedContainer type=agent.Call_KillNestedContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.KillNestedContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.KillNestedContainer == nil {
			uj.KillNestedContainer = new(Call_KillNestedContainer)
		}

		err = uj.KillNestedContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemoveNestedContainer:

	/* handler: uj.RemoveNestedContainer type=agent.Call_RemoveNestedContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.RemoveNestedContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.RemoveNestedContainer == nil {
			uj.RemoveNestedContainer = new(Call_RemoveNestedContainer)
		}

		err = uj.RemoveNestedContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LaunchNestedContainerSession:

	/* handler: uj.LaunchNestedContainerSession type=agent.Call_LaunchNestedContainerSession kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.LaunchNestedContainerSession = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.LaunchNestedContainerSession == nil {
			uj.LaunchNestedContainerSession = new(Call_LaunchNestedContainerSession)
		}

		err = uj.LaunchNestedContainerSession.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AttachContainerInput:

	/* handler: uj.AttachContainerInput type=agent.Call_AttachContainerInput kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AttachContainerInput = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AttachContainerInput == nil {
			uj.AttachContainerInput = new(Call_AttachContainerInput)
		}

		err = uj.AttachContainerInput.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AttachContainerOutput:

	/* handler: uj.AttachContainerOutput type=agent.Call_AttachContainerOutput kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AttachContainerOutput = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AttachContainerOutput == nil {
			uj.AttachContainerOutput = new(Call_AttachContainerOutput)
		}

		err = uj.AttachContainerOutput.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LaunchContainer:

	/* handler: uj.LaunchContainer type=agent.Call_LaunchContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.LaunchContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.LaunchContainer == nil {
			uj.LaunchContainer = new(Call_LaunchContainer)
		}

		err = uj.LaunchContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WaitContainer:

	/* handler: uj.WaitContainer type=agent.Call_WaitContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.WaitContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.WaitContainer == nil {
			uj.WaitContainer = new(Call_WaitContainer)
		}

		err = uj.WaitContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_KillContainer:

	/* handler: uj.KillContainer type=agent.Call_KillContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.KillContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.KillContainer == nil {
			uj.KillContainer = new(Call_KillContainer)
		}

		err = uj.KillContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemoveContainer:

	/* handler: uj.RemoveContainer type=agent.Call_RemoveContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.RemoveContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.RemoveContainer == nil {
			uj.RemoveContainer = new(Call_RemoveContainer)
		}

		err = uj.RemoveContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AddResourceProviderConfig:

	/* handler: uj.AddResourceProviderConfig type=agent.Call_AddResourceProviderConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AddResourceProviderConfig = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AddResourceProviderConfig == nil {
			uj.AddResourceProviderConfig = new(Call_AddResourceProviderConfig)
		}

		err = uj.AddResourceProviderConfig.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UpdateResourceProviderConfig:

	/* handler: uj.UpdateResourceProviderConfig type=agent.Call_UpdateResourceProviderConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.UpdateResourceProviderConfig = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.UpdateResourceProviderConfig == nil {
			uj.UpdateResourceProviderConfig = new(Call_UpdateResourceProviderConfig)
		}

		err = uj.UpdateResourceProviderConfig.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RemoveResourceProviderConfig:

	/* handler: uj.RemoveResourceProviderConfig type=agent.Call_RemoveResourceProviderConfig kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.RemoveResourceProviderConfig = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.RemoveResourceProviderConfig == nil {
			uj.RemoveResourceProviderConfig = new(Call_RemoveResourceProviderConfig)
		}

		err = uj.RemoveResourceProviderConfig.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PruneImages:

	/* handler: uj.PruneImages type=agent.Call_PruneImages kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.PruneImages = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.PruneImages == nil {
			uj.PruneImages = new(Call_PruneImages)
		}

		err = uj.PruneImages.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_AddResourceProviderConfig) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_AddResourceProviderConfig) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"info":`)

	{

		err = mj.Info.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_AddResourceProviderConfigbase = iota
	ffj_t_Call_AddResourceProviderConfigno_such_key

	ffj_t_Call_AddResourceProviderConfig_Info
)

var ffj_key_Call_AddResourceProviderConfig_Info = []byte("info")

func (uj *Call_AddResourceProviderConfig) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_AddResourceProviderConfig) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_AddResourceProviderConfigbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_AddResourceProviderConfigno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_Call_AddResourceProviderConfig_Info, kn) {
						currentKey = ffj_t_Call_AddResourceProviderConfig_Info
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_AddResourceProviderConfig_Info, kn) {
					currentKey = ffj_t_Call_AddResourceProviderConfig_Info
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_AddResourceProviderConfigno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_AddResourceProviderConfig_Info:
					goto handle_Info

				case ffj_t_Call_AddResourceProviderConfigno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Info:

	/* handler: uj.Info type=mesos.ResourceProviderInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Info.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_AttachContainerInput) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_AttachContainerInput) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)

	{

		obj, err = mj.Type.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if mj.ContainerID != nil {
		if true {
			buf.WriteString(`"container_id":`)

			{

				err = mj.ContainerID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ProcessIO != nil {
		if true {
			buf.WriteString(`"process_io":`)

			{

				err = mj.ProcessIO.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_AttachContainerInputbase = iota
	ffj_t_Call_AttachContainerInputno_such_key

	ffj_t_Call_AttachContainerInput_Type

	ffj_t_Call_AttachContainerInput_ContainerID

	ffj_t_Call_AttachContainerInput_ProcessIO
)

var ffj_key_Call_AttachContainerInput_Type = []byte("type")

var ffj_key_Call_AttachContainerInput_ContainerID = []byte("container_id")

var ffj_key_Call_AttachContainerInput_ProcessIO = []byte("process_io")

func (uj *Call_AttachContainerInput) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_AttachContainerInput) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_AttachContainerInputbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_AttachContainerInputno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_AttachContainerInput_ContainerID, kn) {
						currentKey = ffj_t_Call_AttachContainerInput_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Call_AttachContainerInput_ProcessIO, kn) {
						currentKey = ffj_t_Call_AttachContainerInput_ProcessIO
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Call_AttachContainerInput_Type, kn) {
						currentKey = ffj_t_Call_AttachContainerInput_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Call_AttachContainerInput_ProcessIO, kn) {
					currentKey = ffj_t_Call_AttachContainerInput_ProcessIO
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_AttachContainerInput_ContainerID, kn) {
					currentKey = ffj_t_Call_AttachContainerInput_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_AttachContainerInput_Type, kn) {
					currentKey = ffj_t_Call_AttachContainerInput_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_AttachContainerInputno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_AttachContainerInput_Type:
					goto handle_Type

				case ffj_t_Call_AttachContainerInput_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_AttachContainerInput_ProcessIO:
					goto handle_ProcessIO

				case ffj_t_Call_AttachContainerInputno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=agent.Call_AttachContainerInput_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ContainerID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ContainerID == nil {
			uj.ContainerID = new(mesos.ContainerID)
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProcessIO:

	/* handler: uj.ProcessIO type=agent.ProcessIO kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ProcessIO = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ProcessIO == nil {
			uj.ProcessIO = new(ProcessIO)
		}

		err = uj.ProcessIO.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_AttachContainerOutput) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_AttachContainerOutput) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_AttachContainerOutputbase = iota
	ffj_t_Call_AttachContainerOutputno_such_key

	ffj_t_Call_AttachContainerOutput_ContainerID
)

var ffj_key_Call_AttachContainerOutput_ContainerID = []byte("container_id")

func (uj *Call_AttachContainerOutput) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_AttachContainerOutput) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_AttachContainerOutputbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_AttachContainerOutputno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_AttachContainerOutput_ContainerID, kn) {
						currentKey = ffj_t_Call_AttachContainerOutput_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_Call_AttachContainerOutput_ContainerID, kn) {
					currentKey = ffj_t_Call_AttachContainerOutput_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_AttachContainerOutputno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_AttachContainerOutput_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_AttachContainerOutputno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_GetContainers) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_GetContainers) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.ShowNested != nil {
		if true {
			if *mj.ShowNested {
				buf.WriteString(`"show_nested":true`)
			} else {
				buf.WriteString(`"show_nested":false`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.ShowStandalone != nil {
		if true {
			if *mj.ShowStandalone {
				buf.WriteString(`"show_standalone":true`)
			} else {
				buf.WriteString(`"show_standalone":false`)
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_GetContainersbase = iota
	ffj_t_Call_GetContainersno_such_key

	ffj_t_Call_GetContainers_ShowNested

	ffj_t_Call_GetContainers_ShowStandalone
)

var ffj_key_Call_GetContainers_ShowNested = []byte("show_nested")

var ffj_key_Call_GetContainers_ShowStandalone = []byte("show_standalone")

func (uj *Call_GetContainers) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_GetContainers) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_GetContainersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_GetContainersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 's':

					if bytes.Equal(ffj_key_Call_GetContainers_ShowNested, kn) {
						currentKey = ffj_t_Call_GetContainers_ShowNested
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_GetContainers_ShowStandalone, kn) {
						currentKey = ffj_t_Call_GetContainers_ShowStandalone
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Call_GetContainers_ShowStandalone, kn) {
					currentKey = ffj_t_Call_GetContainers_ShowStandalone
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_GetContainers_ShowNested, kn) {
					currentKey = ffj_t_Call_GetContainers_ShowNested
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_GetContainersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_GetContainers_ShowNested:
					goto handle_ShowNested

				case ffj_t_Call_GetContainers_ShowStandalone:
					goto handle_ShowStandalone

				case ffj_t_Call_GetContainersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ShowNested:

	/* handler: uj.ShowNested type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.ShowNested = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.ShowNested = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShowStandalone:

	/* handler: uj.ShowStandalone type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

			uj.ShowStandalone = nil

		} else {
			tmpb := fs.Output.Bytes()

			var tval bool

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				tval = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				tval = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

			uj.ShowStandalone = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_GetMetrics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_GetMetrics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Timeout != nil {
		if true {
			buf.WriteString(`"timeout":`)

			{

				err = mj.Timeout.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_GetMetricsbase = iota
	ffj_t_Call_GetMetricsno_such_key

	ffj_t_Call_GetMetrics_Timeout
)

var ffj_key_Call_GetMetrics_Timeout = []byte("timeout")

func (uj *Call_GetMetrics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_GetMetrics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_GetMetricsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_GetMetricsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffj_key_Call_GetMetrics_Timeout, kn) {
						currentKey = ffj_t_Call_GetMetrics_Timeout
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_GetMetrics_Timeout, kn) {
					currentKey = ffj_t_Call_GetMetrics_Timeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_GetMetricsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_GetMetrics_Timeout:
					goto handle_Timeout

				case ffj_t_Call_GetMetricsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Timeout:

	/* handler: uj.Timeout type=mesos.DurationInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Timeout = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Timeout == nil {
			uj.Timeout = new(mesos.DurationInfo)
		}

		err = uj.Timeout.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_KillContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_KillContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Signal != nil {
		if true {
			buf.WriteString(`"signal":`)
			fflib.FormatBits2(buf, uint64(*mj.Signal), 10, *mj.Signal < 0)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_KillContainerbase = iota
	ffj_t_Call_KillContainerno_such_key

	ffj_t_Call_KillContainer_ContainerID

	ffj_t_Call_KillContainer_Signal
)

var ffj_key_Call_KillContainer_ContainerID = []byte("container_id")

var ffj_key_Call_KillContainer_Signal = []byte("signal")

func (uj *Call_KillContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_KillContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_KillContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_KillContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_KillContainer_ContainerID, kn) {
						currentKey = ffj_t_Call_KillContainer_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Call_KillContainer_Signal, kn) {
						currentKey = ffj_t_Call_KillContainer_Signal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Call_KillContainer_Signal, kn) {
					currentKey = ffj_t_Call_KillContainer_Signal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_KillContainer_ContainerID, kn) {
					currentKey = ffj_t_Call_KillContainer_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_KillContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_KillContainer_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_KillContainer_Signal:
					goto handle_Signal

				case ffj_t_Call_KillContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Signal:

	/* handler: uj.Signal type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Signal = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			uj.Signal = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_KillNestedContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_KillNestedContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Signal != nil {
		if true {
			buf.WriteString(`"signal":`)
			fflib.FormatBits2(buf, uint64(*mj.Signal), 10, *mj.Signal < 0)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_KillNestedContainerbase = iota
	ffj_t_Call_KillNestedContainerno_such_key

	ffj_t_Call_KillNestedContainer_ContainerID

	ffj_t_Call_KillNestedContainer_Signal
)

var ffj_key_Call_KillNestedContainer_ContainerID = []byte("container_id")

var ffj_key_Call_KillNestedContainer_Signal = []byte("signal")

func (uj *Call_KillNestedContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_KillNestedContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_KillNestedContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_KillNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_KillNestedContainer_ContainerID, kn) {
						currentKey = ffj_t_Call_KillNestedContainer_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Call_KillNestedContainer_Signal, kn) {
						currentKey = ffj_t_Call_KillNestedContainer_Signal
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Call_KillNestedContainer_Signal, kn) {
					currentKey = ffj_t_Call_KillNestedContainer_Signal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_KillNestedContainer_ContainerID, kn) {
					currentKey = ffj_t_Call_KillNestedContainer_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_KillNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_KillNestedContainer_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_KillNestedContainer_Signal:
					goto handle_Signal

				case ffj_t_Call_KillNestedContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Signal:

	/* handler: uj.Signal type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Signal = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			uj.Signal = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_LaunchContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_LaunchContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Command != nil {
		if true {
			buf.WriteString(`"command":`)

			{

				err = mj.Command.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"resources":`)
	if mj.Resources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Resources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.Container != nil {
		if true {
			buf.WriteString(`"container":`)

			{

				err = mj.Container.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_LaunchContainerbase = iota
	ffj_t_Call_LaunchContainerno_such_key

	ffj_t_Call_LaunchContainer_ContainerID

	ffj_t_Call_LaunchContainer_Command

	ffj_t_Call_LaunchContainer_Resources

	ffj_t_Call_LaunchContainer_Container
)

var ffj_key_Call_LaunchContainer_ContainerID = []byte("container_id")

var ffj_key_Call_LaunchContainer_Command = []byte("command")

var ffj_key_Call_LaunchContainer_Resources = []byte("resources")

var ffj_key_Call_LaunchContainer_Container = []byte("container")

func (uj *Call_LaunchContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_LaunchContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_LaunchContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_LaunchContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_LaunchContainer_ContainerID, kn) {
						currentKey = ffj_t_Call_LaunchContainer_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchContainer_Command, kn) {
						currentKey = ffj_t_Call_LaunchContainer_Command
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchContainer_Container, kn) {
						currentKey = ffj_t_Call_LaunchContainer_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Call_LaunchContainer_Resources, kn) {
						currentKey = ffj_t_Call_LaunchContainer_Resources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_LaunchContainer_Container, kn) {
					currentKey = ffj_t_Call_LaunchContainer_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_LaunchContainer_Resources, kn) {
					currentKey = ffj_t_Call_LaunchContainer_Resources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_LaunchContainer_Command, kn) {
					currentKey = ffj_t_Call_LaunchContainer_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_LaunchContainer_ContainerID, kn) {
					currentKey = ffj_t_Call_LaunchContainer_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_LaunchContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_LaunchContainer_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_LaunchContainer_Command:
					goto handle_Command

				case ffj_t_Call_LaunchContainer_Resources:
					goto handle_Resources

				case ffj_t_Call_LaunchContainer_Container:
					goto handle_Container

				case ffj_t_Call_LaunchContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Command = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Command == nil {
			uj.Command = new(mesos.CommandInfo)
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Resources:

	/* handler: uj.Resources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Resources = nil
		} else {

			uj.Resources = []mesos.Resource{}

			wantVal := true

			for {

				var tmp_uj__Resources mesos.Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Resources type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Resources.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Resources = append(uj.Resources, tmp_uj__Resources)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Container:

	/* handler: uj.Container type=mesos.ContainerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Container = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Container == nil {
			uj.Container = new(mesos.ContainerInfo)
		}

		err = uj.Container.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_LaunchNestedContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_LaunchNestedContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Command != nil {
		if true {
			buf.WriteString(`"command":`)

			{

				err = mj.Command.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Container != nil {
		if true {
			buf.WriteString(`"container":`)

			{

				err = mj.Container.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_LaunchNestedContainerbase = iota
	ffj_t_Call_LaunchNestedContainerno_such_key

	ffj_t_Call_LaunchNestedContainer_ContainerID

	ffj_t_Call_LaunchNestedContainer_Command

	ffj_t_Call_LaunchNestedContainer_Container
)

var ffj_key_Call_LaunchNestedContainer_ContainerID = []byte("container_id")

var ffj_key_Call_LaunchNestedContainer_Command = []byte("command")

var ffj_key_Call_LaunchNestedContainer_Container = []byte("container")

func (uj *Call_LaunchNestedContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_LaunchNestedContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_LaunchNestedContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_LaunchNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_LaunchNestedContainer_ContainerID, kn) {
						currentKey = ffj_t_Call_LaunchNestedContainer_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchNestedContainer_Command, kn) {
						currentKey = ffj_t_Call_LaunchNestedContainer_Command
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchNestedContainer_Container, kn) {
						currentKey = ffj_t_Call_LaunchNestedContainer_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_LaunchNestedContainer_Container, kn) {
					currentKey = ffj_t_Call_LaunchNestedContainer_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_LaunchNestedContainer_Command, kn) {
					currentKey = ffj_t_Call_LaunchNestedContainer_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_LaunchNestedContainer_ContainerID, kn) {
					currentKey = ffj_t_Call_LaunchNestedContainer_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_LaunchNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_LaunchNestedContainer_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_LaunchNestedContainer_Command:
					goto handle_Command

				case ffj_t_Call_LaunchNestedContainer_Container:
					goto handle_Container

				case ffj_t_Call_LaunchNestedContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Command = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Command == nil {
			uj.Command = new(mesos.CommandInfo)
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Container:

	/* handler: uj.Container type=mesos.ContainerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Container = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Container == nil {
			uj.Container = new(mesos.ContainerInfo)
		}

		err = uj.Container.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_LaunchNestedContainerSession) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_LaunchNestedContainerSession) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.Command != nil {
		if true {
			buf.WriteString(`"command":`)

			{

				err = mj.Command.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Container != nil {
		if true {
			buf.WriteString(`"container":`)

			{

				err = mj.Container.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_LaunchNestedContainerSessionbase = iota
	ffj_t_Call_LaunchNestedContainerSessionno_such_key

	ffj_t_Call_LaunchNestedContainerSession_ContainerID

	ffj_t_Call_LaunchNestedContainerSession_Command

	ffj_t_Call_LaunchNestedContainerSession_Container
)

var ffj_key_Call_LaunchNestedContainerSession_ContainerID = []byte("container_id")

var ffj_key_Call_LaunchNestedContainerSession_Command = []byte("command")

var ffj_key_Call_LaunchNestedContainerSession_Container = []byte("container")

func (uj *Call_LaunchNestedContainerSession) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_LaunchNestedContainerSession) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_LaunchNestedContainerSessionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_LaunchNestedContainerSessionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_LaunchNestedContainerSession_ContainerID, kn) {
						currentKey = ffj_t_Call_LaunchNestedContainerSession_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchNestedContainerSession_Command, kn) {
						currentKey = ffj_t_Call_LaunchNestedContainerSession_Command
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Call_LaunchNestedContainerSession_Container, kn) {
						currentKey = ffj_t_Call_LaunchNestedContainerSession_Container
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_LaunchNestedContainerSession_Container, kn) {
					currentKey = ffj_t_Call_LaunchNestedContainerSession_Container
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_LaunchNestedContainerSession_Command, kn) {
					currentKey = ffj_t_Call_LaunchNestedContainerSession_Command
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Call_LaunchNestedContainerSession_ContainerID, kn) {
					currentKey = ffj_t_Call_LaunchNestedContainerSession_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_LaunchNestedContainerSessionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_LaunchNestedContainerSession_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_LaunchNestedContainerSession_Command:
					goto handle_Command

				case ffj_t_Call_LaunchNestedContainerSession_Container:
					goto handle_Container

				case ffj_t_Call_LaunchNestedContainerSessionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: uj.Command type=mesos.CommandInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Command = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Command == nil {
			uj.Command = new(mesos.CommandInfo)
		}

		err = uj.Command.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Container:

	/* handler: uj.Container type=mesos.ContainerInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Container = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Container == nil {
			uj.Container = new(mesos.ContainerInfo)
		}

		err = uj.Container.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_ListFiles) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_ListFiles) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"path":`)
	fflib.WriteJsonString(buf, string(mj.Path))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_ListFilesbase = iota
	ffj_t_Call_ListFilesno_such_key

	ffj_t_Call_ListFiles_Path
)

var ffj_key_Call_ListFiles_Path = []byte("path")

func (uj *Call_ListFiles) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_ListFiles) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_ListFilesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_ListFilesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_Call_ListFiles_Path, kn) {
						currentKey = ffj_t_Call_ListFiles_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_ListFiles_Path, kn) {
					currentKey = ffj_t_Call_ListFiles_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_ListFilesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_ListFiles_Path:
					goto handle_Path

				case ffj_t_Call_ListFilesno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Path:

	/* handler: uj.Path type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Path = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_PruneImages) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_PruneImages) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"excluded_images":`)
	if mj.ExcludedImages != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ExcludedImages {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_PruneImagesbase = iota
	ffj_t_Call_PruneImagesno_such_key

	ffj_t_Call_PruneImages_ExcludedImages
)

var ffj_key_Call_PruneImages_ExcludedImages = []byte("excluded_images")

func (uj *Call_PruneImages) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_PruneImages) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_PruneImagesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_PruneImagesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_Call_PruneImages_ExcludedImages, kn) {
						currentKey = ffj_t_Call_PruneImages_ExcludedImages
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Call_PruneImages_ExcludedImages, kn) {
					currentKey = ffj_t_Call_PruneImages_ExcludedImages
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_PruneImagesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_PruneImages_ExcludedImages:
					goto handle_ExcludedImages

				case ffj_t_Call_PruneImagesno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExcludedImages:

	/* handler: uj.ExcludedImages type=[]mesos.Image kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ExcludedImages = nil
		} else {

			uj.ExcludedImages = []mesos.Image{}

			wantVal := true

			for {

				var tmp_uj__ExcludedImages mesos.Image

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__ExcludedImages type=mesos.Image kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__ExcludedImages.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.ExcludedImages = append(uj.ExcludedImages, tmp_uj__ExcludedImages)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_ReadFile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_ReadFile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "path":`)
	fflib.WriteJsonString(buf, string(mj.Path))
	buf.WriteString(`,"offset":`)
	fflib.FormatBits2(buf, uint64(mj.Offset), 10, false)
	buf.WriteByte(',')
	if mj.Length != nil {
		if true {
			buf.WriteString(`"length":`)
			fflib.FormatBits2(buf, uint64(*mj.Length), 10, false)
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_ReadFilebase = iota
	ffj_t_Call_ReadFileno_such_key

	ffj_t_Call_ReadFile_Path

	ffj_t_Call_ReadFile_Offset

	ffj_t_Call_ReadFile_Length
)

var ffj_key_Call_ReadFile_Path = []byte("path")

var ffj_key_Call_ReadFile_Offset = []byte("offset")

var ffj_key_Call_ReadFile_Length = []byte("length")

func (uj *Call_ReadFile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_ReadFile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_ReadFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_ReadFileno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_Call_ReadFile_Length, kn) {
						currentKey = ffj_t_Call_ReadFile_Length
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_Call_ReadFile_Offset, kn) {
						currentKey = ffj_t_Call_ReadFile_Offset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Call_ReadFile_Path, kn) {
						currentKey = ffj_t_Call_ReadFile_Path
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_ReadFile_Length, kn) {
					currentKey = ffj_t_Call_ReadFile_Length
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Call_ReadFile_Offset, kn) {
					currentKey = ffj_t_Call_ReadFile_Offset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_ReadFile_Path, kn) {
					currentKey = ffj_t_Call_ReadFile_Path
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_ReadFileno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_ReadFile_Path:
					goto handle_Path

				case ffj_t_Call_ReadFile_Offset:
					goto handle_Offset

				case ffj_t_Call_ReadFile_Length:
					goto handle_Length

				case ffj_t_Call_ReadFileno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Path:

	/* handler: uj.Path type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Path = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Offset:

	/* handler: uj.Offset type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Offset = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Length:

	/* handler: uj.Length type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.Length = nil

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := uint64(tval)
			uj.Length = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_RemoveContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_RemoveContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_RemoveContainerbase = iota
	ffj_t_Call_RemoveContainerno_such_key

	ffj_t_Call_RemoveContainer_ContainerID
)

var ffj_key_Call_RemoveContainer_ContainerID = []byte("container_id")

func (uj *Call_RemoveContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_RemoveContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_RemoveContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_RemoveContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_RemoveContainer_ContainerID, kn) {
						currentKey = ffj_t_Call_RemoveContainer_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_Call_RemoveContainer_ContainerID, kn) {
					currentKey = ffj_t_Call_RemoveContainer_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_RemoveContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_RemoveContainer_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_RemoveContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_RemoveNestedContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_RemoveNestedContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_RemoveNestedContainerbase = iota
	ffj_t_Call_RemoveNestedContainerno_such_key

	ffj_t_Call_RemoveNestedContainer_ContainerID
)

var ffj_key_Call_RemoveNestedContainer_ContainerID = []byte("container_id")

func (uj *Call_RemoveNestedContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_RemoveNestedContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_RemoveNestedContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_RemoveNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_RemoveNestedContainer_ContainerID, kn) {
						currentKey = ffj_t_Call_RemoveNestedContainer_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_Call_RemoveNestedContainer_ContainerID, kn) {
					currentKey = ffj_t_Call_RemoveNestedContainer_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_RemoveNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_RemoveNestedContainer_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_RemoveNestedContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_RemoveResourceProviderConfig) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_RemoveResourceProviderConfig) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_RemoveResourceProviderConfigbase = iota
	ffj_t_Call_RemoveResourceProviderConfigno_such_key

	ffj_t_Call_RemoveResourceProviderConfig_Type

	ffj_t_Call_RemoveResourceProviderConfig_Name
)

var ffj_key_Call_RemoveResourceProviderConfig_Type = []byte("type")

var ffj_key_Call_RemoveResourceProviderConfig_Name = []byte("name")

func (uj *Call_RemoveResourceProviderConfig) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_RemoveResourceProviderConfig) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_RemoveResourceProviderConfigbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_RemoveResourceProviderConfigno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'n':

					if bytes.Equal(ffj_key_Call_RemoveResourceProviderConfig_Name, kn) {
						currentKey = ffj_t_Call_RemoveResourceProviderConfig_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Call_RemoveResourceProviderConfig_Type, kn) {
						currentKey = ffj_t_Call_RemoveResourceProviderConfig_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_RemoveResourceProviderConfig_Name, kn) {
					currentKey = ffj_t_Call_RemoveResourceProviderConfig_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_RemoveResourceProviderConfig_Type, kn) {
					currentKey = ffj_t_Call_RemoveResourceProviderConfig_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_RemoveResourceProviderConfigno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_RemoveResourceProviderConfig_Type:
					goto handle_Type

				case ffj_t_Call_RemoveResourceProviderConfig_Name:
					goto handle_Name

				case ffj_t_Call_RemoveResourceProviderConfigno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_SetLoggingLevel) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_SetLoggingLevel) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"level":`)
	fflib.FormatBits2(buf, uint64(mj.Level), 10, false)
	buf.WriteString(`,"duration":`)

	{

		err = mj.Duration.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_SetLoggingLevelbase = iota
	ffj_t_Call_SetLoggingLevelno_such_key

	ffj_t_Call_SetLoggingLevel_Level

	ffj_t_Call_SetLoggingLevel_Duration
)

var ffj_key_Call_SetLoggingLevel_Level = []byte("level")

var ffj_key_Call_SetLoggingLevel_Duration = []byte("duration")

func (uj *Call_SetLoggingLevel) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_SetLoggingLevel) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_SetLoggingLevelbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_SetLoggingLevelno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Call_SetLoggingLevel_Duration, kn) {
						currentKey = ffj_t_Call_SetLoggingLevel_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Call_SetLoggingLevel_Level, kn) {
						currentKey = ffj_t_Call_SetLoggingLevel_Level
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_SetLoggingLevel_Duration, kn) {
					currentKey = ffj_t_Call_SetLoggingLevel_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_SetLoggingLevel_Level, kn) {
					currentKey = ffj_t_Call_SetLoggingLevel_Level
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_SetLoggingLevelno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_SetLoggingLevel_Level:
					goto handle_Level

				case ffj_t_Call_SetLoggingLevel_Duration:
					goto handle_Duration

				case ffj_t_Call_SetLoggingLevelno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Level:

	/* handler: uj.Level type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Level = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=mesos.DurationInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Duration.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_UpdateResourceProviderConfig) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_UpdateResourceProviderConfig) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"info":`)

	{

		err = mj.Info.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_UpdateResourceProviderConfigbase = iota
	ffj_t_Call_UpdateResourceProviderConfigno_such_key

	ffj_t_Call_UpdateResourceProviderConfig_Info
)

var ffj_key_Call_UpdateResourceProviderConfig_Info = []byte("info")

func (uj *Call_UpdateResourceProviderConfig) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_UpdateResourceProviderConfig) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_UpdateResourceProviderConfigbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_UpdateResourceProviderConfigno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_Call_UpdateResourceProviderConfig_Info, kn) {
						currentKey = ffj_t_Call_UpdateResourceProviderConfig_Info
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Call_UpdateResourceProviderConfig_Info, kn) {
					currentKey = ffj_t_Call_UpdateResourceProviderConfig_Info
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_UpdateResourceProviderConfigno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_UpdateResourceProviderConfig_Info:
					goto handle_Info

				case ffj_t_Call_UpdateResourceProviderConfigno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Info:

	/* handler: uj.Info type=mesos.ResourceProviderInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Info.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_WaitContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_WaitContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_WaitContainerbase = iota
	ffj_t_Call_WaitContainerno_such_key

	ffj_t_Call_WaitContainer_ContainerID
)

var ffj_key_Call_WaitContainer_ContainerID = []byte("container_id")

func (uj *Call_WaitContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_WaitContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_WaitContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_WaitContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_WaitContainer_ContainerID, kn) {
						currentKey = ffj_t_Call_WaitContainer_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_Call_WaitContainer_ContainerID, kn) {
					currentKey = ffj_t_Call_WaitContainer_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_WaitContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_WaitContainer_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_WaitContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Call_WaitNestedContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Call_WaitNestedContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Call_WaitNestedContainerbase = iota
	ffj_t_Call_WaitNestedContainerno_such_key

	ffj_t_Call_WaitNestedContainer_ContainerID
)

var ffj_key_Call_WaitNestedContainer_ContainerID = []byte("container_id")

func (uj *Call_WaitNestedContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Call_WaitNestedContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Call_WaitNestedContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Call_WaitNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Call_WaitNestedContainer_ContainerID, kn) {
						currentKey = ffj_t_Call_WaitNestedContainer_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_Call_WaitNestedContainer_ContainerID, kn) {
					currentKey = ffj_t_Call_WaitNestedContainer_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Call_WaitNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Call_WaitNestedContainer_ContainerID:
					goto handle_ContainerID

				case ffj_t_Call_WaitNestedContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProcessIO) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProcessIO) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)

	{

		obj, err = mj.Type.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if mj.Data != nil {
		if true {
			buf.WriteString(`"data":`)

			{

				err = mj.Data.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Control != nil {
		if true {
			buf.WriteString(`"control":`)

			{

				err = mj.Control.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProcessIObase = iota
	ffj_t_ProcessIOno_such_key

	ffj_t_ProcessIO_Type

	ffj_t_ProcessIO_Data

	ffj_t_ProcessIO_Control
)

var ffj_key_ProcessIO_Type = []byte("type")

var ffj_key_ProcessIO_Data = []byte("data")

var ffj_key_ProcessIO_Control = []byte("control")

func (uj *ProcessIO) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProcessIO) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProcessIObase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProcessIOno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_ProcessIO_Control, kn) {
						currentKey = ffj_t_ProcessIO_Control
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_ProcessIO_Data, kn) {
						currentKey = ffj_t_ProcessIO_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ProcessIO_Type, kn) {
						currentKey = ffj_t_ProcessIO_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProcessIO_Control, kn) {
					currentKey = ffj_t_ProcessIO_Control
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProcessIO_Data, kn) {
					currentKey = ffj_t_ProcessIO_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProcessIO_Type, kn) {
					currentKey = ffj_t_ProcessIO_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProcessIOno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProcessIO_Type:
					goto handle_Type

				case ffj_t_ProcessIO_Data:
					goto handle_Data

				case ffj_t_ProcessIO_Control:
					goto handle_Control

				case ffj_t_ProcessIOno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=agent.ProcessIO_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=agent.ProcessIO_Data kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Data = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Data == nil {
			uj.Data = new(ProcessIO_Data)
		}

		err = uj.Data.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Control:

	/* handler: uj.Control type=agent.ProcessIO_Control kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Control = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Control == nil {
			uj.Control = new(ProcessIO_Control)
		}

		err = uj.Control.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProcessIO_Control) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProcessIO_Control) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)

	{

		obj, err = mj.Type.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if mj.TTYInfo != nil {
		if true {
			buf.WriteString(`"tty_info":`)

			{

				err = mj.TTYInfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Heartbeat != nil {
		if true {
			buf.WriteString(`"heartbeat":`)

			{

				err = mj.Heartbeat.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProcessIO_Controlbase = iota
	ffj_t_ProcessIO_Controlno_such_key

	ffj_t_ProcessIO_Control_Type

	ffj_t_ProcessIO_Control_TTYInfo

	ffj_t_ProcessIO_Control_Heartbeat
)

var ffj_key_ProcessIO_Control_Type = []byte("type")

var ffj_key_ProcessIO_Control_TTYInfo = []byte("tty_info")

var ffj_key_ProcessIO_Control_Heartbeat = []byte("heartbeat")

func (uj *ProcessIO_Control) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProcessIO_Control) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProcessIO_Controlbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProcessIO_Controlno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_ProcessIO_Control_Heartbeat, kn) {
						currentKey = ffj_t_ProcessIO_Control_Heartbeat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ProcessIO_Control_Type, kn) {
						currentKey = ffj_t_ProcessIO_Control_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_ProcessIO_Control_TTYInfo, kn) {
						currentKey = ffj_t_ProcessIO_Control_TTYInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProcessIO_Control_Heartbeat, kn) {
					currentKey = ffj_t_ProcessIO_Control_Heartbeat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ProcessIO_Control_TTYInfo, kn) {
					currentKey = ffj_t_ProcessIO_Control_TTYInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProcessIO_Control_Type, kn) {
					currentKey = ffj_t_ProcessIO_Control_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProcessIO_Controlno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProcessIO_Control_Type:
					goto handle_Type

				case ffj_t_ProcessIO_Control_TTYInfo:
					goto handle_TTYInfo

				case ffj_t_ProcessIO_Control_Heartbeat:
					goto handle_Heartbeat

				case ffj_t_ProcessIO_Controlno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=agent.ProcessIO_Control_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TTYInfo:

	/* handler: uj.TTYInfo type=mesos.TTYInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.TTYInfo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.TTYInfo == nil {
			uj.TTYInfo = new(mesos.TTYInfo)
		}

		err = uj.TTYInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Heartbeat:

	/* handler: uj.Heartbeat type=agent.ProcessIO_Control_Heartbeat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Heartbeat = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Heartbeat == nil {
			uj.Heartbeat = new(ProcessIO_Control_Heartbeat)
		}

		err = uj.Heartbeat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProcessIO_Control_Heartbeat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProcessIO_Control_Heartbeat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.Interval != nil {
		if true {
			buf.WriteString(`"interval":`)

			{

				err = mj.Interval.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProcessIO_Control_Heartbeatbase = iota
	ffj_t_ProcessIO_Control_Heartbeatno_such_key

	ffj_t_ProcessIO_Control_Heartbeat_Interval
)

var ffj_key_ProcessIO_Control_Heartbeat_Interval = []byte("interval")

func (uj *ProcessIO_Control_Heartbeat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProcessIO_Control_Heartbeat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProcessIO_Control_Heartbeatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProcessIO_Control_Heartbeatno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_ProcessIO_Control_Heartbeat_Interval, kn) {
						currentKey = ffj_t_ProcessIO_Control_Heartbeat_Interval
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProcessIO_Control_Heartbeat_Interval, kn) {
					currentKey = ffj_t_ProcessIO_Control_Heartbeat_Interval
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProcessIO_Control_Heartbeatno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProcessIO_Control_Heartbeat_Interval:
					goto handle_Interval

				case ffj_t_ProcessIO_Control_Heartbeatno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Interval:

	/* handler: uj.Interval type=mesos.DurationInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Interval = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Interval == nil {
			uj.Interval = new(mesos.DurationInfo)
		}

		err = uj.Interval.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ProcessIO_Data) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ProcessIO_Data) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)

	{

		obj, err = mj.Type.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		if mj.Data != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ProcessIO_Database = iota
	ffj_t_ProcessIO_Datano_such_key

	ffj_t_ProcessIO_Data_Type

	ffj_t_ProcessIO_Data_Data
)

var ffj_key_ProcessIO_Data_Type = []byte("type")

var ffj_key_ProcessIO_Data_Data = []byte("data")

func (uj *ProcessIO_Data) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ProcessIO_Data) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ProcessIO_Database
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ProcessIO_Datano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_ProcessIO_Data_Data, kn) {
						currentKey = ffj_t_ProcessIO_Data_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_ProcessIO_Data_Type, kn) {
						currentKey = ffj_t_ProcessIO_Data_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProcessIO_Data_Data, kn) {
					currentKey = ffj_t_ProcessIO_Data_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ProcessIO_Data_Type, kn) {
					currentKey = ffj_t_ProcessIO_Data_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ProcessIO_Datano_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ProcessIO_Data_Type:
					goto handle_Type

				case ffj_t_ProcessIO_Data_Data:
					goto handle_Data

				case ffj_t_ProcessIO_Datano_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=agent.ProcessIO_Data_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)

	{

		obj, err = mj.Type.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteByte(',')
	if mj.GetHealth != nil {
		if true {
			buf.WriteString(`"get_health":`)

			{

				err = mj.GetHealth.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetFlags != nil {
		if true {
			buf.WriteString(`"get_flags":`)

			{

				err = mj.GetFlags.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetVersion != nil {
		if true {
			buf.WriteString(`"get_version":`)

			{

				err = mj.GetVersion.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetMetrics != nil {
		if true {
			buf.WriteString(`"get_metrics":`)

			{

				err = mj.GetMetrics.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetLoggingLevel != nil {
		if true {
			buf.WriteString(`"get_logging_level":`)

			{

				err = mj.GetLoggingLevel.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ListFiles != nil {
		if true {
			buf.WriteString(`"list_files":`)

			{

				err = mj.ListFiles.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ReadFile != nil {
		if true {
			buf.WriteString(`"read_file":`)

			{

				err = mj.ReadFile.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetState != nil {
		if true {
			buf.WriteString(`"get_state":`)

			{

				err = mj.GetState.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetContainers != nil {
		if true {
			buf.WriteString(`"get_containers":`)

			{

				err = mj.GetContainers.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetFrameworks != nil {
		if true {
			buf.WriteString(`"get_frameworks":`)

			{

				err = mj.GetFrameworks.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetExecutors != nil {
		if true {
			buf.WriteString(`"get_executors":`)

			{

				err = mj.GetExecutors.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetOperations != nil {
		if true {
			buf.WriteString(`"get_operations":`)

			{

				err = mj.GetOperations.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetTasks != nil {
		if true {
			buf.WriteString(`"get_tasks":`)

			{

				err = mj.GetTasks.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetAgent != nil {
		if true {
			buf.WriteString(`"get_agent":`)

			{

				err = mj.GetAgent.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetResourceProviders != nil {
		if true {
			buf.WriteString(`"get_resource_providers":`)

			{

				err = mj.GetResourceProviders.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.WaitNestedContainer != nil {
		if true {
			buf.WriteString(`"wait_nested_container":`)

			{

				err = mj.WaitNestedContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.WaitContainer != nil {
		if true {
			buf.WriteString(`"wait_container":`)

			{

				err = mj.WaitContainer.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Responsebase = iota
	ffj_t_Responseno_such_key

	ffj_t_Response_Type

	ffj_t_Response_GetHealth

	ffj_t_Response_GetFlags

	ffj_t_Response_GetVersion

	ffj_t_Response_GetMetrics

	ffj_t_Response_GetLoggingLevel

	ffj_t_Response_ListFiles

	ffj_t_Response_ReadFile

	ffj_t_Response_GetState

	ffj_t_Response_GetContainers

	ffj_t_Response_GetFrameworks

	ffj_t_Response_GetExecutors

	ffj_t_Response_GetOperations

	ffj_t_Response_GetTasks

	ffj_t_Response_GetAgent

	ffj_t_Response_GetResourceProviders

	ffj_t_Response_WaitNestedContainer

	ffj_t_Response_WaitContainer
)

var ffj_key_Response_Type = []byte("type")

var ffj_key_Response_GetHealth = []byte("get_health")

var ffj_key_Response_GetFlags = []byte("get_flags")

var ffj_key_Response_GetVersion = []byte("get_version")

var ffj_key_Response_GetMetrics = []byte("get_metrics")

var ffj_key_Response_GetLoggingLevel = []byte("get_logging_level")

var ffj_key_Response_ListFiles = []byte("list_files")

var ffj_key_Response_ReadFile = []byte("read_file")

var ffj_key_Response_GetState = []byte("get_state")

var ffj_key_Response_GetContainers = []byte("get_containers")

var ffj_key_Response_GetFrameworks = []byte("get_frameworks")

var ffj_key_Response_GetExecutors = []byte("get_executors")

var ffj_key_Response_GetOperations = []byte("get_operations")

var ffj_key_Response_GetTasks = []byte("get_tasks")

var ffj_key_Response_GetAgent = []byte("get_agent")

var ffj_key_Response_GetResourceProviders = []byte("get_resource_providers")

var ffj_key_Response_WaitNestedContainer = []byte("wait_nested_container")

var ffj_key_Response_WaitContainer = []byte("wait_container")

func (uj *Response) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Responsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Responseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_Response_GetHealth, kn) {
						currentKey = ffj_t_Response_GetHealth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetFlags, kn) {
						currentKey = ffj_t_Response_GetFlags
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetVersion, kn) {
						currentKey = ffj_t_Response_GetVersion
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetMetrics, kn) {
						currentKey = ffj_t_Response_GetMetrics
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetLoggingLevel, kn) {
						currentKey = ffj_t_Response_GetLoggingLevel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetState, kn) {
						currentKey = ffj_t_Response_GetState
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetContainers, kn) {
						currentKey = ffj_t_Response_GetContainers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetFrameworks, kn) {
						currentKey = ffj_t_Response_GetFrameworks
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetExecutors, kn) {
						currentKey = ffj_t_Response_GetExecutors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetOperations, kn) {
						currentKey = ffj_t_Response_GetOperations
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetTasks, kn) {
						currentKey = ffj_t_Response_GetTasks
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetAgent, kn) {
						currentKey = ffj_t_Response_GetAgent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetResourceProviders, kn) {
						currentKey = ffj_t_Response_GetResourceProviders
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Response_ListFiles, kn) {
						currentKey = ffj_t_Response_ListFiles
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Response_ReadFile, kn) {
						currentKey = ffj_t_Response_ReadFile
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Response_Type, kn) {
						currentKey = ffj_t_Response_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_Response_WaitNestedContainer, kn) {
						currentKey = ffj_t_Response_WaitNestedContainer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_WaitContainer, kn) {
						currentKey = ffj_t_Response_WaitContainer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_Response_WaitContainer, kn) {
					currentKey = ffj_t_Response_WaitContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitNestedContainer, kn) {
					currentKey = ffj_t_Response_WaitNestedContainer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetResourceProviders, kn) {
					currentKey = ffj_t_Response_GetResourceProviders
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Response_GetAgent, kn) {
					currentKey = ffj_t_Response_GetAgent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetTasks, kn) {
					currentKey = ffj_t_Response_GetTasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetOperations, kn) {
					currentKey = ffj_t_Response_GetOperations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetExecutors, kn) {
					currentKey = ffj_t_Response_GetExecutors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetFrameworks, kn) {
					currentKey = ffj_t_Response_GetFrameworks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetContainers, kn) {
					currentKey = ffj_t_Response_GetContainers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetState, kn) {
					currentKey = ffj_t_Response_GetState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Response_ReadFile, kn) {
					currentKey = ffj_t_Response_ReadFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_ListFiles, kn) {
					currentKey = ffj_t_Response_ListFiles
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Response_GetLoggingLevel, kn) {
					currentKey = ffj_t_Response_GetLoggingLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetMetrics, kn) {
					currentKey = ffj_t_Response_GetMetrics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetVersion, kn) {
					currentKey = ffj_t_Response_GetVersion
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetFlags, kn) {
					currentKey = ffj_t_Response_GetFlags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Response_GetHealth, kn) {
					currentKey = ffj_t_Response_GetHealth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Response_Type, kn) {
					currentKey = ffj_t_Response_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Responseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_Type:
					goto handle_Type

				case ffj_t_Response_GetHealth:
					goto handle_GetHealth

				case ffj_t_Response_GetFlags:
					goto handle_GetFlags

				case ffj_t_Response_GetVersion:
					goto handle_GetVersion

				case ffj_t_Response_GetMetrics:
					goto handle_GetMetrics

				case ffj_t_Response_GetLoggingLevel:
					goto handle_GetLoggingLevel

				case ffj_t_Response_ListFiles:
					goto handle_ListFiles

				case ffj_t_Response_ReadFile:
					goto handle_ReadFile

				case ffj_t_Response_GetState:
					goto handle_GetState

				case ffj_t_Response_GetContainers:
					goto handle_GetContainers

				case ffj_t_Response_GetFrameworks:
					goto handle_GetFrameworks

				case ffj_t_Response_GetExecutors:
					goto handle_GetExecutors

				case ffj_t_Response_GetOperations:
					goto handle_GetOperations

				case ffj_t_Response_GetTasks:
					goto handle_GetTasks

				case ffj_t_Response_GetAgent:
					goto handle_GetAgent

				case ffj_t_Response_GetResourceProviders:
					goto handle_GetResourceProviders

				case ffj_t_Response_WaitNestedContainer:
					goto handle_WaitNestedContainer

				case ffj_t_Response_WaitContainer:
					goto handle_WaitContainer

				case ffj_t_Responseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=agent.Response_Type kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Type.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetHealth:

	/* handler: uj.GetHealth type=agent.Response_GetHealth kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetHealth = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetHealth == nil {
			uj.GetHealth = new(Response_GetHealth)
		}

		err = uj.GetHealth.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetFlags:

	/* handler: uj.GetFlags type=agent.Response_GetFlags kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetFlags = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetFlags == nil {
			uj.GetFlags = new(Response_GetFlags)
		}

		err = uj.GetFlags.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetVersion:

	/* handler: uj.GetVersion type=agent.Response_GetVersion kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetVersion = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetVersion == nil {
			uj.GetVersion = new(Response_GetVersion)
		}

		err = uj.GetVersion.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetMetrics:

	/* handler: uj.GetMetrics type=agent.Response_GetMetrics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetMetrics = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetMetrics == nil {
			uj.GetMetrics = new(Response_GetMetrics)
		}

		err = uj.GetMetrics.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetLoggingLevel:

	/* handler: uj.GetLoggingLevel type=agent.Response_GetLoggingLevel kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetLoggingLevel = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetLoggingLevel == nil {
			uj.GetLoggingLevel = new(Response_GetLoggingLevel)
		}

		err = uj.GetLoggingLevel.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ListFiles:

	/* handler: uj.ListFiles type=agent.Response_ListFiles kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ListFiles = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ListFiles == nil {
			uj.ListFiles = new(Response_ListFiles)
		}

		err = uj.ListFiles.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReadFile:

	/* handler: uj.ReadFile type=agent.Response_ReadFile kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReadFile = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReadFile == nil {
			uj.ReadFile = new(Response_ReadFile)
		}

		err = uj.ReadFile.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetState:

	/* handler: uj.GetState type=agent.Response_GetState kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetState = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetState == nil {
			uj.GetState = new(Response_GetState)
		}

		err = uj.GetState.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetContainers:

	/* handler: uj.GetContainers type=agent.Response_GetContainers kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetContainers = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetContainers == nil {
			uj.GetContainers = new(Response_GetContainers)
		}

		err = uj.GetContainers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetFrameworks:

	/* handler: uj.GetFrameworks type=agent.Response_GetFrameworks kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetFrameworks = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetFrameworks == nil {
			uj.GetFrameworks = new(Response_GetFrameworks)
		}

		err = uj.GetFrameworks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetExecutors:

	/* handler: uj.GetExecutors type=agent.Response_GetExecutors kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetExecutors = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetExecutors == nil {
			uj.GetExecutors = new(Response_GetExecutors)
		}

		err = uj.GetExecutors.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetOperations:

	/* handler: uj.GetOperations type=agent.Response_GetOperations kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetOperations = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetOperations == nil {
			uj.GetOperations = new(Response_GetOperations)
		}

		err = uj.GetOperations.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetTasks:

	/* handler: uj.GetTasks type=agent.Response_GetTasks kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetTasks = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetTasks == nil {
			uj.GetTasks = new(Response_GetTasks)
		}

		err = uj.GetTasks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetAgent:

	/* handler: uj.GetAgent type=agent.Response_GetAgent kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetAgent = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetAgent == nil {
			uj.GetAgent = new(Response_GetAgent)
		}

		err = uj.GetAgent.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetResourceProviders:

	/* handler: uj.GetResourceProviders type=agent.Response_GetResourceProviders kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetResourceProviders = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetResourceProviders == nil {
			uj.GetResourceProviders = new(Response_GetResourceProviders)
		}

		err = uj.GetResourceProviders.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WaitNestedContainer:

	/* handler: uj.WaitNestedContainer type=agent.Response_WaitNestedContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.WaitNestedContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.WaitNestedContainer == nil {
			uj.WaitNestedContainer = new(Response_WaitNestedContainer)
		}

		err = uj.WaitNestedContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WaitContainer:

	/* handler: uj.WaitContainer type=agent.Response_WaitContainer kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.WaitContainer = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.WaitContainer == nil {
			uj.WaitContainer = new(Response_WaitContainer)
		}

		err = uj.WaitContainer.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetAgent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetAgent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.AgentInfo != nil {
		if true {
			buf.WriteString(`"agent_info":`)

			{

				err = mj.AgentInfo.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetAgentbase = iota
	ffj_t_Response_GetAgentno_such_key

	ffj_t_Response_GetAgent_AgentInfo
)

var ffj_key_Response_GetAgent_AgentInfo = []byte("agent_info")

func (uj *Response_GetAgent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetAgent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetAgentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetAgentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Response_GetAgent_AgentInfo, kn) {
						currentKey = ffj_t_Response_GetAgent_AgentInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_Response_GetAgent_AgentInfo, kn) {
					currentKey = ffj_t_Response_GetAgent_AgentInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetAgentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetAgent_AgentInfo:
					goto handle_AgentInfo

				case ffj_t_Response_GetAgentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AgentInfo:

	/* handler: uj.AgentInfo type=mesos.AgentInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.AgentInfo = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.AgentInfo == nil {
			uj.AgentInfo = new(mesos.AgentInfo)
		}

		err = uj.AgentInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetContainers) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetContainers) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"containers":`)
	if mj.Containers != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Containers {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetContainersbase = iota
	ffj_t_Response_GetContainersno_such_key

	ffj_t_Response_GetContainers_Containers
)

var ffj_key_Response_GetContainers_Containers = []byte("containers")

func (uj *Response_GetContainers) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetContainers) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetContainersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetContainersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Response_GetContainers_Containers, kn) {
						currentKey = ffj_t_Response_GetContainers_Containers
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetContainers_Containers, kn) {
					currentKey = ffj_t_Response_GetContainers_Containers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetContainersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetContainers_Containers:
					goto handle_Containers

				case ffj_t_Response_GetContainersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Containers:

	/* handler: uj.Containers type=[]agent.Response_GetContainers_Container kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Containers = nil
		} else {

			uj.Containers = []Response_GetContainers_Container{}

			wantVal := true

			for {

				var tmp_uj__Containers Response_GetContainers_Container

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Containers type=agent.Response_GetContainers_Container kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Containers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Containers = append(uj.Containers, tmp_uj__Containers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetContainers_Container) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetContainers_Container) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.FrameworkID != nil {
		if true {
			buf.WriteString(`"framework_id":`)

			{

				err = mj.FrameworkID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ExecutorID != nil {
		if true {
			buf.WriteString(`"executor_id":`)

			{

				err = mj.ExecutorID.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ExecutorName != nil {
		if true {
			buf.WriteString(`"executor_name":`)
			fflib.WriteJsonString(buf, string(*mj.ExecutorName))
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"container_id":`)

	{

		err = mj.ContainerID.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if mj.ContainerStatus != nil {
		if true {
			buf.WriteString(`"container_status":`)

			{

				err = mj.ContainerStatus.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ResourceStatistics != nil {
		if true {
			buf.WriteString(`"resource_statistics":`)

			{

				err = mj.ResourceStatistics.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetContainers_Containerbase = iota
	ffj_t_Response_GetContainers_Containerno_such_key

	ffj_t_Response_GetContainers_Container_FrameworkID

	ffj_t_Response_GetContainers_Container_ExecutorID

	ffj_t_Response_GetContainers_Container_ExecutorName

	ffj_t_Response_GetContainers_Container_ContainerID

	ffj_t_Response_GetContainers_Container_ContainerStatus

	ffj_t_Response_GetContainers_Container_ResourceStatistics
)

var ffj_key_Response_GetContainers_Container_FrameworkID = []byte("framework_id")

var ffj_key_Response_GetContainers_Container_ExecutorID = []byte("executor_id")

var ffj_key_Response_GetContainers_Container_ExecutorName = []byte("executor_name")

var ffj_key_Response_GetContainers_Container_ContainerID = []byte("container_id")

var ffj_key_Response_GetContainers_Container_ContainerStatus = []byte("container_status")

var ffj_key_Response_GetContainers_Container_ResourceStatistics = []byte("resource_statistics")

func (uj *Response_GetContainers_Container) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetContainers_Container) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetContainers_Containerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetContainers_Containerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Response_GetContainers_Container_ContainerID, kn) {
						currentKey = ffj_t_Response_GetContainers_Container_ContainerID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetContainers_Container_ContainerStatus, kn) {
						currentKey = ffj_t_Response_GetContainers_Container_ContainerStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Response_GetContainers_Container_ExecutorID, kn) {
						currentKey = ffj_t_Response_GetContainers_Container_ExecutorID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetContainers_Container_ExecutorName, kn) {
						currentKey = ffj_t_Response_GetContainers_Container_ExecutorName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Response_GetContainers_Container_FrameworkID, kn) {
						currentKey = ffj_t_Response_GetContainers_Container_FrameworkID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Response_GetContainers_Container_ResourceStatistics, kn) {
						currentKey = ffj_t_Response_GetContainers_Container_ResourceStatistics
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetContainers_Container_ResourceStatistics, kn) {
					currentKey = ffj_t_Response_GetContainers_Container_ResourceStatistics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetContainers_Container_ContainerStatus, kn) {
					currentKey = ffj_t_Response_GetContainers_Container_ContainerStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Response_GetContainers_Container_ContainerID, kn) {
					currentKey = ffj_t_Response_GetContainers_Container_ContainerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Response_GetContainers_Container_ExecutorName, kn) {
					currentKey = ffj_t_Response_GetContainers_Container_ExecutorName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Response_GetContainers_Container_ExecutorID, kn) {
					currentKey = ffj_t_Response_GetContainers_Container_ExecutorID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetContainers_Container_FrameworkID, kn) {
					currentKey = ffj_t_Response_GetContainers_Container_FrameworkID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetContainers_Containerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetContainers_Container_FrameworkID:
					goto handle_FrameworkID

				case ffj_t_Response_GetContainers_Container_ExecutorID:
					goto handle_ExecutorID

				case ffj_t_Response_GetContainers_Container_ExecutorName:
					goto handle_ExecutorName

				case ffj_t_Response_GetContainers_Container_ContainerID:
					goto handle_ContainerID

				case ffj_t_Response_GetContainers_Container_ContainerStatus:
					goto handle_ContainerStatus

				case ffj_t_Response_GetContainers_Container_ResourceStatistics:
					goto handle_ResourceStatistics

				case ffj_t_Response_GetContainers_Containerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FrameworkID:

	/* handler: uj.FrameworkID type=mesos.FrameworkID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.FrameworkID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.FrameworkID == nil {
			uj.FrameworkID = new(mesos.FrameworkID)
		}

		err = uj.FrameworkID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecutorID:

	/* handler: uj.ExecutorID type=mesos.ExecutorID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ExecutorID = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ExecutorID == nil {
			uj.ExecutorID = new(mesos.ExecutorID)
		}

		err = uj.ExecutorID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecutorName:

	/* handler: uj.ExecutorName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.ExecutorName = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.ExecutorName = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerID:

	/* handler: uj.ContainerID type=mesos.ContainerID kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ContainerID.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ContainerStatus:

	/* handler: uj.ContainerStatus type=mesos.ContainerStatus kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ContainerStatus = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ContainerStatus == nil {
			uj.ContainerStatus = new(mesos.ContainerStatus)
		}

		err = uj.ContainerStatus.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResourceStatistics:

	/* handler: uj.ResourceStatistics type=mesos.ResourceStatistics kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ResourceStatistics = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ResourceStatistics == nil {
			uj.ResourceStatistics = new(mesos.ResourceStatistics)
		}

		err = uj.ResourceStatistics.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetExecutors) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetExecutors) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"executors":`)
	if mj.Executors != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Executors {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"completed_executors":`)
	if mj.CompletedExecutors != nil {
		buf.WriteString(`[`)
		for i, v := range mj.CompletedExecutors {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetExecutorsbase = iota
	ffj_t_Response_GetExecutorsno_such_key

	ffj_t_Response_GetExecutors_Executors

	ffj_t_Response_GetExecutors_CompletedExecutors
)

var ffj_key_Response_GetExecutors_Executors = []byte("executors")

var ffj_key_Response_GetExecutors_CompletedExecutors = []byte("completed_executors")

func (uj *Response_GetExecutors) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetExecutors) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetExecutorsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetExecutorsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Response_GetExecutors_CompletedExecutors, kn) {
						currentKey = ffj_t_Response_GetExecutors_CompletedExecutors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Response_GetExecutors_Executors, kn) {
						currentKey = ffj_t_Response_GetExecutors_Executors
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetExecutors_CompletedExecutors, kn) {
					currentKey = ffj_t_Response_GetExecutors_CompletedExecutors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetExecutors_Executors, kn) {
					currentKey = ffj_t_Response_GetExecutors_Executors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetExecutorsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetExecutors_Executors:
					goto handle_Executors

				case ffj_t_Response_GetExecutors_CompletedExecutors:
					goto handle_CompletedExecutors

				case ffj_t_Response_GetExecutorsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Executors:

	/* handler: uj.Executors type=[]agent.Response_GetExecutors_Executor kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Executors = nil
		} else {

			uj.Executors = []Response_GetExecutors_Executor{}

			wantVal := true

			for {

				var tmp_uj__Executors Response_GetExecutors_Executor

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Executors type=agent.Response_GetExecutors_Executor kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Executors.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Executors = append(uj.Executors, tmp_uj__Executors)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompletedExecutors:

	/* handler: uj.CompletedExecutors type=[]agent.Response_GetExecutors_Executor kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.CompletedExecutors = nil
		} else {

			uj.CompletedExecutors = []Response_GetExecutors_Executor{}

			wantVal := true

			for {

				var tmp_uj__CompletedExecutors Response_GetExecutors_Executor

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__CompletedExecutors type=agent.Response_GetExecutors_Executor kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__CompletedExecutors.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.CompletedExecutors = append(uj.CompletedExecutors, tmp_uj__CompletedExecutors)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetExecutors_Executor) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetExecutors_Executor) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"executor_info":`)

	{

		err = mj.ExecutorInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetExecutors_Executorbase = iota
	ffj_t_Response_GetExecutors_Executorno_such_key

	ffj_t_Response_GetExecutors_Executor_ExecutorInfo
)

var ffj_key_Response_GetExecutors_Executor_ExecutorInfo = []byte("executor_info")

func (uj *Response_GetExecutors_Executor) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetExecutors_Executor) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetExecutors_Executorbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetExecutors_Executorno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_Response_GetExecutors_Executor_ExecutorInfo, kn) {
						currentKey = ffj_t_Response_GetExecutors_Executor_ExecutorInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_Response_GetExecutors_Executor_ExecutorInfo, kn) {
					currentKey = ffj_t_Response_GetExecutors_Executor_ExecutorInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetExecutors_Executorno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetExecutors_Executor_ExecutorInfo:
					goto handle_ExecutorInfo

				case ffj_t_Response_GetExecutors_Executorno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExecutorInfo:

	/* handler: uj.ExecutorInfo type=mesos.ExecutorInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ExecutorInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetFlags) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetFlags) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"flags":`)
	if mj.Flags != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Flags {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetFlagsbase = iota
	ffj_t_Response_GetFlagsno_such_key

	ffj_t_Response_GetFlags_Flags
)

var ffj_key_Response_GetFlags_Flags = []byte("flags")

func (uj *Response_GetFlags) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetFlags) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetFlagsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetFlagsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_Response_GetFlags_Flags, kn) {
						currentKey = ffj_t_Response_GetFlags_Flags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetFlags_Flags, kn) {
					currentKey = ffj_t_Response_GetFlags_Flags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetFlagsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetFlags_Flags:
					goto handle_Flags

				case ffj_t_Response_GetFlagsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Flags:

	/* handler: uj.Flags type=[]mesos.Flag kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Flags = nil
		} else {

			uj.Flags = []mesos.Flag{}

			wantVal := true

			for {

				var tmp_uj__Flags mesos.Flag

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Flags type=mesos.Flag kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Flags.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Flags = append(uj.Flags, tmp_uj__Flags)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetFrameworks) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetFrameworks) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"frameworks":`)
	if mj.Frameworks != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Frameworks {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"completed_frameworks":`)
	if mj.CompletedFrameworks != nil {
		buf.WriteString(`[`)
		for i, v := range mj.CompletedFrameworks {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetFrameworksbase = iota
	ffj_t_Response_GetFrameworksno_such_key

	ffj_t_Response_GetFrameworks_Frameworks

	ffj_t_Response_GetFrameworks_CompletedFrameworks
)

var ffj_key_Response_GetFrameworks_Frameworks = []byte("frameworks")

var ffj_key_Response_GetFrameworks_CompletedFrameworks = []byte("completed_frameworks")

func (uj *Response_GetFrameworks) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetFrameworks) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetFrameworksbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetFrameworksno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Response_GetFrameworks_CompletedFrameworks, kn) {
						currentKey = ffj_t_Response_GetFrameworks_CompletedFrameworks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Response_GetFrameworks_Frameworks, kn) {
						currentKey = ffj_t_Response_GetFrameworks_Frameworks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetFrameworks_CompletedFrameworks, kn) {
					currentKey = ffj_t_Response_GetFrameworks_CompletedFrameworks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetFrameworks_Frameworks, kn) {
					currentKey = ffj_t_Response_GetFrameworks_Frameworks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetFrameworksno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetFrameworks_Frameworks:
					goto handle_Frameworks

				case ffj_t_Response_GetFrameworks_CompletedFrameworks:
					goto handle_CompletedFrameworks

				case ffj_t_Response_GetFrameworksno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Frameworks:

	/* handler: uj.Frameworks type=[]agent.Response_GetFrameworks_Framework kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Frameworks = nil
		} else {

			uj.Frameworks = []Response_GetFrameworks_Framework{}

			wantVal := true

			for {

				var tmp_uj__Frameworks Response_GetFrameworks_Framework

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Frameworks type=agent.Response_GetFrameworks_Framework kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Frameworks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Frameworks = append(uj.Frameworks, tmp_uj__Frameworks)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompletedFrameworks:

	/* handler: uj.CompletedFrameworks type=[]agent.Response_GetFrameworks_Framework kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.CompletedFrameworks = nil
		} else {

			uj.CompletedFrameworks = []Response_GetFrameworks_Framework{}

			wantVal := true

			for {

				var tmp_uj__CompletedFrameworks Response_GetFrameworks_Framework

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__CompletedFrameworks type=agent.Response_GetFrameworks_Framework kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__CompletedFrameworks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.CompletedFrameworks = append(uj.CompletedFrameworks, tmp_uj__CompletedFrameworks)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetFrameworks_Framework) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetFrameworks_Framework) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"framework_info":`)

	{

		err = mj.FrameworkInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetFrameworks_Frameworkbase = iota
	ffj_t_Response_GetFrameworks_Frameworkno_such_key

	ffj_t_Response_GetFrameworks_Framework_FrameworkInfo
)

var ffj_key_Response_GetFrameworks_Framework_FrameworkInfo = []byte("framework_info")

func (uj *Response_GetFrameworks_Framework) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetFrameworks_Framework) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetFrameworks_Frameworkbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetFrameworks_Frameworkno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_Response_GetFrameworks_Framework_FrameworkInfo, kn) {
						currentKey = ffj_t_Response_GetFrameworks_Framework_FrameworkInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetFrameworks_Framework_FrameworkInfo, kn) {
					currentKey = ffj_t_Response_GetFrameworks_Framework_FrameworkInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetFrameworks_Frameworkno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetFrameworks_Framework_FrameworkInfo:
					goto handle_FrameworkInfo

				case ffj_t_Response_GetFrameworks_Frameworkno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FrameworkInfo:

	/* handler: uj.FrameworkInfo type=mesos.FrameworkInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.FrameworkInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetHealth) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetHealth) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.Healthy {
		buf.WriteString(`{"healthy":true`)
	} else {
		buf.WriteString(`{"healthy":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetHealthbase = iota
	ffj_t_Response_GetHealthno_such_key

	ffj_t_Response_GetHealth_Healthy
)

var ffj_key_Response_GetHealth_Healthy = []byte("healthy")

func (uj *Response_GetHealth) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetHealth) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetHealthbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetHealthno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_Response_GetHealth_Healthy, kn) {
						currentKey = ffj_t_Response_GetHealth_Healthy
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Response_GetHealth_Healthy, kn) {
					currentKey = ffj_t_Response_GetHealth_Healthy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetHealthno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetHealth_Healthy:
					goto handle_Healthy

				case ffj_t_Response_GetHealthno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Healthy:

	/* handler: uj.Healthy type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Healthy = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Healthy = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetLoggingLevel) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetLoggingLevel) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"level":`)
	fflib.FormatBits2(buf, uint64(mj.Level), 10, false)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetLoggingLevelbase = iota
	ffj_t_Response_GetLoggingLevelno_such_key

	ffj_t_Response_GetLoggingLevel_Level
)

var ffj_key_Response_GetLoggingLevel_Level = []byte("level")

func (uj *Response_GetLoggingLevel) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetLoggingLevel) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetLoggingLevelbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetLoggingLevelno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_Response_GetLoggingLevel_Level, kn) {
						currentKey = ffj_t_Response_GetLoggingLevel_Level
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Response_GetLoggingLevel_Level, kn) {
					currentKey = ffj_t_Response_GetLoggingLevel_Level
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetLoggingLevelno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetLoggingLevel_Level:
					goto handle_Level

				case ffj_t_Response_GetLoggingLevelno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Level:

	/* handler: uj.Level type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Level = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetMetrics) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetMetrics) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"metrics":`)
	if mj.Metrics != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Metrics {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetMetricsbase = iota
	ffj_t_Response_GetMetricsno_such_key

	ffj_t_Response_GetMetrics_Metrics
)

var ffj_key_Response_GetMetrics_Metrics = []byte("metrics")

func (uj *Response_GetMetrics) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetMetrics) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetMetricsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetMetricsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffj_key_Response_GetMetrics_Metrics, kn) {
						currentKey = ffj_t_Response_GetMetrics_Metrics
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetMetrics_Metrics, kn) {
					currentKey = ffj_t_Response_GetMetrics_Metrics
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetMetricsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetMetrics_Metrics:
					goto handle_Metrics

				case ffj_t_Response_GetMetricsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Metrics:

	/* handler: uj.Metrics type=[]mesos.Metric kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Metrics = nil
		} else {

			uj.Metrics = []mesos.Metric{}

			wantVal := true

			for {

				var tmp_uj__Metrics mesos.Metric

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Metrics type=mesos.Metric kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Metrics.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Metrics = append(uj.Metrics, tmp_uj__Metrics)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetOperations) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetOperations) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"operations":`)
	if mj.Operations != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Operations {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetOperationsbase = iota
	ffj_t_Response_GetOperationsno_such_key

	ffj_t_Response_GetOperations_Operations
)

var ffj_key_Response_GetOperations_Operations = []byte("operations")

func (uj *Response_GetOperations) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetOperations) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetOperationsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetOperationsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'o':

					if bytes.Equal(ffj_key_Response_GetOperations_Operations, kn) {
						currentKey = ffj_t_Response_GetOperations_Operations
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetOperations_Operations, kn) {
					currentKey = ffj_t_Response_GetOperations_Operations
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetOperationsno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetOperations_Operations:
					goto handle_Operations

				case ffj_t_Response_GetOperationsno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Operations:

	/* handler: uj.Operations type=[]mesos.Operation kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Operations = nil
		} else {

			uj.Operations = []mesos.Operation{}

			wantVal := true

			for {

				var tmp_uj__Operations mesos.Operation

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Operations type=mesos.Operation kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Operations.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Operations = append(uj.Operations, tmp_uj__Operations)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetResourceProviders) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetResourceProviders) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"resource_providers":`)
	if mj.ResourceProviders != nil {
		buf.WriteString(`[`)
		for i, v := range mj.ResourceProviders {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetResourceProvidersbase = iota
	ffj_t_Response_GetResourceProvidersno_such_key

	ffj_t_Response_GetResourceProviders_ResourceProviders
)

var ffj_key_Response_GetResourceProviders_ResourceProviders = []byte("resource_providers")

func (uj *Response_GetResourceProviders) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetResourceProviders) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetResourceProvidersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetResourceProvidersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Response_GetResourceProviders_ResourceProviders, kn) {
						currentKey = ffj_t_Response_GetResourceProviders_ResourceProviders
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetResourceProviders_ResourceProviders, kn) {
					currentKey = ffj_t_Response_GetResourceProviders_ResourceProviders
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetResourceProvidersno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetResourceProviders_ResourceProviders:
					goto handle_ResourceProviders

				case ffj_t_Response_GetResourceProvidersno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ResourceProviders:

	/* handler: uj.ResourceProviders type=[]agent.Response_GetResourceProviders_ResourceProvider kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.ResourceProviders = nil
		} else {

			uj.ResourceProviders = []Response_GetResourceProviders_ResourceProvider{}

			wantVal := true

			for {

				var tmp_uj__ResourceProviders Response_GetResourceProviders_ResourceProvider

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__ResourceProviders type=agent.Response_GetResourceProviders_ResourceProvider kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__ResourceProviders.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.ResourceProviders = append(uj.ResourceProviders, tmp_uj__ResourceProviders)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetResourceProviders_ResourceProvider) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetResourceProviders_ResourceProvider) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"resource_provider_info":`)

	{

		err = mj.ResourceProviderInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"total_resources":`)
	if mj.TotalResources != nil {
		buf.WriteString(`[`)
		for i, v := range mj.TotalResources {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetResourceProviders_ResourceProviderbase = iota
	ffj_t_Response_GetResourceProviders_ResourceProviderno_such_key

	ffj_t_Response_GetResourceProviders_ResourceProvider_ResourceProviderInfo

	ffj_t_Response_GetResourceProviders_ResourceProvider_TotalResources
)

var ffj_key_Response_GetResourceProviders_ResourceProvider_ResourceProviderInfo = []byte("resource_provider_info")

var ffj_key_Response_GetResourceProviders_ResourceProvider_TotalResources = []byte("total_resources")

func (uj *Response_GetResourceProviders_ResourceProvider) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetResourceProviders_ResourceProvider) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetResourceProviders_ResourceProviderbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetResourceProviders_ResourceProviderno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_Response_GetResourceProviders_ResourceProvider_ResourceProviderInfo, kn) {
						currentKey = ffj_t_Response_GetResourceProviders_ResourceProvider_ResourceProviderInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Response_GetResourceProviders_ResourceProvider_TotalResources, kn) {
						currentKey = ffj_t_Response_GetResourceProviders_ResourceProvider_TotalResources
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetResourceProviders_ResourceProvider_TotalResources, kn) {
					currentKey = ffj_t_Response_GetResourceProviders_ResourceProvider_TotalResources
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetResourceProviders_ResourceProvider_ResourceProviderInfo, kn) {
					currentKey = ffj_t_Response_GetResourceProviders_ResourceProvider_ResourceProviderInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetResourceProviders_ResourceProviderno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetResourceProviders_ResourceProvider_ResourceProviderInfo:
					goto handle_ResourceProviderInfo

				case ffj_t_Response_GetResourceProviders_ResourceProvider_TotalResources:
					goto handle_TotalResources

				case ffj_t_Response_GetResourceProviders_ResourceProviderno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ResourceProviderInfo:

	/* handler: uj.ResourceProviderInfo type=mesos.ResourceProviderInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.ResourceProviderInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TotalResources:

	/* handler: uj.TotalResources type=[]mesos.Resource kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.TotalResources = nil
		} else {

			uj.TotalResources = []mesos.Resource{}

			wantVal := true

			for {

				var tmp_uj__TotalResources mesos.Resource

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__TotalResources type=mesos.Resource kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__TotalResources.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.TotalResources = append(uj.TotalResources, tmp_uj__TotalResources)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetState) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetState) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.GetTasks != nil {
		if true {
			buf.WriteString(`"get_tasks":`)

			{

				err = mj.GetTasks.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetExecutors != nil {
		if true {
			buf.WriteString(`"get_executors":`)

			{

				err = mj.GetExecutors.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.GetFrameworks != nil {
		if true {
			buf.WriteString(`"get_frameworks":`)

			{

				err = mj.GetFrameworks.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetStatebase = iota
	ffj_t_Response_GetStateno_such_key

	ffj_t_Response_GetState_GetTasks

	ffj_t_Response_GetState_GetExecutors

	ffj_t_Response_GetState_GetFrameworks
)

var ffj_key_Response_GetState_GetTasks = []byte("get_tasks")

var ffj_key_Response_GetState_GetExecutors = []byte("get_executors")

var ffj_key_Response_GetState_GetFrameworks = []byte("get_frameworks")

func (uj *Response_GetState) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetState) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetStatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetStateno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffj_key_Response_GetState_GetTasks, kn) {
						currentKey = ffj_t_Response_GetState_GetTasks
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetState_GetExecutors, kn) {
						currentKey = ffj_t_Response_GetState_GetExecutors
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Response_GetState_GetFrameworks, kn) {
						currentKey = ffj_t_Response_GetState_GetFrameworks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetState_GetFrameworks, kn) {
					currentKey = ffj_t_Response_GetState_GetFrameworks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetState_GetExecutors, kn) {
					currentKey = ffj_t_Response_GetState_GetExecutors
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetState_GetTasks, kn) {
					currentKey = ffj_t_Response_GetState_GetTasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetStateno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetState_GetTasks:
					goto handle_GetTasks

				case ffj_t_Response_GetState_GetExecutors:
					goto handle_GetExecutors

				case ffj_t_Response_GetState_GetFrameworks:
					goto handle_GetFrameworks

				case ffj_t_Response_GetStateno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GetTasks:

	/* handler: uj.GetTasks type=agent.Response_GetTasks kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetTasks = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetTasks == nil {
			uj.GetTasks = new(Response_GetTasks)
		}

		err = uj.GetTasks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetExecutors:

	/* handler: uj.GetExecutors type=agent.Response_GetExecutors kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetExecutors = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetExecutors == nil {
			uj.GetExecutors = new(Response_GetExecutors)
		}

		err = uj.GetExecutors.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GetFrameworks:

	/* handler: uj.GetFrameworks type=agent.Response_GetFrameworks kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.GetFrameworks = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.GetFrameworks == nil {
			uj.GetFrameworks = new(Response_GetFrameworks)
		}

		err = uj.GetFrameworks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetTasks) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetTasks) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"pending_tasks":`)
	if mj.PendingTasks != nil {
		buf.WriteString(`[`)
		for i, v := range mj.PendingTasks {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"queued_tasks":`)
	if mj.QueuedTasks != nil {
		buf.WriteString(`[`)
		for i, v := range mj.QueuedTasks {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"launched_tasks":`)
	if mj.LaunchedTasks != nil {
		buf.WriteString(`[`)
		for i, v := range mj.LaunchedTasks {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"terminated_tasks":`)
	if mj.TerminatedTasks != nil {
		buf.WriteString(`[`)
		for i, v := range mj.TerminatedTasks {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"completed_tasks":`)
	if mj.CompletedTasks != nil {
		buf.WriteString(`[`)
		for i, v := range mj.CompletedTasks {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetTasksbase = iota
	ffj_t_Response_GetTasksno_such_key

	ffj_t_Response_GetTasks_PendingTasks

	ffj_t_Response_GetTasks_QueuedTasks

	ffj_t_Response_GetTasks_LaunchedTasks

	ffj_t_Response_GetTasks_TerminatedTasks

	ffj_t_Response_GetTasks_CompletedTasks
)

var ffj_key_Response_GetTasks_PendingTasks = []byte("pending_tasks")

var ffj_key_Response_GetTasks_QueuedTasks = []byte("queued_tasks")

var ffj_key_Response_GetTasks_LaunchedTasks = []byte("launched_tasks")

var ffj_key_Response_GetTasks_TerminatedTasks = []byte("terminated_tasks")

var ffj_key_Response_GetTasks_CompletedTasks = []byte("completed_tasks")

func (uj *Response_GetTasks) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetTasks) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetTasksbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetTasksno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Response_GetTasks_CompletedTasks, kn) {
						currentKey = ffj_t_Response_GetTasks_CompletedTasks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Response_GetTasks_LaunchedTasks, kn) {
						currentKey = ffj_t_Response_GetTasks_LaunchedTasks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Response_GetTasks_PendingTasks, kn) {
						currentKey = ffj_t_Response_GetTasks_PendingTasks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_Response_GetTasks_QueuedTasks, kn) {
						currentKey = ffj_t_Response_GetTasks_QueuedTasks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Response_GetTasks_TerminatedTasks, kn) {
						currentKey = ffj_t_Response_GetTasks_TerminatedTasks
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetTasks_CompletedTasks, kn) {
					currentKey = ffj_t_Response_GetTasks_CompletedTasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetTasks_TerminatedTasks, kn) {
					currentKey = ffj_t_Response_GetTasks_TerminatedTasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetTasks_LaunchedTasks, kn) {
					currentKey = ffj_t_Response_GetTasks_LaunchedTasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetTasks_QueuedTasks, kn) {
					currentKey = ffj_t_Response_GetTasks_QueuedTasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_GetTasks_PendingTasks, kn) {
					currentKey = ffj_t_Response_GetTasks_PendingTasks
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetTasksno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetTasks_PendingTasks:
					goto handle_PendingTasks

				case ffj_t_Response_GetTasks_QueuedTasks:
					goto handle_QueuedTasks

				case ffj_t_Response_GetTasks_LaunchedTasks:
					goto handle_LaunchedTasks

				case ffj_t_Response_GetTasks_TerminatedTasks:
					goto handle_TerminatedTasks

				case ffj_t_Response_GetTasks_CompletedTasks:
					goto handle_CompletedTasks

				case ffj_t_Response_GetTasksno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PendingTasks:

	/* handler: uj.PendingTasks type=[]mesos.Task kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.PendingTasks = nil
		} else {

			uj.PendingTasks = []mesos.Task{}

			wantVal := true

			for {

				var tmp_uj__PendingTasks mesos.Task

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__PendingTasks type=mesos.Task kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__PendingTasks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.PendingTasks = append(uj.PendingTasks, tmp_uj__PendingTasks)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_QueuedTasks:

	/* handler: uj.QueuedTasks type=[]mesos.Task kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.QueuedTasks = nil
		} else {

			uj.QueuedTasks = []mesos.Task{}

			wantVal := true

			for {

				var tmp_uj__QueuedTasks mesos.Task

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__QueuedTasks type=mesos.Task kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__QueuedTasks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.QueuedTasks = append(uj.QueuedTasks, tmp_uj__QueuedTasks)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LaunchedTasks:

	/* handler: uj.LaunchedTasks type=[]mesos.Task kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.LaunchedTasks = nil
		} else {

			uj.LaunchedTasks = []mesos.Task{}

			wantVal := true

			for {

				var tmp_uj__LaunchedTasks mesos.Task

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__LaunchedTasks type=mesos.Task kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__LaunchedTasks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.LaunchedTasks = append(uj.LaunchedTasks, tmp_uj__LaunchedTasks)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TerminatedTasks:

	/* handler: uj.TerminatedTasks type=[]mesos.Task kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.TerminatedTasks = nil
		} else {

			uj.TerminatedTasks = []mesos.Task{}

			wantVal := true

			for {

				var tmp_uj__TerminatedTasks mesos.Task

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__TerminatedTasks type=mesos.Task kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__TerminatedTasks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.TerminatedTasks = append(uj.TerminatedTasks, tmp_uj__TerminatedTasks)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CompletedTasks:

	/* handler: uj.CompletedTasks type=[]mesos.Task kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.CompletedTasks = nil
		} else {

			uj.CompletedTasks = []mesos.Task{}

			wantVal := true

			for {

				var tmp_uj__CompletedTasks mesos.Task

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__CompletedTasks type=mesos.Task kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__CompletedTasks.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.CompletedTasks = append(uj.CompletedTasks, tmp_uj__CompletedTasks)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_GetVersion) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_GetVersion) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"version_info":`)

	{

		err = mj.VersionInfo.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_GetVersionbase = iota
	ffj_t_Response_GetVersionno_such_key

	ffj_t_Response_GetVersion_VersionInfo
)

var ffj_key_Response_GetVersion_VersionInfo = []byte("version_info")

func (uj *Response_GetVersion) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_GetVersion) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_GetVersionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_GetVersionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'v':

					if bytes.Equal(ffj_key_Response_GetVersion_VersionInfo, kn) {
						currentKey = ffj_t_Response_GetVersion_VersionInfo
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_GetVersion_VersionInfo, kn) {
					currentKey = ffj_t_Response_GetVersion_VersionInfo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_GetVersionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_GetVersion_VersionInfo:
					goto handle_VersionInfo

				case ffj_t_Response_GetVersionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_VersionInfo:

	/* handler: uj.VersionInfo type=mesos.VersionInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.VersionInfo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_ListFiles) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_ListFiles) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"file_infos":`)
	if mj.FileInfos != nil {
		buf.WriteString(`[`)
		for i, v := range mj.FileInfos {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_ListFilesbase = iota
	ffj_t_Response_ListFilesno_such_key

	ffj_t_Response_ListFiles_FileInfos
)

var ffj_key_Response_ListFiles_FileInfos = []byte("file_infos")

func (uj *Response_ListFiles) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_ListFiles) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_ListFilesbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_ListFilesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_Response_ListFiles_FileInfos, kn) {
						currentKey = ffj_t_Response_ListFiles_FileInfos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_ListFiles_FileInfos, kn) {
					currentKey = ffj_t_Response_ListFiles_FileInfos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_ListFilesno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_ListFiles_FileInfos:
					goto handle_FileInfos

				case ffj_t_Response_ListFilesno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileInfos:

	/* handler: uj.FileInfos type=[]mesos.FileInfo kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.FileInfos = nil
		} else {

			uj.FileInfos = []mesos.FileInfo{}

			wantVal := true

			for {

				var tmp_uj__FileInfos mesos.FileInfo

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__FileInfos type=mesos.FileInfo kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__FileInfos.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.FileInfos = append(uj.FileInfos, tmp_uj__FileInfos)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_ReadFile) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_ReadFile) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "size":`)
	fflib.FormatBits2(buf, uint64(mj.Size), 10, false)
	buf.WriteByte(',')
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		if mj.Data != nil {
			buf.WriteString(`"`)
			{
				enc := base64.NewEncoder(base64.StdEncoding, buf)
				enc.Write(reflect.Indirect(reflect.ValueOf(mj.Data)).Bytes())
				enc.Close()
			}
			buf.WriteString(`"`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_ReadFilebase = iota
	ffj_t_Response_ReadFileno_such_key

	ffj_t_Response_ReadFile_Size

	ffj_t_Response_ReadFile_Data
)

var ffj_key_Response_ReadFile_Size = []byte("size")

var ffj_key_Response_ReadFile_Data = []byte("data")

func (uj *Response_ReadFile) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_ReadFile) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_ReadFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_ReadFileno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Response_ReadFile_Data, kn) {
						currentKey = ffj_t_Response_ReadFile_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Response_ReadFile_Size, kn) {
						currentKey = ffj_t_Response_ReadFile_Size
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Response_ReadFile_Data, kn) {
					currentKey = ffj_t_Response_ReadFile_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_ReadFile_Size, kn) {
					currentKey = ffj_t_Response_ReadFile_Size
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_ReadFileno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_ReadFile_Size:
					goto handle_Size

				case ffj_t_Response_ReadFile_Data:
					goto handle_Data

				case ffj_t_Response_ReadFileno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Size:

	/* handler: uj.Size type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Size = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=[]uint8 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Data = nil
		} else {
			b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
			n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
			if err != nil {
				return fs.WrapErr(err)
			}

			v := reflect.ValueOf(&uj.Data).Elem()
			v.SetBytes(b[0:n])

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_WaitContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_WaitContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.ExitStatus != nil {
		if true {
			buf.WriteString(`"exit_status":`)
			fflib.FormatBits2(buf, uint64(*mj.ExitStatus), 10, *mj.ExitStatus < 0)
			buf.WriteByte(',')
		}
	}
	if mj.State != nil {
		if true {
			buf.WriteString(`"state":`)

			{

				obj, err = mj.State.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Reason != nil {
		if true {
			buf.WriteString(`"reason":`)

			{

				obj, err = mj.Reason.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Limitation != nil {
		if true {
			buf.WriteString(`"limitation":`)

			{

				err = mj.Limitation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Message != nil {
		if true {
			buf.WriteString(`"message":`)
			fflib.WriteJsonString(buf, string(*mj.Message))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_WaitContainerbase = iota
	ffj_t_Response_WaitContainerno_such_key

	ffj_t_Response_WaitContainer_ExitStatus

	ffj_t_Response_WaitContainer_State

	ffj_t_Response_WaitContainer_Reason

	ffj_t_Response_WaitContainer_Limitation

	ffj_t_Response_WaitContainer_Message
)

var ffj_key_Response_WaitContainer_ExitStatus = []byte("exit_status")

var ffj_key_Response_WaitContainer_State = []byte("state")

var ffj_key_Response_WaitContainer_Reason = []byte("reason")

var ffj_key_Response_WaitContainer_Limitation = []byte("limitation")

var ffj_key_Response_WaitContainer_Message = []byte("message")

func (uj *Response_WaitContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_WaitContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_WaitContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_WaitContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_Response_WaitContainer_ExitStatus, kn) {
						currentKey = ffj_t_Response_WaitContainer_ExitStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Response_WaitContainer_Limitation, kn) {
						currentKey = ffj_t_Response_WaitContainer_Limitation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Response_WaitContainer_Message, kn) {
						currentKey = ffj_t_Response_WaitContainer_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Response_WaitContainer_Reason, kn) {
						currentKey = ffj_t_Response_WaitContainer_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Response_WaitContainer_State, kn) {
						currentKey = ffj_t_Response_WaitContainer_State
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitContainer_Message, kn) {
					currentKey = ffj_t_Response_WaitContainer_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Response_WaitContainer_Limitation, kn) {
					currentKey = ffj_t_Response_WaitContainer_Limitation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitContainer_Reason, kn) {
					currentKey = ffj_t_Response_WaitContainer_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitContainer_State, kn) {
					currentKey = ffj_t_Response_WaitContainer_State
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitContainer_ExitStatus, kn) {
					currentKey = ffj_t_Response_WaitContainer_ExitStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_WaitContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_WaitContainer_ExitStatus:
					goto handle_ExitStatus

				case ffj_t_Response_WaitContainer_State:
					goto handle_State

				case ffj_t_Response_WaitContainer_Reason:
					goto handle_Reason

				case ffj_t_Response_WaitContainer_Limitation:
					goto handle_Limitation

				case ffj_t_Response_WaitContainer_Message:
					goto handle_Message

				case ffj_t_Response_WaitContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExitStatus:

	/* handler: uj.ExitStatus type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ExitStatus = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			uj.ExitStatus = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: uj.State type=mesos.TaskState kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.State = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.State == nil {
			uj.State = new(mesos.TaskState)
		}

		err = uj.State.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=mesos.TaskStatus_Reason kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Reason = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Reason == nil {
			uj.Reason = new(mesos.TaskStatus_Reason)
		}

		err = uj.Reason.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Limitation:

	/* handler: uj.Limitation type=mesos.TaskResourceLimitation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Limitation = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Limitation == nil {
			uj.Limitation = new(mesos.TaskResourceLimitation)
		}

		err = uj.Limitation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Message = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Message = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Response_WaitNestedContainer) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Response_WaitNestedContainer) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if mj.ExitStatus != nil {
		if true {
			buf.WriteString(`"exit_status":`)
			fflib.FormatBits2(buf, uint64(*mj.ExitStatus), 10, *mj.ExitStatus < 0)
			buf.WriteByte(',')
		}
	}
	if mj.State != nil {
		if true {
			buf.WriteString(`"state":`)

			{

				obj, err = mj.State.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Reason != nil {
		if true {
			buf.WriteString(`"reason":`)

			{

				obj, err = mj.Reason.MarshalJSON()
				if err != nil {
					return err
				}
				buf.Write(obj)

			}
			buf.WriteByte(',')
		}
	}
	if mj.Limitation != nil {
		if true {
			buf.WriteString(`"limitation":`)

			{

				err = mj.Limitation.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Message != nil {
		if true {
			buf.WriteString(`"message":`)
			fflib.WriteJsonString(buf, string(*mj.Message))
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Response_WaitNestedContainerbase = iota
	ffj_t_Response_WaitNestedContainerno_such_key

	ffj_t_Response_WaitNestedContainer_ExitStatus

	ffj_t_Response_WaitNestedContainer_State

	ffj_t_Response_WaitNestedContainer_Reason

	ffj_t_Response_WaitNestedContainer_Limitation

	ffj_t_Response_WaitNestedContainer_Message
)

var ffj_key_Response_WaitNestedContainer_ExitStatus = []byte("exit_status")

var ffj_key_Response_WaitNestedContainer_State = []byte("state")

var ffj_key_Response_WaitNestedContainer_Reason = []byte("reason")

var ffj_key_Response_WaitNestedContainer_Limitation = []byte("limitation")

var ffj_key_Response_WaitNestedContainer_Message = []byte("message")

func (uj *Response_WaitNestedContainer) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Response_WaitNestedContainer) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Response_WaitNestedContainerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Response_WaitNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'e':

					if bytes.Equal(ffj_key_Response_WaitNestedContainer_ExitStatus, kn) {
						currentKey = ffj_t_Response_WaitNestedContainer_ExitStatus
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Response_WaitNestedContainer_Limitation, kn) {
						currentKey = ffj_t_Response_WaitNestedContainer_Limitation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Response_WaitNestedContainer_Message, kn) {
						currentKey = ffj_t_Response_WaitNestedContainer_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Response_WaitNestedContainer_Reason, kn) {
						currentKey = ffj_t_Response_WaitNestedContainer_Reason
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Response_WaitNestedContainer_State, kn) {
						currentKey = ffj_t_Response_WaitNestedContainer_State
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitNestedContainer_Message, kn) {
					currentKey = ffj_t_Response_WaitNestedContainer_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Response_WaitNestedContainer_Limitation, kn) {
					currentKey = ffj_t_Response_WaitNestedContainer_Limitation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitNestedContainer_Reason, kn) {
					currentKey = ffj_t_Response_WaitNestedContainer_Reason
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitNestedContainer_State, kn) {
					currentKey = ffj_t_Response_WaitNestedContainer_State
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Response_WaitNestedContainer_ExitStatus, kn) {
					currentKey = ffj_t_Response_WaitNestedContainer_ExitStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Response_WaitNestedContainerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Response_WaitNestedContainer_ExitStatus:
					goto handle_ExitStatus

				case ffj_t_Response_WaitNestedContainer_State:
					goto handle_State

				case ffj_t_Response_WaitNestedContainer_Reason:
					goto handle_Reason

				case ffj_t_Response_WaitNestedContainer_Limitation:
					goto handle_Limitation

				case ffj_t_Response_WaitNestedContainer_Message:
					goto handle_Message

				case ffj_t_Response_WaitNestedContainerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ExitStatus:

	/* handler: uj.ExitStatus type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

			uj.ExitStatus = nil

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			ttypval := int32(tval)
			uj.ExitStatus = &ttypval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_State:

	/* handler: uj.State type=mesos.TaskState kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.State = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.State == nil {
			uj.State = new(mesos.TaskState)
		}

		err = uj.State.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reason:

	/* handler: uj.Reason type=mesos.TaskStatus_Reason kind=int32 quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Reason = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		if uj.Reason == nil {
			uj.Reason = new(mesos.TaskStatus_Reason)
		}

		err = uj.Reason.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Limitation:

	/* handler: uj.Limitation type=mesos.TaskResourceLimitation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Limitation = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Limitation == nil {
			uj.Limitation = new(mesos.TaskResourceLimitation)
		}

		err = uj.Limitation.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.Message = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.Message = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
