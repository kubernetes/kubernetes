# Test translations for unit tests.
# Copyright (C) 2017
# This file is distributed under the same license as the Kubernetes package.
# FIRST AUTHOR shiywang@redhat.com, 2017.
# FIRST AUTHOR zhengjiajin@caicloud.io, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: gettext-go-examples-hello\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-12-12 20:03+0000\n"
"PO-Revision-Date: 2017-11-11 19:01+0800\n"
"Last-Translator: zhengjiajin <zhengjiajin@caicloud.io>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 2.0.4\n"
"X-Poedit-SourceCharset: UTF-8\n"
"Language-Team: \n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"Language: zh\n"

#: pkg/kubectl/cmd/create_clusterrolebinding.go:35
msgid ""
"\n"
"\t\t  # Create a ClusterRoleBinding for user1, user2, and group1 using the cluster-admin ClusterRole\n"
"\t\t  kubectl create clusterrolebinding cluster-admin --clusterrole=cluster-admin --user=user1 --user=user2 --group=group1"
msgstr ""
"\n"
"\t\t  # 使用 cluster-admin ClusterRole 为 user1, user2, and group1 创建一个 ClusterRoleBinding\n"
"\t\t  kubectl create clusterrolebinding cluster-admin --clusterrole=cluster-admin --user=user1 --user=user2 --group=group1"

#: pkg/kubectl/cmd/create_rolebinding.go:35
msgid ""
"\n"
"\t\t  # Create a RoleBinding for user1, user2, and group1 using the admin ClusterRole\n"
"\t\t  kubectl create rolebinding admin --clusterrole=admin --user=user1 --user=user2 --group=group1"
msgstr ""
"\n"
"\t\t  # 使用 admin ClusterRole 为 user1, user2, and group1 创建一个 RoleBinding\n"
"\t\t  kubectl create rolebinding admin --clusterrole=admin --user=user1 --user=user2 --group=group1"

#: pkg/kubectl/cmd/create_configmap.go:44
msgid ""
"\n"
"\t\t  # Create a new configmap named my-config based on folder bar\n"
"\t\t  kubectl create configmap my-config --from-file=path/to/bar\n"
"\n"
"\t\t  # Create a new configmap named my-config with specified keys instead of file basenames on disk\n"
"\t\t  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt\n"
"\n"
"\t\t  # Create a new configmap named my-config with key1=config1 and key2=config2\n"
"\t\t  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2"
msgstr ""
"\n"
"\t\t  # 通过文件夹 bar 创建一个名称为 my-config 的 configmap\n"
"\t\t  kubectl create configmap my-config --from-file=path/to/bar\n"
"\n"
"\t\t  # 创建一个名称为 my-config 的 configmap 并指定 keys 而不是使用磁盘上所在的文件名\n"
"\t\t  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt\n"
"\n"
"\t\t  # 创建一个名称为 my-config 的 configmap 且 key1=config1 和 key2=config2\n"
"\t\t  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2"

#: pkg/kubectl/cmd/create_secret.go:135
msgid ""
"\n"
"\t\t  # If you don't already have a .dockercfg file, you can create a dockercfg secret directly by using:\n"
"\t\t  kubectl create secret docker-registry my-secret --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL"
msgstr ""
"\n"
"\t\t  # 如果你还没有一个 .dockercfg 文件, 你可以直接使用下面的命令创建一个 dockercfg 的 secret:\n"
"\t\t  kubectl create secret docker-registry my-secret --docker-server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL"

#: pkg/kubectl/cmd/top_node.go:65
msgid ""
"\n"
"\t\t  # Show metrics for all nodes\n"
"\t\t  kubectl top node\n"
"\n"
"\t\t  # Show metrics for a given node\n"
"\t\t  kubectl top node NODE_NAME"
msgstr ""
"\n"
"\t\t  # 显示所有 nodes 上的指标\n"
"\t\t  kubectl top node\n"
"\n"
"\t\t  # 显示指定 node 上的指标\n"
"\t\t  kubectl top node NODE_NAME"

#: pkg/kubectl/cmd/apply.go:84
msgid ""
"\n"
"\t\t# Apply the configuration in pod.json to a pod.\n"
"\t\tkubectl apply -f ./pod.json\n"
"\n"
"\t\t# Apply the JSON passed into stdin to a pod.\n"
"\t\tcat pod.json | kubectl apply -f -\n"
"\n"
"\t\t# Note: --prune is still in Alpha\n"
"\t\t# Apply the configuration in manifest.yaml that matches label app=nginx and delete all the other resources that are not in the file and match label app=nginx.\n"
"\t\tkubectl apply --prune -f manifest.yaml -l app=nginx\n"
"\n"
"\t\t# Apply the configuration in manifest.yaml and delete all the other configmaps that are not in the file.\n"
"\t\tkubectl apply --prune -f manifest.yaml --all --prune-whitelist=core/v1/ConfigMap"
msgstr ""
"\n"
"\t\t# 将 pod.json 上的配置应用于 pod.\n"
"\t\tkubectl apply -f ./pod.json\n"
"\n"
"\t\t# 将传入 stdin 的 JSON 应用到一个 pod.\n"
"\t\tcat pod.json | kubectl apply -f -\n"
"\n"
"\t\t# Note: --prune 仍然在 Alpha\n"
"\t\t# 应用在 manifest.yaml 中匹配标签 app=nginx 的资源配置并删除所有不在这个文件中并匹配标签app=nginx 的资源\n"
"\t\tkubectl apply --prune -f manifest.yaml -l app=nginx\n"
"\n"
"\t\t# 应用 manifest.yaml 的配置并删除所有不在这个文件中的 configmaps.\n"
"\t\tkubectl apply --prune -f manifest.yaml --all --prune-whitelist=core/v1/ConfigMap"

#: pkg/kubectl/cmd/autoscale.go:40
#, c-format
msgid ""
"\n"
"\t\t# Auto scale a deployment \"foo\", with the number of pods between 2 and 10, target CPU utilization specified so a default autoscaling policy will be used:\n"
"\t\tkubectl autoscale deployment foo --min=2 --max=10\n"
"\n"
"\t\t# Auto scale a replication controller \"foo\", with the number of pods between 1 and 5, target CPU utilization at 80%:\n"
"\t\tkubectl autoscale rc foo --max=5 --cpu-percent=80"
msgstr ""
"\n"
"\t\t# 自动弹性伸缩 deployment \"foo\", pods 的数量在 2 和 10 之间, 目标 CPU 指定为默认的弹性伸缩策略:\n"
"\t\tkubectl autoscale deployment foo --min=2 --max=10\n"
"\n"
"\t\t# 自动弹性伸缩 replication controller \"foo\", pods 的数量在 1 和 5 之间, 目标 CPU 利用率为 80%:\n"
"\t\tkubectl autoscale rc foo --max=5 --cpu-percent=80"

#: pkg/kubectl/cmd/convert.go:49
msgid ""
"\n"
"\t\t# Convert 'pod.yaml' to latest version and print to stdout.\n"
"\t\tkubectl convert -f pod.yaml\n"
"\n"
"\t\t# Convert the live state of the resource specified by 'pod.yaml' to the latest version\n"
"\t\t# and print to stdout in json format.\n"
"\t\tkubectl convert -f pod.yaml --local -o json\n"
"\n"
"\t\t# Convert all files under current directory to latest version and create them all.\n"
"\t\tkubectl convert -f . | kubectl create -f -"
msgstr ""
"\n"
"\t\t# 将’pod.yaml' 转换为最新版本并打印到 stdout.\n"
"\t\tkubectl convert -f pod.yaml\n"
"\n"
"\t\t# 将 ‘pod.yaml' 指定的资源的实时状态转换为最新版本\n"
"\t\t# 并以 json 格式打印到 stdout.\n"
"\t\tkubectl convert -f pod.yaml --local -o json\n"
"\n"
"\t\t# 将当前目录下的所以文件转换为最新版本并创建它们.\n"
"\t\tkubectl convert -f . | kubectl create -f -"

#: pkg/kubectl/cmd/create_role.go:41
msgid ""
"\n"
"\t\t# Create a ClusterRole named \"pod-reader\" that allows user to perform \"get\", \"watch\" and \"list\" on pods\n"
"\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods\n"
"\n"
"\t\t# Create a ClusterRole named \"pod-reader\" with ResourceName specified\n"
"\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods --resource-name=readablepod"
msgstr ""
"\n"
"\t\t# 创建一个名为 \"pod-reader\" 的 ClusterRole, 允许用户在 pods 上执行 “get\", \"watch\" 和 \"list\"\n"
"\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods\n"
"\n"
"\t\t# 创建一个名为 \"pod-reader\" ClusterRole, 其中指定了 ResourceName\n"
"\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods --resource-name=readablepod"

#: pkg/kubectl/cmd/create_quota.go:35
msgid ""
"\n"
"\t\t# Create a new resourcequota named my-quota\n"
"\t\tkubectl create quota my-quota --hard=cpu=1,memory=1G,pods=2,services=3,replicationcontrollers=2,resourcequotas=1,secrets=5,persistentvolumeclaims=10\n"
"\n"
"\t\t# Create a new resourcequota named best-effort\n"
"\t\tkubectl create quota best-effort --hard=pods=100 --scopes=BestEffort"
msgstr ""
"\n"
"\t\t# 创建一个名为 my-quota 的 resourcequota\n"
"\t\tkubectl create quota my-quota --hard=cpu=1,memory=1G,pods=2,services=3,replicationcontrollers=2,resourcequotas=1,secrets=5,persistentvolumeclaims=10\n"
"\n"
"\t\t# 创建一个名为 best-effort 的 resourcequota\n"
"\t\tkubectl create quota best-effort --hard=pods=100 --scopes=BestEffort"

#: pkg/kubectl/cmd/create_pdb.go:35
#, c-format
msgid ""
"\n"
"\t\t# Create a pod disruption budget named my-pdb that will select all pods with the app=rails label\n"
"\t\t# and require at least one of them being available at any point in time.\n"
"\t\tkubectl create poddisruptionbudget my-pdb --selector=app=rails --min-available=1\n"
"\n"
"\t\t# Create a pod disruption budget named my-pdb that will select all pods with the app=nginx label\n"
"\t\t# and require at least half of the pods selected to be available at any point in time.\n"
"\t\tkubectl create pdb my-pdb --selector=app=nginx --min-available=50%"
msgstr ""
"\n"
"\t\t# 创建一个名称为 my-pdb 的 pod disruption budget 并将会选择所有 app=rails 标签的 pods\n"
"\t\t# 并要求他们在同一时间中最少有一个可用. \n"
"\t\tkubectl create poddisruptionbudget my-pdb --selector=app=rails --min-available=1\n"
"\n"
"\t\t# 创建一个名称为 my-pdb 的 pod disruption budget 并将会选择所有 app=rails 标签的 pods\n"
"\t\t# 并要求他们在同一时间中最少有一半可用.\n"
"\t\tkubectl create pdb my-pdb --selector=app=nginx --min-available=50%"

#: pkg/kubectl/cmd/create.go:47
msgid ""
"\n"
"\t\t# Create a pod using the data in pod.json.\n"
"\t\tkubectl create -f ./pod.json\n"
"\n"
"\t\t# Create a pod based on the JSON passed into stdin.\n"
"\t\tcat pod.json | kubectl create -f -\n"
"\n"
"\t\t# Edit the data in docker-registry.yaml in JSON using the v1 API format then create the resource using the edited data.\n"
"\t\tkubectl create -f docker-registry.yaml --edit --output-version=v1 -o json"
msgstr ""
"\n"
"\t\t# 使用在 pod.json 的 数据创建一个 pod.\n"
"\t\tkubectl create -f ./pod.json\n"
"\n"
"\t\t# 根据传入 stdin 的 JSON 创建一个 pod.\n"
"\t\tcat pod.json | kubectl create -f -\n"
"\n"
"\t\t# 使用 v1 API 格式在 JSON 中编辑在 docker-registry.yaml 中的数据然后使用被编辑后的数据创建资源.\n"
"\t\tkubectl create -f docker-registry.yaml --edit --output-version=v1 -o json"

#: pkg/kubectl/cmd/expose.go:53
msgid ""
"\n"
"\t\t# Create a service for a replicated nginx, which serves on port 80 and connects to the containers on port 8000.\n"
"\t\tkubectl expose rc nginx --port=80 --target-port=8000\n"
"\n"
"\t\t# Create a service for a replication controller identified by type and name specified in \"nginx-controller.yaml\", which serves on port 80 and connects to the containers on port 8000.\n"
"\t\tkubectl expose -f nginx-controller.yaml --port=80 --target-port=8000\n"
"\n"
"\t\t# Create a service for a pod valid-pod, which serves on port 444 with the name \"frontend\"\n"
"\t\tkubectl expose pod valid-pod --port=444 --name=frontend\n"
"\n"
"\t\t# Create a second service based on the above service, exposing the container port 8443 as port 443 with the name \"nginx-https\"\n"
"\t\tkubectl expose service nginx --port=443 --target-port=8443 --name=nginx-https\n"
"\n"
"\t\t# Create a service for a replicated streaming application on port 4100 balancing UDP traffic and named 'video-stream'.\n"
"\t\tkubectl expose rc streamer --port=4100 --protocol=udp --name=video-stream\n"
"\n"
"\t\t# Create a service for a replicated nginx using replica set, which serves on port 80 and connects to the containers on port 8000.\n"
"\t\tkubectl expose rs nginx --port=80 --target-port=8000\n"
"\n"
"\t\t# Create a service for an nginx deployment, which serves on port 80 and connects to the containers on port 8000.\n"
"\t\tkubectl expose deployment nginx --port=80 --target-port=8000"
msgstr ""
"\n"
"\t\t# 为一个 replicated nginx 创建一个 service, 服务在端口 80 并连接到 containers 的8000端口.\n"
"\t\tkubectl expose rc nginx --port=80 --target-port=8000\n"
"\n"
"\t\t# 使用在 \"nginx-controller.yaml\\ 中指定的 type 和 name 为一个replication controller 创建一个 service, 服务在端口 80 并连接到 containers 的8000端口.\n"
"\t\tkubectl expose -f nginx-controller.yaml --port=80 --target-port=8000\n"
"\n"
"\t\t# 为名为 valid-pod 的 pod 创建一个 service, 服务在端口 444 并命名为 \"frontend\" \n"
"\t\tkubectl expose pod valid-pod --port=444 --name=frontend\n"
"\n"
"\t\t# 基于上面的 service 创建第二个 service, 暴露容器端口 8443 并命名为 \"nginx-https\" 端口为 443 \n"
"\t\tkubectl expose service nginx --port=443 --target-port=8443 --name=nginx-https\n"
"\n"
"\t\t# 为一个名称为 streaming 的应用创建一个 service 暴露端口 4100, 协议为 UDP 名称为 'video-stream'.\n"
"\t\tkubectl expose rc streamer --port=4100 --protocol=udp --name=video-stream\n"
"\n"
"\t\t# 为一个名称为 nginx 的 replica set 创建一个 service, 服务在 端口 80 且连接到容器端口 8000.\n"
"\t\tkubectl expose rs nginx --port=80 --target-port=8000\n"
"\n"
"\t\t# 为一个名称为 nginx 的 deployment 创建一个 service, 服务在端口 80 且 连接到 containers 的 8000 端口.\n"
"\t\tkubectl expose deployment nginx --port=80 --target-port=8000"

#: pkg/kubectl/cmd/delete.go:68
msgid ""
"\n"
"\t\t# Delete a pod using the type and name specified in pod.json.\n"
"\t\tkubectl delete -f ./pod.json\n"
"\n"
"\t\t# Delete a pod based on the type and name in the JSON passed into stdin.\n"
"\t\tcat pod.json | kubectl delete -f -\n"
"\n"
"\t\t# Delete pods and services with same names \"baz\" and \"foo\"\n"
"\t\tkubectl delete pod,service baz foo\n"
"\n"
"\t\t# Delete pods and services with label name=myLabel.\n"
"\t\tkubectl delete pods,services -l name=myLabel\n"
"\n"
"\t\t# Delete a pod with minimal delay\n"
"\t\tkubectl delete pod foo --now\n"
"\n"
"\t\t# Force delete a pod on a dead node\n"
"\t\tkubectl delete pod foo --grace-period=0 --force\n"
"\n"
"\t\t# Delete all pods\n"
"\t\tkubectl delete pods --all"
msgstr ""
"\n"
"\t\t# 使用 pod.json 中的类型和名称删除一个 pod.\n"
"\t\tkubectl delete -f ./pod.json\n"
"\n"
"\t\t# 基于重定向到 stdin 中的 JSON 的类型和名称删除一个 pod.\n"
"\t\tcat pod.json | kubectl delete -f -\n"
"\n"
"\t\t# 删除名为 \"baz\" 和 \"foo\" 的 pod 和 service\n"
"\t\tkubectl delete pod,service baz foo\n"
"\n"
"\t\t# 删除标签为 name=myLabel 的 pods 和 services.\n"
"\t\tkubectl delete pods,services -l name=myLabel\n"
"\n"
"\t\t# 删除最小延迟的 pod\n"
"\t\tkubectl delete pod foo --now\n"
"\n"
"\t\t# 强制删除名为 foo 的 pod\n"
"\t\tkubectl delete pod foo --grace-period=0 --force\n"
"\n"
"\t\t# 删除所有 pods\n"
"\t\tkubectl delete pods --all"

#: pkg/kubectl/cmd/describe.go:54
msgid ""
"\n"
"\t\t# Describe a node\n"
"\t\tkubectl describe nodes kubernetes-node-emt8.c.myproject.internal\n"
"\n"
"\t\t# Describe a pod\n"
"\t\tkubectl describe pods/nginx\n"
"\n"
"\t\t# Describe a pod identified by type and name in \"pod.json\"\n"
"\t\tkubectl describe -f pod.json\n"
"\n"
"\t\t# Describe all pods\n"
"\t\tkubectl describe pods\n"
"\n"
"\t\t# Describe pods by label name=myLabel\n"
"\t\tkubectl describe po -l name=myLabel\n"
"\n"
"\t\t# Describe all pods managed by the 'frontend' replication controller (rc-created pods\n"
"\t\t# get the name of the rc as a prefix in the pod the name).\n"
"\t\tkubectl describe pods frontend"
msgstr ""
"\n"
"\t\t# 描述一个 node\n"
"\t\tkubectl describe nodes kubernetes-node-emt8.c.myproject.internal\n"
"\n"
"\t\t# 描述一个 pod\n"
"\t\tkubectl describe pods/nginx\n"
"\n"
"\t\t# 描述一个被 \"pod.json\" 中的类型和名称标识的 pod\n"
"\t\tkubectl describe -f pod.json\n"
"\n"
"\t\t# 描述所有 pods\n"
"\t\tkubectl describe pods\n"
"\n"
"\t\t# 描述标签为 name=myLabel 的 pods\n"
"\t\tkubectl describe po -l name=myLabel\n"
"\n"
"\t\t# 描述所有被名称为 'frontend' 的 replication controller 管理的 pods(rc-创建 pods\n"
"\t\t# 并使用 rc 的名称作为 pod 的前缀).\n"
"\t\tkubectl describe pods frontend"

#: pkg/kubectl/cmd/drain.go:165
msgid ""
"\n"
"\t\t# Drain node \"foo\", even if there are pods not managed by a ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet on it.\n"
"\t\t$ kubectl drain foo --force\n"
"\n"
"\t\t# As above, but abort if there are pods not managed by a ReplicationController, ReplicaSet, Job, DaemonSet 或者 StatefulSet, and use a grace period of 15 minutes.\n"
"\t\t$ kubectl drain foo --grace-period=900"
msgstr ""
"\n"
"\t\t# 驱逐节点 \"foo\", 即使很多 pods 没有被一个在 node 上的 ReplicationController, ReplicaSet, Job, DaemonSet 或者 StatefulSet 管理.\n"
"\t\t$ kubectl drain foo --force\n"
"\n"
"\t\t# 同上, 如果存在 pods 没有被一个 ReplicationController, ReplicaSet, Job, DaemonSet 或者 StatefulSet 管理超过 15 分钟则退出.\n"
"\t\t$ kubectl drain foo --grace-period=900"

#: pkg/kubectl/cmd/edit.go:80
msgid ""
"\n"
"\t\t# Edit the service named 'docker-registry':\n"
"\t\tkubectl edit svc/docker-registry\n"
"\n"
"\t\t# Use an alternative editor\n"
"\t\tKUBE_EDITOR=\"nano\" kubectl edit svc/docker-registry\n"
"\n"
"\t\t# Edit the job 'myjob' in JSON using the v1 API format:\n"
"\t\tkubectl edit job.v1.batch/myjob -o json\n"
"\n"
"\t\t# Edit the deployment 'mydeployment' in YAML and save the modified config in its annotation:\n"
"\t\tkubectl edit deployment/mydeployment -o yaml --save-config"
msgstr ""
"\n"
"\t\t# 编辑名为 'docker-registry' 的 service:\n"
"\t\tkubectl edit svc/docker-registry\n"
"\n"
"\t\t# 使用一个可选择的编辑器\n"
"\t\tKUBE_EDITOR=\"nano\" kubectl edit svc/docker-registry\n"
"\n"
"\t\t# 使用 v1 API 格式的 JSON 编辑名为 'myjob' 的 job:\n"
"\t\tkubectl edit job.v1.batch/myjob -o json\n"
"\n"
"\t\t# 在 YAML 中编辑名为 'mydeployment' 的 deployment 并在它的注解中保存修改后的配置:\n"
"\t\tkubectl edit deployment/mydeployment -o yaml --save-config"

#: pkg/kubectl/cmd/exec.go:41
msgid ""
"\n"
"\t\t# Get output from running 'date' from pod 123456-7890, using the first container by default\n"
"\t\tkubectl exec 123456-7890 date\n"
"\n"
"\t\t# Get output from running 'date' in ruby-container from pod 123456-7890\n"
"\t\tkubectl exec 123456-7890 -c ruby-container date\n"
"\n"
"\t\t# Switch to raw terminal mode, sends stdin to 'bash' in ruby-container from pod 123456-7890\n"
"\t\t# and sends stdout/stderr from 'bash' back to the client\n"
"\t\tkubectl exec 123456-7890 -c ruby-container -i -t -- bash -il"
msgstr ""
"\n"
"\t\t# 从运行中pod 123456-7890 获取执行 'date' 的输出, 默认使用第一个容器\n"
"\t\tkubectl exec 123456-7890 date\n"
"\n"
"\t\t# 从 pod 123456-7890 的容器 ruby-container 获取执行 'date' 的输出\n"
"\t\tkubectl exec 123456-7890 -c ruby-container date\n"
"\n"
"\t\t# 切换到 terminal 模式, 发送 stdin 到运行在 pod 123456-7890 的容器 ruby-container 'bash' \n"
"\t\t# 并从 'bash' 发送 stdout/stderr 返回到 client\n"
"\t\tkubectl exec 123456-7890 -c ruby-container -i -t -- bash -il"

#: pkg/kubectl/cmd/attach.go:42
msgid ""
"\n"
"\t\t# Get output from running pod 123456-7890, using the first container by default\n"
"\t\tkubectl attach 123456-7890\n"
"\n"
"\t\t# Get output from ruby-container from pod 123456-7890\n"
"\t\tkubectl attach 123456-7890 -c ruby-container\n"
"\n"
"\t\t# Switch to raw terminal mode, sends stdin to 'bash' in ruby-container from pod 123456-7890\n"
"\t\t# and sends stdout/stderr from 'bash' back to the client\n"
"\t\tkubectl attach 123456-7890 -c ruby-container -i -t\n"
"\n"
"\t\t# Get output from the first pod of a ReplicaSet named nginx\n"
"\t\tkubectl attach rs/nginx\n"
"\t\t"
msgstr ""
"\n"
"\t\t# 从运行中pod 123456-7890 获取执行 'date' 的输出, 默认使用第一个容器\n"
"\t\tkubectl attach 123456-7890\n"
"\n"
"\t\t# 从 pod 123456-7890 的容器 ruby-container 获取输出\n"
"\t\tkubectl attach 123456-7890 -c ruby-container\n"
"\n"
"\t\t# 切换到 terminal 模式, 发送 stdin 到运行在 pod 123456-7890 的容器 ruby-container 'bash' \n"
"\t\t# 并从 'bash' 发送 stdout/stderr 返回到 client\n"
"\t\tkubectl attach 123456-7890 -c ruby-container -i -t\n"
"\n"
"\t\t# 从名称为 nginx 的 ReplicaSet 获取第一个 pod 的输出\n"
"\t\tkubectl attach rs/nginx\n"
"\t\t"

#: pkg/kubectl/cmd/explain.go:39
msgid ""
"\n"
"\t\t# Get the documentation of the resource and its fields\n"
"\t\tkubectl explain pods\n"
"\n"
"\t\t# Get the documentation of a specific field of a resource\n"
"\t\tkubectl explain pods.spec.containers"
msgstr ""
"\n"
"\t\t# 获取资源及其字段的文档\n"
"\t\tkubectl explain pods\n"
"\n"
"\t\t# 获取资源指定字段的文档\n"
"\t\tkubectl explain pods.spec.containers"

#: pkg/kubectl/cmd/completion.go:65
msgid ""
"\n"
"\t\t# Install bash completion on a Mac using homebrew\n"
"\t\tbrew install bash-completion\n"
"\t\tprintf \"\n"
"# Bash completion support\n"
"source $(brew --prefix)/etc/bash_completion\n"
"\" >> $HOME/.bash_profile\n"
"\t\tsource $HOME/.bash_profile\n"
"\n"
"\t\t# Load the kubectl completion code for bash into the current shell\n"
"\t\tsource <(kubectl completion bash)\n"
"\n"
"\t\t# Write bash completion code to a file and source if from .bash_profile\n"
"\t\tkubectl completion bash > ~/.kube/completion.bash.inc\n"
"\t\tprintf \"\n"
"# Kubectl shell completion\n"
"source '$HOME/.kube/completion.bash.inc'\n"
"\" >> $HOME/.bash_profile\n"
"\t\tsource $HOME/.bash_profile\n"
"\n"
"\t\t# Load the kubectl completion code for zsh[1] into the current shell\n"
"\t\tsource <(kubectl completion zsh)"
msgstr ""
"\n"
"\t\t# 在一个 Mac 中使用 homebrew 安装 bash 补全\n"
"\t\tbrew install bash-completion\n"
"\t\tprintf \"\n"
"# Bash 补全支持\n"
"source $(brew --prefix)/etc/bash_completion\n"
"\" >> $HOME/.bash_profile\n"
"\t\tsource $HOME/.bash_profile\n"
"\n"
"\t\t# 导入 kubectl 补全代码到当前 shell\n"
"\t\tsource <(kubectl completion bash)\n"
"\n"
"\t\t# 写入 bash 补全代码到一个文件并 source 如果它是 .bash_profile\n"
"\t\tkubectl completion bash > ~/.kube/completion.bash.inc\n"
"\t\tprintf \"\n"
"# Kubectl shell 补全\n"
"source '$HOME/.kube/completion.bash.inc'\n"
"\" >> $HOME/.bash_profile\n"
"\t\tsource $HOME/.bash_profile\n"
"\n"
"\t\t# 为 zsh[1] 导入 kubectl 补全代码到当前 shell\n"
"\t\tsource <(kubectl completion zsh)"

#: pkg/kubectl/cmd/get.go:64
msgid ""
"\n"
"\t\t# List all pods in ps output format.\n"
"\t\tkubectl get pods\n"
"\n"
"\t\t# List all pods in ps output format with more information (such as node name).\n"
"\t\tkubectl get pods -o wide\n"
"\n"
"\t\t# List a single replication controller with specified NAME in ps output format.\n"
"\t\tkubectl get replicationcontroller web\n"
"\n"
"\t\t# List a single pod in JSON output format.\n"
"\t\tkubectl get -o json pod web-pod-13je7\n"
"\n"
"\t\t# List a pod identified by type and name specified in \"pod.yaml\" in JSON output format.\n"
"\t\tkubectl get -f pod.yaml -o json\n"
"\n"
"\t\t# Return only the phase value of the specified pod.\n"
"\t\tkubectl get -o template pod/web-pod-13je7 --template={{.status.phase}}\n"
"\n"
"\t\t# List all replication controllers and services together in ps output format.\n"
"\t\tkubectl get rc,services\n"
"\n"
"\t\t# List one or more resources by their type and names.\n"
"\t\tkubectl get rc/web service/frontend pods/web-pod-13je7\n"
"\n"
"\t\t# List all resources with different types.\n"
"\t\tkubectl get all"
msgstr ""
"\n"
"\t\t# 以 ps 输出格式列出所有 pod.\n"
"\t\tkubectl get pods\n"
"\n"
"\t\t# 以 ps 输出格式列出所有 pod(如节点名称).\n"
"\t\tkubectl get pods -o wide\n"
"\n"
"\t\t# 获取名称为 web 的 replicationcontroller.\n"
"\t\tkubectl get replicationcontroller web\n"
"\n"
"\t\t# 使用 JSON 格式化输出显示一个单独的 pod.\n"
"\t\tkubectl get -o json pod web-pod-13je7\n"
"\n"
"\t\t# 显示一个被 \"pod.yaml\" 中的 type 和 name 标识的 pod 并使用 JSON 格式化输出.\n"
"\t\tkubectl get -f pod.yaml -o json\n"
"\n"
"\t\t# 只返回被指定 pod 中 phase 的值.\n"
"\t\tkubectl get -o template pod/web-pod-13je7 --template={{.status.phase}}\n"
"\n"
"\t\t# 显示所有的 replication controllers 和 services 并格式化输出.\n"
"\t\tkubectl get rc,services\n"
"\n"
"\t\t# 显示一个或者更多 resources 通过它们的 type 和 names.\n"
"\t\tkubectl get rc/web service/frontend pods/web-pod-13je7\n"
"\n"
"\t\t# 使用不同的 types 显示所有 resources.\n"
"\t\tkubectl get all"

#: pkg/kubectl/cmd/portforward.go:53
msgid ""
"\n"
"\t\t# Listen on ports 5000 and 6000 locally, forwarding data to/from ports 5000 and 6000 in the pod\n"
"\t\tkubectl port-forward mypod 5000 6000\n"
"\n"
"\t\t# Listen on port 8888 locally, forwarding to 5000 in the pod\n"
"\t\tkubectl port-forward mypod 8888:5000\n"
"\n"
"\t\t# Listen on a random port locally, forwarding to 5000 in the pod\n"
"\t\tkubectl port-forward mypod :5000\n"
"\n"
"\t\t# Listen on a random port locally, forwarding to 5000 in the pod\n"
"\t\tkubectl port-forward mypod 0:5000"
msgstr ""
"\n"
"\t\t# 在本地监听端口 5000 和 6000 , forwarding 数据 to/from 在 pod 5000 和 6000 端口\n"
"\t\tkubectl port-forward mypod 5000 6000\n"
"\n"
"\t\t# 在本地监听端口 8888 , forwarding 到 pod 的 5000端口\n"
"\t\tkubectl port-forward mypod 8888:5000\n"
"\n"
"\t\t# 在本地随机监听一个端口 , forwarding 到 pod 的 5000端口\n"
"\t\tkubectl port-forward mypod :5000\n"
"\n"
"\t\t# 在本地随机监听一个端口 , forwarding 到 pod 的 5000端口\n"
"\t\tkubectl port-forward mypod 0:5000"

#: pkg/kubectl/cmd/drain.go:118
msgid ""
"\n"
"\t\t# Mark node \"foo\" as schedulable.\n"
"\t\t$ kubectl uncordon foo"
msgstr ""
"\n"
"\t\t# 标记 node \"foo\" 为 schedulable.\n"
"\t\t$ kubectl uncordon foo"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L102
#: pkg/kubectl/cmd/drain.go:93
msgid ""
"\n"
"\t\t# Mark node \"foo\" as unschedulable.\n"
"\t\tkubectl cordon foo"
msgstr ""
"\n"
"\t\t# 标记 node \"foo\" 为 unschedulable.\n"
"\t\tkubectl cordon foo"

#: pkg/kubectl/cmd/patch.go:66
msgid ""
"\n"
"\t\t# Partially update a node using strategic merge patch\n"
"\t\tkubectl patch node k8s-node-1 -p '{\"spec\":{\"unschedulable\":true}}'\n"
"\n"
"\t\t# Partially update a node identified by the type and name specified in \"node.json\" using strategic merge patch\n"
"\t\tkubectl patch -f node.json -p '{\"spec\":{\"unschedulable\":true}}'\n"
"\n"
"\t\t# Update a container's image; spec.containers[*].name is required because it's a merge key\n"
"\t\tkubectl patch pod valid-pod -p '{\"spec\":{\"containers\":[{\"name\":\"kubernetes-serve-hostname\",\"image\":\"new image\"}]}}'\n"
"\n"
"\t\t# Update a container's image using a json patch with positional arrays\n"
"\t\tkubectl patch pod valid-pod --type='json' -p='[{\"op\": \"replace\", \"path\": \"/spec/containers/0/image\", \"value\":\"new image\"}]'"
msgstr ""
"\n"
"\t\t# 使用 strategic merge patch 部分更新一个 node\n"
"\t\tkubectl patch node k8s-node-1 -p '{\"spec\":{\"unschedulable\":true}}'\n"
"\n"
"\t\t# 使用 strategic merge patch 部分更新一个被 \"node.json\" 的 type 和 name 标示  的 node.\n"
"\t\tkubectl patch -f node.json -p '{\"spec\":{\"unschedulable\":true}}'\n"
"\n"
"\t\t# 更新一个 container 的 image; spec.containers[*].name 是必须的 因为它是一个 merge key\n"
"\t\tkubectl patch pod valid-pod -p '{\"spec\":{\"containers\":[{\"name\":\"kubernetes-serve-hostname\",\"image\":\"new image\"}]}}'\n"
"\n"
"\t\t#  使用一个 json patch 更新一个指定坐标的 container 的 image \n"
"\t\tkubectl patch pod valid-pod --type='json' -p='[{\"op\": \"replace\", \"path\": \"/spec/containers/0/image\", \"value\":\"new image\"}]'"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/options.go#L37
#: pkg/kubectl/cmd/options.go:29
msgid ""
"\n"
"\t\t# Print flags inherited by all commands\n"
"\t\tkubectl options"
msgstr ""
"\n"
"\t\t# 输出所有命令继承的 flags\n"
"\t\tkubectl options"

#: pkg/kubectl/cmd/clusterinfo.go:41
msgid ""
"\n"
"\t\t# Print the address of the master and cluster services\n"
"\t\tkubectl cluster-info"
msgstr ""
"\n"
"\t\t# 输出 master 和 cluster services 的地址\n"
"\t\tkubectl cluster-info"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/version.go#L39
#: pkg/kubectl/cmd/version.go:32
msgid ""
"\n"
"\t\t# Print the client and server versions for the current context\n"
"\t\tkubectl version"
msgstr ""
"\n"
"\t\t# 输出当前 client 和 server 版本\n"
"\t\tkubectl version"

#: pkg/kubectl/cmd/apiversions.go:34
msgid ""
"\n"
"\t\t# Print the supported API versions\n"
"\t\tkubectl api-versions"
msgstr ""
"\n"
"\t\t# 输出支持的 API 版本\n"
"\t\tkubectl api-versions"

#: pkg/kubectl/cmd/replace.go:50
msgid ""
"\n"
"\t\t# Replace a pod using the data in pod.json.\n"
"\t\tkubectl replace -f ./pod.json\n"
"\n"
"\t\t# Replace a pod based on the JSON passed into stdin.\n"
"\t\tcat pod.json | kubectl replace -f -\n"
"\n"
"\t\t# Update a single-container pod's image version (tag) to v4\n"
"\t\tkubectl get pod mypod -o yaml | sed 's/\\(image: myimage\\):.*$/:v4/' | kubectl replace -f -\n"
"\n"
"\t\t# Force replace, delete and then re-create the resource\n"
"\t\tkubectl replace --force -f ./pod.json"
msgstr ""
"\n"
"\t\t# 使用在 pod.json 中的数据替换一个 pod.\n"
"\t\tkubectl replace -f ./pod.json\n"
"\n"
"\t\t# 基于被重定向到 stdin 中的 JSON 替换一个 pod.\n"
"\t\tcat pod.json | kubectl replace -f -\n"
"\n"
"\t\t# 更新一个单独容器的 pod 的 image 版本 (tag) 到 v4\n"
"\t\tkubectl get pod mypod -o yaml | sed 's/\\(image: myimage\\):.*$/:v4/' | kubectl replace -f -\n"
"\n"
"\t\t# 强制替换, 删除然后重新创建这个 resource\n"
"\t\tkubectl replace --force -f ./pod.json"

#: pkg/kubectl/cmd/logs.go:40
msgid ""
"\n"
"\t\t# Return snapshot logs from pod nginx with only one container\n"
"\t\tkubectl logs nginx\n"
"\n"
"\t\t# Return snapshot logs for the pods defined by label app=nginx\n"
"\t\tkubectl logs -lapp=nginx\n"
"\n"
"\t\t# Return snapshot of previous terminated ruby container logs from pod web-1\n"
"\t\tkubectl logs -p -c ruby web-1\n"
"\n"
"\t\t# Begin streaming the logs of the ruby container in pod web-1\n"
"\t\tkubectl logs -f -c ruby web-1\n"
"\n"
"\t\t# Display only the most recent 20 lines of output in pod nginx\n"
"\t\tkubectl logs --tail=20 nginx\n"
"\n"
"\t\t# Show all logs from pod nginx written in the last hour\n"
"\t\tkubectl logs --since=1h nginx\n"
"\n"
"\t\t# Return snapshot logs from first container of a job named hello\n"
"\t\tkubectl logs job/hello\n"
"\n"
"\t\t# Return snapshot logs from container nginx-1 of a deployment named nginx\n"
"\t\tkubectl logs deployment/nginx -c nginx-1"
msgstr ""
"\n"
"\t\t# 返回仅有一个容器 pod 名称为 nginx 的 snapshot 日志\n"
"\t\tkubectl logs nginx\n"
"\n"
"\t\t# 返回 label 为 app=nginx 的 pods 的 snapshot 日志\n"
"\t\tkubectl logs -lapp=nginx\n"
"\n"
"\t\t# Return snapshot of previous terminated ruby container logs from pod web-1\n"
"\t\tkubectl logs -p -c ruby web-1\n"
"\n"
"\t\t# Begin streaming the logs of the ruby container in pod web-1\n"
"\t\tkubectl logs -f -c ruby web-1\n"
"\n"
"\t\t# Display only the most recent 20 lines of output in pod nginx\n"
"\t\tkubectl logs --tail=20 nginx\n"
"\n"
"\t\t# Show all logs from pod nginx written in the last hour\n"
"\t\tkubectl logs --since=1h nginx\n"
"\n"
"\t\t# Return snapshot logs from first container of a job named hello\n"
"\t\tkubectl logs job/hello\n"
"\n"
"\t\t# Return snapshot logs from container nginx-1 of a deployment named nginx\n"
"\t\tkubectl logs deployment/nginx -c nginx-1"

#: pkg/kubectl/cmd/proxy.go:53
msgid ""
"\n"
"\t\t# Run a proxy to kubernetes apiserver on port 8011, serving static content from ./local/www/\n"
"\t\tkubectl proxy --port=8011 --www=./local/www/\n"
"\n"
"\t\t# Run a proxy to kubernetes apiserver on an arbitrary local port.\n"
"\t\t# The chosen port for the server will be output to stdout.\n"
"\t\tkubectl proxy --port=0\n"
"\n"
"\t\t# Run a proxy to kubernetes apiserver, changing the api prefix to k8s-api\n"
"\t\t# This makes e.g. the pods api available at localhost:8001/k8s-api/v1/pods/\n"
"\t\tkubectl proxy --api-prefix=/k8s-api"
msgstr ""
"\n"
"\t\t# 运行 proxy 到 kubernetes apiserver 的 8011 端口上, 服务静态内容路径为 ./local/www/\n"
"\t\tkubectl proxy --port=8011 --www=./local/www/\n"
"\n"
"\t\t# 在任意的本地端口上运行一个 proxy 到 kubernetes apiserver.\n"
"\t\t# 为这个 server 挑选的端口将会被输出到 stdout.\n"
"\t\tkubectl proxy --port=0\n"
"\n"
"\t\t# 运行一个 proxy 到 kubernetes apiserver, 修改 api prefix 为 k8s-api\n"
"\t\t# 这会使 e.g. 这个 pods 的有效 api 为 localhost:8001/k8s-api/v1/pods/\n"
"\t\tkubectl proxy --api-prefix=/k8s-api"

#: pkg/kubectl/cmd/scale.go:43
msgid ""
"\n"
"\t\t# Scale a replicaset named 'foo' to 3.\n"
"\t\tkubectl scale --replicas=3 rs/foo\n"
"\n"
"\t\t# Scale a resource identified by type and name specified in \"foo.yaml\" to 3.\n"
"\t\tkubectl scale --replicas=3 -f foo.yaml\n"
"\n"
"\t\t# If the deployment named mysql's current size is 2, scale mysql to 3.\n"
"\t\tkubectl scale --current-replicas=2 --replicas=3 deployment/mysql\n"
"\n"
"\t\t# Scale multiple replication controllers.\n"
"\t\tkubectl scale --replicas=5 rc/foo rc/bar rc/baz\n"
"\n"
"\t\t# Scale job named 'cron' to 3.\n"
"\t\tkubectl scale --replicas=3 job/cron"
msgstr ""
"\n"
"\t\t# Scale 一个名称为 ‘foo’ 的 replicaset 服本数为 3.\n"
"\t\tkubectl scale --replicas=3 rs/foo\n"
"\n"
"\t\t# Scale 指定的 \"foo.yaml\" 的 type 和 name 标识的 resource 副本数量为 3.\n"
"\t\tkubectl scale --replicas=3 -f foo.yaml\n"
"\n"
"\t\t# 如果名称为 mysql 的 deployment 当前副本数量为 2, scale mysql 到 3.\n"
"\t\tkubectl scale --current-replicas=2 --replicas=3 deployment/mysql\n"
"\n"
"\t\t# Scale 多个 replication controllers.\n"
"\t\tkubectl scale --replicas=5 rc/foo rc/bar rc/baz\n"
"\n"
"\t\t# Scale 名称为 ’cron’ 的 job 副本数量为 3.\n"
"\t\tkubectl scale --replicas=3 job/cron"

#: pkg/kubectl/cmd/apply_set_last_applied.go:67
msgid ""
"\n"
"\t\t# Set the last-applied-configuration of a resource to match the contents of a file.\n"
"\t\tkubectl apply set-last-applied -f deploy.yaml\n"
"\n"
"\t\t# Execute set-last-applied against each configuration file in a directory.\n"
"\t\tkubectl apply set-last-applied -f path/\n"
"\n"
"\t\t# Set the last-applied-configuration of a resource to match the contents of a file, will create the annotation if it does not already exist.\n"
"\t\tkubectl apply set-last-applied -f deploy.yaml --create-annotation=true\n"
"\t\t"
msgstr ""
"\n"
"\t\t# 设置一个资源的 last-applied-configuration 去匹配一个文件的内容.\n"
"\t\tkubectl apply set-last-applied -f deploy.yaml\n"
"\n"
"\t\t# Execute set-last-applied against each configuration file in a directory.\n"
"\t\tkubectl apply set-last-applied -f path/\n"
"\n"
"\t\t# 设置一个资源的 last-applied-configuration 去匹配一个文件的内容, 如果不存在将会创建一个 annotation.\n"
"\t\tkubectl apply set-last-applied -f deploy.yaml --create-annotation=true\n"
"\t\t"

#: pkg/kubectl/cmd/top_pod.go:61
msgid ""
"\n"
"\t\t# Show metrics for all pods in the default namespace\n"
"\t\tkubectl top pod\n"
"\n"
"\t\t# Show metrics for all pods in the given namespace\n"
"\t\tkubectl top pod --namespace=NAMESPACE\n"
"\n"
"\t\t# Show metrics for a given pod and its containers\n"
"\t\tkubectl top pod POD_NAME --containers\n"
"\n"
"\t\t# Show metrics for the pods defined by label name=myLabel\n"
"\t\tkubectl top pod -l name=myLabel"
msgstr ""
"\n"
"\t\t# 显示 default namespace 下所有 pods 下的 metrics\n"
"\t\tkubectl top pod\n"
"\n"
"\t\t# 显示指定 namespace 下所有 pods 的 metrics\n"
"\t\tkubectl top pod --namespace=NAMESPACE\n"
"\n"
"\t\t# 显示指定 pod 和它的容器的 metrics\n"
"\t\tkubectl top pod POD_NAME --containers\n"
"\n"
"\t\t# 显示指定 label 为 name=myLabel 的 pods 的 metrics\n"
"\t\tkubectl top pod -l name=myLabel"

#: pkg/kubectl/cmd/stop.go:40
msgid ""
"\n"
"\t\t# Shut down foo.\n"
"\t\tkubectl stop replicationcontroller foo\n"
"\n"
"\t\t# Stop pods and services with label name=myLabel.\n"
"\t\tkubectl stop pods,services -l name=myLabel\n"
"\n"
"\t\t# Shut down the service defined in service.json\n"
"\t\tkubectl stop -f service.json\n"
"\n"
"\t\t# Shut down all resources in the path/to/resources directory\n"
"\t\tkubectl stop -f path/to/resources"
msgstr ""
"\n"
"\t\t# Shut down foo.\n"
"\t\tkubectl stop replicationcontroller foo\n"
"\n"
"\t\t# Stop pods and services with label name=myLabel.\n"
"\t\tkubectl stop pods,services -l name=myLabel\n"
"\n"
"\t\t# Shut down the service defined in service.json\n"
"\t\tkubectl stop -f service.json\n"
"\n"
"\t\t# Shut down all resources in the path/to/resources directory\n"
"\t\tkubectl stop -f path/to/resources"

#: pkg/kubectl/cmd/run.go:57
msgid ""
"\n"
"\t\t# Start a single instance of nginx.\n"
"\t\tkubectl run nginx --image=nginx\n"
"\n"
"\t\t# Start a single instance of hazelcast and let the container expose port 5701 .\n"
"\t\tkubectl run hazelcast --image=hazelcast --port=5701\n"
"\n"
"\t\t# Start a single instance of hazelcast and set environment variables \"DNS_DOMAIN=cluster\" and \"POD_NAMESPACE=default\" in the container.\n"
"\t\tkubectl run hazelcast --image=hazelcast --env=\"DNS_DOMAIN=cluster\" --env=\"POD_NAMESPACE=default\"\n"
"\n"
"\t\t# Start a replicated instance of nginx.\n"
"\t\tkubectl run nginx --image=nginx --replicas=5\n"
"\n"
"\t\t# Dry run. Print the corresponding API objects without creating them.\n"
"\t\tkubectl run nginx --image=nginx --dry-run\n"
"\n"
"\t\t# Start a single instance of nginx, but overload the spec of the deployment with a partial set of values parsed from JSON.\n"
"\t\tkubectl run nginx --image=nginx --overrides='{ \"apiVersion\": \"v1\", \"spec\": { ... } }'\n"
"\n"
"\t\t# Start a pod of busybox and keep it in the foreground, don't restart it if it exits.\n"
"\t\tkubectl run -i -t busybox --image=busybox --restart=Never\n"
"\n"
"\t\t# Start the nginx container using the default command, but use custom arguments (arg1 .. argN) for that command.\n"
"\t\tkubectl run nginx --image=nginx -- <arg1> <arg2> ... <argN>\n"
"\n"
"\t\t# Start the nginx container using a different command and custom arguments.\n"
"\t\tkubectl run nginx --image=nginx --command -- <cmd> <arg1> ... <argN>\n"
"\n"
"\t\t# Start the perl container to compute π to 2000 places and print it out.\n"
"\t\tkubectl run pi --image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'\n"
"\n"
"\t\t# Start the cron job to compute π to 2000 places and print it out every 5 minutes.\n"
"\t\tkubectl run pi --schedule=\"0/5 * * * ?\" --image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'"
msgstr ""
"\n"
"\t\t# Start a single instance of nginx.\n"
"\t\tkubectl run nginx --image=nginx\n"
"\n"
"\t\t# Start a single instance of hazelcast and let the container expose port 5701 .\n"
"\t\tkubectl run hazelcast --image=hazelcast --port=5701\n"
"\n"
"\t\t# Start a single instance of hazelcast and set environment variables \"DNS_DOMAIN=cluster\" and \"POD_NAMESPACE=default\" in the container.\n"
"\t\tkubectl run hazelcast --image=hazelcast --env=\"DNS_DOMAIN=cluster\" --env=\"POD_NAMESPACE=default\"\n"
"\n"
"\t\t# Start a replicated instance of nginx.\n"
"\t\tkubectl run nginx --image=nginx --replicas=5\n"
"\n"
"\t\t# Dry run. Print the corresponding API objects without creating them.\n"
"\t\tkubectl run nginx --image=nginx --dry-run\n"
"\n"
"\t\t# Start a single instance of nginx, but overload the spec of the deployment with a partial set of values parsed from JSON.\n"
"\t\tkubectl run nginx --image=nginx --overrides='{ \"apiVersion\": \"v1\", \"spec\": { ... } }'\n"
"\n"
"\t\t# Start a pod of busybox and keep it in the foreground, don't restart it if it exits.\n"
"\t\tkubectl run -i -t busybox --image=busybox --restart=Never\n"
"\n"
"\t\t# Start the nginx container using the default command, but use custom arguments (arg1 .. argN) for that command.\n"
"\t\tkubectl run nginx --image=nginx -- <arg1> <arg2> ... <argN>\n"
"\n"
"\t\t# Start the nginx container using a different command and custom arguments.\n"
"\t\tkubectl run nginx --image=nginx --command -- <cmd> <arg1> ... <argN>\n"
"\n"
"\t\t# Start the perl container to compute π to 2000 places and print it out.\n"
"\t\tkubectl run pi --image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'\n"
"\n"
"\t\t# Start the cron job to compute π to 2000 places and print it out every 5 minutes.\n"
"\t\tkubectl run pi --schedule=\"0/5 * * * ?\" --image=perl --restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'"

#: pkg/kubectl/cmd/taint.go:67
msgid ""
"\n"
"\t\t# Update node 'foo' with a taint with key 'dedicated' and value 'special-user' and effect 'NoSchedule'.\n"
"\t\t# If a taint with that key and effect already exists, its value is replaced as specified.\n"
"\t\tkubectl taint nodes foo dedicated=special-user:NoSchedule\n"
"\n"
"\t\t# Remove from node 'foo' the taint with key 'dedicated' and effect 'NoSchedule' if one exists.\n"
"\t\tkubectl taint nodes foo dedicated:NoSchedule-\n"
"\n"
"\t\t# Remove from node 'foo' all the taints with key 'dedicated'\n"
"\t\tkubectl taint nodes foo dedicated-"
msgstr ""
"\n"
"\t\t# Update node 'foo' with a taint with key 'dedicated' and value 'special-user' and effect 'NoSchedule'.\n"
"\t\t# If a taint with that key and effect already exists, its value is replaced as specified.\n"
"\t\tkubectl taint nodes foo dedicated=special-user:NoSchedule\n"
"\n"
"\t\t# Remove from node 'foo' the taint with key 'dedicated' and effect 'NoSchedule' if one exists.\n"
"\t\tkubectl taint nodes foo dedicated:NoSchedule-\n"
"\n"
"\t\t# Remove from node 'foo' all the taints with key 'dedicated'\n"
"\t\tkubectl taint nodes foo dedicated-"

#: pkg/kubectl/cmd/label.go:77
msgid ""
"\n"
"\t\t# Update pod 'foo' with the label 'unhealthy' and the value 'true'.\n"
"\t\tkubectl label pods foo unhealthy=true\n"
"\n"
"\t\t# Update pod 'foo' with the label 'status' and the value 'unhealthy', overwriting any existing value.\n"
"\t\tkubectl label --overwrite pods foo status=unhealthy\n"
"\n"
"\t\t# Update all pods in the namespace\n"
"\t\tkubectl label pods --all status=unhealthy\n"
"\n"
"\t\t# Update a pod identified by the type and name in \"pod.json\"\n"
"\t\tkubectl label -f pod.json status=unhealthy\n"
"\n"
"\t\t# Update pod 'foo' only if the resource is unchanged from version 1.\n"
"\t\tkubectl label pods foo status=unhealthy --resource-version=1\n"
"\n"
"\t\t# Update pod 'foo' by removing a label named 'bar' if it exists.\n"
"\t\t# Does not require the --overwrite flag.\n"
"\t\tkubectl label pods foo bar-"
msgstr ""
"\n"
"\t\t# Update pod 'foo' with the label 'unhealthy' and the value 'true'.\n"
"\t\tkubectl label pods foo unhealthy=true\n"
"\n"
"\t\t# Update pod 'foo' with the label 'status' and the value 'unhealthy', overwriting any existing value.\n"
"\t\tkubectl label --overwrite pods foo status=unhealthy\n"
"\n"
"\t\t# Update all pods in the namespace\n"
"\t\tkubectl label pods --all status=unhealthy\n"
"\n"
"\t\t# Update a pod identified by the type and name in \"pod.json\"\n"
"\t\tkubectl label -f pod.json status=unhealthy\n"
"\n"
"\t\t# Update pod 'foo' only if the resource is unchanged from version 1.\n"
"\t\tkubectl label pods foo status=unhealthy --resource-version=1\n"
"\n"
"\t\t# Update pod 'foo' by removing a label named 'bar' if it exists.\n"
"\t\t# Does not require the --overwrite flag.\n"
"\t\tkubectl label pods foo bar-"

#: pkg/kubectl/cmd/rollingupdate.go:54
msgid ""
"\n"
"\t\t# Update pods of frontend-v1 using new replication controller data in frontend-v2.json.\n"
"\t\tkubectl rolling-update frontend-v1 -f frontend-v2.json\n"
"\n"
"\t\t# Update pods of frontend-v1 using JSON data passed into stdin.\n"
"\t\tcat frontend-v2.json | kubectl rolling-update frontend-v1 -f -\n"
"\n"
"\t\t# Update the pods of frontend-v1 to frontend-v2 by just changing the image, and switching the\n"
"\t\t# name of the replication controller.\n"
"\t\tkubectl rolling-update frontend-v1 frontend-v2 --image=image:v2\n"
"\n"
"\t\t# Update the pods of frontend by just changing the image, and keeping the old name.\n"
"\t\tkubectl rolling-update frontend --image=image:v2\n"
"\n"
"\t\t# Abort and reverse an existing rollout in progress (from frontend-v1 to frontend-v2).\n"
"\t\tkubectl rolling-update frontend-v1 frontend-v2 --rollback"
msgstr ""
"\n"
"\t\t# Update pods of frontend-v1 using new replication controller data in frontend-v2.json.\n"
"\t\tkubectl rolling-update frontend-v1 -f frontend-v2.json\n"
"\n"
"\t\t# Update pods of frontend-v1 using JSON data passed into stdin.\n"
"\t\tcat frontend-v2.json | kubectl rolling-update frontend-v1 -f -\n"
"\n"
"\t\t# Update the pods of frontend-v1 to frontend-v2 by just changing the image, and switching the\n"
"\t\t# name of the replication controller.\n"
"\t\tkubectl rolling-update frontend-v1 frontend-v2 --image=image:v2\n"
"\n"
"\t\t# Update the pods of frontend by just changing the image, and keeping the old name.\n"
"\t\tkubectl rolling-update frontend --image=image:v2\n"
"\n"
"\t\t# Abort and reverse an existing rollout in progress (from frontend-v1 to frontend-v2).\n"
"\t\tkubectl rolling-update frontend-v1 frontend-v2 --rollback"

#: pkg/kubectl/cmd/apply_view_last_applied.go:52
msgid ""
"\n"
"\t\t# View the last-applied-configuration annotations by type/name in YAML.\n"
"\t\tkubectl apply view-last-applied deployment/nginx\n"
"\n"
"\t\t# View the last-applied-configuration annotations by file in JSON\n"
"\t\tkubectl apply view-last-applied -f deploy.yaml -o json"
msgstr ""
"\n"
"\t\t# View the last-applied-configuration annotations by type/name in YAML.\n"
"\t\tkubectl apply view-last-applied deployment/nginx\n"
"\n"
"\t\t# View the last-applied-configuration annotations by file in JSON\n"
"\t\tkubectl apply view-last-applied -f deploy.yaml -o json"

#: pkg/kubectl/cmd/apply.go:75
msgid ""
"\n"
"\t\tApply a configuration to a resource by filename or stdin.\n"
"\t\tThis resource will be created if it doesn't exist yet.\n"
"\t\tTo use 'apply', always create the resource initially with either 'apply' or 'create --save-config'.\n"
"\n"
"\t\tJSON and YAML formats are accepted.\n"
"\n"
"\t\tAlpha Disclaimer: the --prune functionality is not yet complete. Do not use unless you are aware of what the current state is. See https://issues.k8s.io/34274."
msgstr ""
"\n"
"\t\t通过文件名或标准输入流(stdin)对资源进行配置.\n"
"\t\tThis resource will be created if it doesn't exist yet.\n"
"\t\tTo use 'apply', always create the resource initially with either 'apply' or 'create --save-config'.\n"
"\n"
"\t\tJSON and YAML formats are accepted.\n"
"\n"
"\t\tAlpha Disclaimer: the --prune functionality is not yet complete. Do not use unless you are aware of what the current state is. See https://issues.k8s.io/34274."

#: pkg/kubectl/cmd/convert.go:38
msgid ""
"\n"
"\t\tConvert config files between different API versions. Both YAML\n"
"\t\tand JSON formats are accepted.\n"
"\n"
"\t\tThe command takes filename, directory, or URL as input, and convert it into format\n"
"\t\tof version specified by --output-version flag. If target version is not specified or\n"
"\t\tnot supported, convert to latest version.\n"
"\n"
"\t\tThe default output will be printed to stdout in YAML format. One can use -o option\n"
"\t\tto change to output destination."
msgstr ""
"\n"
"\t\t在不同的 API versions 转换配置文件. 接受 YAML\n"
"\t\t和 JSON 格式.\n"
"\n"
"\t\t这个命令以 filename, directory, 或者 URL 作为输入, 并通过 —output-version flag\n"
"\t\t 转换到指定版本的格式. 如果目标版本没有被指定或者\n"
"\t\t不支持, 转换到最后的版本.\n"
"\n"
"\t\t默认以 YAML 格式输出到 stdout. 可以使用 -o option\n"
"\t\t修改目标输出的格式."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L68
#: pkg/kubectl/cmd/create_clusterrole.go:31
msgid ""
"\n"
"\t\tCreate a ClusterRole."
msgstr ""
"\n"
"\t\t创建一个 ClusterRole."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_clusterrolebinding.go#L43
#: pkg/kubectl/cmd/create_clusterrolebinding.go:32
msgid ""
"\n"
"\t\tCreate a ClusterRoleBinding for a particular ClusterRole."
msgstr ""
"\n"
"\t\t 为指定的 ClusterRole 创建一个 ClusterRoleBinding."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_rolebinding.go#L43
#: pkg/kubectl/cmd/create_rolebinding.go:32
msgid ""
"\n"
"\t\tCreate a RoleBinding for a particular Role or ClusterRole."
msgstr ""
"\n"
"\t\t为指定的 Role 或者 ClusterRole 创建一个 RoleBinding."

#: pkg/kubectl/cmd/create_secret.go:200
msgid ""
"\n"
"\t\tCreate a TLS secret from the given public/private key pair.\n"
"\n"
"\t\tThe public/private key pair must exist before hand. The public key certificate must be .PEM encoded and match the given private key."
msgstr ""
"\n"
"\t\t为指定的 public/private key pair 创建一个 TLS secret.\n"
"\n"
"\t\tpublic/private key pair 必须在传递前存在. public key certificate 必须以 .PEM 被编码且匹配指定的 private key."

#: pkg/kubectl/cmd/create_configmap.go:32
msgid ""
"\n"
"\t\tCreate a configmap based on a file, directory, or specified literal value.\n"
"\n"
"\t\tA single configmap may package one or more key/value pairs.\n"
"\n"
"\t\tWhen creating a configmap based on a file, the key will default to the basename of the file, and the value will\n"
"\t\tdefault to the file content.  If the basename is an invalid key, you may specify an alternate key.\n"
"\n"
"\t\tWhen creating a configmap based on a directory, each file whose basename is a valid key in the directory will be\n"
"\t\tpackaged into the configmap.  Any directory entries except regular files are ignored (e.g. subdirectories,\n"
"\t\tsymlinks, devices, pipes, etc)."
msgstr ""
"\n"
"\t\tCreate a configmap based on a file, directory, or specified literal value.\n"
"\n"
"\t\tA single configmap may package one or more key/value pairs.\n"
"\n"
"\t\tWhen creating a configmap based on a file, the key will default to the basename of the file, and the value will\n"
"\t\tdefault to the file content.  If the basename is an invalid key, you may specify an alternate key.\n"
"\n"
"\t\tWhen creating a configmap based on a directory, each file whose basename is a valid key in the directory will be\n"
"\t\tpackaged into the configmap.  Any directory entries except regular files are ignored (e.g. subdirectories,\n"
"\t\tsymlinks, devices, pipes, etc)."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_namespace.go#L44
#: pkg/kubectl/cmd/create_namespace.go:32
msgid ""
"\n"
"\t\tCreate a namespace with the specified name."
msgstr ""
"\n"
"\t\t创建一个 namespace 并指定名称."

#: pkg/kubectl/cmd/create_secret.go:119
msgid ""
"\n"
"\t\tCreate a new secret for use with Docker registries.\n"
"\n"
"\t\tDockercfg secrets are used to authenticate against Docker registries.\n"
"\n"
"\t\tWhen using the Docker command line to push images, you can authenticate to a given registry by running\n"
"\n"
"\t\t    $ docker login DOCKER_REGISTRY_SERVER --username=DOCKER_USER --password=DOCKER_PASSWORD --email=DOCKER_EMAIL'.\n"
"\n"
"    That produces a ~/.dockercfg file that is used by subsequent 'docker push' and 'docker pull' commands to\n"
"\t\tauthenticate to the registry. The email address is optional.\n"
"\n"
"\t\tWhen creating applications, you may have a Docker registry that requires authentication.  In order for the\n"
"\t\tnodes to pull images on your behalf, they have to have the credentials.  You can provide this information\n"
"\t\tby creating a dockercfg secret and attaching it to your service account."
msgstr ""
"\n"
"\t\tCreate a new secret for use with Docker registries.\n"
"\n"
"\t\tDockercfg secrets are used to authenticate against Docker registries.\n"
"\n"
"\t\tWhen using the Docker command line to push images, you can authenticate to a given registry by running\n"
"\n"
"\t\t    $ docker login DOCKER_REGISTRY_SERVER --username=DOCKER_USER --password=DOCKER_PASSWORD --email=DOCKER_EMAIL'.\n"
"\n"
"    That produces a ~/.dockercfg file that is used by subsequent 'docker push' and 'docker pull' commands to\n"
"\t\tauthenticate to the registry. The email address is optional.\n"
"\n"
"\t\tWhen creating applications, you may have a Docker registry that requires authentication.  In order for the\n"
"\t\tnodes to pull images on your behalf, they have to have the credentials.  You can provide this information\n"
"\t\tby creating a dockercfg secret and attaching it to your service account."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_pdb.go#L49
#: pkg/kubectl/cmd/create_pdb.go:32
msgid ""
"\n"
"\t\tCreate a pod disruption budget with the specified name, selector, and desired minimum available pods"
msgstr ""
"\n"
"\t\tCreate a pod disruption budget with the specified name, selector, and desired minimum available pods"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create.go#L56
#: pkg/kubectl/cmd/create.go:42
msgid ""
"\n"
"\t\tCreate a resource by filename or stdin.\n"
"\n"
"\t\tJSON and YAML formats are accepted."
msgstr ""
"\n"
"\t\t通过文件名或者标准输入流(stdin)创建一个资源.\n"
"\n"
"\t\tJSON and YAML formats are accepted."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L47
#: pkg/kubectl/cmd/create_quota.go:32
msgid ""
"\n"
"\t\tCreate a resourcequota with the specified name, hard limits and optional scopes"
msgstr ""
"\n"
"\t\tCreate a resourcequota with the specified name, hard limits and optional scopes"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L47
#: pkg/kubectl/cmd/create_role.go:38
msgid ""
"\n"
"\t\tCreate a role with single rule."
msgstr ""
"\n"
"\t\t创建单一 rule 的 role."

#: pkg/kubectl/cmd/create_secret.go:47
msgid ""
"\n"
"\t\tCreate a secret based on a file, directory, or specified literal value.\n"
"\n"
"\t\tA single secret may package one or more key/value pairs.\n"
"\n"
"\t\tWhen creating a secret based on a file, the key will default to the basename of the file, and the value will\n"
"\t\tdefault to the file content.  If the basename is an invalid key, you may specify an alternate key.\n"
"\n"
"\t\tWhen creating a secret based on a directory, each file whose basename is a valid key in the directory will be\n"
"\t\tpackaged into the secret.  Any directory entries except regular files are ignored (e.g. subdirectories,\n"
"\t\tsymlinks, devices, pipes, etc)."
msgstr ""
"\n"
"\t\tCreate a secret based on a file, directory, or specified literal value.\n"
"\n"
"\t\tA single secret may package one or more key/value pairs.\n"
"\n"
"\t\tWhen creating a secret based on a file, the key will default to the basename of the file, and the value will\n"
"\t\tdefault to the file content.  If the basename is an invalid key, you may specify an alternate key.\n"
"\n"
"\t\tWhen creating a secret based on a directory, each file whose basename is a valid key in the directory will be\n"
"\t\tpackaged into the secret.  Any directory entries except regular files are ignored (e.g. subdirectories,\n"
"\t\tsymlinks, devices, pipes, etc)."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_serviceaccount.go#L44
#: pkg/kubectl/cmd/create_serviceaccount.go:32
msgid ""
"\n"
"\t\tCreate a service account with the specified name."
msgstr ""
"\n"
"\t\t创建一个指定名称的 service account."

#: pkg/kubectl/cmd/run.go:52
msgid ""
"\n"
"\t\tCreate and run a particular image, possibly replicated.\n"
"\n"
"\t\tCreates a deployment or job to manage the created container(s)."
msgstr ""
"\n"
"\t\tCreate and run a particular image, possibly replicated.\n"
"\n"
"\t\tCreates a deployment or job to manage the created container(s)."

#: pkg/kubectl/cmd/autoscale.go:34
msgid ""
"\n"
"\t\tCreates an autoscaler that automatically chooses and sets the number of pods that run in a kubernetes cluster.\n"
"\n"
"\t\tLooks up a Deployment, ReplicaSet, or ReplicationController by name and creates an autoscaler that uses the given resource as a reference.\n"
"\t\tAn autoscaler can automatically increase or decrease number of pods deployed within the system as needed."
msgstr ""
"\n"
"\t\tCreates an autoscaler that automatically chooses and sets the number of pods that run in a kubernetes cluster.\n"
"\n"
"\t\tLooks up a Deployment, ReplicaSet, or ReplicationController by name and creates an autoscaler that uses the given resource as a reference.\n"
"\t\tAn autoscaler can automatically increase or decrease number of pods deployed within the system as needed."

#: pkg/kubectl/cmd/delete.go:40
msgid ""
"\n"
"\t\tDelete resources by filenames, stdin, resources and names, or by resources and label selector.\n"
"\n"
"\t\tJSON and YAML formats are accepted. Only one type of the arguments may be specified: filenames,\n"
"\t\tresources and names, or resources and label selector.\n"
"\n"
"\t\tSome resources, such as pods, support graceful deletion. These resources define a default period\n"
"\t\tbefore they are forcibly terminated (the grace period) but you may override that value with\n"
"\t\tthe --grace-period flag, or pass --now to set a grace-period of 1. Because these resources often\n"
"\t\trepresent entities in the cluster, deletion may not be acknowledged immediately. If the node\n"
"\t\thosting a pod is down or cannot reach the API server, termination may take significantly longer\n"
"\t\tthan the grace period. To force delete a resource,\tyou must pass a grace\tperiod of 0 and specify\n"
"\t\tthe --force flag.\n"
"\n"
"\t\tIMPORTANT: Force deleting pods does not wait for confirmation that the pod's processes have been\n"
"\t\tterminated, which can leave those processes running until the node detects the deletion and\n"
"\t\tcompletes graceful deletion. If your processes use shared storage or talk to a remote API and\n"
"\t\tdepend on the name of the pod to identify themselves, force deleting those pods may result in\n"
"\t\tmultiple processes running on different machines using the same identification which may lead\n"
"\t\tto data corruption or inconsistency. Only force delete pods when you are sure the pod is\n"
"\t\tterminated, or if your application can tolerate multiple copies of the same pod running at once.\n"
"\t\tAlso, if you force delete pods the scheduler may place new pods on those nodes before the node\n"
"\t\thas released those resources and causing those pods to be evicted immediately.\n"
"\n"
"\t\tNote that the delete command does NOT do resource version checks, so if someone\n"
"\t\tsubmits an update to a resource right when you submit a delete, their update\n"
"\t\twill be lost along with the rest of the resource."
msgstr ""
"\n"
"\t\tDelete resources by filenames, stdin, resources and names, or by resources and label selector.\n"
"\n"
"\t\tJSON and YAML formats are accepted. Only one type of the arguments may be specified: filenames,\n"
"\t\tresources and names, or resources and label selector.\n"
"\n"
"\t\tSome resources, such as pods, support graceful deletion. These resources define a default period\n"
"\t\tbefore they are forcibly terminated (the grace period) but you may override that value with\n"
"\t\tthe --grace-period flag, or pass --now to set a grace-period of 1. Because these resources often\n"
"\t\trepresent entities in the cluster, deletion may not be acknowledged immediately. If the node\n"
"\t\thosting a pod is down or cannot reach the API server, termination may take significantly longer\n"
"\t\tthan the grace period. To force delete a resource,\tyou must pass a grace\tperiod of 0 and specify\n"
"\t\tthe --force flag.\n"
"\n"
"\t\tIMPORTANT: Force deleting pods does not wait for confirmation that the pod's processes have been\n"
"\t\tterminated, which can leave those processes running until the node detects the deletion and\n"
"\t\tcompletes graceful deletion. If your processes use shared storage or talk to a remote API and\n"
"\t\tdepend on the name of the pod to identify themselves, force deleting those pods may result in\n"
"\t\tmultiple processes running on different machines using the same identification which may lead\n"
"\t\tto data corruption or inconsistency. Only force delete pods when you are sure the pod is\n"
"\t\tterminated, or if your application can tolerate multiple copies of the same pod running at once.\n"
"\t\tAlso, if you force delete pods the scheduler may place new pods on those nodes before the node\n"
"\t\thas released those resources and causing those pods to be evicted immediately.\n"
"\n"
"\t\tNote that the delete command does NOT do resource version checks, so if someone\n"
"\t\tsubmits an update to a resource right when you submit a delete, their update\n"
"\t\twill be lost along with the rest of the resource."

#: pkg/kubectl/cmd/stop.go:31
msgid ""
"\n"
"\t\tDeprecated: Gracefully shut down a resource by name or filename.\n"
"\n"
"\t\tThe stop command is deprecated, all its functionalities are covered by delete command.\n"
"\t\tSee 'kubectl delete --help' for more details.\n"
"\n"
"\t\tAttempts to shut down and delete a resource that supports graceful termination.\n"
"\t\tIf the resource is scalable it will be scaled to 0 before deletion."
msgstr ""
"\n"
"\t\tDeprecated: Gracefully shut down a resource by name or filename.\n"
"\n"
"\t\tThe stop command is deprecated, all its functionalities are covered by delete command.\n"
"\t\tSee 'kubectl delete --help' for more details.\n"
"\n"
"\t\tAttempts to shut down and delete a resource that supports graceful termination.\n"
"\t\tIf the resource is scalable it will be scaled to 0 before deletion."

#: pkg/kubectl/cmd/top_node.go:60
msgid ""
"\n"
"\t\tDisplay Resource (CPU/Memory/Storage) usage of nodes.\n"
"\n"
"\t\tThe top-node command allows you to see the resource consumption of nodes."
msgstr ""
"\n"
"\t\t显示 node 的资源(CPU/Memory/Storage)使用.\n"
"\n"
"\t\tThe top-node command allows you to see the resource consumption of nodes."

#: pkg/kubectl/cmd/top_pod.go:53
msgid ""
"\n"
"\t\tDisplay Resource (CPU/Memory/Storage) usage of pods.\n"
"\n"
"\t\tThe 'top pod' command allows you to see the resource consumption of pods.\n"
"\n"
"\t\tDue to the metrics pipeline delay, they may be unavailable for a few minutes\n"
"\t\tsince pod creation."
msgstr ""
"\n"
"\t\t显示 pods 资源(CPU/Memory/Storage)使用.\n"
"\n"
"\t\tThe 'top pod' command allows you to see the resource consumption of pods.\n"
"\n"
"\t\tDue to the metrics pipeline delay, they may be unavailable for a few minutes\n"
"\t\tsince pod creation."

#: pkg/kubectl/cmd/top.go:33
msgid ""
"\n"
"\t\tDisplay Resource (CPU/Memory/Storage) usage.\n"
"\n"
"\t\tThe top command allows you to see the resource consumption for nodes or pods.\n"
"\n"
"\t\tThis command requires Heapster to be correctly configured and working on the server. "
msgstr ""
"\n"
"\t\t显示资源(CPU/Memory/Storage)使用.\n"
"\n"
"\t\tThe top command allows you to see the resource consumption for nodes or pods.\n"
"\n"
"\t\tThis command requires Heapster to be correctly configured and working on the server. "

#: pkg/kubectl/cmd/drain.go:140
msgid ""
"\n"
"\t\tDrain node in preparation for maintenance.\n"
"\n"
"\t\tThe given node will be marked unschedulable to prevent new pods from arriving.\n"
"\t\t'drain' evicts the pods if the APIServer supports eviction\n"
"\t\t(http://kubernetes.io/docs/admin/disruptions/). Otherwise, it will use normal DELETE\n"
"\t\tto delete the pods.\n"
"\t\tThe 'drain' evicts or deletes all pods except mirror pods (which cannot be deleted through\n"
"\t\tthe API server).  If there are DaemonSet-managed pods, drain will not proceed\n"
"\t\twithout --ignore-daemonsets, and regardless it will not delete any\n"
"\t\tDaemonSet-managed pods, because those pods would be immediately replaced by the\n"
"\t\tDaemonSet controller, which ignores unschedulable markings.  If there are any\n"
"\t\tpods that are neither mirror pods nor managed by ReplicationController,\n"
"\t\tReplicaSet, DaemonSet, StatefulSet or Job, then drain will not delete any pods unless you\n"
"\t\tuse --force.  --force will also allow deletion to proceed if the managing resource of one\n"
"\t\tor more pods is missing.\n"
"\n"
"\t\t'drain' waits for graceful termination. You should not operate on the machine until\n"
"\t\tthe command completes.\n"
"\n"
"\t\tWhen you are ready to put the node back into service, use kubectl uncordon, which\n"
"\t\twill make the node schedulable again.\n"
"\n"
"\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_drain.svg)"
msgstr ""
"\n"
"\t\t清理节点为节点维护做准备.\n"
"\n"
"\t\tThe given node will be marked unschedulable to prevent new pods from arriving.\n"
"\t\t'drain' evicts the pods if the APIServer supports eviction\n"
"\t\t(http://kubernetes.io/docs/admin/disruptions/). Otherwise, it will use normal DELETE\n"
"\t\tto delete the pods.\n"
"\t\tThe 'drain' evicts or deletes all pods except mirror pods (which cannot be deleted through\n"
"\t\tthe API server).  If there are DaemonSet-managed pods, drain will not proceed\n"
"\t\twithout --ignore-daemonsets, and regardless it will not delete any\n"
"\t\tDaemonSet-managed pods, because those pods would be immediately replaced by the\n"
"\t\tDaemonSet controller, which ignores unschedulable markings.  If there are any\n"
"\t\tpods that are neither mirror pods nor managed by ReplicationController,\n"
"\t\tReplicaSet, DaemonSet, StatefulSet or Job, then drain will not delete any pods unless you\n"
"\t\tuse --force.  --force will also allow deletion to proceed if the managing resource of one\n"
"\t\tor more pods is missing.\n"
"\n"
"\t\t'drain' waits for graceful termination. You should not operate on the machine until\n"
"\t\tthe command completes.\n"
"\n"
"\t\tWhen you are ready to put the node back into service, use kubectl uncordon, which\n"
"\t\twill make the node schedulable again.\n"
"\n"
"\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_drain.svg)"

#: pkg/kubectl/cmd/edit.go:56
msgid ""
"\n"
"\t\tEdit a resource from the default editor.\n"
"\n"
"\t\tThe edit command allows you to directly edit any API resource you can retrieve via the\n"
"\t\tcommand line tools. It will open the editor defined by your KUBE_EDITOR, or EDITOR\n"
"\t\tenvironment variables, or fall back to 'vi' for Linux or 'notepad' for Windows.\n"
"\t\tYou can edit multiple objects, although changes are applied one at a time. The command\n"
"\t\taccepts filenames as well as command line arguments, although the files you point to must\n"
"\t\tbe previously saved versions of resources.\n"
"\n"
"\t\tEditing is done with the API version used to fetch the resource.\n"
"\t\tTo edit using a specific API version, fully-qualify the resource, version, and group.\n"
"\n"
"\t\tThe default format is YAML. To edit in JSON, specify \"-o json\".\n"
"\n"
"\t\tThe flag --windows-line-endings can be used to force Windows line endings,\n"
"\t\totherwise the default for your operating system will be used.\n"
"\n"
"\t\tIn the event an error occurs while updating, a temporary file will be created on disk\n"
"\t\tthat contains your unapplied changes. The most common error when updating a resource\n"
"\t\tis another editor changing the resource on the server. When this occurs, you will have\n"
"\t\tto apply your changes to the newer version of the resource, or update your temporary\n"
"\t\tsaved copy to include the latest resource version."
msgstr ""
"\n"
"\t\t使用默认的编辑器修改资源.\n"
"\n"
"\t\tedit 命令允许你通过命令行直接修改 API 资源.\n"
"\t\t它会打开你在 KUBE_EDITOR 或者EDITOR 环境变量中定义的编辑器\n"
"\t\t或者回滚到 Linux vi 编辑器或者 Windows notepad.\n"
"\t\t你可以修改多个对象, 虽然每次只能修改一次. 这个命令\n"
"\t\t同时也接受文件名作为命令行参数, 尽管这些文件你指出必须是\n"
"\t\t你之前保存的资源版本.\n"
"\n"
"\t\tEditing 是通过用于获取资源的API版本完成的.\n"
"\t\t为了能通过指定的 API 版本修改, 请完全限定 resource, version 和 group.\n"
"\n"
"\t\t默认是 YAML 格式. 想在 JSON 中修改, 指定 \"-o json\".\n"
"\n"
"\t\t--windows-line-endings 命令行参数可以用来强制使用 Windows line endings,\n"
"\t\t否则会使用你操作系统的默认值.\n"
"\n"
"\t\t如果更新时发生错误，将在磁盘上创建一个临时文件\n"
"\t\t里面包含您未应用的更改. 更新资源时最常见的错误\n"
"\t\t是另一个编辑器也在服务器中修改这个资源. 当发生这种情况时, 你将\n"
"\t\t需要应用你的修改到资源的最新版本, 或者更新你被保存的临时文件\n"
"\t\t复制它并使用最新的版本."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L127
#: pkg/kubectl/cmd/drain.go:115
msgid ""
"\n"
"\t\tMark node as schedulable."
msgstr ""
"\n"
"\t\t标记 node 为 schedulable."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L102
#: pkg/kubectl/cmd/drain.go:90
msgid ""
"\n"
"\t\tMark node as unschedulable."
msgstr ""
"\n"
"\t\t标记 node 为 unschedulable."

#: pkg/kubectl/cmd/completion.go:47
msgid ""
"\n"
"\t\tOutput shell completion code for the specified shell (bash or zsh).\n"
"\t\tThe shell code must be evaluated to provide interactive\n"
"\t\tcompletion of kubectl commands.  This can be done by sourcing it from\n"
"\t\tthe .bash_profile.\n"
"\n"
"\t\tNote: this requires the bash-completion framework, which is not installed\n"
"\t\tby default on Mac.  This can be installed by using homebrew:\n"
"\n"
"\t\t    $ brew install bash-completion\n"
"\n"
"\t\tOnce installed, bash_completion must be evaluated.  This can be done by adding the\n"
"\t\tfollowing line to the .bash_profile\n"
"\n"
"\t\t    $ source $(brew --prefix)/etc/bash_completion\n"
"\n"
"\t\tNote for zsh users: [1] zsh completions are only supported in versions of zsh >= 5.2"
msgstr ""
"\n"
"\t\tOutput shell completion code for the specified shell (bash or zsh).\n"
"\t\tThe shell code must be evaluated to provide interactive\n"
"\t\tcompletion of kubectl commands.  This can be done by sourcing it from\n"
"\t\tthe .bash_profile.\n"
"\n"
"\t\tNote: this requires the bash-completion framework, which is not installed\n"
"\t\tby default on Mac.  This can be installed by using homebrew:\n"
"\n"
"\t\t    $ brew install bash-completion\n"
"\n"
"\t\tOnce installed, bash_completion must be evaluated.  This can be done by adding the\n"
"\t\tfollowing line to the .bash_profile\n"
"\n"
"\t\t    $ source $(brew --prefix)/etc/bash_completion\n"
"\n"
"\t\tNote for zsh users: [1] zsh completions are only supported in versions of zsh >= 5.2"

#: pkg/kubectl/cmd/rollingupdate.go:45
msgid ""
"\n"
"\t\tPerform a rolling update of the given ReplicationController.\n"
"\n"
"\t\tReplaces the specified replication controller with a new replication controller by updating one pod at a time to use the\n"
"\t\tnew PodTemplate. The new-controller.json must specify the same namespace as the\n"
"\t\texisting replication controller and overwrite at least one (common) label in its replicaSelector.\n"
"\n"
"\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_rollingupdate.svg)"
msgstr ""
"\n"
"\t\t完成指定的 ReplicationController 的滚动升级.\n"
"\n"
"\t\tReplaces the specified replication controller with a new replication controller by updating one pod at a time to use the\n"
"\t\tnew PodTemplate. The new-controller.json must specify the same namespace as the\n"
"\t\texisting replication controller and overwrite at least one (common) label in its replicaSelector.\n"
"\n"
"\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_rollingupdate.svg)"

#: pkg/kubectl/cmd/replace.go:40
msgid ""
"\n"
"\t\tReplace a resource by filename or stdin.\n"
"\n"
"\t\tJSON and YAML formats are accepted. If replacing an existing resource, the\n"
"\t\tcomplete resource spec must be provided. This can be obtained by\n"
"\n"
"\t\t    $ kubectl get TYPE NAME -o yaml\n"
msgstr ""
"\n"
"\t\tReplace a resource by filename or stdin.\n"
"\n"
"\t\tJSON and YAML formats are accepted. If replacing an existing resource, the\n"
"\t\tcomplete resource spec must be provided. This can be obtained by\n"
"\n"
"\t\t    $ kubectl get TYPE NAME -o yaml\n"

#: pkg/kubectl/cmd/scale.go:34
msgid ""
"\n"
"\t\tSet a new size for a Deployment, ReplicaSet, Replication Controller, or Job.\n"
"\n"
"\t\tScale also allows users to specify one or more preconditions for the scale action.\n"
"\n"
"\t\tIf --current-replicas or --resource-version is specified, it is validated before the\n"
"\t\tscale is attempted, and it is guaranteed that the precondition holds true when the\n"
"\t\tscale is sent to the server."
msgstr ""
"\n"
"\t\tSet a new size for a Deployment, ReplicaSet, Replication Controller, or Job.\n"
"\n"
"\t\tScale also allows users to specify one or more preconditions for the scale action.\n"
"\n"
"\t\tIf --current-replicas or --resource-version is specified, it is validated before the\n"
"\t\tscale is attempted, and it is guaranteed that the precondition holds true when the\n"
"\t\tscale is sent to the server."

#: pkg/kubectl/cmd/apply_set_last_applied.go:62
msgid ""
"\n"
"\t\tSet the latest last-applied-configuration annotations by setting it to match the contents of a file.\n"
"\t\tThis results in the last-applied-configuration being updated as though 'kubectl apply -f <file>' was run,\n"
"\t\twithout updating any other parts of the object."
msgstr ""
"\n"
"\t\tSet the latest last-applied-configuration annotations by setting it to match the contents of a file.\n"
"\t\tThis results in the last-applied-configuration being updated as though 'kubectl apply -f <file>' was run,\n"
"\t\twithout updating any other parts of the object."

#: pkg/kubectl/cmd/proxy.go:36
msgid ""
"\n"
"\t\tTo proxy all of the kubernetes api and nothing else, use:\n"
"\n"
"\t\t    $ kubectl proxy --api-prefix=/\n"
"\n"
"\t\tTo proxy only part of the kubernetes api and also some static files:\n"
"\n"
"\t\t    $ kubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/api/\n"
"\n"
"\t\tThe above lets you 'curl localhost:8001/api/v1/pods'.\n"
"\n"
"\t\tTo proxy the entire kubernetes api at a different root, use:\n"
"\n"
"\t\t    $ kubectl proxy --api-prefix=/custom/\n"
"\n"
"\t\tThe above lets you 'curl localhost:8001/custom/api/v1/pods'"
msgstr ""
"\n"
"\t\tTo proxy all of the kubernetes api and nothing else, use:\n"
"\n"
"\t\t    $ kubectl proxy --api-prefix=/\n"
"\n"
"\t\tTo proxy only part of the kubernetes api and also some static files:\n"
"\n"
"\t\t    $ kubectl proxy --www=/my/files --www-prefix=/static/ --api-prefix=/api/\n"
"\n"
"\t\tThe above lets you 'curl localhost:8001/api/v1/pods'.\n"
"\n"
"\t\tTo proxy the entire kubernetes api at a different root, use:\n"
"\n"
"\t\t    $ kubectl proxy --api-prefix=/custom/\n"
"\n"
"\t\tThe above lets you 'curl localhost:8001/custom/api/v1/pods'"

#: pkg/kubectl/cmd/patch.go:59
msgid ""
"\n"
"\t\tUpdate field(s) of a resource using strategic merge patch\n"
"\n"
"\t\tJSON and YAML formats are accepted.\n"
msgstr ""
"\n"
"\t\tUpdate field(s) of a resource using strategic merge patch\n"
"\n"
"\t\tJSON and YAML formats are accepted.\n"

#: pkg/kubectl/cmd/label.go:70
#, c-format
msgid ""
"\n"
"\t\tUpdate the labels on a resource.\n"
"\n"
"\t\t* A label must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
"\t\t* If --overwrite is true, then existing labels can be overwritten, otherwise attempting to overwrite a label will result in an error.\n"
"\t\t* If --resource-version is specified, then updates will use this resource version, otherwise the existing resource-version will be used."
msgstr ""
"\n"
"\t\tUpdate the labels on a resource.\n"
"\n"
"\t\t* A label must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
"\t\t* If --overwrite is true, then existing labels can be overwritten, otherwise attempting to overwrite a label will result in an error.\n"
"\t\t* If --resource-version is specified, then updates will use this resource version, otherwise the existing resource-version will be used."

#: pkg/kubectl/cmd/taint.go:58
#, c-format
msgid ""
"\n"
"\t\tUpdate the taints on one or more nodes.\n"
"\n"
"\t\t* A taint consists of a key, value, and effect. As an argument here, it is expressed as key=value:effect.\n"
"\t\t* The key must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
"\t\t* The value must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[2]d characters.\n"
"\t\t* The effect must be NoSchedule, PreferNoSchedule or NoExecute.\n"
"\t\t* Currently taint can only apply to node."
msgstr ""
"\n"
"\t\t更新一个或者多个 node 上的 taints.\n"
"\n"
"\t\t* A taint consists of a key, value, and effect. As an argument here, it is expressed as key=value:effect.\n"
"\t\t* The key must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
"\t\t* The value must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores, up to %[2]d characters.\n"
"\t\t* The effect must be NoSchedule, PreferNoSchedule or NoExecute.\n"
"\t\t* Currently taint can only apply to node."

#: pkg/kubectl/cmd/apply_view_last_applied.go:46
msgid ""
"\n"
"\t\tView the latest last-applied-configuration annotations by type/name or file.\n"
"\n"
"\t\tThe default output will be printed to stdout in YAML format. One can use -o option\n"
"\t\tto change output format."
msgstr ""
"\n"
"\t\tView the latest last-applied-configuration annotations by type/name or file.\n"
"\n"
"\t\tThe default output will be printed to stdout in YAML format. One can use -o option\n"
"\t\tto change output format."

#: pkg/kubectl/cmd/cp.go:37
msgid ""
"\n"
"\t    # !!!Important Note!!!\n"
"\t    # Requires that the 'tar' binary is present in your container\n"
"\t    # image.  If 'tar' is not present, 'kubectl cp' will fail.\n"
"\n"
"\t    # Copy /tmp/foo_dir local directory to /tmp/bar_dir in a remote pod in the default namespace\n"
"\t\tkubectl cp /tmp/foo_dir <some-pod>:/tmp/bar_dir\n"
"\n"
"        # Copy /tmp/foo local file to /tmp/bar in a remote pod in a specific container\n"
"\t\tkubectl cp /tmp/foo <some-pod>:/tmp/bar -c <specific-container>\n"
"\n"
"\t\t# Copy /tmp/foo local file to /tmp/bar in a remote pod in namespace <some-namespace>\n"
"\t\tkubectl cp /tmp/foo <some-namespace>/<some-pod>:/tmp/bar\n"
"\n"
"\t\t# Copy /tmp/foo from a remote pod to /tmp/bar locally\n"
"\t\tkubectl cp <some-namespace>/<some-pod>:/tmp/foo /tmp/bar"
msgstr ""
"\n"
"\t    # !!!注意!!!\n"
"\t    # 要求容器中有 'tar' 命令\n"
"\t    # image.  If 'tar' is not present, 'kubectl cp' will fail.\n"
"\n"
"\t    # 复制本地目录 /tmp/foo_dir 到 default namespace 下的远程 pod 的 /tmp/bar_dir 路径 \n"
"\t\tkubectl cp /tmp/foo_dir <some-pod>:/tmp/bar_dir\n"
"\n"
"        # 复制 /tmp/foo local 本地文件到指定远程 pod 的指定容器的 /tmp/bar 路径\n"
"\t\tkubectl cp /tmp/foo <some-pod>:/tmp/bar -c <specific-container>\n"
"\n"
"\t\t# 复制 /tmp/foo 本地文件到在 namespace <some-namespace> 下的某个 pod 的 /tmp/bar 路径\n"
"\t\tkubectl cp /tmp/foo <some-namespace>/<some-pod>:/tmp/bar\n"
"\n"
"\t\t# 从一个远程的 pod 的 /tmp/foo 路径复制到本地 /tmp/bar 路径\n"
"\t\tkubectl cp <some-namespace>/<some-pod>:/tmp/foo /tmp/bar"

#: pkg/kubectl/cmd/create_secret.go:205
msgid ""
"\n"
"\t  # Create a new TLS secret named tls-secret with the given key pair:\n"
"\t  kubectl create secret tls tls-secret --cert=path/to/tls.cert --key=path/to/tls.key"
msgstr ""
"\n"
"\t  # 使用提供的 key pair 名称为tls-secret 的 secret:\n"
"\t  kubectl create secret tls tls-secret --cert=path/to/tls.cert --key=path/to/tls.key"

#: pkg/kubectl/cmd/create_namespace.go:35
msgid ""
"\n"
"\t  # Create a new namespace named my-namespace\n"
"\t  kubectl create namespace my-namespace"
msgstr ""
"\n"
"\t  # 创建一个名称为 my-namespace 的 namespace\n"
"\t  kubectl create namespace my-namespace"

#: pkg/kubectl/cmd/create_secret.go:59
msgid ""
"\n"
"\t  # Create a new secret named my-secret with keys for each file in folder bar\n"
"\t  kubectl create secret generic my-secret --from-file=path/to/bar\n"
"\n"
"\t  # Create a new secret named my-secret with specified keys instead of names on disk\n"
"\t  kubectl create secret generic my-secret --from-file=ssh-privatekey=~/.ssh/id_rsa --from-file=ssh-publickey=~/.ssh/id_rsa.pub\n"
"\n"
"\t  # Create a new secret named my-secret with key1=supersecret and key2=topsecret\n"
"\t  kubectl create secret generic my-secret --from-literal=key1=supersecret --from-literal=key2=topsecret"
msgstr ""
"\n"
"\t  # Create a new secret named my-secret with keys for each file in folder bar\n"
"\t  kubectl create secret generic my-secret --from-file=path/to/bar\n"
"\n"
"\t  # Create a new secret named my-secret with specified keys instead of names on disk\n"
"\t  kubectl create secret generic my-secret --from-file=ssh-privatekey=~/.ssh/id_rsa --from-file=ssh-publickey=~/.ssh/id_rsa.pub\n"
"\n"
"\t  # Create a new secret named my-secret with key1=supersecret and key2=topsecret\n"
"\t  kubectl create secret generic my-secret --from-literal=key1=supersecret --from-literal=key2=topsecret"

#: pkg/kubectl/cmd/create_serviceaccount.go:35
msgid ""
"\n"
"\t  # Create a new service account named my-service-account\n"
"\t  kubectl create serviceaccount my-service-account"
msgstr ""
"\n"
"\t  # Create a new service account named my-service-account\n"
"\t  kubectl create serviceaccount my-service-account"

#: pkg/kubectl/cmd/create_service.go:232
msgid ""
"\n"
"\t# Create a new ExternalName service named my-ns \n"
"\tkubectl create service externalname my-ns --external-name bar.com"
msgstr ""
"\n"
"\t# Create a new ExternalName service named my-ns \n"
"\tkubectl create service externalname my-ns --external-name bar.com"

#: pkg/kubectl/cmd/create_service.go:225
msgid ""
"\n"
"\tCreate an ExternalName service with the specified name.\n"
"\n"
"\tExternalName service references to an external DNS address instead of\n"
"\tonly pods, which will allow application authors to reference services\n"
"\tthat exist off platform, on other clusters, or locally."
msgstr ""
"\n"
"\tCreate an ExternalName service with the specified name.\n"
"\n"
"\tExternalName service references to an external DNS address instead of\n"
"\tonly pods, which will allow application authors to reference services\n"
"\tthat exist off platform, on other clusters, or locally."

#: pkg/kubectl/cmd/help.go:30
msgid ""
"\n"
"\tHelp provides help for any command in the application.\n"
"\tSimply type kubectl help [path to command] for full details."
msgstr ""
"\n"
"\tHelp provides help for any command in the application.\n"
"\tSimply type kubectl help [path to command] for full details."

#: pkg/kubectl/cmd/create_service.go:173
msgid ""
"\n"
"    # Create a new LoadBalancer service named my-lbs\n"
"    kubectl create service loadbalancer my-lbs --tcp=5678:8080"
msgstr ""
"\n"
"    # 创建一个名称为 my-lbs 的 LoadBalancer service\n"
"    kubectl create service loadbalancer my-lbs --tcp=5678:8080"

#: pkg/kubectl/cmd/create_service.go:53
msgid ""
"\n"
"    # Create a new clusterIP service named my-cs\n"
"    kubectl create service clusterip my-cs --tcp=5678:8080\n"
"\n"
"    # Create a new clusterIP service named my-cs (in headless mode)\n"
"    kubectl create service clusterip my-cs --clusterip=\"None\""
msgstr ""
"\n"
"    # 创建一个名称为 my-cs 的 clusterIP service\n"
"    kubectl create service clusterip my-cs --tcp=5678:8080\n"
"\n"
"    # 创建一个名称为 my-cs 的 clusterIP service (在 headless 模式)\n"
"    kubectl create service clusterip my-cs --clusterip=\"None\""

#: pkg/kubectl/cmd/create_deployment.go:36
msgid ""
"\n"
"    # Create a new deployment named my-dep that runs the busybox image.\n"
"    kubectl create deployment my-dep --image=busybox"
msgstr ""
"\n"
"    # 创建一个名称为 my-dep 的 deployment 并运行 busybox image.\n"
"    kubectl create deployment my-dep --image=busybox"

#: pkg/kubectl/cmd/create_service.go:116
msgid ""
"\n"
"    # Create a new nodeport service named my-ns\n"
"    kubectl create service nodeport my-ns --tcp=5678:8080"
msgstr ""
"\n"
"    # 创建一个名称为 my-ns 的 nodeport service\n"
"    kubectl create service nodeport my-ns --tcp=5678:8080"

#: pkg/kubectl/cmd/clusterinfo_dump.go:62
msgid ""
"\n"
"    # Dump current cluster state to stdout\n"
"    kubectl cluster-info dump\n"
"\n"
"    # Dump current cluster state to /path/to/cluster-state\n"
"    kubectl cluster-info dump --output-directory=/path/to/cluster-state\n"
"\n"
"    # Dump all namespaces to stdout\n"
"    kubectl cluster-info dump --all-namespaces\n"
"\n"
"    # Dump a set of namespaces to /path/to/cluster-state\n"
"    kubectl cluster-info dump --namespaces default,kube-system --output-directory=/path/to/cluster-state"
msgstr ""
"\n"
"    # 导出当前的集群状态信息到 stdout\n"
"    kubectl cluster-info dump\n"
"\n"
"    # 导出当前的集群状态 /path/to/cluster-state\n"
"    kubectl cluster-info dump --output-directory=/path/to/cluster-state\n"
"\n"
"    # 导出所有分区到 stdout\n"
"    kubectl cluster-info dump --all-namespaces\n"
"\n"
"    # 导出一组分区到 /path/to/cluster-state\n"
"    kubectl cluster-info dump --namespaces default,kube-system --output-directory=/path/to/cluster-state"

#: pkg/kubectl/cmd/annotate.go:78
msgid ""
"\n"
"    # Update pod 'foo' with the annotation 'description' and the value 'my frontend'.\n"
"    # If the same annotation is set multiple times, only the last value will be applied\n"
"    kubectl annotate pods foo description='my frontend'\n"
"\n"
"    # Update a pod identified by type and name in \"pod.json\"\n"
"    kubectl annotate -f pod.json description='my frontend'\n"
"\n"
"    # Update pod 'foo' with the annotation 'description' and the value 'my frontend running nginx', overwriting any existing value.\n"
"    kubectl annotate --overwrite pods foo description='my frontend running nginx'\n"
"\n"
"    # Update all pods in the namespace\n"
"    kubectl annotate pods --all description='my frontend running nginx'\n"
"\n"
"    # Update pod 'foo' only if the resource is unchanged from version 1.\n"
"    kubectl annotate pods foo description='my frontend running nginx' --resource-version=1\n"
"\n"
"    # Update pod 'foo' by removing an annotation named 'description' if it exists.\n"
"    # Does not require the --overwrite flag.\n"
"    kubectl annotate pods foo description-"
msgstr ""
"\n"
"    # Update pod 'foo' with the annotation 'description' and the value 'my frontend'.\n"
"    # If the same annotation is set multiple times, only the last value will be applied\n"
"    kubectl annotate pods foo description='my frontend'\n"
"\n"
"    # Update a pod identified by type and name in \"pod.json\"\n"
"    kubectl annotate -f pod.json description='my frontend'\n"
"\n"
"    # Update pod 'foo' with the annotation 'description' and the value 'my frontend running nginx', overwriting any existing value.\n"
"    kubectl annotate --overwrite pods foo description='my frontend running nginx'\n"
"\n"
"    # Update all pods in the namespace\n"
"    kubectl annotate pods --all description='my frontend running nginx'\n"
"\n"
"    # Update pod 'foo' only if the resource is unchanged from version 1.\n"
"    kubectl annotate pods foo description='my frontend running nginx' --resource-version=1\n"
"\n"
"    # 更新名称为 'foo' 的 pod, 删除一个名称为 'description' 的 annotation 如果它存在. \n"
"    # 不要求使用 --overwrite flag.\n"
"    kubectl annotate pods foo description-"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_namespace.go#L44
#: pkg/kubectl/cmd/create_service.go:170
msgid ""
"\n"
"    Create a LoadBalancer service with the specified name."
msgstr ""
"\n"
"    使用一个指定的名称创建一个 LoadBalancer service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_serviceaccount.go#L44
#: pkg/kubectl/cmd/create_service.go:50
msgid ""
"\n"
"    Create a clusterIP service with the specified name."
msgstr ""
"\n"
"    使用一个指定的名称创建一个 clusterIP service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_deployment.go#L44
#: pkg/kubectl/cmd/create_deployment.go:33
msgid ""
"\n"
"    Create a deployment with the specified name."
msgstr ""
"\n"
"    使用一个指定的名称创建一个 deployment."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_deployment.go#L44
#: pkg/kubectl/cmd/create_service.go:113
msgid ""
"\n"
"    Create a nodeport service with the specified name."
msgstr ""
"\n"
"    使用一个指定的名称创建一个 nodeport service."

#: pkg/kubectl/cmd/clusterinfo_dump.go:53
msgid ""
"\n"
"    Dumps cluster info out suitable for debugging and diagnosing cluster problems.  By default, dumps everything to\n"
"    stdout. You can optionally specify a directory with --output-directory.  If you specify a directory, kubernetes will\n"
"    build a set of files in that directory.  By default only dumps things in the 'kube-system' namespace, but you can\n"
"    switch to a different namespace with the --namespaces flag, or specify --all-namespaces to dump all namespaces.\n"
"\n"
"    The command also dumps the logs of all of the pods in the cluster, these logs are dumped into different directories\n"
"    based on namespace and pod name."
msgstr ""
"\n"
"    Dumps cluster info out suitable for debugging and diagnosing cluster problems.  By default, dumps everything to\n"
"    stdout. You can optionally specify a directory with --output-directory.  If you specify a directory, kubernetes will\n"
"    build a set of files in that directory.  By default only dumps things in the 'kube-system' namespace, but you can\n"
"    switch to a different namespace with the --namespaces flag, or specify --all-namespaces to dump all namespaces.\n"
"\n"
"    The command also dumps the logs of all of the pods in the cluster, these logs are dumped into different directories\n"
"    based on namespace and pod name."

#: pkg/kubectl/cmd/clusterinfo.go:37
msgid ""
"\n"
"  Display addresses of the master and services with label kubernetes.io/cluster-service=true\n"
"  To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'."
msgstr ""
"\n"
"  Display addresses of the master and services with label kubernetes.io/cluster-service=true\n"
"  To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L61
#: pkg/kubectl/cmd/create_quota.go:62
msgid "A comma-delimited set of quota scopes that must all match each object tracked by the quota."
msgstr "A comma-delimited set of quota scopes that must all match each object tracked by the quota."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L60
#: pkg/kubectl/cmd/create_quota.go:61
msgid "A comma-delimited set of resource=quantity pairs that define a hard limit."
msgstr "A comma-delimited set of resource=quantity pairs that define a hard limit."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_pdb.go#L63
#: pkg/kubectl/cmd/create_pdb.go:64
msgid "A label selector to use for this budget. Only equality-based selector requirements are supported."
msgstr "A label selector to use for this budget. Only equality-based selector requirements are supported."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L106
#: pkg/kubectl/cmd/expose.go:104
msgid "A label selector to use for this service. Only equality-based selector requirements are supported. If empty (the default) infer the selector from the replication controller or replica set.)"
msgstr "A label selector to use for this service. Only equality-based selector requirements are supported. If empty (the default) infer the selector from the replication controller or replica set.)"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L136
#: pkg/kubectl/cmd/run.go:139
msgid "A schedule in the Cron format the job should be run with."
msgstr "A schedule in the Cron format the job should be run with."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L111
#: pkg/kubectl/cmd/expose.go:109
msgid "Additional external IP address (not managed by Kubernetes) to accept for the service. If this IP is routed to a node, the service can be accessed by this IP in addition to its generated service IP."
msgstr "Additional external IP address (not managed by Kubernetes) to accept for the service. If this IP is routed to a node, the service can be accessed by this IP in addition to its generated service IP."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L119
#: pkg/kubectl/cmd/expose.go:110 pkg/kubectl/cmd/run.go:122
msgid "An inline JSON override for the generated object. If this is non-empty, it is used to override the generated object. Requires that the object supply a valid apiVersion field."
msgstr "An inline JSON override for the generated object. If this is non-empty, it is used to override the generated object. Requires that the object supply a valid apiVersion field."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L134
#: pkg/kubectl/cmd/run.go:137
msgid "An inline JSON override for the generated service object. If this is non-empty, it is used to override the generated object. Requires that the object supply a valid apiVersion field.  Only used if --expose is true."
msgstr "An inline JSON override for the generated service object. If this is non-empty, it is used to override the generated object. Requires that the object supply a valid apiVersion field.  Only used if --expose is true."

#: pkg/kubectl/cmd/apply.go:104
msgid "Apply a configuration to a resource by filename or stdin"
msgstr "通过文件名或标准输入流(stdin)对资源进行配置"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/certificates.go#L71
#: pkg/kubectl/cmd/certificates.go:72
msgid "Approve a certificate signing request"
msgstr "同意一个自签证书请求"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L81
#: pkg/kubectl/cmd/create_service.go:82
msgid "Assign your own ClusterIP or set to 'None' for a 'headless' service (no loadbalancing)."
msgstr "Assign your own ClusterIP or set to 'None' for a 'headless' service (no loadbalancing)."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/attach.go#L64
#: pkg/kubectl/cmd/attach.go:70
msgid "Attach to a running container"
msgstr "Attach 到一个运行中的 container"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/autoscale.go#L55
#: pkg/kubectl/cmd/autoscale.go:56
msgid "Auto-scale a Deployment, ReplicaSet, or ReplicationController"
msgstr "自动调整一个 Deployment, ReplicaSet, 或者 ReplicationController 的副本数量"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L115
#: pkg/kubectl/cmd/expose.go:113
msgid "ClusterIP to be assigned to the service. Leave empty to auto-allocate, or set to 'None' to create a headless service."
msgstr "ClusterIP to be assigned to the service. Leave empty to auto-allocate, or set to 'None' to create a headless service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_clusterrolebinding.go#L55
#: pkg/kubectl/cmd/create_clusterrolebinding.go:56
msgid "ClusterRole this ClusterRoleBinding should reference"
msgstr "ClusterRoleBinding 应该指定 ClusterRole"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_rolebinding.go#L55
#: pkg/kubectl/cmd/create_rolebinding.go:56
msgid "ClusterRole this RoleBinding should reference"
msgstr "RoleBinding 应该指定 ClusterRole"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L101
#: pkg/kubectl/cmd/rollingupdate.go:102
msgid "Container name which will have its image upgraded. Only relevant when --image is specified, ignored otherwise. Required when using --image on a multi-container pod"
msgstr "Container name which will have its image upgraded. Only relevant when --image is specified, ignored otherwise. Required when using --image on a multi-container pod"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/convert.go#L67
#: pkg/kubectl/cmd/convert.go:68
msgid "Convert config files between different API versions"
msgstr "在不同的 API versions 转换配置文件"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/cp.go#L64
#: pkg/kubectl/cmd/cp.go:65
msgid "Copy files and directories to and from containers."
msgstr "复制 files 和 directories 到 containers 和从容器中复制 files 和 directories."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_clusterrolebinding.go#L43
#: pkg/kubectl/cmd/create_clusterrolebinding.go:44
msgid "Create a ClusterRoleBinding for a particular ClusterRole"
msgstr "为一个指定的 ClusterRole 创建一个 ClusterRoleBinding"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L181
#: pkg/kubectl/cmd/create_service.go:182
msgid "Create a LoadBalancer service."
msgstr "创建一个 LoadBalancer service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L124
#: pkg/kubectl/cmd/create_service.go:125
msgid "Create a NodePort service."
msgstr "创建一个 NodePort service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_rolebinding.go#L43
#: pkg/kubectl/cmd/create_rolebinding.go:44
msgid "Create a RoleBinding for a particular Role or ClusterRole"
msgstr "为一个指定的 Role 或者 ClusterRole创建一个 RoleBinding"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L214
#: pkg/kubectl/cmd/create_secret.go:214
msgid "Create a TLS secret"
msgstr "创建一个 TLS secret"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L68
#: pkg/kubectl/cmd/create_service.go:69
msgid "Create a clusterIP service."
msgstr "创建一个 clusterIP service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_configmap.go#L59
#: pkg/kubectl/cmd/create_configmap.go:60
msgid "Create a configmap from a local file, directory or literal value"
msgstr "从本地 file, directory 或者 literal value 创建一个 configmap"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_deployment.go#L44
#: pkg/kubectl/cmd/create_deployment.go:46
msgid "Create a deployment with the specified name."
msgstr "创建一个指定名称的 deployment."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_namespace.go#L44
#: pkg/kubectl/cmd/create_namespace.go:45
msgid "Create a namespace with the specified name"
msgstr "创建一个指定名称的 namespace"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_pdb.go#L49
#: pkg/kubectl/cmd/create_pdb.go:50
msgid "Create a pod disruption budget with the specified name."
msgstr "创建一个指定名称的 pod disruption budget."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L47
#: pkg/kubectl/cmd/create_quota.go:48
msgid "Create a quota with the specified name."
msgstr "创建一个指定名称的 quota."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create.go#L56
#: pkg/kubectl/cmd/create.go:63
msgid "Create a resource by filename or stdin"
msgstr "通过文件名或者标准输入流(stdin)创建一个资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L143
#: pkg/kubectl/cmd/create_secret.go:144
msgid "Create a secret for use with a Docker registry"
msgstr "创建一个给 Docker registry 使用的 secret"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L73
#: pkg/kubectl/cmd/create_secret.go:74
msgid "Create a secret from a local file, directory or literal value"
msgstr "从本地 file, directory 或者 literal value 创建一个 secret"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L34
#: pkg/kubectl/cmd/create_secret.go:35
msgid "Create a secret using specified subcommand"
msgstr "使用指定的 subcommand 创建一个 secret"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_serviceaccount.go#L44
#: pkg/kubectl/cmd/create_serviceaccount.go:45
msgid "Create a service account with the specified name"
msgstr "创建一个指定名称的 service account"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L36
#: pkg/kubectl/cmd/create_service.go:37
msgid "Create a service using specified subcommand."
msgstr "使用指定的 subcommand 创建一个 service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L240
#: pkg/kubectl/cmd/create_service.go:241
msgid "Create an ExternalName service."
msgstr "Create an ExternalName service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/delete.go#L130
#: pkg/kubectl/cmd/delete.go:132
msgid "Delete resources by filenames, stdin, resources and names, or by resources and label selector"
msgstr "Delete resources by filenames, stdin, resources and names, or by resources and label selector"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/delete_cluster.go#L38
#: pkg/kubectl/cmd/config/delete_cluster.go:39
msgid "Delete the specified cluster from the kubeconfig"
msgstr "删除 kubeconfig 文件中指定的集群"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/delete_context.go#L38
#: pkg/kubectl/cmd/config/delete_context.go:39
msgid "Delete the specified context from the kubeconfig"
msgstr "删除 kubeconfig 文件中指定的 context"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/certificates.go#L121
#: pkg/kubectl/cmd/certificates.go:122
msgid "Deny a certificate signing request"
msgstr "拒绝一个自签证书请求"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/stop.go#L58
#: pkg/kubectl/cmd/stop.go:59
msgid "Deprecated: Gracefully shut down a resource by name or filename"
msgstr "Deprecated: Gracefully shut down a resource by name or filename"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/get_contexts.go#L62
#: pkg/kubectl/cmd/config/get_contexts.go:64
msgid "Describe one or many contexts"
msgstr "描述一个或多个 contexts"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/top_node.go#L77
#: pkg/kubectl/cmd/top_node.go:78
msgid "Display Resource (CPU/Memory) usage of nodes"
msgstr "显示 nodes 的 Resource (CPU/Memory) 使用"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/top_pod.go#L79
#: pkg/kubectl/cmd/top_pod.go:80
msgid "Display Resource (CPU/Memory) usage of pods"
msgstr "显示 pods 的 Resource (CPU/Memory) 使用"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/top.go#L43
#: pkg/kubectl/cmd/top.go:44
msgid "Display Resource (CPU/Memory) usage."
msgstr "显示 Resource (CPU/Memory) 使用."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/clusterinfo.go#L49
#: pkg/kubectl/cmd/clusterinfo.go:51
msgid "Display cluster info"
msgstr "显示集群信息"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/get_clusters.go#L40
#: pkg/kubectl/cmd/config/get_clusters.go:41
msgid "Display clusters defined in the kubeconfig"
msgstr "显示 kubeconfig 文件中定义的集群"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/view.go#L64
#: pkg/kubectl/cmd/config/view.go:67
msgid "Display merged kubeconfig settings or a specified kubeconfig file"
msgstr "显示合并的 kubeconfig 配置或一个指定的 kubeconfig 文件"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/get.go#L107
#: pkg/kubectl/cmd/get.go:111
msgid "Display one or many resources"
msgstr "显示一个或更多 resources"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/current_context.go#L48
#: pkg/kubectl/cmd/config/current_context.go:49
msgid "Displays the current-context"
msgstr "显示当前的 context"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/explain.go#L50
#: pkg/kubectl/cmd/explain.go:51
msgid "Documentation of resources"
msgstr "查看资源的文档"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L176
#: pkg/kubectl/cmd/drain.go:178
msgid "Drain node in preparation for maintenance"
msgstr "Drain node in preparation for maintenance"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/clusterinfo_dump.go#L37
#: pkg/kubectl/cmd/clusterinfo_dump.go:39
msgid "Dump lots of relevant info for debugging and diagnosis"
msgstr "Dump lots of relevant info for debugging and diagnosis"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/edit.go#L100
#: pkg/kubectl/cmd/edit.go:110
msgid "Edit a resource on the server"
msgstr "在服务器上编辑一个资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L159
#: pkg/kubectl/cmd/create_secret.go:160
msgid "Email for Docker registry"
msgstr "Email for Docker registry"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/exec.go#L68
#: pkg/kubectl/cmd/exec.go:69
msgid "Execute a command in a container"
msgstr "在一个 container 中执行一个命令"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L102
#: pkg/kubectl/cmd/rollingupdate.go:103
msgid "Explicit policy for when to pull container images. Required when --image is same as existing image, ignored otherwise."
msgstr "Explicit policy for when to pull container images. Required when --image is same as existing image, ignored otherwise."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/portforward.go#L75
#: pkg/kubectl/cmd/portforward.go:76
msgid "Forward one or more local ports to a pod"
msgstr "Forward one or more local ports to a pod"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/help.go#L36
#: pkg/kubectl/cmd/help.go:37
msgid "Help about any command"
msgstr "Help about any command"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L105
#: pkg/kubectl/cmd/expose.go:103
msgid "IP to assign to the Load Balancer. If empty, an ephemeral IP will be created and used (cloud-provider specific)."
msgstr "IP to assign to the Load Balancer. If empty, an ephemeral IP will be created and used (cloud-provider specific)."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L114
#: pkg/kubectl/cmd/expose.go:112
msgid "If non-empty, set the session affinity for the service to this; legal values: 'None', 'ClientIP'"
msgstr "If non-empty, set the session affinity for the service to this; legal values: 'None', 'ClientIP'"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/annotate.go#L135
#: pkg/kubectl/cmd/annotate.go:136
msgid "If non-empty, the annotation update will only succeed if this is the current resource-version for the object. Only valid when specifying a single resource."
msgstr "If non-empty, the annotation update will only succeed if this is the current resource-version for the object. Only valid when specifying a single resource."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/label.go#L132
#: pkg/kubectl/cmd/label.go:134
msgid "If non-empty, the labels update will only succeed if this is the current resource-version for the object. Only valid when specifying a single resource."
msgstr "If non-empty, the labels update will only succeed if this is the current resource-version for the object. Only valid when specifying a single resource."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L98
#: pkg/kubectl/cmd/rollingupdate.go:99
msgid "Image to use for upgrading the replication controller. Must be distinct from the existing image (either new image or new image tag).  Can not be used with --filename/-f"
msgstr "Image to use for upgrading the replication controller. Must be distinct from the existing image (either new image or new image tag).  Can not be used with --filename/-f"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout.go#L46
#: pkg/kubectl/cmd/rollout/rollout.go:47
msgid "Manage a deployment rollout"
msgstr "管理一个 deployment 的 rollout"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L127
#: pkg/kubectl/cmd/drain.go:128
msgid "Mark node as schedulable"
msgstr "标记 node 为 schedulable"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L102
#: pkg/kubectl/cmd/drain.go:103
msgid "Mark node as unschedulable"
msgstr "标记 node 为 unschedulable"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_pause.go#L73
#: pkg/kubectl/cmd/rollout/rollout_pause.go:74
msgid "Mark the provided resource as paused"
msgstr "标记提供的 resource 为中止状态"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/certificates.go#L35
#: pkg/kubectl/cmd/certificates.go:36
msgid "Modify certificate resources."
msgstr "修改 certificate 资源."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/config.go#L39
#: pkg/kubectl/cmd/config/config.go:40
msgid "Modify kubeconfig files"
msgstr "修改 kubeconfig 文件"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L110
#: pkg/kubectl/cmd/expose.go:108
msgid "Name or number for the port on the container that the service should direct traffic to. Optional."
msgstr "Name or number for the port on the container that the service should direct traffic to. Optional."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/logs.go#L108
#: pkg/kubectl/cmd/logs.go:113
msgid "Only return logs after a specific date (RFC3339). Defaults to all logs. Only one of since-time / since may be used."
msgstr "Only return logs after a specific date (RFC3339). Defaults to all logs. Only one of since-time / since may be used."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/completion.go#L97
#: pkg/kubectl/cmd/completion.go:104
msgid "Output shell completion code for the specified shell (bash or zsh)"
msgstr "Output shell completion code for the specified shell (bash or zsh)"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/edit.go#L115
#: pkg/kubectl/cmd/convert.go:85
msgid "Output the formatted object with the given group version (for ex: 'extensions/v1beta1').)"
msgstr "Output the formatted object with the given group version (for ex: 'extensions/v1beta1').)"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L157
#: pkg/kubectl/cmd/create_secret.go:158
msgid "Password for Docker registry authentication"
msgstr "Password for Docker registry authentication"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L226
#: pkg/kubectl/cmd/create_secret.go:226
msgid "Path to PEM encoded public key certificate."
msgstr "Path to PEM encoded public key certificate."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L227
#: pkg/kubectl/cmd/create_secret.go:227
msgid "Path to private key associated with given certificate."
msgstr "Path to private key associated with given certificate."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L84
#: pkg/kubectl/cmd/rollingupdate.go:85
msgid "Perform a rolling update of the given ReplicationController"
msgstr "完成指定的 ReplicationController 的滚动升级"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/scale.go#L82
#: pkg/kubectl/cmd/scale.go:83
msgid "Precondition for resource version. Requires that the current resource version match this value in order to scale."
msgstr "Precondition for resource version. Requires that the current resource version match this value in order to scale."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/version.go#L39
#: pkg/kubectl/cmd/version.go:40
msgid "Print the client and server version information"
msgstr "输出 client 和 server 的版本信息"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/options.go#L37
#: pkg/kubectl/cmd/options.go:38
msgid "Print the list of flags inherited by all commands"
msgstr "输出所有命令的层级关系"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/logs.go#L86
#: pkg/kubectl/cmd/logs.go:93
msgid "Print the logs for a container in a pod"
msgstr "输出容器在 pod 中的日志"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/replace.go#L70
#: pkg/kubectl/cmd/replace.go:71
msgid "Replace a resource by filename or stdin"
msgstr "通过 filename 或者 stdin替换一个资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_resume.go#L71
#: pkg/kubectl/cmd/rollout/rollout_resume.go:72
msgid "Resume a paused resource"
msgstr "继续一个停止的 resource"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_rolebinding.go#L56
#: pkg/kubectl/cmd/create_rolebinding.go:57
msgid "Role this RoleBinding should reference"
msgstr "RoleBinding 的 Role 应该被引用"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L94
#: pkg/kubectl/cmd/run.go:97
msgid "Run a particular image on the cluster"
msgstr "在集群中运行一个指定的镜像"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/proxy.go#L68
#: pkg/kubectl/cmd/proxy.go:69
msgid "Run a proxy to the Kubernetes API server"
msgstr "运行一个 proxy 到 Kubernetes API server"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L161
#: pkg/kubectl/cmd/create_secret.go:161
msgid "Server location for Docker registry"
msgstr "Server location for Docker registry"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/scale.go#L71
#: pkg/kubectl/cmd/scale.go:71
msgid "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job"
msgstr "为 Deployment, ReplicaSet, Replication Controller 或者 Job 设置一个新的副本数量"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/set/set.go#L37
#: pkg/kubectl/cmd/set/set.go:38
msgid "Set specific features on objects"
msgstr "为 objects 设置一个指定的特征"

#: pkg/kubectl/cmd/apply_set_last_applied.go:83
msgid "Set the last-applied-configuration annotation on a live object to match the contents of a file."
msgstr "Set the last-applied-configuration annotation on a live object to match the contents of a file."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/set/set_selector.go#L81
#: pkg/kubectl/cmd/set/set_selector.go:82
msgid "Set the selector on a resource"
msgstr "设置 resource 的 selector"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/create_cluster.go#L67
#: pkg/kubectl/cmd/config/create_cluster.go:68
msgid "Sets a cluster entry in kubeconfig"
msgstr "设置 kubeconfig 文件中的一个集群条目"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/create_context.go#L57
#: pkg/kubectl/cmd/config/create_context.go:58
msgid "Sets a context entry in kubeconfig"
msgstr "设置 kubeconfig 文件中的一个 context 条目"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/create_authinfo.go#L103
#: pkg/kubectl/cmd/config/create_authinfo.go:104
msgid "Sets a user entry in kubeconfig"
msgstr "设置 kubeconfig 文件中的一个用户条目"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/set.go#L59
#: pkg/kubectl/cmd/config/set.go:60
msgid "Sets an individual value in a kubeconfig file"
msgstr "设置 kubeconfig 文件中的一个单个值"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/use_context.go#L48
#: pkg/kubectl/cmd/config/use_context.go:49
msgid "Sets the current-context in a kubeconfig file"
msgstr "设置 kubeconfig 文件中的当前上下文"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/describe.go#L80
#: pkg/kubectl/cmd/describe.go:86
msgid "Show details of a specific resource or group of resources"
msgstr "显示一个指定 resource 或者 group 的 resources 详情"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_status.go#L57
#: pkg/kubectl/cmd/rollout/rollout_status.go:58
msgid "Show the status of the rollout"
msgstr "显示 rollout 的状态"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L108
#: pkg/kubectl/cmd/expose.go:106
msgid "Synonym for --target-port"
msgstr "Synonym for --target-port"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L87
#: pkg/kubectl/cmd/expose.go:88
msgid "Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service"
msgstr "使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的 Kubernetes Service"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L114
#: pkg/kubectl/cmd/run.go:117
msgid "The image for the container to run."
msgstr "指定容器要运行的镜像."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L116
#: pkg/kubectl/cmd/run.go:119
msgid "The image pull policy for the container. If left empty, this value will not be specified by the client and defaulted by the server"
msgstr "容器的镜像拉取策略. 如果为空, 这个值将不会 被 client 指定且使用 server 端的默认值"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L100
#: pkg/kubectl/cmd/rollingupdate.go:101
msgid "The key to use to differentiate between two different controllers, default 'deployment'.  Only relevant when --image is specified, ignored otherwise"
msgstr "这个 key 使用有区别在两个不同的 controllers, 默认 'deployment'. 只有当 --image 指定值, 否则忽略"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_pdb.go#L62
#: pkg/kubectl/cmd/create_pdb.go:63
msgid "The minimum number or percentage of available pods this budget requires."
msgstr "最小数量百分比可用的 pods 作为 budget 要求."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L113
#: pkg/kubectl/cmd/expose.go:111
msgid "The name for the newly created object."
msgstr "名称为最新创建的对象."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/autoscale.go#L71
#: pkg/kubectl/cmd/autoscale.go:72
msgid "The name for the newly created object. If not specified, the name of the input resource will be used."
msgstr "名称为最新创建的对象. 如果没有指定, 输入资源的 名称即将被使用."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L113
#: pkg/kubectl/cmd/run.go:116
msgid "The name of the API generator to use, see http://kubernetes.io/docs/user-guide/kubectl-conventions/#generators for a list."
msgstr "使用 API generator 的名字, 在 http://kubernetes.io/docs/user-guide/kubectl-conventions/#generators 查看列表."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/autoscale.go#L66
#: pkg/kubectl/cmd/autoscale.go:67
msgid "The name of the API generator to use. Currently there is only 1 generator."
msgstr "使用 API generator 的名字. 目前只有 1 个 generator."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L98
#: pkg/kubectl/cmd/expose.go:99
msgid "The name of the API generator to use. There are 2 generators: 'service/v1' and 'service/v2'. The only difference between them is that service port in v1 is named 'default', while it is left unnamed in v2. Default is 'service/v2'."
msgstr "使用 generator 的名称. 这里有 2 个 generators: 'service/v1' 和 'service/v2'. 为一个不同地方是服务端口在 v1 的情况下叫 'default', 如果在 v2 中没有指定名称. 默认的名称是 'service/v2'."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L133
#: pkg/kubectl/cmd/run.go:136
msgid "The name of the generator to use for creating a service.  Only used if --expose is true"
msgstr "使用 gnerator 的名称创建一个 service.  只有在 --expose 为 true 的时候使用"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L99
#: pkg/kubectl/cmd/expose.go:100
msgid "The network protocol for the service to be created. Default is 'TCP'."
msgstr "创建 service 的时候伴随着一个网络协议被创建. 默认是 'TCP'."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L100
#: pkg/kubectl/cmd/expose.go:101
msgid "The port that the service should serve on. Copied from the resource being exposed, if unspecified"
msgstr "服务的端口应该被指定. 如果没有指定, 从被创建的资源中复制"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L121
#: pkg/kubectl/cmd/run.go:124
msgid "The port that this container exposes.  If --expose is true, this is also the port used by the service that is created."
msgstr "The port that this container exposes.  If --expose is true, this is also the port used by the service that is created."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L131
#: pkg/kubectl/cmd/run.go:134
msgid "The resource requirement limits for this container.  For example, 'cpu=200m,memory=512Mi'.  Note that server side components may assign limits depending on the server configuration, such as limit ranges."
msgstr "The resource requirement limits for this container.  For example, 'cpu=200m,memory=512Mi'.  Note that server side components may assign limits depending on the server configuration, such as limit ranges."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L130
#: pkg/kubectl/cmd/run.go:133
msgid "The resource requirement requests for this container.  For example, 'cpu=100m,memory=256Mi'.  Note that server side components may assign requests depending on the server configuration, such as limit ranges."
msgstr "资源为 container 请求 requests . 例如, 'cpu=100m,memory=256Mi'. 注意服务端组件也许会赋予 requests, 这决定于服务器端配置, 比如 limit ranges."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L128
#: pkg/kubectl/cmd/run.go:131
msgid "The restart policy for this Pod.  Legal values [Always, OnFailure, Never].  If set to 'Always' a deployment is created, if set to 'OnFailure' a job is created, if set to 'Never', a regular pod is created. For the latter two --replicas must be 1.  Default 'Always', for CronJobs `Never`."
msgstr "这个 Pod 的 restart policy.  Legal values [Always, OnFailure, Never]. 如果设置为 'Always' 一个 deployment 被创建, 如果设置为 ’OnFailure' 一个 job 被创建, 如果设置为 'Never', 一个普通的 pod 被创建. 对于后面两个 --replicas 必须为 1.  默认 'Always', 为 CronJobs 设置为 `Never`."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L87
#: pkg/kubectl/cmd/create_secret.go:88
msgid "The type of secret to create"
msgstr "创建 secret 类型资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L101
#: pkg/kubectl/cmd/expose.go:102
msgid "Type for this service: ClusterIP, NodePort, or LoadBalancer. Default is 'ClusterIP'."
msgstr "对于服务的类型: ClusterIP, NodePort, 或者 LoadBalancer. 默认是 'ClusterIP’."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_undo.go#L71
#: pkg/kubectl/cmd/rollout/rollout_undo.go:72
msgid "Undo a previous rollout"
msgstr "撤销上一次的 rollout"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/unset.go#L47
#: pkg/kubectl/cmd/config/unset.go:48
msgid "Unsets an individual value in a kubeconfig file"
msgstr "取消设置 kubeconfig 文件中的一个单个值"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/patch.go#L91
#: pkg/kubectl/cmd/patch.go:96
msgid "Update field(s) of a resource using strategic merge patch"
msgstr "使用 strategic merge patch 更新一个资源的 field(s)"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/set/set_image.go#L94
#: pkg/kubectl/cmd/set/set_image.go:95
msgid "Update image of a pod template"
msgstr "更新一个 pod template 的镜像"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/set/set_resources.go#L101
#: pkg/kubectl/cmd/set/set_resources.go:102
msgid "Update resource requests/limits on objects with pod templates"
msgstr "在对象的 pod templates 上更新资源的 requests/limits"

#: pkg/kubectl/cmd/annotate.go:116
msgid "Update the annotations on a resource"
msgstr "更新一个资源的注解"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/label.go#L109
#: pkg/kubectl/cmd/label.go:114
msgid "Update the labels on a resource"
msgstr "更新在这个资源上的 labels"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/taint.go#L88
#: pkg/kubectl/cmd/taint.go:87
msgid "Update the taints on one or more nodes"
msgstr "更新一个或者多个 node 上的 taints"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L155
#: pkg/kubectl/cmd/create_secret.go:156
msgid "Username for Docker registry authentication"
msgstr "Username 为 Docker registry authentication"

#: pkg/kubectl/cmd/apply_view_last_applied.go:64
msgid "View latest last-applied-configuration annotations of a resource/object"
msgstr "显示最后的 resource/object 的 last-applied-configuration annotations"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_history.go#L51
#: pkg/kubectl/cmd/rollout/rollout_history.go:52
msgid "View rollout history"
msgstr "显示 rollout 历史"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/clusterinfo_dump.go#L45
#: pkg/kubectl/cmd/clusterinfo_dump.go:46
msgid "Where to output the files.  If empty or '-' uses stdout, otherwise creates a directory hierarchy in that directory"
msgstr "输出到 files.  如果是 empty or '-' 使用 stdout, 否则创建一个 目录层级在那个目录"

#: pkg/kubectl/cmd/run_test.go:85
msgid "dummy restart flag)"
msgstr "dummy restart flag)"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L253
#: pkg/kubectl/cmd/create_service.go:254
msgid "external name of service"
msgstr "服务的外部名称"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/cmd.go#L217
#: pkg/kubectl/cmd/cmd.go:227
msgid "kubectl controls the Kubernetes cluster manager"
msgstr "kubectl 控制 Kubernetes cluster 管理"

#~ msgid "watch is only supported on individual resources and resource collections - %d resources were found"
#~ msgid_plural "watch is only supported on individual resources and resource collections - %d resources were found"
#~ msgstr[0] "watch 仅支持单独的资源或者资源集合 - 找到了 %d 个资源watch is only supported on individual resources and resource collections - %d resource was found"
#~ msgstr[1] "watch 仅支持单独的资源或者资源集合 - 找到了 %d 个资源watch is only supported on individual resources and resource collections - %d resources were found"
