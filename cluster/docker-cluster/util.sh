#!/bin/bash

# Copyright 2015 The Kubernetes Authors All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# A library of helper functions that each provider hosting Kubernetes must implement to use cluster/kube-*.sh scripts.
set -e


# Verify SSH is available and ENVs are set
# 
# Assumed vars:
#   MASTER 
#   NODES
function verify-prereqs {
  local rc

  rc=0
  ssh-add -L 1> /dev/null 2> /dev/null || rc="$?"
  # "Could not open a connection to your authentication agent."
  if [[ "${rc}" -eq 2 ]]; then
    eval "$(ssh-agent)" > /dev/null
    trap-add "kill ${SSH_AGENT_PID}" EXIT
  fi

  rc=0
  ssh-add -L 1> /dev/null 2> /dev/null || rc="$?"
  # "The agent has no identities."
  if [[ "${rc}" -eq 1 ]]; then
    # Try adding one of the default identities, with or without passphrase.
    ssh-add || true
  fi
  # Expect at least one identity to be available.
  if ! ssh-add -L 1> /dev/null 2> /dev/null; then
    echo "Could not find or add an SSH identity."
    echo "Please start ssh-agent, add your identity, and retry."
    exit 1
  fi

  # Make sure env is properly set
  : ${MASTER?"Need to set MASTER"}
  : ${NODES?"Need to set NODES"}
}

# Verify cluster
# 
# Assumed vars:
#   MASTER
#   NODES
#   SSH_OPTS
function validate-cluster {
  sleep 5 # For now we just sleep to wait the world

  ssh $SSH_OPTS $MASTER "bash ~/docker-cluster/kube-deploy/verify.sh master"

  for node in $NODES
  do
    {
      if [ "$node" != $MASTER ]; then
        ssh $SSH_OPTS $node "bash ~/docker-cluster/kube-deploy/verify.sh node"
      fi
    }
  done

  echo
  echo "Kubernetes-in-docker cluster is deployed.  The master should be running at:"
  echo
  echo "  http://${MASTER_IP}:8080"
}


# Instantiate a kubernetes cluster on docker-cluster
#
# Assumed vars:
#   MASTER
#   NODES
#   NODE_ONLY
# Vars set:
#   KUBE_ROOT
#   NUM_MINIONS
function kube-up() {
  KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
  source "docker-cluster/config-default.sh"

  generate_env

  NUM_MINIONS=1
 
  for node in $NODES
  do
    {
      if [ "$node" != $MASTER ]; then
        deploy-node ${node#*@}
      else
        # This machine occurs both in NODEs & MASTER, we
        # should deploy it as a "master with node"
        #
        # NODE_ONLY=yes means that we only want to join existing master
        if [[ "yes" != $NODE_ONLY ]]; then
          deploy-node-master "WITH_NODE"
          # In this case no need to deploy master seperately
          DEPLOYED="yes"
        fi
      fi
      NUM_MINIONS=$((NUM_MINIONS+1))
    }
  done

  # Deploy master seperately only when:
  # 1. not node-only mode
  # 2. this machine is only a master 
  if [[ "yes" != $NODE_ONLY && -z $DEPLOYED ]]; then
    deploy-node-master
  fi

  wait

  export NUM_MINIONS=$NUM_MINIONS

  echo "Deploy Complete!"
}

# Generate ENV file for nodes to use
#
# Assumed vars:
#   in config-default.sh
function generate_env(){
  cat <<EOF > docker-cluster/kube-config/node.env
# Do not modify!
# This file is generated by docker-cluster/util.sh#generate_env()
export FLANNEL_VERSION=$FLANNEL_VERSION
export ETCD_VERSION=$ETCD_VERSION
export K8S_VERSION=$K8S_VERSION
export NODES="$NODES"
export MASTER=$MASTER
export MASTER_IP=$MASTER_IP
export MASTER_CONF=$MASTER_CONF
export SSH_OPTS="$SSH_OPTS"
export FLANNEL_NET=$FLANNEL_NET
EOF
  cat docker-cluster/kube-config/node.env

  read -p "Are you sure? (y|n) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]
  then
      echo "Abort!"
      exit 1
  fi

}

# Provison master
#
# Assumed vars:
#   MASTER_IP
#   MASTER
#   SSH_OPTS
#   WITH_NODE(in $1)
function deploy-node-master() {
  # copy the scripts to the ~/docker-cluster directory on the master
  echo "... Deploying Master on machine $MASTER_IP"
  echo
  scp -r $SSH_OPTS images/hyperkube/master-multi.json docker-cluster "${MASTER}:~"

  # remote login to MASTER and use sudo to configue k8s master
  # $1 is set to 'WITH_NODE' if this machine is both master & node
  ssh $SSH_OPTS -t $MASTER "sudo bash ~/docker-cluster/kube-deploy/master.sh $1;"
}

# Provison node
#
# Assumed vars:
#   MASTER_IP
#   MASTER
#   SSH_OPTS
function deploy-node() {
  # copy the scripts to the ~/docker-cluster directory on the node
  echo "... Deploying Node on machine $1"
  echo
  scp -r $SSH_OPTS docker-cluster "$node:~"

  # remote login to node and use sudo to configue k8s node
  ssh $SSH_OPTS -t $node "sudo bash ~/docker-cluster/kube-deploy/node.sh;" 
}

# Delete a kubernetes cluster
#
# Assumed vars:
#   NODES
function kube-down {
  KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
  source "${KUBE_ROOT}/cluster/docker-cluster/${KUBE_CONFIG_FILE-"config-default.sh"}"

  for i in ${NODES}; do
  {
    echo "... Cleaning on node ${i#*@}"
    ssh -t $i "sudo bash ~/docker-cluster/kube-deploy/destroy.sh clear_all \
    && rm -rf ~/docker-cluster/"
  }
  done
  wait
}

# Install handler for signal trap
function trap-add {
  local handler="$1"
  local signal="${2-EXIT}"
  local cur

  cur="$(eval "sh -c 'echo \$3' -- $(trap -p ${signal})")"
  if [[ -n "${cur}" ]]; then
    handler="${cur}; ${handler}"
  fi

  trap "${handler}" ${signal}
}

# Update a kubernetes cluster with latest source
function kube-push {
  echo "TODO Not implemented"
}

# Perform preparations required to run e2e tests
function prepare-e2e() {
  echo "Kube-in-docker doesn't have special preparations for e2e tests" 1>&2
}

