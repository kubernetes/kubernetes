// +build !ignore_autogenerated

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package api

import (
	unversioned "k8s.io/client-go/pkg/api/unversioned"
	conversion "k8s.io/client-go/pkg/conversion"
	fields "k8s.io/client-go/pkg/fields"
	labels "k8s.io/client-go/pkg/labels"
	runtime "k8s.io/client-go/pkg/runtime"
	types "k8s.io/client-go/pkg/types"
	reflect "reflect"
)

func init() {
	SchemeBuilder.Register(RegisterDeepCopies)
}

// RegisterDeepCopies adds deep-copy functions to the given scheme. Public
// to allow building arbitrary schemes.
func RegisterDeepCopies(scheme *runtime.Scheme) error {
	return scheme.AddGeneratedDeepCopyFuncs(
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AWSElasticBlockStoreVolumeSource, InType: reflect.TypeOf(&AWSElasticBlockStoreVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Affinity, InType: reflect.TypeOf(&Affinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AttachedVolume, InType: reflect.TypeOf(&AttachedVolume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AvoidPods, InType: reflect.TypeOf(&AvoidPods{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AzureDiskVolumeSource, InType: reflect.TypeOf(&AzureDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_AzureFileVolumeSource, InType: reflect.TypeOf(&AzureFileVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Binding, InType: reflect.TypeOf(&Binding{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Capabilities, InType: reflect.TypeOf(&Capabilities{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_CephFSVolumeSource, InType: reflect.TypeOf(&CephFSVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_CinderVolumeSource, InType: reflect.TypeOf(&CinderVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ComponentCondition, InType: reflect.TypeOf(&ComponentCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ComponentStatus, InType: reflect.TypeOf(&ComponentStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ComponentStatusList, InType: reflect.TypeOf(&ComponentStatusList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMap, InType: reflect.TypeOf(&ConfigMap{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMapKeySelector, InType: reflect.TypeOf(&ConfigMapKeySelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMapList, InType: reflect.TypeOf(&ConfigMapList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConfigMapVolumeSource, InType: reflect.TypeOf(&ConfigMapVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Container, InType: reflect.TypeOf(&Container{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerImage, InType: reflect.TypeOf(&ContainerImage{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerPort, InType: reflect.TypeOf(&ContainerPort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerState, InType: reflect.TypeOf(&ContainerState{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerStateRunning, InType: reflect.TypeOf(&ContainerStateRunning{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerStateTerminated, InType: reflect.TypeOf(&ContainerStateTerminated{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerStateWaiting, InType: reflect.TypeOf(&ContainerStateWaiting{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ContainerStatus, InType: reflect.TypeOf(&ContainerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ConversionError, InType: reflect.TypeOf(&ConversionError{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DaemonEndpoint, InType: reflect.TypeOf(&DaemonEndpoint{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DeleteOptions, InType: reflect.TypeOf(&DeleteOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DownwardAPIVolumeFile, InType: reflect.TypeOf(&DownwardAPIVolumeFile{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DownwardAPIVolumeSource, InType: reflect.TypeOf(&DownwardAPIVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EmptyDirVolumeSource, InType: reflect.TypeOf(&EmptyDirVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EndpointAddress, InType: reflect.TypeOf(&EndpointAddress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EndpointPort, InType: reflect.TypeOf(&EndpointPort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EndpointSubset, InType: reflect.TypeOf(&EndpointSubset{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Endpoints, InType: reflect.TypeOf(&Endpoints{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EndpointsList, InType: reflect.TypeOf(&EndpointsList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EnvVar, InType: reflect.TypeOf(&EnvVar{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EnvVarSource, InType: reflect.TypeOf(&EnvVarSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Event, InType: reflect.TypeOf(&Event{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EventList, InType: reflect.TypeOf(&EventList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_EventSource, InType: reflect.TypeOf(&EventSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ExecAction, InType: reflect.TypeOf(&ExecAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ExportOptions, InType: reflect.TypeOf(&ExportOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_FCVolumeSource, InType: reflect.TypeOf(&FCVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_FlexVolumeSource, InType: reflect.TypeOf(&FlexVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_FlockerVolumeSource, InType: reflect.TypeOf(&FlockerVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_GCEPersistentDiskVolumeSource, InType: reflect.TypeOf(&GCEPersistentDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_GitRepoVolumeSource, InType: reflect.TypeOf(&GitRepoVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_GlusterfsVolumeSource, InType: reflect.TypeOf(&GlusterfsVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_HTTPGetAction, InType: reflect.TypeOf(&HTTPGetAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_HTTPHeader, InType: reflect.TypeOf(&HTTPHeader{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Handler, InType: reflect.TypeOf(&Handler{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_HostPathVolumeSource, InType: reflect.TypeOf(&HostPathVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ISCSIVolumeSource, InType: reflect.TypeOf(&ISCSIVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_KeyToPath, InType: reflect.TypeOf(&KeyToPath{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Lifecycle, InType: reflect.TypeOf(&Lifecycle{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LimitRange, InType: reflect.TypeOf(&LimitRange{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LimitRangeItem, InType: reflect.TypeOf(&LimitRangeItem{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LimitRangeList, InType: reflect.TypeOf(&LimitRangeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LimitRangeSpec, InType: reflect.TypeOf(&LimitRangeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_List, InType: reflect.TypeOf(&List{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ListOptions, InType: reflect.TypeOf(&ListOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LoadBalancerIngress, InType: reflect.TypeOf(&LoadBalancerIngress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LoadBalancerStatus, InType: reflect.TypeOf(&LoadBalancerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_LocalObjectReference, InType: reflect.TypeOf(&LocalObjectReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NFSVolumeSource, InType: reflect.TypeOf(&NFSVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Namespace, InType: reflect.TypeOf(&Namespace{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NamespaceList, InType: reflect.TypeOf(&NamespaceList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NamespaceSpec, InType: reflect.TypeOf(&NamespaceSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NamespaceStatus, InType: reflect.TypeOf(&NamespaceStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Node, InType: reflect.TypeOf(&Node{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeAddress, InType: reflect.TypeOf(&NodeAddress{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeAffinity, InType: reflect.TypeOf(&NodeAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeCondition, InType: reflect.TypeOf(&NodeCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeDaemonEndpoints, InType: reflect.TypeOf(&NodeDaemonEndpoints{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeList, InType: reflect.TypeOf(&NodeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeProxyOptions, InType: reflect.TypeOf(&NodeProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeResources, InType: reflect.TypeOf(&NodeResources{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSelector, InType: reflect.TypeOf(&NodeSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSelectorRequirement, InType: reflect.TypeOf(&NodeSelectorRequirement{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSelectorTerm, InType: reflect.TypeOf(&NodeSelectorTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSpec, InType: reflect.TypeOf(&NodeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeStatus, InType: reflect.TypeOf(&NodeStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_NodeSystemInfo, InType: reflect.TypeOf(&NodeSystemInfo{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ObjectFieldSelector, InType: reflect.TypeOf(&ObjectFieldSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ObjectMeta, InType: reflect.TypeOf(&ObjectMeta{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ObjectReference, InType: reflect.TypeOf(&ObjectReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_OwnerReference, InType: reflect.TypeOf(&OwnerReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolume, InType: reflect.TypeOf(&PersistentVolume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaim, InType: reflect.TypeOf(&PersistentVolumeClaim{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaimList, InType: reflect.TypeOf(&PersistentVolumeClaimList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaimSpec, InType: reflect.TypeOf(&PersistentVolumeClaimSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaimStatus, InType: reflect.TypeOf(&PersistentVolumeClaimStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeClaimVolumeSource, InType: reflect.TypeOf(&PersistentVolumeClaimVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeList, InType: reflect.TypeOf(&PersistentVolumeList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeSource, InType: reflect.TypeOf(&PersistentVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeSpec, InType: reflect.TypeOf(&PersistentVolumeSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PersistentVolumeStatus, InType: reflect.TypeOf(&PersistentVolumeStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PhotonPersistentDiskVolumeSource, InType: reflect.TypeOf(&PhotonPersistentDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Pod, InType: reflect.TypeOf(&Pod{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodAffinity, InType: reflect.TypeOf(&PodAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodAffinityTerm, InType: reflect.TypeOf(&PodAffinityTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodAntiAffinity, InType: reflect.TypeOf(&PodAntiAffinity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodAttachOptions, InType: reflect.TypeOf(&PodAttachOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodCondition, InType: reflect.TypeOf(&PodCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodExecOptions, InType: reflect.TypeOf(&PodExecOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodList, InType: reflect.TypeOf(&PodList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodLogOptions, InType: reflect.TypeOf(&PodLogOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodProxyOptions, InType: reflect.TypeOf(&PodProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodSecurityContext, InType: reflect.TypeOf(&PodSecurityContext{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodSignature, InType: reflect.TypeOf(&PodSignature{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodSpec, InType: reflect.TypeOf(&PodSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodStatus, InType: reflect.TypeOf(&PodStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodStatusResult, InType: reflect.TypeOf(&PodStatusResult{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodTemplate, InType: reflect.TypeOf(&PodTemplate{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodTemplateList, InType: reflect.TypeOf(&PodTemplateList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PodTemplateSpec, InType: reflect.TypeOf(&PodTemplateSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Preconditions, InType: reflect.TypeOf(&Preconditions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PreferAvoidPodsEntry, InType: reflect.TypeOf(&PreferAvoidPodsEntry{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_PreferredSchedulingTerm, InType: reflect.TypeOf(&PreferredSchedulingTerm{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Probe, InType: reflect.TypeOf(&Probe{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_QuobyteVolumeSource, InType: reflect.TypeOf(&QuobyteVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_RBDVolumeSource, InType: reflect.TypeOf(&RBDVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_RangeAllocation, InType: reflect.TypeOf(&RangeAllocation{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationController, InType: reflect.TypeOf(&ReplicationController{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationControllerCondition, InType: reflect.TypeOf(&ReplicationControllerCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationControllerList, InType: reflect.TypeOf(&ReplicationControllerList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationControllerSpec, InType: reflect.TypeOf(&ReplicationControllerSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ReplicationControllerStatus, InType: reflect.TypeOf(&ReplicationControllerStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceFieldSelector, InType: reflect.TypeOf(&ResourceFieldSelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceQuota, InType: reflect.TypeOf(&ResourceQuota{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceQuotaList, InType: reflect.TypeOf(&ResourceQuotaList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceQuotaSpec, InType: reflect.TypeOf(&ResourceQuotaSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceQuotaStatus, InType: reflect.TypeOf(&ResourceQuotaStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ResourceRequirements, InType: reflect.TypeOf(&ResourceRequirements{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SELinuxOptions, InType: reflect.TypeOf(&SELinuxOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Secret, InType: reflect.TypeOf(&Secret{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SecretKeySelector, InType: reflect.TypeOf(&SecretKeySelector{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SecretList, InType: reflect.TypeOf(&SecretList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SecretVolumeSource, InType: reflect.TypeOf(&SecretVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SecurityContext, InType: reflect.TypeOf(&SecurityContext{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SerializedReference, InType: reflect.TypeOf(&SerializedReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Service, InType: reflect.TypeOf(&Service{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceAccount, InType: reflect.TypeOf(&ServiceAccount{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceAccountList, InType: reflect.TypeOf(&ServiceAccountList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceList, InType: reflect.TypeOf(&ServiceList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServicePort, InType: reflect.TypeOf(&ServicePort{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceProxyOptions, InType: reflect.TypeOf(&ServiceProxyOptions{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceSpec, InType: reflect.TypeOf(&ServiceSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ServiceStatus, InType: reflect.TypeOf(&ServiceStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Sysctl, InType: reflect.TypeOf(&Sysctl{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_TCPSocketAction, InType: reflect.TypeOf(&TCPSocketAction{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Taint, InType: reflect.TypeOf(&Taint{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Toleration, InType: reflect.TypeOf(&Toleration{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Volume, InType: reflect.TypeOf(&Volume{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_VolumeMount, InType: reflect.TypeOf(&VolumeMount{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_VolumeSource, InType: reflect.TypeOf(&VolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_VsphereVirtualDiskVolumeSource, InType: reflect.TypeOf(&VsphereVirtualDiskVolumeSource{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_WeightedPodAffinityTerm, InType: reflect.TypeOf(&WeightedPodAffinityTerm{})},
	)
}

func DeepCopy_api_AWSElasticBlockStoreVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AWSElasticBlockStoreVolumeSource)
		out := out.(*AWSElasticBlockStoreVolumeSource)
		out.VolumeID = in.VolumeID
		out.FSType = in.FSType
		out.Partition = in.Partition
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_Affinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Affinity)
		out := out.(*Affinity)
		if in.NodeAffinity != nil {
			in, out := &in.NodeAffinity, &out.NodeAffinity
			*out = new(NodeAffinity)
			if err := DeepCopy_api_NodeAffinity(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.NodeAffinity = nil
		}
		if in.PodAffinity != nil {
			in, out := &in.PodAffinity, &out.PodAffinity
			*out = new(PodAffinity)
			if err := DeepCopy_api_PodAffinity(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.PodAffinity = nil
		}
		if in.PodAntiAffinity != nil {
			in, out := &in.PodAntiAffinity, &out.PodAntiAffinity
			*out = new(PodAntiAffinity)
			if err := DeepCopy_api_PodAntiAffinity(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.PodAntiAffinity = nil
		}
		return nil
	}
}

func DeepCopy_api_AttachedVolume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AttachedVolume)
		out := out.(*AttachedVolume)
		out.Name = in.Name
		out.DevicePath = in.DevicePath
		return nil
	}
}

func DeepCopy_api_AvoidPods(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AvoidPods)
		out := out.(*AvoidPods)
		if in.PreferAvoidPods != nil {
			in, out := &in.PreferAvoidPods, &out.PreferAvoidPods
			*out = make([]PreferAvoidPodsEntry, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PreferAvoidPodsEntry(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.PreferAvoidPods = nil
		}
		return nil
	}
}

func DeepCopy_api_AzureDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AzureDiskVolumeSource)
		out := out.(*AzureDiskVolumeSource)
		out.DiskName = in.DiskName
		out.DataDiskURI = in.DataDiskURI
		if in.CachingMode != nil {
			in, out := &in.CachingMode, &out.CachingMode
			*out = new(AzureDataDiskCachingMode)
			**out = **in
		} else {
			out.CachingMode = nil
		}
		if in.FSType != nil {
			in, out := &in.FSType, &out.FSType
			*out = new(string)
			**out = **in
		} else {
			out.FSType = nil
		}
		if in.ReadOnly != nil {
			in, out := &in.ReadOnly, &out.ReadOnly
			*out = new(bool)
			**out = **in
		} else {
			out.ReadOnly = nil
		}
		return nil
	}
}

func DeepCopy_api_AzureFileVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*AzureFileVolumeSource)
		out := out.(*AzureFileVolumeSource)
		out.SecretName = in.SecretName
		out.ShareName = in.ShareName
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_Binding(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Binding)
		out := out.(*Binding)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.Target = in.Target
		return nil
	}
}

func DeepCopy_api_Capabilities(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Capabilities)
		out := out.(*Capabilities)
		if in.Add != nil {
			in, out := &in.Add, &out.Add
			*out = make([]Capability, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Add = nil
		}
		if in.Drop != nil {
			in, out := &in.Drop, &out.Drop
			*out = make([]Capability, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Drop = nil
		}
		return nil
	}
}

func DeepCopy_api_CephFSVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*CephFSVolumeSource)
		out := out.(*CephFSVolumeSource)
		if in.Monitors != nil {
			in, out := &in.Monitors, &out.Monitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Monitors = nil
		}
		out.Path = in.Path
		out.User = in.User
		out.SecretFile = in.SecretFile
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
		} else {
			out.SecretRef = nil
		}
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_CinderVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*CinderVolumeSource)
		out := out.(*CinderVolumeSource)
		out.VolumeID = in.VolumeID
		out.FSType = in.FSType
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_ComponentCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentCondition)
		out := out.(*ComponentCondition)
		out.Type = in.Type
		out.Status = in.Status
		out.Message = in.Message
		out.Error = in.Error
		return nil
	}
}

func DeepCopy_api_ComponentStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentStatus)
		out := out.(*ComponentStatus)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]ComponentCondition, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Conditions = nil
		}
		return nil
	}
}

func DeepCopy_api_ComponentStatusList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ComponentStatusList)
		out := out.(*ComponentStatusList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ComponentStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ComponentStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ConfigMap(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMap)
		out := out.(*ConfigMap)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.Data = nil
		}
		return nil
	}
}

func DeepCopy_api_ConfigMapKeySelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapKeySelector)
		out := out.(*ConfigMapKeySelector)
		out.LocalObjectReference = in.LocalObjectReference
		out.Key = in.Key
		return nil
	}
}

func DeepCopy_api_ConfigMapList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapList)
		out := out.(*ConfigMapList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ConfigMap, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ConfigMap(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ConfigMapVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConfigMapVolumeSource)
		out := out.(*ConfigMapVolumeSource)
		out.LocalObjectReference = in.LocalObjectReference
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopy_api_KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		} else {
			out.DefaultMode = nil
		}
		return nil
	}
}

func DeepCopy_api_Container(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Container)
		out := out.(*Container)
		out.Name = in.Name
		out.Image = in.Image
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Command = nil
		}
		if in.Args != nil {
			in, out := &in.Args, &out.Args
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Args = nil
		}
		out.WorkingDir = in.WorkingDir
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]ContainerPort, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Ports = nil
		}
		if in.Env != nil {
			in, out := &in.Env, &out.Env
			*out = make([]EnvVar, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EnvVar(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Env = nil
		}
		if err := DeepCopy_api_ResourceRequirements(&in.Resources, &out.Resources, c); err != nil {
			return err
		}
		if in.VolumeMounts != nil {
			in, out := &in.VolumeMounts, &out.VolumeMounts
			*out = make([]VolumeMount, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.VolumeMounts = nil
		}
		if in.LivenessProbe != nil {
			in, out := &in.LivenessProbe, &out.LivenessProbe
			*out = new(Probe)
			if err := DeepCopy_api_Probe(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.LivenessProbe = nil
		}
		if in.ReadinessProbe != nil {
			in, out := &in.ReadinessProbe, &out.ReadinessProbe
			*out = new(Probe)
			if err := DeepCopy_api_Probe(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.ReadinessProbe = nil
		}
		if in.Lifecycle != nil {
			in, out := &in.Lifecycle, &out.Lifecycle
			*out = new(Lifecycle)
			if err := DeepCopy_api_Lifecycle(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Lifecycle = nil
		}
		out.TerminationMessagePath = in.TerminationMessagePath
		out.ImagePullPolicy = in.ImagePullPolicy
		if in.SecurityContext != nil {
			in, out := &in.SecurityContext, &out.SecurityContext
			*out = new(SecurityContext)
			if err := DeepCopy_api_SecurityContext(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.SecurityContext = nil
		}
		out.Stdin = in.Stdin
		out.StdinOnce = in.StdinOnce
		out.TTY = in.TTY
		return nil
	}
}

func DeepCopy_api_ContainerImage(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerImage)
		out := out.(*ContainerImage)
		if in.Names != nil {
			in, out := &in.Names, &out.Names
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Names = nil
		}
		out.SizeBytes = in.SizeBytes
		return nil
	}
}

func DeepCopy_api_ContainerPort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerPort)
		out := out.(*ContainerPort)
		out.Name = in.Name
		out.HostPort = in.HostPort
		out.ContainerPort = in.ContainerPort
		out.Protocol = in.Protocol
		out.HostIP = in.HostIP
		return nil
	}
}

func DeepCopy_api_ContainerState(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerState)
		out := out.(*ContainerState)
		if in.Waiting != nil {
			in, out := &in.Waiting, &out.Waiting
			*out = new(ContainerStateWaiting)
			**out = **in
		} else {
			out.Waiting = nil
		}
		if in.Running != nil {
			in, out := &in.Running, &out.Running
			*out = new(ContainerStateRunning)
			if err := DeepCopy_api_ContainerStateRunning(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Running = nil
		}
		if in.Terminated != nil {
			in, out := &in.Terminated, &out.Terminated
			*out = new(ContainerStateTerminated)
			if err := DeepCopy_api_ContainerStateTerminated(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Terminated = nil
		}
		return nil
	}
}

func DeepCopy_api_ContainerStateRunning(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateRunning)
		out := out.(*ContainerStateRunning)
		out.StartedAt = in.StartedAt.DeepCopy()
		return nil
	}
}

func DeepCopy_api_ContainerStateTerminated(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateTerminated)
		out := out.(*ContainerStateTerminated)
		out.ExitCode = in.ExitCode
		out.Signal = in.Signal
		out.Reason = in.Reason
		out.Message = in.Message
		out.StartedAt = in.StartedAt.DeepCopy()
		out.FinishedAt = in.FinishedAt.DeepCopy()
		out.ContainerID = in.ContainerID
		return nil
	}
}

func DeepCopy_api_ContainerStateWaiting(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStateWaiting)
		out := out.(*ContainerStateWaiting)
		out.Reason = in.Reason
		out.Message = in.Message
		return nil
	}
}

func DeepCopy_api_ContainerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ContainerStatus)
		out := out.(*ContainerStatus)
		out.Name = in.Name
		if err := DeepCopy_api_ContainerState(&in.State, &out.State, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ContainerState(&in.LastTerminationState, &out.LastTerminationState, c); err != nil {
			return err
		}
		out.Ready = in.Ready
		out.RestartCount = in.RestartCount
		out.Image = in.Image
		out.ImageID = in.ImageID
		out.ContainerID = in.ContainerID
		return nil
	}
}

func DeepCopy_api_ConversionError(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ConversionError)
		out := out.(*ConversionError)
		if in.In == nil {
			out.In = nil
		} else if newVal, err := c.DeepCopy(&in.In); err != nil {
			return err
		} else {
			out.In = *newVal.(*interface{})
		}
		if in.Out == nil {
			out.Out = nil
		} else if newVal, err := c.DeepCopy(&in.Out); err != nil {
			return err
		} else {
			out.Out = *newVal.(*interface{})
		}
		out.Message = in.Message
		return nil
	}
}

func DeepCopy_api_DaemonEndpoint(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DaemonEndpoint)
		out := out.(*DaemonEndpoint)
		out.Port = in.Port
		return nil
	}
}

func DeepCopy_api_DeleteOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DeleteOptions)
		out := out.(*DeleteOptions)
		out.TypeMeta = in.TypeMeta
		if in.GracePeriodSeconds != nil {
			in, out := &in.GracePeriodSeconds, &out.GracePeriodSeconds
			*out = new(int64)
			**out = **in
		} else {
			out.GracePeriodSeconds = nil
		}
		if in.Preconditions != nil {
			in, out := &in.Preconditions, &out.Preconditions
			*out = new(Preconditions)
			if err := DeepCopy_api_Preconditions(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Preconditions = nil
		}
		if in.OrphanDependents != nil {
			in, out := &in.OrphanDependents, &out.OrphanDependents
			*out = new(bool)
			**out = **in
		} else {
			out.OrphanDependents = nil
		}
		return nil
	}
}

func DeepCopy_api_DownwardAPIVolumeFile(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DownwardAPIVolumeFile)
		out := out.(*DownwardAPIVolumeFile)
		out.Path = in.Path
		if in.FieldRef != nil {
			in, out := &in.FieldRef, &out.FieldRef
			*out = new(ObjectFieldSelector)
			**out = **in
		} else {
			out.FieldRef = nil
		}
		if in.ResourceFieldRef != nil {
			in, out := &in.ResourceFieldRef, &out.ResourceFieldRef
			*out = new(ResourceFieldSelector)
			if err := DeepCopy_api_ResourceFieldSelector(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.ResourceFieldRef = nil
		}
		if in.Mode != nil {
			in, out := &in.Mode, &out.Mode
			*out = new(int32)
			**out = **in
		} else {
			out.Mode = nil
		}
		return nil
	}
}

func DeepCopy_api_DownwardAPIVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DownwardAPIVolumeSource)
		out := out.(*DownwardAPIVolumeSource)
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]DownwardAPIVolumeFile, len(*in))
			for i := range *in {
				if err := DeepCopy_api_DownwardAPIVolumeFile(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		} else {
			out.DefaultMode = nil
		}
		return nil
	}
}

func DeepCopy_api_EmptyDirVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EmptyDirVolumeSource)
		out := out.(*EmptyDirVolumeSource)
		out.Medium = in.Medium
		return nil
	}
}

func DeepCopy_api_EndpointAddress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointAddress)
		out := out.(*EndpointAddress)
		out.IP = in.IP
		out.Hostname = in.Hostname
		if in.NodeName != nil {
			in, out := &in.NodeName, &out.NodeName
			*out = new(string)
			**out = **in
		} else {
			out.NodeName = nil
		}
		if in.TargetRef != nil {
			in, out := &in.TargetRef, &out.TargetRef
			*out = new(ObjectReference)
			**out = **in
		} else {
			out.TargetRef = nil
		}
		return nil
	}
}

func DeepCopy_api_EndpointPort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointPort)
		out := out.(*EndpointPort)
		out.Name = in.Name
		out.Port = in.Port
		out.Protocol = in.Protocol
		return nil
	}
}

func DeepCopy_api_EndpointSubset(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointSubset)
		out := out.(*EndpointSubset)
		if in.Addresses != nil {
			in, out := &in.Addresses, &out.Addresses
			*out = make([]EndpointAddress, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EndpointAddress(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Addresses = nil
		}
		if in.NotReadyAddresses != nil {
			in, out := &in.NotReadyAddresses, &out.NotReadyAddresses
			*out = make([]EndpointAddress, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EndpointAddress(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.NotReadyAddresses = nil
		}
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]EndpointPort, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Ports = nil
		}
		return nil
	}
}

func DeepCopy_api_Endpoints(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Endpoints)
		out := out.(*Endpoints)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Subsets != nil {
			in, out := &in.Subsets, &out.Subsets
			*out = make([]EndpointSubset, len(*in))
			for i := range *in {
				if err := DeepCopy_api_EndpointSubset(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Subsets = nil
		}
		return nil
	}
}

func DeepCopy_api_EndpointsList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EndpointsList)
		out := out.(*EndpointsList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Endpoints, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Endpoints(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_EnvVar(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EnvVar)
		out := out.(*EnvVar)
		out.Name = in.Name
		out.Value = in.Value
		if in.ValueFrom != nil {
			in, out := &in.ValueFrom, &out.ValueFrom
			*out = new(EnvVarSource)
			if err := DeepCopy_api_EnvVarSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.ValueFrom = nil
		}
		return nil
	}
}

func DeepCopy_api_EnvVarSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EnvVarSource)
		out := out.(*EnvVarSource)
		if in.FieldRef != nil {
			in, out := &in.FieldRef, &out.FieldRef
			*out = new(ObjectFieldSelector)
			**out = **in
		} else {
			out.FieldRef = nil
		}
		if in.ResourceFieldRef != nil {
			in, out := &in.ResourceFieldRef, &out.ResourceFieldRef
			*out = new(ResourceFieldSelector)
			if err := DeepCopy_api_ResourceFieldSelector(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.ResourceFieldRef = nil
		}
		if in.ConfigMapKeyRef != nil {
			in, out := &in.ConfigMapKeyRef, &out.ConfigMapKeyRef
			*out = new(ConfigMapKeySelector)
			**out = **in
		} else {
			out.ConfigMapKeyRef = nil
		}
		if in.SecretKeyRef != nil {
			in, out := &in.SecretKeyRef, &out.SecretKeyRef
			*out = new(SecretKeySelector)
			**out = **in
		} else {
			out.SecretKeyRef = nil
		}
		return nil
	}
}

func DeepCopy_api_Event(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Event)
		out := out.(*Event)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.InvolvedObject = in.InvolvedObject
		out.Reason = in.Reason
		out.Message = in.Message
		out.Source = in.Source
		out.FirstTimestamp = in.FirstTimestamp.DeepCopy()
		out.LastTimestamp = in.LastTimestamp.DeepCopy()
		out.Count = in.Count
		out.Type = in.Type
		return nil
	}
}

func DeepCopy_api_EventList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EventList)
		out := out.(*EventList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Event, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Event(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_EventSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*EventSource)
		out := out.(*EventSource)
		out.Component = in.Component
		out.Host = in.Host
		return nil
	}
}

func DeepCopy_api_ExecAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ExecAction)
		out := out.(*ExecAction)
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Command = nil
		}
		return nil
	}
}

func DeepCopy_api_ExportOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ExportOptions)
		out := out.(*ExportOptions)
		out.TypeMeta = in.TypeMeta
		out.Export = in.Export
		out.Exact = in.Exact
		return nil
	}
}

func DeepCopy_api_FCVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FCVolumeSource)
		out := out.(*FCVolumeSource)
		if in.TargetWWNs != nil {
			in, out := &in.TargetWWNs, &out.TargetWWNs
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.TargetWWNs = nil
		}
		if in.Lun != nil {
			in, out := &in.Lun, &out.Lun
			*out = new(int32)
			**out = **in
		} else {
			out.Lun = nil
		}
		out.FSType = in.FSType
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_FlexVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FlexVolumeSource)
		out := out.(*FlexVolumeSource)
		out.Driver = in.Driver
		out.FSType = in.FSType
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
		} else {
			out.SecretRef = nil
		}
		out.ReadOnly = in.ReadOnly
		if in.Options != nil {
			in, out := &in.Options, &out.Options
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.Options = nil
		}
		return nil
	}
}

func DeepCopy_api_FlockerVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*FlockerVolumeSource)
		out := out.(*FlockerVolumeSource)
		out.DatasetName = in.DatasetName
		out.DatasetUUID = in.DatasetUUID
		return nil
	}
}

func DeepCopy_api_GCEPersistentDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GCEPersistentDiskVolumeSource)
		out := out.(*GCEPersistentDiskVolumeSource)
		out.PDName = in.PDName
		out.FSType = in.FSType
		out.Partition = in.Partition
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_GitRepoVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GitRepoVolumeSource)
		out := out.(*GitRepoVolumeSource)
		out.Repository = in.Repository
		out.Revision = in.Revision
		out.Directory = in.Directory
		return nil
	}
}

func DeepCopy_api_GlusterfsVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*GlusterfsVolumeSource)
		out := out.(*GlusterfsVolumeSource)
		out.EndpointsName = in.EndpointsName
		out.Path = in.Path
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_HTTPGetAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HTTPGetAction)
		out := out.(*HTTPGetAction)
		out.Path = in.Path
		out.Port = in.Port
		out.Host = in.Host
		out.Scheme = in.Scheme
		if in.HTTPHeaders != nil {
			in, out := &in.HTTPHeaders, &out.HTTPHeaders
			*out = make([]HTTPHeader, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.HTTPHeaders = nil
		}
		return nil
	}
}

func DeepCopy_api_HTTPHeader(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HTTPHeader)
		out := out.(*HTTPHeader)
		out.Name = in.Name
		out.Value = in.Value
		return nil
	}
}

func DeepCopy_api_Handler(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Handler)
		out := out.(*Handler)
		if in.Exec != nil {
			in, out := &in.Exec, &out.Exec
			*out = new(ExecAction)
			if err := DeepCopy_api_ExecAction(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Exec = nil
		}
		if in.HTTPGet != nil {
			in, out := &in.HTTPGet, &out.HTTPGet
			*out = new(HTTPGetAction)
			if err := DeepCopy_api_HTTPGetAction(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.HTTPGet = nil
		}
		if in.TCPSocket != nil {
			in, out := &in.TCPSocket, &out.TCPSocket
			*out = new(TCPSocketAction)
			**out = **in
		} else {
			out.TCPSocket = nil
		}
		return nil
	}
}

func DeepCopy_api_HostPathVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*HostPathVolumeSource)
		out := out.(*HostPathVolumeSource)
		out.Path = in.Path
		return nil
	}
}

func DeepCopy_api_ISCSIVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ISCSIVolumeSource)
		out := out.(*ISCSIVolumeSource)
		out.TargetPortal = in.TargetPortal
		out.IQN = in.IQN
		out.Lun = in.Lun
		out.ISCSIInterface = in.ISCSIInterface
		out.FSType = in.FSType
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_KeyToPath(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*KeyToPath)
		out := out.(*KeyToPath)
		out.Key = in.Key
		out.Path = in.Path
		if in.Mode != nil {
			in, out := &in.Mode, &out.Mode
			*out = new(int32)
			**out = **in
		} else {
			out.Mode = nil
		}
		return nil
	}
}

func DeepCopy_api_Lifecycle(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Lifecycle)
		out := out.(*Lifecycle)
		if in.PostStart != nil {
			in, out := &in.PostStart, &out.PostStart
			*out = new(Handler)
			if err := DeepCopy_api_Handler(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.PostStart = nil
		}
		if in.PreStop != nil {
			in, out := &in.PreStop, &out.PreStop
			*out = new(Handler)
			if err := DeepCopy_api_Handler(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.PreStop = nil
		}
		return nil
	}
}

func DeepCopy_api_LimitRange(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRange)
		out := out.(*LimitRange)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_LimitRangeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_LimitRangeItem(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeItem)
		out := out.(*LimitRangeItem)
		out.Type = in.Type
		if in.Max != nil {
			in, out := &in.Max, &out.Max
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Max = nil
		}
		if in.Min != nil {
			in, out := &in.Min, &out.Min
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Min = nil
		}
		if in.Default != nil {
			in, out := &in.Default, &out.Default
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Default = nil
		}
		if in.DefaultRequest != nil {
			in, out := &in.DefaultRequest, &out.DefaultRequest
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.DefaultRequest = nil
		}
		if in.MaxLimitRequestRatio != nil {
			in, out := &in.MaxLimitRequestRatio, &out.MaxLimitRequestRatio
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.MaxLimitRequestRatio = nil
		}
		return nil
	}
}

func DeepCopy_api_LimitRangeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeList)
		out := out.(*LimitRangeList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]LimitRange, len(*in))
			for i := range *in {
				if err := DeepCopy_api_LimitRange(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_LimitRangeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LimitRangeSpec)
		out := out.(*LimitRangeSpec)
		if in.Limits != nil {
			in, out := &in.Limits, &out.Limits
			*out = make([]LimitRangeItem, len(*in))
			for i := range *in {
				if err := DeepCopy_api_LimitRangeItem(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Limits = nil
		}
		return nil
	}
}

func DeepCopy_api_List(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*List)
		out := out.(*List)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]runtime.Object, len(*in))
			for i := range *in {
				if newVal, err := c.DeepCopy(&(*in)[i]); err != nil {
					return err
				} else {
					(*out)[i] = *newVal.(*runtime.Object)
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ListOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ListOptions)
		out := out.(*ListOptions)
		out.TypeMeta = in.TypeMeta
		if in.LabelSelector == nil {
			out.LabelSelector = nil
		} else if newVal, err := c.DeepCopy(&in.LabelSelector); err != nil {
			return err
		} else {
			out.LabelSelector = *newVal.(*labels.Selector)
		}
		if in.FieldSelector == nil {
			out.FieldSelector = nil
		} else if newVal, err := c.DeepCopy(&in.FieldSelector); err != nil {
			return err
		} else {
			out.FieldSelector = *newVal.(*fields.Selector)
		}
		out.Watch = in.Watch
		out.ResourceVersion = in.ResourceVersion
		if in.TimeoutSeconds != nil {
			in, out := &in.TimeoutSeconds, &out.TimeoutSeconds
			*out = new(int64)
			**out = **in
		} else {
			out.TimeoutSeconds = nil
		}
		return nil
	}
}

func DeepCopy_api_LoadBalancerIngress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LoadBalancerIngress)
		out := out.(*LoadBalancerIngress)
		out.IP = in.IP
		out.Hostname = in.Hostname
		return nil
	}
}

func DeepCopy_api_LoadBalancerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LoadBalancerStatus)
		out := out.(*LoadBalancerStatus)
		if in.Ingress != nil {
			in, out := &in.Ingress, &out.Ingress
			*out = make([]LoadBalancerIngress, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Ingress = nil
		}
		return nil
	}
}

func DeepCopy_api_LocalObjectReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*LocalObjectReference)
		out := out.(*LocalObjectReference)
		out.Name = in.Name
		return nil
	}
}

func DeepCopy_api_NFSVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NFSVolumeSource)
		out := out.(*NFSVolumeSource)
		out.Server = in.Server
		out.Path = in.Path
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_Namespace(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Namespace)
		out := out.(*Namespace)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_NamespaceSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		out.Status = in.Status
		return nil
	}
}

func DeepCopy_api_NamespaceList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceList)
		out := out.(*NamespaceList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Namespace, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Namespace(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_NamespaceSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceSpec)
		out := out.(*NamespaceSpec)
		if in.Finalizers != nil {
			in, out := &in.Finalizers, &out.Finalizers
			*out = make([]FinalizerName, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Finalizers = nil
		}
		return nil
	}
}

func DeepCopy_api_NamespaceStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NamespaceStatus)
		out := out.(*NamespaceStatus)
		out.Phase = in.Phase
		return nil
	}
}

func DeepCopy_api_Node(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Node)
		out := out.(*Node)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.Spec = in.Spec
		if err := DeepCopy_api_NodeStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_NodeAddress(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeAddress)
		out := out.(*NodeAddress)
		out.Type = in.Type
		out.Address = in.Address
		return nil
	}
}

func DeepCopy_api_NodeAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeAffinity)
		out := out.(*NodeAffinity)
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = new(NodeSelector)
			if err := DeepCopy_api_NodeSelector(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.RequiredDuringSchedulingIgnoredDuringExecution = nil
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]PreferredSchedulingTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PreferredSchedulingTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.PreferredDuringSchedulingIgnoredDuringExecution = nil
		}
		return nil
	}
}

func DeepCopy_api_NodeCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeCondition)
		out := out.(*NodeCondition)
		out.Type = in.Type
		out.Status = in.Status
		out.LastHeartbeatTime = in.LastHeartbeatTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
		return nil
	}
}

func DeepCopy_api_NodeDaemonEndpoints(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeDaemonEndpoints)
		out := out.(*NodeDaemonEndpoints)
		out.KubeletEndpoint = in.KubeletEndpoint
		return nil
	}
}

func DeepCopy_api_NodeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeList)
		out := out.(*NodeList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Node, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Node(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_NodeProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeProxyOptions)
		out := out.(*NodeProxyOptions)
		out.TypeMeta = in.TypeMeta
		out.Path = in.Path
		return nil
	}
}

func DeepCopy_api_NodeResources(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeResources)
		out := out.(*NodeResources)
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Capacity = nil
		}
		return nil
	}
}

func DeepCopy_api_NodeSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelector)
		out := out.(*NodeSelector)
		if in.NodeSelectorTerms != nil {
			in, out := &in.NodeSelectorTerms, &out.NodeSelectorTerms
			*out = make([]NodeSelectorTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_NodeSelectorTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.NodeSelectorTerms = nil
		}
		return nil
	}
}

func DeepCopy_api_NodeSelectorRequirement(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelectorRequirement)
		out := out.(*NodeSelectorRequirement)
		out.Key = in.Key
		out.Operator = in.Operator
		if in.Values != nil {
			in, out := &in.Values, &out.Values
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Values = nil
		}
		return nil
	}
}

func DeepCopy_api_NodeSelectorTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSelectorTerm)
		out := out.(*NodeSelectorTerm)
		if in.MatchExpressions != nil {
			in, out := &in.MatchExpressions, &out.MatchExpressions
			*out = make([]NodeSelectorRequirement, len(*in))
			for i := range *in {
				if err := DeepCopy_api_NodeSelectorRequirement(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.MatchExpressions = nil
		}
		return nil
	}
}

func DeepCopy_api_NodeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSpec)
		out := out.(*NodeSpec)
		out.PodCIDR = in.PodCIDR
		out.ExternalID = in.ExternalID
		out.ProviderID = in.ProviderID
		out.Unschedulable = in.Unschedulable
		return nil
	}
}

func DeepCopy_api_NodeStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeStatus)
		out := out.(*NodeStatus)
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Capacity = nil
		}
		if in.Allocatable != nil {
			in, out := &in.Allocatable, &out.Allocatable
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Allocatable = nil
		}
		out.Phase = in.Phase
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]NodeCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_NodeCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Conditions = nil
		}
		if in.Addresses != nil {
			in, out := &in.Addresses, &out.Addresses
			*out = make([]NodeAddress, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Addresses = nil
		}
		out.DaemonEndpoints = in.DaemonEndpoints
		out.NodeInfo = in.NodeInfo
		if in.Images != nil {
			in, out := &in.Images, &out.Images
			*out = make([]ContainerImage, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ContainerImage(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Images = nil
		}
		if in.VolumesInUse != nil {
			in, out := &in.VolumesInUse, &out.VolumesInUse
			*out = make([]UniqueVolumeName, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.VolumesInUse = nil
		}
		if in.VolumesAttached != nil {
			in, out := &in.VolumesAttached, &out.VolumesAttached
			*out = make([]AttachedVolume, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.VolumesAttached = nil
		}
		return nil
	}
}

func DeepCopy_api_NodeSystemInfo(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*NodeSystemInfo)
		out := out.(*NodeSystemInfo)
		out.MachineID = in.MachineID
		out.SystemUUID = in.SystemUUID
		out.BootID = in.BootID
		out.KernelVersion = in.KernelVersion
		out.OSImage = in.OSImage
		out.ContainerRuntimeVersion = in.ContainerRuntimeVersion
		out.KubeletVersion = in.KubeletVersion
		out.KubeProxyVersion = in.KubeProxyVersion
		out.OperatingSystem = in.OperatingSystem
		out.Architecture = in.Architecture
		return nil
	}
}

func DeepCopy_api_ObjectFieldSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectFieldSelector)
		out := out.(*ObjectFieldSelector)
		out.APIVersion = in.APIVersion
		out.FieldPath = in.FieldPath
		return nil
	}
}

func DeepCopy_api_ObjectMeta(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectMeta)
		out := out.(*ObjectMeta)
		out.Name = in.Name
		out.GenerateName = in.GenerateName
		out.Namespace = in.Namespace
		out.SelfLink = in.SelfLink
		out.UID = in.UID
		out.ResourceVersion = in.ResourceVersion
		out.Generation = in.Generation
		out.CreationTimestamp = in.CreationTimestamp.DeepCopy()
		if in.DeletionTimestamp != nil {
			in, out := &in.DeletionTimestamp, &out.DeletionTimestamp
			*out = new(unversioned.Time)
			**out = (*in).DeepCopy()
		} else {
			out.DeletionTimestamp = nil
		}
		if in.DeletionGracePeriodSeconds != nil {
			in, out := &in.DeletionGracePeriodSeconds, &out.DeletionGracePeriodSeconds
			*out = new(int64)
			**out = **in
		} else {
			out.DeletionGracePeriodSeconds = nil
		}
		if in.Labels != nil {
			in, out := &in.Labels, &out.Labels
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.Labels = nil
		}
		if in.Annotations != nil {
			in, out := &in.Annotations, &out.Annotations
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.Annotations = nil
		}
		if in.OwnerReferences != nil {
			in, out := &in.OwnerReferences, &out.OwnerReferences
			*out = make([]OwnerReference, len(*in))
			for i := range *in {
				if err := DeepCopy_api_OwnerReference(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.OwnerReferences = nil
		}
		if in.Finalizers != nil {
			in, out := &in.Finalizers, &out.Finalizers
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Finalizers = nil
		}
		out.ClusterName = in.ClusterName
		return nil
	}
}

func DeepCopy_api_ObjectReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ObjectReference)
		out := out.(*ObjectReference)
		out.Kind = in.Kind
		out.Namespace = in.Namespace
		out.Name = in.Name
		out.UID = in.UID
		out.APIVersion = in.APIVersion
		out.ResourceVersion = in.ResourceVersion
		out.FieldPath = in.FieldPath
		return nil
	}
}

func DeepCopy_api_OwnerReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*OwnerReference)
		out := out.(*OwnerReference)
		out.APIVersion = in.APIVersion
		out.Kind = in.Kind
		out.Name = in.Name
		out.UID = in.UID
		if in.Controller != nil {
			in, out := &in.Controller, &out.Controller
			*out = new(bool)
			**out = **in
		} else {
			out.Controller = nil
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolume)
		out := out.(*PersistentVolume)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PersistentVolumeSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		out.Status = in.Status
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaim(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaim)
		out := out.(*PersistentVolumeClaim)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PersistentVolumeClaimSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PersistentVolumeClaimStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaimList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimList)
		out := out.(*PersistentVolumeClaimList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PersistentVolumeClaim, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PersistentVolumeClaim(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaimSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimSpec)
		out := out.(*PersistentVolumeClaimSpec)
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.AccessModes = nil
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = new(unversioned.LabelSelector)
			if err := unversioned.DeepCopy_unversioned_LabelSelector(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Selector = nil
		}
		if err := DeepCopy_api_ResourceRequirements(&in.Resources, &out.Resources, c); err != nil {
			return err
		}
		out.VolumeName = in.VolumeName
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaimStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimStatus)
		out := out.(*PersistentVolumeClaimStatus)
		out.Phase = in.Phase
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.AccessModes = nil
		}
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Capacity = nil
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeClaimVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeClaimVolumeSource)
		out := out.(*PersistentVolumeClaimVolumeSource)
		out.ClaimName = in.ClaimName
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_PersistentVolumeList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeList)
		out := out.(*PersistentVolumeList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PersistentVolume, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PersistentVolume(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeSource)
		out := out.(*PersistentVolumeSource)
		if in.GCEPersistentDisk != nil {
			in, out := &in.GCEPersistentDisk, &out.GCEPersistentDisk
			*out = new(GCEPersistentDiskVolumeSource)
			**out = **in
		} else {
			out.GCEPersistentDisk = nil
		}
		if in.AWSElasticBlockStore != nil {
			in, out := &in.AWSElasticBlockStore, &out.AWSElasticBlockStore
			*out = new(AWSElasticBlockStoreVolumeSource)
			**out = **in
		} else {
			out.AWSElasticBlockStore = nil
		}
		if in.HostPath != nil {
			in, out := &in.HostPath, &out.HostPath
			*out = new(HostPathVolumeSource)
			**out = **in
		} else {
			out.HostPath = nil
		}
		if in.Glusterfs != nil {
			in, out := &in.Glusterfs, &out.Glusterfs
			*out = new(GlusterfsVolumeSource)
			**out = **in
		} else {
			out.Glusterfs = nil
		}
		if in.NFS != nil {
			in, out := &in.NFS, &out.NFS
			*out = new(NFSVolumeSource)
			**out = **in
		} else {
			out.NFS = nil
		}
		if in.RBD != nil {
			in, out := &in.RBD, &out.RBD
			*out = new(RBDVolumeSource)
			if err := DeepCopy_api_RBDVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.RBD = nil
		}
		if in.Quobyte != nil {
			in, out := &in.Quobyte, &out.Quobyte
			*out = new(QuobyteVolumeSource)
			**out = **in
		} else {
			out.Quobyte = nil
		}
		if in.ISCSI != nil {
			in, out := &in.ISCSI, &out.ISCSI
			*out = new(ISCSIVolumeSource)
			**out = **in
		} else {
			out.ISCSI = nil
		}
		if in.FlexVolume != nil {
			in, out := &in.FlexVolume, &out.FlexVolume
			*out = new(FlexVolumeSource)
			if err := DeepCopy_api_FlexVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.FlexVolume = nil
		}
		if in.Cinder != nil {
			in, out := &in.Cinder, &out.Cinder
			*out = new(CinderVolumeSource)
			**out = **in
		} else {
			out.Cinder = nil
		}
		if in.CephFS != nil {
			in, out := &in.CephFS, &out.CephFS
			*out = new(CephFSVolumeSource)
			if err := DeepCopy_api_CephFSVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.CephFS = nil
		}
		if in.FC != nil {
			in, out := &in.FC, &out.FC
			*out = new(FCVolumeSource)
			if err := DeepCopy_api_FCVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.FC = nil
		}
		if in.Flocker != nil {
			in, out := &in.Flocker, &out.Flocker
			*out = new(FlockerVolumeSource)
			**out = **in
		} else {
			out.Flocker = nil
		}
		if in.AzureFile != nil {
			in, out := &in.AzureFile, &out.AzureFile
			*out = new(AzureFileVolumeSource)
			**out = **in
		} else {
			out.AzureFile = nil
		}
		if in.VsphereVolume != nil {
			in, out := &in.VsphereVolume, &out.VsphereVolume
			*out = new(VsphereVirtualDiskVolumeSource)
			**out = **in
		} else {
			out.VsphereVolume = nil
		}
		if in.AzureDisk != nil {
			in, out := &in.AzureDisk, &out.AzureDisk
			*out = new(AzureDiskVolumeSource)
			if err := DeepCopy_api_AzureDiskVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.AzureDisk = nil
		}
		if in.PhotonPersistentDisk != nil {
			in, out := &in.PhotonPersistentDisk, &out.PhotonPersistentDisk
			*out = new(PhotonPersistentDiskVolumeSource)
			**out = **in
		} else {
			out.PhotonPersistentDisk = nil
		}
		return nil
	}
}

func DeepCopy_api_PersistentVolumeSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeSpec)
		out := out.(*PersistentVolumeSpec)
		if in.Capacity != nil {
			in, out := &in.Capacity, &out.Capacity
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Capacity = nil
		}
		if err := DeepCopy_api_PersistentVolumeSource(&in.PersistentVolumeSource, &out.PersistentVolumeSource, c); err != nil {
			return err
		}
		if in.AccessModes != nil {
			in, out := &in.AccessModes, &out.AccessModes
			*out = make([]PersistentVolumeAccessMode, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.AccessModes = nil
		}
		if in.ClaimRef != nil {
			in, out := &in.ClaimRef, &out.ClaimRef
			*out = new(ObjectReference)
			**out = **in
		} else {
			out.ClaimRef = nil
		}
		out.PersistentVolumeReclaimPolicy = in.PersistentVolumeReclaimPolicy
		return nil
	}
}

func DeepCopy_api_PersistentVolumeStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PersistentVolumeStatus)
		out := out.(*PersistentVolumeStatus)
		out.Phase = in.Phase
		out.Message = in.Message
		out.Reason = in.Reason
		return nil
	}
}

func DeepCopy_api_PhotonPersistentDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PhotonPersistentDiskVolumeSource)
		out := out.(*PhotonPersistentDiskVolumeSource)
		out.PdID = in.PdID
		out.FSType = in.FSType
		return nil
	}
}

func DeepCopy_api_Pod(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Pod)
		out := out.(*Pod)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_PodAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAffinity)
		out := out.(*PodAffinity)
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = make([]PodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.RequiredDuringSchedulingIgnoredDuringExecution = nil
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]WeightedPodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_WeightedPodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.PreferredDuringSchedulingIgnoredDuringExecution = nil
		}
		return nil
	}
}

func DeepCopy_api_PodAffinityTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAffinityTerm)
		out := out.(*PodAffinityTerm)
		if in.LabelSelector != nil {
			in, out := &in.LabelSelector, &out.LabelSelector
			*out = new(unversioned.LabelSelector)
			if err := unversioned.DeepCopy_unversioned_LabelSelector(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.LabelSelector = nil
		}
		if in.Namespaces != nil {
			in, out := &in.Namespaces, &out.Namespaces
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Namespaces = nil
		}
		out.TopologyKey = in.TopologyKey
		return nil
	}
}

func DeepCopy_api_PodAntiAffinity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAntiAffinity)
		out := out.(*PodAntiAffinity)
		if in.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.RequiredDuringSchedulingIgnoredDuringExecution, &out.RequiredDuringSchedulingIgnoredDuringExecution
			*out = make([]PodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.RequiredDuringSchedulingIgnoredDuringExecution = nil
		}
		if in.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			in, out := &in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution
			*out = make([]WeightedPodAffinityTerm, len(*in))
			for i := range *in {
				if err := DeepCopy_api_WeightedPodAffinityTerm(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.PreferredDuringSchedulingIgnoredDuringExecution = nil
		}
		return nil
	}
}

func DeepCopy_api_PodAttachOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodAttachOptions)
		out := out.(*PodAttachOptions)
		out.TypeMeta = in.TypeMeta
		out.Stdin = in.Stdin
		out.Stdout = in.Stdout
		out.Stderr = in.Stderr
		out.TTY = in.TTY
		out.Container = in.Container
		return nil
	}
}

func DeepCopy_api_PodCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodCondition)
		out := out.(*PodCondition)
		out.Type = in.Type
		out.Status = in.Status
		out.LastProbeTime = in.LastProbeTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
		return nil
	}
}

func DeepCopy_api_PodExecOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodExecOptions)
		out := out.(*PodExecOptions)
		out.TypeMeta = in.TypeMeta
		out.Stdin = in.Stdin
		out.Stdout = in.Stdout
		out.Stderr = in.Stderr
		out.TTY = in.TTY
		out.Container = in.Container
		if in.Command != nil {
			in, out := &in.Command, &out.Command
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Command = nil
		}
		return nil
	}
}

func DeepCopy_api_PodList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodList)
		out := out.(*PodList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Pod, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Pod(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_PodLogOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodLogOptions)
		out := out.(*PodLogOptions)
		out.TypeMeta = in.TypeMeta
		out.Container = in.Container
		out.Follow = in.Follow
		out.Previous = in.Previous
		if in.SinceSeconds != nil {
			in, out := &in.SinceSeconds, &out.SinceSeconds
			*out = new(int64)
			**out = **in
		} else {
			out.SinceSeconds = nil
		}
		if in.SinceTime != nil {
			in, out := &in.SinceTime, &out.SinceTime
			*out = new(unversioned.Time)
			**out = (*in).DeepCopy()
		} else {
			out.SinceTime = nil
		}
		out.Timestamps = in.Timestamps
		if in.TailLines != nil {
			in, out := &in.TailLines, &out.TailLines
			*out = new(int64)
			**out = **in
		} else {
			out.TailLines = nil
		}
		if in.LimitBytes != nil {
			in, out := &in.LimitBytes, &out.LimitBytes
			*out = new(int64)
			**out = **in
		} else {
			out.LimitBytes = nil
		}
		return nil
	}
}

func DeepCopy_api_PodProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodProxyOptions)
		out := out.(*PodProxyOptions)
		out.TypeMeta = in.TypeMeta
		out.Path = in.Path
		return nil
	}
}

func DeepCopy_api_PodSecurityContext(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSecurityContext)
		out := out.(*PodSecurityContext)
		out.HostNetwork = in.HostNetwork
		out.HostPID = in.HostPID
		out.HostIPC = in.HostIPC
		if in.SELinuxOptions != nil {
			in, out := &in.SELinuxOptions, &out.SELinuxOptions
			*out = new(SELinuxOptions)
			**out = **in
		} else {
			out.SELinuxOptions = nil
		}
		if in.RunAsUser != nil {
			in, out := &in.RunAsUser, &out.RunAsUser
			*out = new(int64)
			**out = **in
		} else {
			out.RunAsUser = nil
		}
		if in.RunAsNonRoot != nil {
			in, out := &in.RunAsNonRoot, &out.RunAsNonRoot
			*out = new(bool)
			**out = **in
		} else {
			out.RunAsNonRoot = nil
		}
		if in.SupplementalGroups != nil {
			in, out := &in.SupplementalGroups, &out.SupplementalGroups
			*out = make([]int64, len(*in))
			copy(*out, *in)
		} else {
			out.SupplementalGroups = nil
		}
		if in.FSGroup != nil {
			in, out := &in.FSGroup, &out.FSGroup
			*out = new(int64)
			**out = **in
		} else {
			out.FSGroup = nil
		}
		return nil
	}
}

func DeepCopy_api_PodSignature(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSignature)
		out := out.(*PodSignature)
		if in.PodController != nil {
			in, out := &in.PodController, &out.PodController
			*out = new(OwnerReference)
			if err := DeepCopy_api_OwnerReference(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.PodController = nil
		}
		return nil
	}
}

func DeepCopy_api_PodSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodSpec)
		out := out.(*PodSpec)
		if in.Volumes != nil {
			in, out := &in.Volumes, &out.Volumes
			*out = make([]Volume, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Volume(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Volumes = nil
		}
		if in.InitContainers != nil {
			in, out := &in.InitContainers, &out.InitContainers
			*out = make([]Container, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Container(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.InitContainers = nil
		}
		if in.Containers != nil {
			in, out := &in.Containers, &out.Containers
			*out = make([]Container, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Container(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Containers = nil
		}
		out.RestartPolicy = in.RestartPolicy
		if in.TerminationGracePeriodSeconds != nil {
			in, out := &in.TerminationGracePeriodSeconds, &out.TerminationGracePeriodSeconds
			*out = new(int64)
			**out = **in
		} else {
			out.TerminationGracePeriodSeconds = nil
		}
		if in.ActiveDeadlineSeconds != nil {
			in, out := &in.ActiveDeadlineSeconds, &out.ActiveDeadlineSeconds
			*out = new(int64)
			**out = **in
		} else {
			out.ActiveDeadlineSeconds = nil
		}
		out.DNSPolicy = in.DNSPolicy
		if in.NodeSelector != nil {
			in, out := &in.NodeSelector, &out.NodeSelector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.NodeSelector = nil
		}
		out.ServiceAccountName = in.ServiceAccountName
		out.NodeName = in.NodeName
		if in.SecurityContext != nil {
			in, out := &in.SecurityContext, &out.SecurityContext
			*out = new(PodSecurityContext)
			if err := DeepCopy_api_PodSecurityContext(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.SecurityContext = nil
		}
		if in.ImagePullSecrets != nil {
			in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
			*out = make([]LocalObjectReference, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.ImagePullSecrets = nil
		}
		out.Hostname = in.Hostname
		out.Subdomain = in.Subdomain
		return nil
	}
}

func DeepCopy_api_PodStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodStatus)
		out := out.(*PodStatus)
		out.Phase = in.Phase
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]PodCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PodCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Conditions = nil
		}
		out.Message = in.Message
		out.Reason = in.Reason
		out.HostIP = in.HostIP
		out.PodIP = in.PodIP
		if in.StartTime != nil {
			in, out := &in.StartTime, &out.StartTime
			*out = new(unversioned.Time)
			**out = (*in).DeepCopy()
		} else {
			out.StartTime = nil
		}
		if in.InitContainerStatuses != nil {
			in, out := &in.InitContainerStatuses, &out.InitContainerStatuses
			*out = make([]ContainerStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ContainerStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.InitContainerStatuses = nil
		}
		if in.ContainerStatuses != nil {
			in, out := &in.ContainerStatuses, &out.ContainerStatuses
			*out = make([]ContainerStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ContainerStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.ContainerStatuses = nil
		}
		return nil
	}
}

func DeepCopy_api_PodStatusResult(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodStatusResult)
		out := out.(*PodStatusResult)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_PodTemplate(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplate)
		out := out.(*PodTemplate)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodTemplateSpec(&in.Template, &out.Template, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_PodTemplateList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplateList)
		out := out.(*PodTemplateList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]PodTemplate, len(*in))
			for i := range *in {
				if err := DeepCopy_api_PodTemplate(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_PodTemplateSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PodTemplateSpec)
		out := out.(*PodTemplateSpec)
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_PodSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_Preconditions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Preconditions)
		out := out.(*Preconditions)
		if in.UID != nil {
			in, out := &in.UID, &out.UID
			*out = new(types.UID)
			**out = **in
		} else {
			out.UID = nil
		}
		return nil
	}
}

func DeepCopy_api_PreferAvoidPodsEntry(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PreferAvoidPodsEntry)
		out := out.(*PreferAvoidPodsEntry)
		if err := DeepCopy_api_PodSignature(&in.PodSignature, &out.PodSignature, c); err != nil {
			return err
		}
		out.EvictionTime = in.EvictionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
		return nil
	}
}

func DeepCopy_api_PreferredSchedulingTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*PreferredSchedulingTerm)
		out := out.(*PreferredSchedulingTerm)
		out.Weight = in.Weight
		if err := DeepCopy_api_NodeSelectorTerm(&in.Preference, &out.Preference, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_Probe(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Probe)
		out := out.(*Probe)
		if err := DeepCopy_api_Handler(&in.Handler, &out.Handler, c); err != nil {
			return err
		}
		out.InitialDelaySeconds = in.InitialDelaySeconds
		out.TimeoutSeconds = in.TimeoutSeconds
		out.PeriodSeconds = in.PeriodSeconds
		out.SuccessThreshold = in.SuccessThreshold
		out.FailureThreshold = in.FailureThreshold
		return nil
	}
}

func DeepCopy_api_QuobyteVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*QuobyteVolumeSource)
		out := out.(*QuobyteVolumeSource)
		out.Registry = in.Registry
		out.Volume = in.Volume
		out.ReadOnly = in.ReadOnly
		out.User = in.User
		out.Group = in.Group
		return nil
	}
}

func DeepCopy_api_RBDVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*RBDVolumeSource)
		out := out.(*RBDVolumeSource)
		if in.CephMonitors != nil {
			in, out := &in.CephMonitors, &out.CephMonitors
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.CephMonitors = nil
		}
		out.RBDImage = in.RBDImage
		out.FSType = in.FSType
		out.RBDPool = in.RBDPool
		out.RadosUser = in.RadosUser
		out.Keyring = in.Keyring
		if in.SecretRef != nil {
			in, out := &in.SecretRef, &out.SecretRef
			*out = new(LocalObjectReference)
			**out = **in
		} else {
			out.SecretRef = nil
		}
		out.ReadOnly = in.ReadOnly
		return nil
	}
}

func DeepCopy_api_RangeAllocation(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*RangeAllocation)
		out := out.(*RangeAllocation)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.Range = in.Range
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make([]byte, len(*in))
			copy(*out, *in)
		} else {
			out.Data = nil
		}
		return nil
	}
}

func DeepCopy_api_ReplicationController(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationController)
		out := out.(*ReplicationController)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ReplicationControllerSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ReplicationControllerStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ReplicationControllerCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerCondition)
		out := out.(*ReplicationControllerCondition)
		out.Type = in.Type
		out.Status = in.Status
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
		return nil
	}
}

func DeepCopy_api_ReplicationControllerList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerList)
		out := out.(*ReplicationControllerList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ReplicationController, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ReplicationController(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ReplicationControllerSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerSpec)
		out := out.(*ReplicationControllerSpec)
		out.Replicas = in.Replicas
		out.MinReadySeconds = in.MinReadySeconds
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.Selector = nil
		}
		if in.Template != nil {
			in, out := &in.Template, &out.Template
			*out = new(PodTemplateSpec)
			if err := DeepCopy_api_PodTemplateSpec(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Template = nil
		}
		return nil
	}
}

func DeepCopy_api_ReplicationControllerStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ReplicationControllerStatus)
		out := out.(*ReplicationControllerStatus)
		out.Replicas = in.Replicas
		out.FullyLabeledReplicas = in.FullyLabeledReplicas
		out.ReadyReplicas = in.ReadyReplicas
		out.AvailableReplicas = in.AvailableReplicas
		out.ObservedGeneration = in.ObservedGeneration
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]ReplicationControllerCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ReplicationControllerCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Conditions = nil
		}
		return nil
	}
}

func DeepCopy_api_ResourceFieldSelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceFieldSelector)
		out := out.(*ResourceFieldSelector)
		out.ContainerName = in.ContainerName
		out.Resource = in.Resource
		out.Divisor = in.Divisor.DeepCopy()
		return nil
	}
}

func DeepCopy_api_ResourceQuota(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuota)
		out := out.(*ResourceQuota)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ResourceQuotaSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ResourceQuotaStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ResourceQuotaList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaList)
		out := out.(*ResourceQuotaList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ResourceQuota, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ResourceQuota(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ResourceQuotaSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaSpec)
		out := out.(*ResourceQuotaSpec)
		if in.Hard != nil {
			in, out := &in.Hard, &out.Hard
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Hard = nil
		}
		if in.Scopes != nil {
			in, out := &in.Scopes, &out.Scopes
			*out = make([]ResourceQuotaScope, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Scopes = nil
		}
		return nil
	}
}

func DeepCopy_api_ResourceQuotaStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceQuotaStatus)
		out := out.(*ResourceQuotaStatus)
		if in.Hard != nil {
			in, out := &in.Hard, &out.Hard
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Hard = nil
		}
		if in.Used != nil {
			in, out := &in.Used, &out.Used
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Used = nil
		}
		return nil
	}
}

func DeepCopy_api_ResourceRequirements(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ResourceRequirements)
		out := out.(*ResourceRequirements)
		if in.Limits != nil {
			in, out := &in.Limits, &out.Limits
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Limits = nil
		}
		if in.Requests != nil {
			in, out := &in.Requests, &out.Requests
			*out = make(ResourceList)
			for key, val := range *in {
				(*out)[key] = val.DeepCopy()
			}
		} else {
			out.Requests = nil
		}
		return nil
	}
}

func DeepCopy_api_SELinuxOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SELinuxOptions)
		out := out.(*SELinuxOptions)
		out.User = in.User
		out.Role = in.Role
		out.Type = in.Type
		out.Level = in.Level
		return nil
	}
}

func DeepCopy_api_Secret(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Secret)
		out := out.(*Secret)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Data != nil {
			in, out := &in.Data, &out.Data
			*out = make(map[string][]byte)
			for key, val := range *in {
				if newVal, err := c.DeepCopy(&val); err != nil {
					return err
				} else {
					(*out)[key] = *newVal.(*[]byte)
				}
			}
		} else {
			out.Data = nil
		}
		out.Type = in.Type
		return nil
	}
}

func DeepCopy_api_SecretKeySelector(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretKeySelector)
		out := out.(*SecretKeySelector)
		out.LocalObjectReference = in.LocalObjectReference
		out.Key = in.Key
		return nil
	}
}

func DeepCopy_api_SecretList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretList)
		out := out.(*SecretList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Secret, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Secret(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_SecretVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecretVolumeSource)
		out := out.(*SecretVolumeSource)
		out.SecretName = in.SecretName
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]KeyToPath, len(*in))
			for i := range *in {
				if err := DeepCopy_api_KeyToPath(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		if in.DefaultMode != nil {
			in, out := &in.DefaultMode, &out.DefaultMode
			*out = new(int32)
			**out = **in
		} else {
			out.DefaultMode = nil
		}
		return nil
	}
}

func DeepCopy_api_SecurityContext(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SecurityContext)
		out := out.(*SecurityContext)
		if in.Capabilities != nil {
			in, out := &in.Capabilities, &out.Capabilities
			*out = new(Capabilities)
			if err := DeepCopy_api_Capabilities(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Capabilities = nil
		}
		if in.Privileged != nil {
			in, out := &in.Privileged, &out.Privileged
			*out = new(bool)
			**out = **in
		} else {
			out.Privileged = nil
		}
		if in.SELinuxOptions != nil {
			in, out := &in.SELinuxOptions, &out.SELinuxOptions
			*out = new(SELinuxOptions)
			**out = **in
		} else {
			out.SELinuxOptions = nil
		}
		if in.RunAsUser != nil {
			in, out := &in.RunAsUser, &out.RunAsUser
			*out = new(int64)
			**out = **in
		} else {
			out.RunAsUser = nil
		}
		if in.RunAsNonRoot != nil {
			in, out := &in.RunAsNonRoot, &out.RunAsNonRoot
			*out = new(bool)
			**out = **in
		} else {
			out.RunAsNonRoot = nil
		}
		if in.ReadOnlyRootFilesystem != nil {
			in, out := &in.ReadOnlyRootFilesystem, &out.ReadOnlyRootFilesystem
			*out = new(bool)
			**out = **in
		} else {
			out.ReadOnlyRootFilesystem = nil
		}
		return nil
	}
}

func DeepCopy_api_SerializedReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SerializedReference)
		out := out.(*SerializedReference)
		out.TypeMeta = in.TypeMeta
		out.Reference = in.Reference
		return nil
	}
}

func DeepCopy_api_Service(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Service)
		out := out.(*Service)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ServiceSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ServiceStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ServiceAccount(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceAccount)
		out := out.(*ServiceAccount)
		out.TypeMeta = in.TypeMeta
		if err := DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Secrets != nil {
			in, out := &in.Secrets, &out.Secrets
			*out = make([]ObjectReference, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Secrets = nil
		}
		if in.ImagePullSecrets != nil {
			in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
			*out = make([]LocalObjectReference, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.ImagePullSecrets = nil
		}
		return nil
	}
}

func DeepCopy_api_ServiceAccountList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceAccountList)
		out := out.(*ServiceAccountList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ServiceAccount, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ServiceAccount(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ServiceList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceList)
		out := out.(*ServiceList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Service, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Service(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ServicePort(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServicePort)
		out := out.(*ServicePort)
		out.Name = in.Name
		out.Protocol = in.Protocol
		out.Port = in.Port
		out.TargetPort = in.TargetPort
		out.NodePort = in.NodePort
		return nil
	}
}

func DeepCopy_api_ServiceProxyOptions(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceProxyOptions)
		out := out.(*ServiceProxyOptions)
		out.TypeMeta = in.TypeMeta
		out.Path = in.Path
		return nil
	}
}

func DeepCopy_api_ServiceSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceSpec)
		out := out.(*ServiceSpec)
		out.Type = in.Type
		if in.Ports != nil {
			in, out := &in.Ports, &out.Ports
			*out = make([]ServicePort, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Ports = nil
		}
		if in.Selector != nil {
			in, out := &in.Selector, &out.Selector
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.Selector = nil
		}
		out.ClusterIP = in.ClusterIP
		out.ExternalName = in.ExternalName
		if in.ExternalIPs != nil {
			in, out := &in.ExternalIPs, &out.ExternalIPs
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.ExternalIPs = nil
		}
		out.LoadBalancerIP = in.LoadBalancerIP
		out.SessionAffinity = in.SessionAffinity
		if in.LoadBalancerSourceRanges != nil {
			in, out := &in.LoadBalancerSourceRanges, &out.LoadBalancerSourceRanges
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.LoadBalancerSourceRanges = nil
		}
		return nil
	}
}

func DeepCopy_api_ServiceStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ServiceStatus)
		out := out.(*ServiceStatus)
		if err := DeepCopy_api_LoadBalancerStatus(&in.LoadBalancer, &out.LoadBalancer, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_Sysctl(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Sysctl)
		out := out.(*Sysctl)
		out.Name = in.Name
		out.Value = in.Value
		return nil
	}
}

func DeepCopy_api_TCPSocketAction(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*TCPSocketAction)
		out := out.(*TCPSocketAction)
		out.Port = in.Port
		return nil
	}
}

func DeepCopy_api_Taint(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Taint)
		out := out.(*Taint)
		out.Key = in.Key
		out.Value = in.Value
		out.Effect = in.Effect
		return nil
	}
}

func DeepCopy_api_Toleration(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Toleration)
		out := out.(*Toleration)
		out.Key = in.Key
		out.Operator = in.Operator
		out.Value = in.Value
		out.Effect = in.Effect
		return nil
	}
}

func DeepCopy_api_Volume(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Volume)
		out := out.(*Volume)
		out.Name = in.Name
		if err := DeepCopy_api_VolumeSource(&in.VolumeSource, &out.VolumeSource, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_VolumeMount(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VolumeMount)
		out := out.(*VolumeMount)
		out.Name = in.Name
		out.ReadOnly = in.ReadOnly
		out.MountPath = in.MountPath
		out.SubPath = in.SubPath
		return nil
	}
}

func DeepCopy_api_VolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VolumeSource)
		out := out.(*VolumeSource)
		if in.HostPath != nil {
			in, out := &in.HostPath, &out.HostPath
			*out = new(HostPathVolumeSource)
			**out = **in
		} else {
			out.HostPath = nil
		}
		if in.EmptyDir != nil {
			in, out := &in.EmptyDir, &out.EmptyDir
			*out = new(EmptyDirVolumeSource)
			**out = **in
		} else {
			out.EmptyDir = nil
		}
		if in.GCEPersistentDisk != nil {
			in, out := &in.GCEPersistentDisk, &out.GCEPersistentDisk
			*out = new(GCEPersistentDiskVolumeSource)
			**out = **in
		} else {
			out.GCEPersistentDisk = nil
		}
		if in.AWSElasticBlockStore != nil {
			in, out := &in.AWSElasticBlockStore, &out.AWSElasticBlockStore
			*out = new(AWSElasticBlockStoreVolumeSource)
			**out = **in
		} else {
			out.AWSElasticBlockStore = nil
		}
		if in.GitRepo != nil {
			in, out := &in.GitRepo, &out.GitRepo
			*out = new(GitRepoVolumeSource)
			**out = **in
		} else {
			out.GitRepo = nil
		}
		if in.Secret != nil {
			in, out := &in.Secret, &out.Secret
			*out = new(SecretVolumeSource)
			if err := DeepCopy_api_SecretVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Secret = nil
		}
		if in.NFS != nil {
			in, out := &in.NFS, &out.NFS
			*out = new(NFSVolumeSource)
			**out = **in
		} else {
			out.NFS = nil
		}
		if in.ISCSI != nil {
			in, out := &in.ISCSI, &out.ISCSI
			*out = new(ISCSIVolumeSource)
			**out = **in
		} else {
			out.ISCSI = nil
		}
		if in.Glusterfs != nil {
			in, out := &in.Glusterfs, &out.Glusterfs
			*out = new(GlusterfsVolumeSource)
			**out = **in
		} else {
			out.Glusterfs = nil
		}
		if in.PersistentVolumeClaim != nil {
			in, out := &in.PersistentVolumeClaim, &out.PersistentVolumeClaim
			*out = new(PersistentVolumeClaimVolumeSource)
			**out = **in
		} else {
			out.PersistentVolumeClaim = nil
		}
		if in.RBD != nil {
			in, out := &in.RBD, &out.RBD
			*out = new(RBDVolumeSource)
			if err := DeepCopy_api_RBDVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.RBD = nil
		}
		if in.Quobyte != nil {
			in, out := &in.Quobyte, &out.Quobyte
			*out = new(QuobyteVolumeSource)
			**out = **in
		} else {
			out.Quobyte = nil
		}
		if in.FlexVolume != nil {
			in, out := &in.FlexVolume, &out.FlexVolume
			*out = new(FlexVolumeSource)
			if err := DeepCopy_api_FlexVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.FlexVolume = nil
		}
		if in.Cinder != nil {
			in, out := &in.Cinder, &out.Cinder
			*out = new(CinderVolumeSource)
			**out = **in
		} else {
			out.Cinder = nil
		}
		if in.CephFS != nil {
			in, out := &in.CephFS, &out.CephFS
			*out = new(CephFSVolumeSource)
			if err := DeepCopy_api_CephFSVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.CephFS = nil
		}
		if in.Flocker != nil {
			in, out := &in.Flocker, &out.Flocker
			*out = new(FlockerVolumeSource)
			**out = **in
		} else {
			out.Flocker = nil
		}
		if in.DownwardAPI != nil {
			in, out := &in.DownwardAPI, &out.DownwardAPI
			*out = new(DownwardAPIVolumeSource)
			if err := DeepCopy_api_DownwardAPIVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.DownwardAPI = nil
		}
		if in.FC != nil {
			in, out := &in.FC, &out.FC
			*out = new(FCVolumeSource)
			if err := DeepCopy_api_FCVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.FC = nil
		}
		if in.AzureFile != nil {
			in, out := &in.AzureFile, &out.AzureFile
			*out = new(AzureFileVolumeSource)
			**out = **in
		} else {
			out.AzureFile = nil
		}
		if in.ConfigMap != nil {
			in, out := &in.ConfigMap, &out.ConfigMap
			*out = new(ConfigMapVolumeSource)
			if err := DeepCopy_api_ConfigMapVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.ConfigMap = nil
		}
		if in.VsphereVolume != nil {
			in, out := &in.VsphereVolume, &out.VsphereVolume
			*out = new(VsphereVirtualDiskVolumeSource)
			**out = **in
		} else {
			out.VsphereVolume = nil
		}
		if in.AzureDisk != nil {
			in, out := &in.AzureDisk, &out.AzureDisk
			*out = new(AzureDiskVolumeSource)
			if err := DeepCopy_api_AzureDiskVolumeSource(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.AzureDisk = nil
		}
		if in.PhotonPersistentDisk != nil {
			in, out := &in.PhotonPersistentDisk, &out.PhotonPersistentDisk
			*out = new(PhotonPersistentDiskVolumeSource)
			**out = **in
		} else {
			out.PhotonPersistentDisk = nil
		}
		return nil
	}
}

func DeepCopy_api_VsphereVirtualDiskVolumeSource(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*VsphereVirtualDiskVolumeSource)
		out := out.(*VsphereVirtualDiskVolumeSource)
		out.VolumePath = in.VolumePath
		out.FSType = in.FSType
		return nil
	}
}

func DeepCopy_api_WeightedPodAffinityTerm(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*WeightedPodAffinityTerm)
		out := out.(*WeightedPodAffinityTerm)
		out.Weight = in.Weight
		if err := DeepCopy_api_PodAffinityTerm(&in.PodAffinityTerm, &out.PodAffinityTerm, c); err != nil {
			return err
		}
		return nil
	}
}
