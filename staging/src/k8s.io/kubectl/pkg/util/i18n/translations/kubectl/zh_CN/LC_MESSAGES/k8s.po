# Test translations for unit tests.
# Copyright (C) 2017
# This file is distributed under the same license as the Kubernetes package.
# FIRST AUTHOR shiywang@redhat.com, 2017.
# FIRST AUTHOR zhengjiajin@caicloud.io, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: gettext-go-examples-hello\n"
"Report-Msgid-Bugs-To: EMAIL\n"
"POT-Creation-Date: 2021-07-07 20:15+0200\n"
"PO-Revision-Date: 2022-07-04 18:54+0800\n"
"Last-Translator: zhengjiajin <zhengjiajin@caicloud.io>\n"
"Language-Team: \n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.0.1\n"
"X-Poedit-SourceCharset: UTF-8\n"

#: staging/src/k8s.io/kubectl/pkg/cmd/top/top_node.go:62
msgid ""
"\n"
"\t\t  # Show metrics for all nodes\n"
"\t\t  kubectl top node\n"
"\n"
"\t\t  # Show metrics for a given node\n"
"\t\t  kubectl top node NODE_NAME"
msgstr ""
"\n"
"\t\t  # 显示所有节点的指标\n"
"\t\t  kubectl top node\n"
"\n"
"\t\t  # 显示指定节点的指标\n"
"\t\t  kubectl top node NODE_NAME"

#: staging/src/k8s.io/kubectl/pkg/cmd/explain/explain.go:46
msgid ""
"\n"
"\t\t# Get the documentation of the resource and its fields\n"
"\t\tkubectl explain pods\n"
"\n"
"\t\t# Get the documentation of a specific field of a resource\n"
"\t\tkubectl explain pods.spec.containers"
msgstr ""
"\n"
"\t\t# 获取资源及其字段的文档\n"
"\t\tkubectl explain pods\n"
"\n"
"\t\t# 获取资源指定字段的文档\n"
"\t\tkubectl explain pods.spec.containers"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/options.go#L37
#: staging/src/k8s.io/kubectl/pkg/cmd/options/options.go:29
msgid ""
"\n"
"\t\t# Print flags inherited by all commands\n"
"\t\tkubectl options"
msgstr ""
"\n"
"\t\t# 输出所有命令继承的 flags\n"
"\t\tkubectl options"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/version.go#L39
#: staging/src/k8s.io/kubectl/pkg/cmd/version/version.go:44
msgid ""
"\n"
"\t\t# Print the client and server versions for the current context\n"
"\t\tkubectl version"
msgstr ""
"\n"
"\t\t# 输出当前客户端和服务端的版本\n"
"\t\tkubectl version"

#: staging/src/k8s.io/kubectl/pkg/cmd/apiresources/apiversions.go:34
msgid ""
"\n"
"\t\t# Print the supported API versions\n"
"\t\tkubectl api-versions"
msgstr ""
"\n"
"\t\t# 输出支持的 API 版本\n"
"\t\tkubectl api-versions"

#: staging/src/k8s.io/kubectl/pkg/cmd/top/top_pod.go:75
msgid ""
"\n"
"\t\t# Show metrics for all pods in the default namespace\n"
"\t\tkubectl top pod\n"
"\n"
"\t\t# Show metrics for all pods in the given namespace\n"
"\t\tkubectl top pod --namespace=NAMESPACE\n"
"\n"
"\t\t# Show metrics for a given pod and its containers\n"
"\t\tkubectl top pod POD_NAME --containers\n"
"\n"
"\t\t# Show metrics for the pods defined by label name=myLabel\n"
"\t\tkubectl top pod -l name=myLabel"
msgstr ""
"\n"
"\t\t# 显示 default 命名空间下所有 Pods 的指标\n"
"\t\tkubectl top pod\n"
"\n"
"\t\t# 显示指定命名空间下所有 Pods 的指标\n"
"\t\tkubectl top pod --namespace=NAMESPACE\n"
"\n"
"\t\t# 显示指定 Pod 和它的容器的 metrics\n"
"\t\tkubectl top pod POD_NAME --containers\n"
"\n"
"\t\t# 显示指定 label 为 name=myLabel 的 Pods 的 metrics\n"
"\t\tkubectl top pod -l name=myLabel"

#: pkg/kubectl/cmd/convert/convert.go:40
msgid ""
"\n"
"\t\tConvert config files between different API versions. Both YAML\n"
"\t\tand JSON formats are accepted.\n"
"\n"
"\t\tThe command takes filename, directory, or URL as input, and convert it "
"into format\n"
"\t\tof version specified by --output-version flag. If target version is not "
"specified or\n"
"\t\tnot supported, convert to latest version.\n"
"\n"
"\t\tThe default output will be printed to stdout in YAML format. One can use -"
"o option\n"
"\t\tto change to output destination."
msgstr ""
"\n"
"\t\t在不同的 API 版本之间转换配置文件。接受 YAML\n"
"\t\t和 JSON 格式。\n"
"\n"
"\t\t这个命令以文件名, 目录, 或者 URL 作为输入，并通过 —output-version 参数\n"
"\t\t 转换到指定版本的格式。如果没有指定目标版本或者所指定版本\n"
"\t\t不支持, 则转换为最新版本。\n"
"\n"
"\t\t默认以 YAML 格式输出到标准输出。可以使用 -o option\n"
"\t\t修改目标输出的格式。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_namespace.go#L44
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_namespace.go:39
msgid ""
"\n"
"\t\tCreate a namespace with the specified name."
msgstr ""
"\n"
"\t\t用给定名称创建一个命名空间。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L47
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_role.go:43
msgid ""
"\n"
"\t\tCreate a role with single rule."
msgstr ""
"\n"
"\t\t创建一个具有单一规则的角色。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_serviceaccount.go#L44
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_serviceaccount.go:40
msgid ""
"\n"
"\t\tCreate a service account with the specified name."
msgstr ""
"\n"
"\t\t用指定的名称创建一个服务账户。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L127
#: staging/src/k8s.io/kubectl/pkg/cmd/drain/drain.go:84
msgid ""
"\n"
"\t\tMark node as schedulable."
msgstr ""
"\n"
"\t\t标记节点为可调度。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L102
#: staging/src/k8s.io/kubectl/pkg/cmd/drain/drain.go:55
msgid ""
"\n"
"\t\tMark node as unschedulable."
msgstr ""
"\n"
"\t\t标记节点为不可调度。"

#: staging/src/k8s.io/kubectl/pkg/cmd/apply/apply_set_last_applied.go:70
msgid ""
"\n"
"\t\tSet the latest last-applied-configuration annotations by setting it to "
"match the contents of a file.\n"
"\t\tThis results in the last-applied-configuration being updated as though "
"'kubectl apply -f <file>' was run,\n"
"\t\twithout updating any other parts of the object."
msgstr ""
"\n"
"\t\t设置最新的 last-applied-configuration 注解，使之匹配某文件的内容。\n"
"\t\t这会导致 last-applied-configuration 被更新，就像执行了 kubectl apply -f "
"<file> 一样，\n"
"\t\t只是不会更新对象的其他部分。"

#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_namespace.go:42
msgid ""
"\n"
"\t  # Create a new namespace named my-namespace\n"
"\t  kubectl create namespace my-namespace"
msgstr ""
"\n"
"\t  # 创建一个名为 my-namespace 的新命名空间\n"
"\t  kubectl create namespace my-namespace"

#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_serviceaccount.go:43
msgid ""
"\n"
"\t  # Create a new service account named my-service-account\n"
"\t  kubectl create serviceaccount my-service-account"
msgstr ""
"\n"
"\t  # 创建一个名为 my-service-account 的新服务帐户\n"
"\t  kubectl create serviceaccount my-service-account"

#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_service.go:344
msgid ""
"\n"
"\tCreate an ExternalName service with the specified name.\n"
"\n"
"\tExternalName service references to an external DNS address instead of\n"
"\tonly pods, which will allow application authors to reference services\n"
"\tthat exist off platform, on other clusters, or locally."
msgstr ""
"\n"
"\t创建具有指定名称的 ExternalName 服务。\n"
"\n"
"\tExternalName 服务引用外部 DNS 地址而不是 Pod 地址，\n"
"\t这将允许应用程序作者引用存在于平台外、其他集群上或本地的服务。"

#: staging/src/k8s.io/kubectl/pkg/cmd/help/help.go:28
msgid ""
"\n"
"\tHelp provides help for any command in the application.\n"
"\tSimply type kubectl help [path to command] for full details."
msgstr ""
"\n"
"\tHelp 为应用程序中的任何命令提供帮助。\n"
"\t只需键入 kubectl help [命令路径] 即可获得完整的详细信息。"

#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_service.go:311
msgid ""
"\n"
"    # Create a new LoadBalancer service named my-lbs\n"
"    kubectl create service loadbalancer my-lbs --tcp=5678:8080"
msgstr ""
"\n"
"    # 创建一个名称为 my-lbs 的新负载均衡服务\n"
"    kubectl create service loadbalancer my-lbs --tcp=5678:8080"

#: staging/src/k8s.io/kubectl/pkg/cmd/clusterinfo/clusterinfo_dump.go:102
msgid ""
"\n"
"    # Dump current cluster state to stdout\n"
"    kubectl cluster-info dump\n"
"\n"
"    # Dump current cluster state to /path/to/cluster-state\n"
"    kubectl cluster-info dump --output-directory=/path/to/cluster-state\n"
"\n"
"    # Dump all namespaces to stdout\n"
"    kubectl cluster-info dump --all-namespaces\n"
"\n"
"    # Dump a set of namespaces to /path/to/cluster-state\n"
"    kubectl cluster-info dump --namespaces default,kube-system --output-"
"directory=/path/to/cluster-state"
msgstr ""
"\n"
"    # 导出当前的集群状态信息到标准输出\n"
"    kubectl cluster-info dump\n"
"\n"
"    # 导出当前的集群状态到 /path/to/cluster-state\n"
"    kubectl cluster-info dump --output-directory=/path/to/cluster-state\n"
"\n"
"    # 导出所有命名空间到标准输出\n"
"    kubectl cluster-info dump --all-namespaces\n"
"\n"
"    # 导出一组命名空间到 /path/to/cluster-state\n"
"    kubectl cluster-info dump --namespaces default,kube-system --output-"
"directory=/path/to/cluster-state"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_namespace.go#L44
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_service.go:308
msgid ""
"\n"
"    Create a LoadBalancer service with the specified name."
msgstr ""
"\n"
"    使用一个指定的名称创建一个 LoadBalancer 服务。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L61
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_quota.go:107
msgid ""
"A comma-delimited set of quota scopes that must all match each object tracked "
"by the quota."
msgstr "一组以逗号分隔的配额范围，必须全部匹配配额所跟踪的每个对象。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L60
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_quota.go:106
msgid ""
"A comma-delimited set of resource=quantity pairs that define a hard limit."
msgstr "一组以逗号分隔的资源=数量对，用于定义硬性限制。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_pdb.go#L63
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_pdb.go:113
msgid ""
"A label selector to use for this budget. Only equality-based selector "
"requirements are supported."
msgstr "一个用于该预算的标签选择器。只支持基于等值比较的选择器要求。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L106
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:152
msgid ""
"A label selector to use for this service. Only equality-based selector "
"requirements are supported. If empty (the default) infer the selector from "
"the replication controller or replica set.)"
msgstr ""
"用于此服务的标签选择器。仅支持基于等值比较的选择器要求。如果为空（默认），则从"
"副本控制器或副本集中推断选择器。）"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L111
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:157
msgid ""
"Additional external IP address (not managed by Kubernetes) to accept for the "
"service. If this IP is routed to a node, the service can be accessed by this "
"IP in addition to its generated service IP."
msgstr ""
"为服务所接受的其他外部 IP 地址（不由 Kubernetes 管理）。如果这个 IP 被路由到一"
"个节点，除了其生成的服务 IP 外，还可以通过这个 IP 访问服务。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L119
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:158
#: staging/src/k8s.io/kubectl/pkg/cmd/run/run.go:178
msgid ""
"An inline JSON override for the generated object. If this is non-empty, it is "
"used to override the generated object. Requires that the object supply a "
"valid apiVersion field."
msgstr ""
"针对所生成对象的内联 JSON 覆盖。如果这一对象是非空的，将用于覆盖所生成的对象。"
"要求对象提供有效的 apiVersion 字段。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/certificates.go#L71
#: staging/src/k8s.io/kubectl/pkg/cmd/certificates/certificates.go:125
msgid "Approve a certificate signing request"
msgstr "批准一个证书签署请求"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L81
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_service.go:263
msgid ""
"Assign your own ClusterIP or set to 'None' for a 'headless' service (no "
"loadbalancing)."
msgstr "为“无头”服务（无负载平衡）分配你自己的 ClusterIP 或设置为“无。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/attach.go#L64
#: staging/src/k8s.io/kubectl/pkg/cmd/attach/attach.go:105
msgid "Attach to a running container"
msgstr "挂接到一个运行中的容器"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L115
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:161
msgid ""
"ClusterIP to be assigned to the service. Leave empty to auto-allocate, or set "
"to 'None' to create a headless service."
msgstr ""
"要分配给服务的 ClusterIP。留空表示自动分配，或设置为 “None” 以创建无头服务。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_clusterrolebinding.go#L55
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_clusterrolebinding.go:101
msgid "ClusterRole this ClusterRoleBinding should reference"
msgstr "ClusterRoleBinding 应该指定 ClusterRole"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_rolebinding.go#L55
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_rolebinding.go:104
msgid "ClusterRole this RoleBinding should reference"
msgstr "RoleBinding 应该指定 ClusterRole"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/convert.go#L67
#: pkg/kubectl/cmd/convert/convert.go:95
msgid "Convert config files between different API versions"
msgstr "在不同的 API 版本之间转换配置文件"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/cp.go#L64
#: staging/src/k8s.io/kubectl/pkg/cmd/cp/cp.go:106
msgid "Copy files and directories to and from containers."
msgstr "将文件和目录复制到容器中或从容器中复制出来。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L214
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_tls.go:94
msgid "Create a TLS secret"
msgstr "创建一个 TLS secret"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_namespace.go#L44
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_namespace.go:83
msgid "Create a namespace with the specified name"
msgstr "用指定的名称创建一个命名空间"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L143
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_docker.go:134
msgid "Create a secret for use with a Docker registry"
msgstr "创建一个给 Docker registry 使用的 Secret"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L34
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret.go:49
msgid "Create a secret using specified subcommand"
msgstr "使用指定的子命令创建一个 Secret"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_serviceaccount.go#L44
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_serviceaccount.go:85
msgid "Create a service account with the specified name"
msgstr "创建一个指定名称的服务账户"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/delete_cluster.go#L38
#: staging/src/k8s.io/kubectl/pkg/cmd/config/delete_cluster.go:42
msgid "Delete the specified cluster from the kubeconfig"
msgstr "从 kubeconfig 中删除指定的集群"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/delete_context.go#L38
#: staging/src/k8s.io/kubectl/pkg/cmd/config/delete_context.go:42
msgid "Delete the specified context from the kubeconfig"
msgstr "从 kubeconfig 中删除指定的上下文"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/certificates.go#L121
#: staging/src/k8s.io/kubectl/pkg/cmd/certificates/certificates.go:174
msgid "Deny a certificate signing request"
msgstr "拒绝一个证书签名请求"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/get_contexts.go#L62
#: staging/src/k8s.io/kubectl/pkg/cmd/config/get_contexts.go:72
msgid "Describe one or many contexts"
msgstr "描述一个或多个上下文"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/get_clusters.go#L40
#: staging/src/k8s.io/kubectl/pkg/cmd/config/get_clusters.go:41
msgid "Display clusters defined in the kubeconfig"
msgstr "显示在 kubeconfig 中定义的集群"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/view.go#L64
#: staging/src/k8s.io/kubectl/pkg/cmd/config/view.go:81
msgid "Display merged kubeconfig settings or a specified kubeconfig file"
msgstr "显示合并的 kubeconfig 配置或一个指定的 kubeconfig 文件"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/get.go#L107
#: staging/src/k8s.io/kubectl/pkg/cmd/get/get.go:165
msgid "Display one or many resources"
msgstr "显示一个或多个资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L176
#: staging/src/k8s.io/kubectl/pkg/cmd/drain/drain.go:184
msgid "Drain node in preparation for maintenance"
msgstr "清空节点以准备维护"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/edit.go#L100
#: staging/src/k8s.io/kubectl/pkg/cmd/edit/edit.go:77
msgid "Edit a resource on the server"
msgstr "编辑服务器上的资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L159
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_docker.go:152
msgid "Email for Docker registry"
msgstr "用于 Docker 镜像库的邮件地址"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/exec.go#L68
#: staging/src/k8s.io/kubectl/pkg/cmd/exec/exec.go:89
msgid "Execute a command in a container"
msgstr "在某个容器中执行一个命令"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/portforward.go#L75
#: staging/src/k8s.io/kubectl/pkg/cmd/portforward/portforward.go:109
msgid "Forward one or more local ports to a pod"
msgstr "将一个或多个本地端口转发到某个 Pod"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/help.go#L36
#: staging/src/k8s.io/kubectl/pkg/cmd/help/help.go:37
msgid "Help about any command"
msgstr "关于任何命令的帮助"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L114
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:160
msgid ""
"If non-empty, set the session affinity for the service to this; legal values: "
"'None', 'ClientIP'"
msgstr "如果非空，则将服务的会话亲和性设置为此值；合法值：'None'、'ClientIP'"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/annotate.go#L135
#: staging/src/k8s.io/kubectl/pkg/cmd/annotate/annotate.go:157
msgid ""
"If non-empty, the annotation update will only succeed if this is the current "
"resource-version for the object. Only valid when specifying a single resource."
msgstr ""
"如果非空，则只有当所给值是对象的当前资源版本时，注解更新才会成功。 仅在指定单"
"个资源时有效。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/label.go#L132
#: staging/src/k8s.io/kubectl/pkg/cmd/label/label.go:154
msgid ""
"If non-empty, the labels update will only succeed if this is the current "
"resource-version for the object. Only valid when specifying a single resource."
msgstr ""
"如果非空，则标签更新只有在所给值是对象的当前资源版本时才会成功。仅在指定单个资"
"源时有效。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L127
#: staging/src/k8s.io/kubectl/pkg/cmd/drain/drain.go:98
msgid "Mark node as schedulable"
msgstr "标记节点为可调度"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L102
#: staging/src/k8s.io/kubectl/pkg/cmd/drain/drain.go:69
msgid "Mark node as unschedulable"
msgstr "标记节点为不可调度"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_pause.go#L73
#: staging/src/k8s.io/kubectl/pkg/cmd/rollout/rollout_pause.go:83
msgid "Mark the provided resource as paused"
msgstr "将所指定的资源标记为已暂停"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/certificates.go#L35
#: staging/src/k8s.io/kubectl/pkg/cmd/certificates/certificates.go:49
#: staging/src/k8s.io/kubectl/pkg/cmd/certificates/certificates.go:50
msgid "Modify certificate resources."
msgstr "修改证书资源。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/config.go#L39
#: staging/src/k8s.io/kubectl/pkg/cmd/config/config.go:42
msgid "Modify kubeconfig files"
msgstr "修改 kubeconfig 文件"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L110
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:156
msgid ""
"Name or number for the port on the container that the service should direct "
"traffic to. Optional."
msgstr ""
"此为端口的名称或端口号，服务应将流量定向到容器上的这一端口。此属性为可选。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/logs.go#L108
#: staging/src/k8s.io/kubectl/pkg/cmd/logs/logs.go:174
msgid ""
"Only return logs after a specific date (RFC3339). Defaults to all logs. Only "
"one of since-time / since may be used."
msgstr ""
"仅返回在指定日期 (RFC3339) 之后的日志。默认为所有日志。只能使用 since-time / "
"since 之一。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/completion.go#L97
#: staging/src/k8s.io/kubectl/pkg/cmd/completion/completion.go:112
msgid "Output shell completion code for the specified shell (bash or zsh)"
msgstr "为指定的 Shell(Bash 或 zsh) 输出 Shell 补全代码。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L157
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_docker.go:151
msgid "Password for Docker registry authentication"
msgstr "用于 Docker 镜像库身份验证的密码"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L226
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_tls.go:110
msgid "Path to PEM encoded public key certificate."
msgstr "PEM 编码的公钥证书的路径。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L227
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_tls.go:111
msgid "Path to private key associated with given certificate."
msgstr "与给定证书关联的私钥的路径。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/scale.go#L82
#: staging/src/k8s.io/kubectl/pkg/cmd/scale/scale.go:130
msgid ""
"Precondition for resource version. Requires that the current resource version "
"match this value in order to scale."
msgstr "资源版本的前提条件。要求当前资源版本与此值匹配才能进行扩缩操作。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/version.go#L39
#: staging/src/k8s.io/kubectl/pkg/cmd/version/version.go:73
msgid "Print the client and server version information"
msgstr "输出客户端和服务端的版本信息"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/options.go#L37
#: staging/src/k8s.io/kubectl/pkg/cmd/options/options.go:38
#: staging/src/k8s.io/kubectl/pkg/cmd/options/options.go:39
msgid "Print the list of flags inherited by all commands"
msgstr "输出所有命令的层级关系"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/logs.go#L86
#: staging/src/k8s.io/kubectl/pkg/cmd/logs/logs.go:152
msgid "Print the logs for a container in a pod"
msgstr "打印 Pod 中容器的日志"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_resume.go#L71
#: staging/src/k8s.io/kubectl/pkg/cmd/rollout/rollout_resume.go:87
msgid "Resume a paused resource"
msgstr "恢复暂停的资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_rolebinding.go#L56
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_rolebinding.go:105
msgid "Role this RoleBinding should reference"
msgstr "RoleBinding 应该引用的 Role"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L94
#: staging/src/k8s.io/kubectl/pkg/cmd/run/run.go:152
msgid "Run a particular image on the cluster"
msgstr "在集群上运行特定镜像"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/proxy.go#L68
#: staging/src/k8s.io/kubectl/pkg/cmd/proxy/proxy.go:119
msgid "Run a proxy to the Kubernetes API server"
msgstr "运行一个指向 Kubernetes API 服务器的代理"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L161
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_docker.go:153
msgid "Server location for Docker registry"
msgstr "Docker 镜像库的服务器位置"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/set/set.go#L37
#: staging/src/k8s.io/kubectl/pkg/cmd/set/set.go:39
msgid "Set specific features on objects"
msgstr "为对象设置指定特性"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/set/set_selector.go#L81
#: staging/src/k8s.io/kubectl/pkg/cmd/set/set_selector.go:104
msgid "Set the selector on a resource"
msgstr "为资源设置选择器"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/describe.go#L80
#: staging/src/k8s.io/kubectl/pkg/cmd/describe/describe.go:107
msgid "Show details of a specific resource or group of resources"
msgstr "显示特定资源或资源组的详细信息"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_status.go#L57
#: staging/src/k8s.io/kubectl/pkg/cmd/rollout/rollout_status.go:102
msgid "Show the status of the rollout"
msgstr "显示上线的状态"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L108
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:154
msgid "Synonym for --target-port"
msgstr "--target-port 的同义词"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L114
#: staging/src/k8s.io/kubectl/pkg/cmd/run/run.go:174
msgid "The image for the container to run."
msgstr "指定容器要运行的镜像."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L116
#: staging/src/k8s.io/kubectl/pkg/cmd/run/run.go:176
msgid ""
"The image pull policy for the container. If left empty, this value will not "
"be specified by the client and defaulted by the server"
msgstr "容器的镜像拉取策略。如果留空，该值将不由客户端指定，由服务器默认设置"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_pdb.go#L62
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_pdb.go:111
msgid "The minimum number or percentage of available pods this budget requires."
msgstr "此预算要求的可用 Pod 的最小数量或百分比。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L113
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:159
msgid "The name for the newly created object."
msgstr "新创建的对象的名称。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/autoscale.go#L71
#: staging/src/k8s.io/kubectl/pkg/cmd/autoscale/autoscale.go:125
msgid ""
"The name for the newly created object. If not specified, the name of the "
"input resource will be used."
msgstr "新创建的对象的名称。如果未指定，将使用输入资源的名称。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L98
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:147
msgid ""
"The name of the API generator to use. There are 2 generators: 'service/v1' "
"and 'service/v2'. The only difference between them is that service port in v1 "
"is named 'default', while it is left unnamed in v2. Default is 'service/v2'."
msgstr ""
"要使用的 API 生成器的名称。有两个生成器。'service/v1' 和 'service/v2'。它们之"
"间唯一的区别是，v1 中的服务端口被命名为 'default'，如果在 v2 中没有指定名称。"
"默认是 'service/v2'。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L99
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:148
msgid "The network protocol for the service to be created. Default is 'TCP'."
msgstr "要创建的服务的网络协议。默认为 “TCP”。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L100
#: staging/src/k8s.io/kubectl/pkg/cmd/expose/expose.go:149
msgid ""
"The port that the service should serve on. Copied from the resource being "
"exposed, if unspecified"
msgstr "服务要使用的端口。如果没有指定，则从被暴露的资源复制"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L131
#: staging/src/k8s.io/kubectl/pkg/cmd/run/run.go:194
msgid ""
"The resource requirement limits for this container.  For example, 'cpu=200m,"
"memory=512Mi'.  Note that server side components may assign limits depending "
"on the server configuration, such as limit ranges."
msgstr ""
"这个容器的资源需求限制。例如，\"cpu=200m,内存=512Mi\"。请注意，服务器端的组件"
"可能会根据服务器的配置来分配限制，例如限制范围。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L130
#: staging/src/k8s.io/kubectl/pkg/cmd/run/run.go:192
msgid ""
"The resource requirement requests for this container.  For example, 'cpu=100m,"
"memory=256Mi'.  Note that server side components may assign requests "
"depending on the server configuration, such as limit ranges."
msgstr ""
"这个容器的资源需求请求。例如，\"cpu=200m,内存=512Mi\"。请注意，服务器端的组件"
"可能会根据服务器的配置来分配限制，例如限制范围。"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L87
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret.go:155
msgid "The type of secret to create"
msgstr "要创建的 Secret 类型"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_undo.go#L71
#: staging/src/k8s.io/kubectl/pkg/cmd/rollout/rollout_undo.go:87
msgid "Undo a previous rollout"
msgstr "撤销上一次的上线"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/set/set_resources.go#L101
#: staging/src/k8s.io/kubectl/pkg/cmd/set/set_resources.go:116
msgid "Update resource requests/limits on objects with pod templates"
msgstr "使用 Pod 模板更新对象的资源请求/限制"

#: staging/src/k8s.io/kubectl/pkg/cmd/annotate/annotate.go:135
msgid "Update the annotations on a resource"
msgstr "更新一个资源的注解"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/label.go#L109
#: staging/src/k8s.io/kubectl/pkg/cmd/label/label.go:133
msgid "Update the labels on a resource"
msgstr "更新某资源上的标签"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/taint.go#L88
#: staging/src/k8s.io/kubectl/pkg/cmd/taint/taint.go:109
msgid "Update the taints on one or more nodes"
msgstr "更新一个或者多个节点上的污点"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L155
#: staging/src/k8s.io/kubectl/pkg/cmd/create/create_secret_docker.go:150
msgid "Username for Docker registry authentication"
msgstr "用于 Docker 镜像库身份验证的用户名"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout_history.go#L51
#: staging/src/k8s.io/kubectl/pkg/cmd/rollout/rollout_history.go:83
msgid "View rollout history"
msgstr "显示上线历史"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/clusterinfo_dump.go#L45
#: staging/src/k8s.io/kubectl/pkg/cmd/clusterinfo/clusterinfo_dump.go:85
msgid ""
"Where to output the files.  If empty or '-' uses stdout, otherwise creates a "
"directory hierarchy in that directory"
msgstr ""
"在哪里输出文件。如果为空或 “-” 则使用标准输出，否则在该目录中创建目录层次结构"

#: staging/src/k8s.io/kubectl/pkg/cmd/run/run_test.go:88
msgid "dummy restart flag)"
msgstr "假的重启标志)"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/cmd.go#L217
#: staging/src/k8s.io/kubectl/pkg/cmd/cmd.go:227
msgid "kubectl controls the Kubernetes cluster manager"
msgstr "kubectl 控制 Kubernetes 集群管理器"

#~ msgid ""
#~ "\n"
#~ "\t\t  # Create a ClusterRoleBinding for user1, user2, and group1 using the "
#~ "cluster-admin ClusterRole\n"
#~ "\t\t  kubectl create clusterrolebinding cluster-admin --"
#~ "clusterrole=cluster-admin --user=user1 --user=user2 --group=group1"
#~ msgstr ""
#~ "\n"
#~ "\t\t  # 使用 cluster-admin ClusterRole 为 user1, user2, and group1 创建一"
#~ "个 ClusterRoleBinding\n"
#~ "\t\t  kubectl create clusterrolebinding cluster-admin --"
#~ "clusterrole=cluster-admin --user=user1 --user=user2 --group=group1"

#~ msgid ""
#~ "\n"
#~ "\t\t  # Create a RoleBinding for user1, user2, and group1 using the admin "
#~ "ClusterRole\n"
#~ "\t\t  kubectl create rolebinding admin --clusterrole=admin --user=user1 --"
#~ "user=user2 --group=group1"
#~ msgstr ""
#~ "\n"
#~ "\t\t  # 使用 admin ClusterRole 为 user1, user2, and group1 创建一个 "
#~ "RoleBinding\n"
#~ "\t\t  kubectl create rolebinding admin --clusterrole=admin --user=user1 --"
#~ "user=user2 --group=group1"

#~ msgid ""
#~ "\n"
#~ "\t\t  # Create a new configmap named my-config based on folder bar\n"
#~ "\t\t  kubectl create configmap my-config --from-file=path/to/bar\n"
#~ "\n"
#~ "\t\t  # Create a new configmap named my-config with specified keys instead "
#~ "of file basenames on disk\n"
#~ "\t\t  kubectl create configmap my-config --from-file=key1=/path/to/bar/"
#~ "file1.txt --from-file=key2=/path/to/bar/file2.txt\n"
#~ "\n"
#~ "\t\t  # Create a new configmap named my-config with key1=config1 and "
#~ "key2=config2\n"
#~ "\t\t  kubectl create configmap my-config --from-literal=key1=config1 --"
#~ "from-literal=key2=config2"
#~ msgstr ""
#~ "\n"
#~ "\t\t  # 通过文件夹 bar 创建一个名称为 my-config 的 configmap\n"
#~ "\t\t  kubectl create configmap my-config --from-file=path/to/bar\n"
#~ "\n"
#~ "\t\t  # 创建一个名称为 my-config 的 configmap 并指定 keys 而不是使用磁盘上"
#~ "所在的文件名\n"
#~ "\t\t  kubectl create configmap my-config --from-file=key1=/path/to/bar/"
#~ "file1.txt --from-file=key2=/path/to/bar/file2.txt\n"
#~ "\n"
#~ "\t\t  # 创建一个名称为 my-config 的 configmap 且 key1=config1 和 "
#~ "key2=config2\n"
#~ "\t\t  kubectl create configmap my-config --from-literal=key1=config1 --"
#~ "from-literal=key2=config2"

#~ msgid ""
#~ "\n"
#~ "\t\t  # If you don't already have a .dockercfg file, you can create a "
#~ "dockercfg secret directly by using:\n"
#~ "\t\t  kubectl create secret docker-registry my-secret --docker-"
#~ "server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-"
#~ "password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL"
#~ msgstr ""
#~ "\n"
#~ "\t\t  # 如果你还没有 .dockercfg 文件, 你可以直接使用下面的命令创建一个 "
#~ "dockercfg 类型的 Secret：\n"
#~ "\t\t  kubectl create secret docker-registry my-secret --docker-"
#~ "server=DOCKER_REGISTRY_SERVER --docker-username=DOCKER_USER --docker-"
#~ "password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL"

#~ msgid ""
#~ "\n"
#~ "\t\t# Apply the configuration in pod.json to a pod.\n"
#~ "\t\tkubectl apply -f ./pod.json\n"
#~ "\n"
#~ "\t\t# Apply the JSON passed into stdin to a pod.\n"
#~ "\t\tcat pod.json | kubectl apply -f -\n"
#~ "\n"
#~ "\t\t# Note: --prune is still in Alpha\n"
#~ "\t\t# Apply the configuration in manifest.yaml that matches label "
#~ "app=nginx and delete all the other resources that are not in the file and "
#~ "match label app=nginx.\n"
#~ "\t\tkubectl apply --prune -f manifest.yaml -l app=nginx\n"
#~ "\n"
#~ "\t\t# Apply the configuration in manifest.yaml and delete all the other "
#~ "configmaps that are not in the file.\n"
#~ "\t\tkubectl apply --prune -f manifest.yaml --all --prune-allowlist=core/v1/"
#~ "ConfigMap"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 将 pod.json 上的配置应用于 pod.\n"
#~ "\t\tkubectl apply -f ./pod.json\n"
#~ "\n"
#~ "\t\t# 将传入 stdin 的 JSON 应用到一个 pod.\n"
#~ "\t\tcat pod.json | kubectl apply -f -\n"
#~ "\n"
#~ "\t\t# Note: --prune 仍然在 Alpha\n"
#~ "\t\t# 应用在 manifest.yaml 中匹配标签 app=nginx 的资源配置并删除所有不在这"
#~ "个文件中并匹配标签app=nginx 的资源\n"
#~ "\t\tkubectl apply --prune -f manifest.yaml -l app=nginx\n"
#~ "\n"
#~ "\t\t# 应用 manifest.yaml 的配置并删除所有不在这个文件中的 ConfigMaps。\n"
#~ "\t\tkubectl apply --prune -f manifest.yaml --all --prune-allowlist=core/v1/"
#~ "ConfigMap"

#, c-format
#~ msgid ""
#~ "\n"
#~ "\t\t# Auto scale a deployment \"foo\", with the number of pods between 2 "
#~ "and 10, target CPU utilization specified so a default autoscaling policy "
#~ "will be used:\n"
#~ "\t\tkubectl autoscale deployment foo --min=2 --max=10\n"
#~ "\n"
#~ "\t\t# Auto scale a replication controller \"foo\", with the number of pods "
#~ "between 1 and 5, target CPU utilization at 80%:\n"
#~ "\t\tkubectl autoscale rc foo --max=5 --cpu-percent=80"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 自动弹性伸缩 deployment \"foo\", pods 的数量在 2 和 10 之间, 目标 "
#~ "CPU 指定为默认的弹性伸缩策略:\n"
#~ "\t\tkubectl autoscale deployment foo --min=2 --max=10\n"
#~ "\n"
#~ "\t\t# 自动弹性伸缩 replication controller \"foo\", pods 的数量在 1 和 5 之"
#~ "间, 目标 CPU 利用率为 80%:\n"
#~ "\t\tkubectl autoscale rc foo --max=5 --cpu-percent=80"

#~ msgid ""
#~ "\n"
#~ "\t\t# Convert 'pod.yaml' to latest version and print to stdout.\n"
#~ "\t\tkubectl convert -f pod.yaml\n"
#~ "\n"
#~ "\t\t# Convert the live state of the resource specified by 'pod.yaml' to "
#~ "the latest version\n"
#~ "\t\t# and print to stdout in json format.\n"
#~ "\t\tkubectl convert -f pod.yaml --local -o json\n"
#~ "\n"
#~ "\t\t# Convert all files under current directory to latest version and "
#~ "create them all.\n"
#~ "\t\tkubectl convert -f . | kubectl create -f -"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 将’pod.yaml' 转换为最新版本并打印到 stdout.\n"
#~ "\t\tkubectl convert -f pod.yaml\n"
#~ "\n"
#~ "\t\t# 将 ‘pod.yaml' 指定的资源的实时状态转换为最新版本\n"
#~ "\t\t# 并以 json 格式打印到 stdout.\n"
#~ "\t\tkubectl convert -f pod.yaml --local -o json\n"
#~ "\n"
#~ "\t\t# 将当前目录下的所以文件转换为最新版本并创建它们.\n"
#~ "\t\tkubectl convert -f . | kubectl create -f -"

#~ msgid ""
#~ "\n"
#~ "\t\t# Create a ClusterRole named \"pod-reader\" that allows user to "
#~ "perform \"get\", \"watch\" and \"list\" on pods\n"
#~ "\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --"
#~ "resource=pods\n"
#~ "\n"
#~ "\t\t# Create a ClusterRole named \"pod-reader\" with ResourceName "
#~ "specified\n"
#~ "\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --"
#~ "resource=pods --resource-name=readablepod"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 创建一个名为 \"pod-reader\" 的 ClusterRole, 允许用户在 pods 上执行 "
#~ "“get\", \"watch\" 和 \"list\"\n"
#~ "\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --"
#~ "resource=pods\n"
#~ "\n"
#~ "\t\t# 创建一个名为 \"pod-reader\" ClusterRole, 其中指定了 ResourceName\n"
#~ "\t\tkubectl create clusterrole pod-reader --verb=get,list,watch --"
#~ "resource=pods --resource-name=readablepod"

#~ msgid ""
#~ "\n"
#~ "\t\t# Create a new resourcequota named my-quota\n"
#~ "\t\tkubectl create quota my-quota --hard=cpu=1,memory=1G,pods=2,services=3,"
#~ "replicationcontrollers=2,resourcequotas=1,secrets=5,"
#~ "persistentvolumeclaims=10\n"
#~ "\n"
#~ "\t\t# Create a new resourcequota named best-effort\n"
#~ "\t\tkubectl create quota best-effort --hard=pods=100 --scopes=BestEffort"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 创建一个名为 my-quota 的 resourcequota\n"
#~ "\t\tkubectl create quota my-quota --hard=cpu=1,memory=1G,pods=2,services=3,"
#~ "replicationcontrollers=2,resourcequotas=1,secrets=5,"
#~ "persistentvolumeclaims=10\n"
#~ "\n"
#~ "\t\t# 创建一个名为 best-effort 的 resourcequota\n"
#~ "\t\tkubectl create quota best-effort --hard=pods=100 --scopes=BestEffort"

#, c-format
#~ msgid ""
#~ "\n"
#~ "\t\t# Create a pod disruption budget named my-pdb that will select all "
#~ "pods with the app=rails label\n"
#~ "\t\t# and require at least one of them being available at any point in "
#~ "time.\n"
#~ "\t\tkubectl create poddisruptionbudget my-pdb --selector=app=rails --min-"
#~ "available=1\n"
#~ "\n"
#~ "\t\t# Create a pod disruption budget named my-pdb that will select all "
#~ "pods with the app=nginx label\n"
#~ "\t\t# and require at least half of the pods selected to be available at "
#~ "any point in time.\n"
#~ "\t\tkubectl create pdb my-pdb --selector=app=nginx --min-available=50%"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 创建一个名称为 my-pdb 的 pod disruption budget 并将会选择所有 "
#~ "app=rails 标签的 pods\n"
#~ "\t\t# 并要求他们在同一时间中最少有一个可用. \n"
#~ "\t\tkubectl create poddisruptionbudget my-pdb --selector=app=rails --min-"
#~ "available=1\n"
#~ "\n"
#~ "\t\t# 创建一个名称为 my-pdb 的 pod disruption budget 并将会选择所有 "
#~ "app=rails 标签的 pods\n"
#~ "\t\t# 并要求他们在同一时间中最少有一半可用.\n"
#~ "\t\tkubectl create pdb my-pdb --selector=app=nginx --min-available=50%"

#~ msgid ""
#~ "\n"
#~ "\t\t# Create a pod using the data in pod.json.\n"
#~ "\t\tkubectl create -f ./pod.json\n"
#~ "\n"
#~ "\t\t# Create a pod based on the JSON passed into stdin.\n"
#~ "\t\tcat pod.json | kubectl create -f -\n"
#~ "\n"
#~ "\t\t# Edit the data in docker-registry.yaml in JSON using the v1 API "
#~ "format then create the resource using the edited data.\n"
#~ "\t\tkubectl create -f docker-registry.yaml --edit --output-version=v1 -o "
#~ "json"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 使用在 pod.json 的 数据创建一个 pod.\n"
#~ "\t\tkubectl create -f ./pod.json\n"
#~ "\n"
#~ "\t\t# 根据传入 stdin 的 JSON 创建一个 pod.\n"
#~ "\t\tcat pod.json | kubectl create -f -\n"
#~ "\n"
#~ "\t\t# 使用 v1 API 格式在 JSON 中编辑在 docker-registry.yaml 中的数据然后使"
#~ "用被编辑后的数据创建资源.\n"
#~ "\t\tkubectl create -f docker-registry.yaml --edit --output-version=v1 -o "
#~ "json"

#~ msgid ""
#~ "\n"
#~ "\t\t# Create a service for a replicated nginx, which serves on port 80 and "
#~ "connects to the containers on port 8000.\n"
#~ "\t\tkubectl expose rc nginx --port=80 --target-port=8000\n"
#~ "\n"
#~ "\t\t# Create a service for a replication controller identified by type and "
#~ "name specified in \"nginx-controller.yaml\", which serves on port 80 and "
#~ "connects to the containers on port 8000.\n"
#~ "\t\tkubectl expose -f nginx-controller.yaml --port=80 --target-port=8000\n"
#~ "\n"
#~ "\t\t# Create a service for a pod valid-pod, which serves on port 444 with "
#~ "the name \"frontend\"\n"
#~ "\t\tkubectl expose pod valid-pod --port=444 --name=frontend\n"
#~ "\n"
#~ "\t\t# Create a second service based on the above service, exposing the "
#~ "container port 8443 as port 443 with the name \"nginx-https\"\n"
#~ "\t\tkubectl expose service nginx --port=443 --target-port=8443 --"
#~ "name=nginx-https\n"
#~ "\n"
#~ "\t\t# Create a service for a replicated streaming application on port 4100 "
#~ "balancing UDP traffic and named 'video-stream'.\n"
#~ "\t\tkubectl expose rc streamer --port=4100 --protocol=udp --name=video-"
#~ "stream\n"
#~ "\n"
#~ "\t\t# Create a service for a replicated nginx using replica set, which "
#~ "serves on port 80 and connects to the containers on port 8000.\n"
#~ "\t\tkubectl expose rs nginx --port=80 --target-port=8000\n"
#~ "\n"
#~ "\t\t# Create a service for an nginx deployment, which serves on port 80 "
#~ "and connects to the containers on port 8000.\n"
#~ "\t\tkubectl expose deployment nginx --port=80 --target-port=8000"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 为一个 replicated nginx 创建一个 service, 服务在端口 80 并连接到 "
#~ "containers 的8000端口.\n"
#~ "\t\tkubectl expose rc nginx --port=80 --target-port=8000\n"
#~ "\n"
#~ "\t\t# 使用在 \"nginx-controller.yaml\\ 中指定的 type 和 name 为一个"
#~ "replication controller 创建一个 service, 服务在端口 80 并连接到 containers "
#~ "的8000端口.\n"
#~ "\t\tkubectl expose -f nginx-controller.yaml --port=80 --target-port=8000\n"
#~ "\n"
#~ "\t\t# 为名为 valid-pod 的 pod 创建一个 service, 服务在端口 444 并命名为 "
#~ "\"frontend\" \n"
#~ "\t\tkubectl expose pod valid-pod --port=444 --name=frontend\n"
#~ "\n"
#~ "\t\t# 基于上面的 service 创建第二个 service, 暴露容器端口 8443 并命名为 "
#~ "\"nginx-https\" 端口为 443 \n"
#~ "\t\tkubectl expose service nginx --port=443 --target-port=8443 --"
#~ "name=nginx-https\n"
#~ "\n"
#~ "\t\t# 为一个名称为 streaming 的应用创建一个 service 暴露端口 4100, 协议为 "
#~ "UDP 名称为 'video-stream'.\n"
#~ "\t\tkubectl expose rc streamer --port=4100 --protocol=udp --name=video-"
#~ "stream\n"
#~ "\n"
#~ "\t\t# 为一个名称为 nginx 的 replica set 创建一个 service, 服务在 端口 80 且"
#~ "连接到容器端口 8000.\n"
#~ "\t\tkubectl expose rs nginx --port=80 --target-port=8000\n"
#~ "\n"
#~ "\t\t# 为一个名称为 nginx 的 deployment 创建一个 service, 服务在端口 80 且 "
#~ "连接到 containers 的 8000 端口.\n"
#~ "\t\tkubectl expose deployment nginx --port=80 --target-port=8000"

#~ msgid ""
#~ "\n"
#~ "\t\t# Delete a pod using the type and name specified in pod.json.\n"
#~ "\t\tkubectl delete -f ./pod.json\n"
#~ "\n"
#~ "\t\t# Delete a pod based on the type and name in the JSON passed into "
#~ "stdin.\n"
#~ "\t\tcat pod.json | kubectl delete -f -\n"
#~ "\n"
#~ "\t\t# Delete pods and services with same names \"baz\" and \"foo\"\n"
#~ "\t\tkubectl delete pod,service baz foo\n"
#~ "\n"
#~ "\t\t# Delete pods and services with label name=myLabel.\n"
#~ "\t\tkubectl delete pods,services -l name=myLabel\n"
#~ "\n"
#~ "\t\t# Delete a pod with minimal delay\n"
#~ "\t\tkubectl delete pod foo --now\n"
#~ "\n"
#~ "\t\t# Force delete a pod on a dead node\n"
#~ "\t\tkubectl delete pod foo --grace-period=0 --force\n"
#~ "\n"
#~ "\t\t# Delete all pods\n"
#~ "\t\tkubectl delete pods --all"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 使用 pod.json 中的类型和名称删除一个 pod.\n"
#~ "\t\tkubectl delete -f ./pod.json\n"
#~ "\n"
#~ "\t\t# 基于重定向到 stdin 中的 JSON 的类型和名称删除一个 pod.\n"
#~ "\t\tcat pod.json | kubectl delete -f -\n"
#~ "\n"
#~ "\t\t# 删除名为 \"baz\" 和 \"foo\" 的 pod 和 service\n"
#~ "\t\tkubectl delete pod,service baz foo\n"
#~ "\n"
#~ "\t\t# 删除标签为 name=myLabel 的 pods 和 services.\n"
#~ "\t\tkubectl delete pods,services -l name=myLabel\n"
#~ "\n"
#~ "\t\t# 删除最小延迟的 pod\n"
#~ "\t\tkubectl delete pod foo --now\n"
#~ "\n"
#~ "\t\t# 强制删除名为 foo 的 pod\n"
#~ "\t\tkubectl delete pod foo --grace-period=0 --force\n"
#~ "\n"
#~ "\t\t# 删除所有 pods\n"
#~ "\t\tkubectl delete pods --all"

#~ msgid ""
#~ "\n"
#~ "\t\t# Describe a node\n"
#~ "\t\tkubectl describe nodes kubernetes-node-emt8.c.myproject.internal\n"
#~ "\n"
#~ "\t\t# Describe a pod\n"
#~ "\t\tkubectl describe pods/nginx\n"
#~ "\n"
#~ "\t\t# Describe a pod identified by type and name in \"pod.json\"\n"
#~ "\t\tkubectl describe -f pod.json\n"
#~ "\n"
#~ "\t\t# Describe all pods\n"
#~ "\t\tkubectl describe pods\n"
#~ "\n"
#~ "\t\t# Describe pods by label name=myLabel\n"
#~ "\t\tkubectl describe po -l name=myLabel\n"
#~ "\n"
#~ "\t\t# Describe all pods managed by the 'frontend' replication controller "
#~ "(rc-created pods\n"
#~ "\t\t# get the name of the rc as a prefix in the pod the name).\n"
#~ "\t\tkubectl describe pods frontend"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 描述一个 node\n"
#~ "\t\tkubectl describe nodes kubernetes-node-emt8.c.myproject.internal\n"
#~ "\n"
#~ "\t\t# 描述一个 pod\n"
#~ "\t\tkubectl describe pods/nginx\n"
#~ "\n"
#~ "\t\t# 描述一个被 \"pod.json\" 中的类型和名称标识的 pod\n"
#~ "\t\tkubectl describe -f pod.json\n"
#~ "\n"
#~ "\t\t# 描述所有 pods\n"
#~ "\t\tkubectl describe pods\n"
#~ "\n"
#~ "\t\t# 描述标签为 name=myLabel 的 pods\n"
#~ "\t\tkubectl describe po -l name=myLabel\n"
#~ "\n"
#~ "\t\t# 描述所有被名称为 'frontend' 的 replication controller 管理的 pods(rc-"
#~ "创建 pods\n"
#~ "\t\t# 并使用 rc 的名称作为 pod 的前缀).\n"
#~ "\t\tkubectl describe pods frontend"

#~ msgid ""
#~ "\n"
#~ "\t\t# Drain node \"foo\", even if there are pods not managed by a "
#~ "ReplicationController, ReplicaSet, Job, DaemonSet or StatefulSet on it.\n"
#~ "\t\t$ kubectl drain foo --force\n"
#~ "\n"
#~ "\t\t# As above, but abort if there are pods not managed by a "
#~ "ReplicationController, ReplicaSet, Job, DaemonSet 或者 StatefulSet, and "
#~ "use a grace period of 15 minutes.\n"
#~ "\t\t$ kubectl drain foo --grace-period=900"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 驱逐节点 \"foo\", 即使很多 pods 没有被一个在 node 上的 "
#~ "ReplicationController, ReplicaSet, Job, DaemonSet 或者 StatefulSet 管理.\n"
#~ "\t\t$ kubectl drain foo --force\n"
#~ "\n"
#~ "\t\t# 同上, 如果存在 pods 没有被一个 ReplicationController, ReplicaSet, "
#~ "Job, DaemonSet 或者 StatefulSet 管理超过 15 分钟则退出.\n"
#~ "\t\t$ kubectl drain foo --grace-period=900"

#~ msgid ""
#~ "\n"
#~ "\t\t# Edit the service named 'docker-registry':\n"
#~ "\t\tkubectl edit svc/docker-registry\n"
#~ "\n"
#~ "\t\t# Use an alternative editor\n"
#~ "\t\tKUBE_EDITOR=\"nano\" kubectl edit svc/docker-registry\n"
#~ "\n"
#~ "\t\t# Edit the job 'myjob' in JSON using the v1 API format:\n"
#~ "\t\tkubectl edit job.v1.batch/myjob -o json\n"
#~ "\n"
#~ "\t\t# Edit the deployment 'mydeployment' in YAML and save the modified "
#~ "config in its annotation:\n"
#~ "\t\tkubectl edit deployment/mydeployment -o yaml --save-config"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 编辑名为 'docker-registry' 的 service:\n"
#~ "\t\tkubectl edit svc/docker-registry\n"
#~ "\n"
#~ "\t\t# 使用一个可选择的编辑器\n"
#~ "\t\tKUBE_EDITOR=\"nano\" kubectl edit svc/docker-registry\n"
#~ "\n"
#~ "\t\t# 使用 v1 API 格式的 JSON 编辑名为 'myjob' 的 job:\n"
#~ "\t\tkubectl edit job.v1.batch/myjob -o json\n"
#~ "\n"
#~ "\t\t# 在 YAML 中编辑名为 'mydeployment' 的 deployment 并在它的注解中保存修"
#~ "改后的配置:\n"
#~ "\t\tkubectl edit deployment/mydeployment -o yaml --save-config"

#~ msgid ""
#~ "\n"
#~ "\t\t# Get output from running 'date' from pod 123456-7890, using the first "
#~ "container by default\n"
#~ "\t\tkubectl exec 123456-7890 date\n"
#~ "\n"
#~ "\t\t# Get output from running 'date' in ruby-container from pod "
#~ "123456-7890\n"
#~ "\t\tkubectl exec 123456-7890 -c ruby-container date\n"
#~ "\n"
#~ "\t\t# Switch to raw terminal mode, sends stdin to 'bash' in ruby-container "
#~ "from pod 123456-7890\n"
#~ "\t\t# and sends stdout/stderr from 'bash' back to the client\n"
#~ "\t\tkubectl exec 123456-7890 -c ruby-container -i -t -- bash -il"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 从运行中pod 123456-7890 获取执行 'date' 的输出, 默认使用第一个容器\n"
#~ "\t\tkubectl exec 123456-7890 date\n"
#~ "\n"
#~ "\t\t# 从 pod 123456-7890 的容器 ruby-container 获取执行 'date' 的输出\n"
#~ "\t\tkubectl exec 123456-7890 -c ruby-container date\n"
#~ "\n"
#~ "\t\t# 切换到 terminal 模式, 发送 stdin 到运行在 pod 123456-7890 的容器 "
#~ "ruby-container 'bash' \n"
#~ "\t\t# 并从 'bash' 发送 stdout/stderr 返回到 client\n"
#~ "\t\tkubectl exec 123456-7890 -c ruby-container -i -t -- bash -il"

#~ msgid ""
#~ "\n"
#~ "\t\t# Get output from running pod 123456-7890, using the first container "
#~ "by default\n"
#~ "\t\tkubectl attach 123456-7890\n"
#~ "\n"
#~ "\t\t# Get output from ruby-container from pod 123456-7890\n"
#~ "\t\tkubectl attach 123456-7890 -c ruby-container\n"
#~ "\n"
#~ "\t\t# Switch to raw terminal mode, sends stdin to 'bash' in ruby-container "
#~ "from pod 123456-7890\n"
#~ "\t\t# and sends stdout/stderr from 'bash' back to the client\n"
#~ "\t\tkubectl attach 123456-7890 -c ruby-container -i -t\n"
#~ "\n"
#~ "\t\t# Get output from the first pod of a ReplicaSet named nginx\n"
#~ "\t\tkubectl attach rs/nginx\n"
#~ "\t\t"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 从运行中pod 123456-7890 获取执行 'date' 的输出, 默认使用第一个容器\n"
#~ "\t\tkubectl attach 123456-7890\n"
#~ "\n"
#~ "\t\t# 从 pod 123456-7890 的容器 ruby-container 获取输出\n"
#~ "\t\tkubectl attach 123456-7890 -c ruby-container\n"
#~ "\n"
#~ "\t\t# 切换到 terminal 模式, 发送 stdin 到运行在 pod 123456-7890 的容器 "
#~ "ruby-container 'bash' \n"
#~ "\t\t# 并从 'bash' 发送 stdout/stderr 返回到 client\n"
#~ "\t\tkubectl attach 123456-7890 -c ruby-container -i -t\n"
#~ "\n"
#~ "\t\t# 从名称为 nginx 的 ReplicaSet 获取第一个 pod 的输出\n"
#~ "\t\tkubectl attach rs/nginx\n"
#~ "\t\t"

#~ msgid ""
#~ "\n"
#~ "\t\t# Install bash completion on a Mac using homebrew\n"
#~ "\t\tbrew install bash-completion\n"
#~ "\t\tprintf \"\n"
#~ "# Bash completion support\n"
#~ "source $(brew --prefix)/etc/bash_completion\n"
#~ "\" >> $HOME/.bash_profile\n"
#~ "\t\tsource $HOME/.bash_profile\n"
#~ "\n"
#~ "\t\t# Load the kubectl completion code for bash into the current shell\n"
#~ "\t\tsource <(kubectl completion bash)\n"
#~ "\n"
#~ "\t\t# Write bash completion code to a file and source if from ."
#~ "bash_profile\n"
#~ "\t\tkubectl completion bash > ~/.kube/completion.bash.inc\n"
#~ "\t\tprintf \"\n"
#~ "# Kubectl shell completion\n"
#~ "source '$HOME/.kube/completion.bash.inc'\n"
#~ "\" >> $HOME/.bash_profile\n"
#~ "\t\tsource $HOME/.bash_profile\n"
#~ "\n"
#~ "\t\t# Load the kubectl completion code for zsh[1] into the current shell\n"
#~ "\t\tsource <(kubectl completion zsh)"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 在一个 Mac 中使用 homebrew 安装 bash 补全\n"
#~ "\t\tbrew install bash-completion\n"
#~ "\t\tprintf \"\n"
#~ "# Bash 补全支持\n"
#~ "source $(brew --prefix)/etc/bash_completion\n"
#~ "\" >> $HOME/.bash_profile\n"
#~ "\t\tsource $HOME/.bash_profile\n"
#~ "\n"
#~ "\t\t# 导入 kubectl 补全代码到当前 shell\n"
#~ "\t\tsource <(kubectl completion bash)\n"
#~ "\n"
#~ "\t\t# 写入 bash 补全代码到一个文件并 source 如果它是 .bash_profile\n"
#~ "\t\tkubectl completion bash > ~/.kube/completion.bash.inc\n"
#~ "\t\tprintf \"\n"
#~ "# Kubectl shell 补全\n"
#~ "source '$HOME/.kube/completion.bash.inc'\n"
#~ "\" >> $HOME/.bash_profile\n"
#~ "\t\tsource $HOME/.bash_profile\n"
#~ "\n"
#~ "\t\t# 为 zsh[1] 导入 kubectl 补全代码到当前 shell\n"
#~ "\t\tsource <(kubectl completion zsh)"

#~ msgid ""
#~ "\n"
#~ "\t\t# List all pods in ps output format.\n"
#~ "\t\tkubectl get pods\n"
#~ "\n"
#~ "\t\t# List all pods in ps output format with more information (such as "
#~ "node name).\n"
#~ "\t\tkubectl get pods -o wide\n"
#~ "\n"
#~ "\t\t# List a single replication controller with specified NAME in ps "
#~ "output format.\n"
#~ "\t\tkubectl get replicationcontroller web\n"
#~ "\n"
#~ "\t\t# List a single pod in JSON output format.\n"
#~ "\t\tkubectl get -o json pod web-pod-13je7\n"
#~ "\n"
#~ "\t\t# List a pod identified by type and name specified in \"pod.yaml\" in "
#~ "JSON output format.\n"
#~ "\t\tkubectl get -f pod.yaml -o json\n"
#~ "\n"
#~ "\t\t# Return only the phase value of the specified pod.\n"
#~ "\t\tkubectl get -o template pod/web-pod-13je7 --template={{.status."
#~ "phase}}\n"
#~ "\n"
#~ "\t\t# List all replication controllers and services together in ps output "
#~ "format.\n"
#~ "\t\tkubectl get rc,services\n"
#~ "\n"
#~ "\t\t# List one or more resources by their type and names.\n"
#~ "\t\tkubectl get rc/web service/frontend pods/web-pod-13je7\n"
#~ "\n"
#~ "\t\t# List all resources with different types.\n"
#~ "\t\tkubectl get all"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 以 ps 输出格式列出所有 pod.\n"
#~ "\t\tkubectl get pods\n"
#~ "\n"
#~ "\t\t# 以 ps 输出格式列出所有 pod(如节点名称).\n"
#~ "\t\tkubectl get pods -o wide\n"
#~ "\n"
#~ "\t\t# 获取名称为 web 的 replicationcontroller.\n"
#~ "\t\tkubectl get replicationcontroller web\n"
#~ "\n"
#~ "\t\t# 使用 JSON 格式化输出显示一个单独的 pod.\n"
#~ "\t\tkubectl get -o json pod web-pod-13je7\n"
#~ "\n"
#~ "\t\t# 显示一个被 \"pod.yaml\" 中的 type 和 name 标识的 pod 并使用 JSON 格式"
#~ "化输出.\n"
#~ "\t\tkubectl get -f pod.yaml -o json\n"
#~ "\n"
#~ "\t\t# 只返回被指定 pod 中 phase 的值.\n"
#~ "\t\tkubectl get -o template pod/web-pod-13je7 --template={{.status."
#~ "phase}}\n"
#~ "\n"
#~ "\t\t# 显示所有的 replication controllers 和 services 并格式化输出.\n"
#~ "\t\tkubectl get rc,services\n"
#~ "\n"
#~ "\t\t# 显示一个或者更多 resources 通过它们的 type 和 names.\n"
#~ "\t\tkubectl get rc/web service/frontend pods/web-pod-13je7\n"
#~ "\n"
#~ "\t\t# 使用不同的 types 显示所有 resources.\n"
#~ "\t\tkubectl get all"

#~ msgid ""
#~ "\n"
#~ "\t\t# Listen on ports 5000 and 6000 locally, forwarding data to/from ports "
#~ "5000 and 6000 in the pod\n"
#~ "\t\tkubectl port-forward mypod 5000 6000\n"
#~ "\n"
#~ "\t\t# Listen on port 8888 locally, forwarding to 5000 in the pod\n"
#~ "\t\tkubectl port-forward mypod 8888:5000\n"
#~ "\n"
#~ "\t\t# Listen on a random port locally, forwarding to 5000 in the pod\n"
#~ "\t\tkubectl port-forward mypod :5000\n"
#~ "\n"
#~ "\t\t# Listen on a random port locally, forwarding to 5000 in the pod\n"
#~ "\t\tkubectl port-forward mypod 0:5000"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 在本地监听端口 5000 和 6000 , forwarding 数据 to/from 在 pod 5000 和 "
#~ "6000 端口\n"
#~ "\t\tkubectl port-forward mypod 5000 6000\n"
#~ "\n"
#~ "\t\t# 在本地监听端口 8888 , forwarding 到 pod 的 5000端口\n"
#~ "\t\tkubectl port-forward mypod 8888:5000\n"
#~ "\n"
#~ "\t\t# 在本地随机监听一个端口 , forwarding 到 pod 的 5000端口\n"
#~ "\t\tkubectl port-forward mypod :5000\n"
#~ "\n"
#~ "\t\t# 在本地随机监听一个端口 , forwarding 到 pod 的 5000端口\n"
#~ "\t\tkubectl port-forward mypod 0:5000"

#~ msgid ""
#~ "\n"
#~ "\t\t# Mark node \"foo\" as schedulable.\n"
#~ "\t\t$ kubectl uncordon foo"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 标记 node \"foo\" 为 schedulable.\n"
#~ "\t\t$ kubectl uncordon foo"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/drain.go#L102
#~ msgid ""
#~ "\n"
#~ "\t\t# Mark node \"foo\" as unschedulable.\n"
#~ "\t\tkubectl cordon foo"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 标记 node \"foo\" 为 unschedulable.\n"
#~ "\t\tkubectl cordon foo"

#~ msgid ""
#~ "\n"
#~ "\t\t# Partially update a node using strategic merge patch\n"
#~ "\t\tkubectl patch node k8s-node-1 -p '{\"spec\":{\"unschedulable\":"
#~ "true}}'\n"
#~ "\n"
#~ "\t\t# Partially update a node identified by the type and name specified in "
#~ "\"node.json\" using strategic merge patch\n"
#~ "\t\tkubectl patch -f node.json -p '{\"spec\":{\"unschedulable\":true}}'\n"
#~ "\n"
#~ "\t\t# Update a container's image; spec.containers[*].name is required "
#~ "because it's a merge key\n"
#~ "\t\tkubectl patch pod valid-pod -p '{\"spec\":{\"containers\":[{\"name\":"
#~ "\"kubernetes-serve-hostname\",\"image\":\"new image\"}]}}'\n"
#~ "\n"
#~ "\t\t# Update a container's image using a json patch with positional "
#~ "arrays\n"
#~ "\t\tkubectl patch pod valid-pod --type='json' -p='[{\"op\": \"replace\", "
#~ "\"path\": \"/spec/containers/0/image\", \"value\":\"new image\"}]'"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 使用 strategic merge patch 部分更新一个 node\n"
#~ "\t\tkubectl patch node k8s-node-1 -p '{\"spec\":{\"unschedulable\":"
#~ "true}}'\n"
#~ "\n"
#~ "\t\t# 使用 strategic merge patch 部分更新一个被 \"node.json\" 的 type 和 "
#~ "name 标示  的 node.\n"
#~ "\t\tkubectl patch -f node.json -p '{\"spec\":{\"unschedulable\":true}}'\n"
#~ "\n"
#~ "\t\t# 更新一个 container 的 image; spec.containers[*].name 是必须的 因为它"
#~ "是一个 merge key\n"
#~ "\t\tkubectl patch pod valid-pod -p '{\"spec\":{\"containers\":[{\"name\":"
#~ "\"kubernetes-serve-hostname\",\"image\":\"new image\"}]}}'\n"
#~ "\n"
#~ "\t\t#  使用一个 json patch 更新一个指定坐标的 container 的 image \n"
#~ "\t\tkubectl patch pod valid-pod --type='json' -p='[{\"op\": \"replace\", "
#~ "\"path\": \"/spec/containers/0/image\", \"value\":\"new image\"}]'"

#~ msgid ""
#~ "\n"
#~ "\t\t# Print the address of the master and cluster services\n"
#~ "\t\tkubectl cluster-info"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 输出 master 和 cluster services 的地址\n"
#~ "\t\tkubectl cluster-info"

#~ msgid ""
#~ "\n"
#~ "\t\t# Replace a pod using the data in pod.json.\n"
#~ "\t\tkubectl replace -f ./pod.json\n"
#~ "\n"
#~ "\t\t# Replace a pod based on the JSON passed into stdin.\n"
#~ "\t\tcat pod.json | kubectl replace -f -\n"
#~ "\n"
#~ "\t\t# Update a single-container pod's image version (tag) to v4\n"
#~ "\t\tkubectl get pod mypod -o yaml | sed 's/\\(image: myimage\\):.*$/:v4/' "
#~ "| kubectl replace -f -\n"
#~ "\n"
#~ "\t\t# Force replace, delete and then re-create the resource\n"
#~ "\t\tkubectl replace --force -f ./pod.json"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 使用在 pod.json 中的数据替换一个 pod.\n"
#~ "\t\tkubectl replace -f ./pod.json\n"
#~ "\n"
#~ "\t\t# 基于被重定向到 stdin 中的 JSON 替换一个 pod.\n"
#~ "\t\tcat pod.json | kubectl replace -f -\n"
#~ "\n"
#~ "\t\t# 更新一个单独容器的 pod 的 image 版本 (tag) 到 v4\n"
#~ "\t\tkubectl get pod mypod -o yaml | sed 's/\\(image: myimage\\):.*$/:v4/' "
#~ "| kubectl replace -f -\n"
#~ "\n"
#~ "\t\t# 强制替换, 删除然后重新创建这个 resource\n"
#~ "\t\tkubectl replace --force -f ./pod.json"

#~ msgid ""
#~ "\n"
#~ "\t\t# Return snapshot logs from pod nginx with only one container\n"
#~ "\t\tkubectl logs nginx\n"
#~ "\n"
#~ "\t\t# Return snapshot logs for the pods defined by label app=nginx\n"
#~ "\t\tkubectl logs -lapp=nginx\n"
#~ "\n"
#~ "\t\t# Return snapshot of previous terminated ruby container logs from pod "
#~ "web-1\n"
#~ "\t\tkubectl logs -p -c ruby web-1\n"
#~ "\n"
#~ "\t\t# Begin streaming the logs of the ruby container in pod web-1\n"
#~ "\t\tkubectl logs -f -c ruby web-1\n"
#~ "\n"
#~ "\t\t# Display only the most recent 20 lines of output in pod nginx\n"
#~ "\t\tkubectl logs --tail=20 nginx\n"
#~ "\n"
#~ "\t\t# Show all logs from pod nginx written in the last hour\n"
#~ "\t\tkubectl logs --since=1h nginx\n"
#~ "\n"
#~ "\t\t# Return snapshot logs from first container of a job named hello\n"
#~ "\t\tkubectl logs job/hello\n"
#~ "\n"
#~ "\t\t# Return snapshot logs from container nginx-1 of a deployment named "
#~ "nginx\n"
#~ "\t\tkubectl logs deployment/nginx -c nginx-1"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 返回仅有一个容器 pod 名称为 nginx 的 snapshot 日志\n"
#~ "\t\tkubectl logs nginx\n"
#~ "\n"
#~ "\t\t# 返回 label 为 app=nginx 的 pods 的 snapshot 日志\n"
#~ "\t\tkubectl logs -lapp=nginx\n"
#~ "\n"
#~ "\t\t# Return snapshot of previous terminated ruby container logs from pod "
#~ "web-1\n"
#~ "\t\tkubectl logs -p -c ruby web-1\n"
#~ "\n"
#~ "\t\t# Begin streaming the logs of the ruby container in pod web-1\n"
#~ "\t\tkubectl logs -f -c ruby web-1\n"
#~ "\n"
#~ "\t\t# Display only the most recent 20 lines of output in pod nginx\n"
#~ "\t\tkubectl logs --tail=20 nginx\n"
#~ "\n"
#~ "\t\t# Show all logs from pod nginx written in the last hour\n"
#~ "\t\tkubectl logs --since=1h nginx\n"
#~ "\n"
#~ "\t\t# Return snapshot logs from first container of a job named hello\n"
#~ "\t\tkubectl logs job/hello\n"
#~ "\n"
#~ "\t\t# Return snapshot logs from container nginx-1 of a deployment named "
#~ "nginx\n"
#~ "\t\tkubectl logs deployment/nginx -c nginx-1"

#~ msgid ""
#~ "\n"
#~ "\t\t# Run a proxy to kubernetes apiserver on port 8011, serving static "
#~ "content from ./local/www/\n"
#~ "\t\tkubectl proxy --port=8011 --www=./local/www/\n"
#~ "\n"
#~ "\t\t# Run a proxy to kubernetes apiserver on an arbitrary local port.\n"
#~ "\t\t# The chosen port for the server will be output to stdout.\n"
#~ "\t\tkubectl proxy --port=0\n"
#~ "\n"
#~ "\t\t# Run a proxy to kubernetes apiserver, changing the api prefix to k8s-"
#~ "api\n"
#~ "\t\t# This makes e.g. the pods api available at localhost:8001/k8s-api/v1/"
#~ "pods/\n"
#~ "\t\tkubectl proxy --api-prefix=/k8s-api"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 运行 proxy 到 kubernetes apiserver 的 8011 端口上, 服务静态内容路径"
#~ "为 ./local/www/\n"
#~ "\t\tkubectl proxy --port=8011 --www=./local/www/\n"
#~ "\n"
#~ "\t\t# 在任意的本地端口上运行一个 proxy 到 kubernetes apiserver.\n"
#~ "\t\t# 为这个 server 挑选的端口将会被输出到 stdout.\n"
#~ "\t\tkubectl proxy --port=0\n"
#~ "\n"
#~ "\t\t# 运行一个 proxy 到 kubernetes apiserver, 修改 api prefix 为 k8s-api\n"
#~ "\t\t# 这会使 e.g. 这个 pods 的有效 api 为 localhost:8001/k8s-api/v1/pods/\n"
#~ "\t\tkubectl proxy --api-prefix=/k8s-api"

#~ msgid ""
#~ "\n"
#~ "\t\t# Scale a replicaset named 'foo' to 3.\n"
#~ "\t\tkubectl scale --replicas=3 rs/foo\n"
#~ "\n"
#~ "\t\t# Scale a resource identified by type and name specified in \"foo."
#~ "yaml\" to 3.\n"
#~ "\t\tkubectl scale --replicas=3 -f foo.yaml\n"
#~ "\n"
#~ "\t\t# If the deployment named mysql's current size is 2, scale mysql to "
#~ "3.\n"
#~ "\t\tkubectl scale --current-replicas=2 --replicas=3 deployment/mysql\n"
#~ "\n"
#~ "\t\t# Scale multiple replication controllers.\n"
#~ "\t\tkubectl scale --replicas=5 rc/foo rc/bar rc/baz\n"
#~ "\n"
#~ "\t\t# Scale job named 'cron' to 3.\n"
#~ "\t\tkubectl scale --replicas=3 job/cron"
#~ msgstr ""
#~ "\n"
#~ "\t\t# Scale 一个名称为 ‘foo’ 的 replicaset 服本数为 3.\n"
#~ "\t\tkubectl scale --replicas=3 rs/foo\n"
#~ "\n"
#~ "\t\t# Scale 指定的 \"foo.yaml\" 的 type 和 name 标识的 resource 副本数量为 "
#~ "3.\n"
#~ "\t\tkubectl scale --replicas=3 -f foo.yaml\n"
#~ "\n"
#~ "\t\t# 如果名称为 mysql 的 deployment 当前副本数量为 2, scale mysql 到 3.\n"
#~ "\t\tkubectl scale --current-replicas=2 --replicas=3 deployment/mysql\n"
#~ "\n"
#~ "\t\t# Scale 多个 replication controllers.\n"
#~ "\t\tkubectl scale --replicas=5 rc/foo rc/bar rc/baz\n"
#~ "\n"
#~ "\t\t# Scale 名称为 ’cron’ 的 job 副本数量为 3.\n"
#~ "\t\tkubectl scale --replicas=3 job/cron"

#~ msgid ""
#~ "\n"
#~ "\t\t# Set the last-applied-configuration of a resource to match the "
#~ "contents of a file.\n"
#~ "\t\tkubectl apply set-last-applied -f deploy.yaml\n"
#~ "\n"
#~ "\t\t# Execute set-last-applied against each configuration file in a "
#~ "directory.\n"
#~ "\t\tkubectl apply set-last-applied -f path/\n"
#~ "\n"
#~ "\t\t# Set the last-applied-configuration of a resource to match the "
#~ "contents of a file, will create the annotation if it does not already "
#~ "exist.\n"
#~ "\t\tkubectl apply set-last-applied -f deploy.yaml --create-"
#~ "annotation=true\n"
#~ "\t\t"
#~ msgstr ""
#~ "\n"
#~ "\t\t# 设置一个资源的 last-applied-configuration 去匹配一个文件的内容.\n"
#~ "\t\tkubectl apply set-last-applied -f deploy.yaml\n"
#~ "\n"
#~ "\t\t# Execute set-last-applied against each configuration file in a "
#~ "directory.\n"
#~ "\t\tkubectl apply set-last-applied -f path/\n"
#~ "\n"
#~ "\t\t# 设置一个资源的 last-applied-configuration 去匹配一个文件的内容, 如果"
#~ "不存在将会创建一个 annotation.\n"
#~ "\t\tkubectl apply set-last-applied -f deploy.yaml --create-"
#~ "annotation=true\n"
#~ "\t\t"

#~ msgid ""
#~ "\n"
#~ "\t\t# Shut down foo.\n"
#~ "\t\tkubectl stop replicationcontroller foo\n"
#~ "\n"
#~ "\t\t# Stop pods and services with label name=myLabel.\n"
#~ "\t\tkubectl stop pods,services -l name=myLabel\n"
#~ "\n"
#~ "\t\t# Shut down the service defined in service.json\n"
#~ "\t\tkubectl stop -f service.json\n"
#~ "\n"
#~ "\t\t# Shut down all resources in the path/to/resources directory\n"
#~ "\t\tkubectl stop -f path/to/resources"
#~ msgstr ""
#~ "\n"
#~ "\t\t# Shut down foo.\n"
#~ "\t\tkubectl stop replicationcontroller foo\n"
#~ "\n"
#~ "\t\t# Stop pods and services with label name=myLabel.\n"
#~ "\t\tkubectl stop pods,services -l name=myLabel\n"
#~ "\n"
#~ "\t\t# Shut down the service defined in service.json\n"
#~ "\t\tkubectl stop -f service.json\n"
#~ "\n"
#~ "\t\t# Shut down all resources in the path/to/resources directory\n"
#~ "\t\tkubectl stop -f path/to/resources"

#~ msgid ""
#~ "\n"
#~ "\t\t# Start a single instance of nginx.\n"
#~ "\t\tkubectl run nginx --image=nginx\n"
#~ "\n"
#~ "\t\t# Start a single instance of hazelcast and let the container expose "
#~ "port 5701 .\n"
#~ "\t\tkubectl run hazelcast --image=hazelcast --port=5701\n"
#~ "\n"
#~ "\t\t# Start a single instance of hazelcast and set environment variables "
#~ "\"DNS_DOMAIN=cluster\" and \"POD_NAMESPACE=default\" in the container.\n"
#~ "\t\tkubectl run hazelcast --image=hazelcast --env=\"DNS_DOMAIN=cluster\" --"
#~ "env=\"POD_NAMESPACE=default\"\n"
#~ "\n"
#~ "\t\t# Start a replicated instance of nginx.\n"
#~ "\t\tkubectl run nginx --image=nginx --replicas=5\n"
#~ "\n"
#~ "\t\t# Dry run. Print the corresponding API objects without creating them.\n"
#~ "\t\tkubectl run nginx --image=nginx --dry-run\n"
#~ "\n"
#~ "\t\t# Start a single instance of nginx, but overload the spec of the "
#~ "deployment with a partial set of values parsed from JSON.\n"
#~ "\t\tkubectl run nginx --image=nginx --overrides='{ \"apiVersion\": \"v1\", "
#~ "\"spec\": { ... } }'\n"
#~ "\n"
#~ "\t\t# Start a pod of busybox and keep it in the foreground, don't restart "
#~ "it if it exits.\n"
#~ "\t\tkubectl run -i -t busybox --image=busybox --restart=Never\n"
#~ "\n"
#~ "\t\t# Start the nginx container using the default command, but use custom "
#~ "arguments (arg1 .. argN) for that command.\n"
#~ "\t\tkubectl run nginx --image=nginx -- <arg1> <arg2> ... <argN>\n"
#~ "\n"
#~ "\t\t# Start the nginx container using a different command and custom "
#~ "arguments.\n"
#~ "\t\tkubectl run nginx --image=nginx --command -- <cmd> <arg1> ... <argN>\n"
#~ "\n"
#~ "\t\t# Start the perl container to compute π to 2000 places and print it "
#~ "out.\n"
#~ "\t\tkubectl run pi --image=perl --restart=OnFailure -- perl -Mbignum=bpi -"
#~ "wle 'print bpi(2000)'\n"
#~ "\n"
#~ "\t\t# Start the cron job to compute π to 2000 places and print it out "
#~ "every 5 minutes.\n"
#~ "\t\tkubectl run pi --schedule=\"0/5 * * * ?\" --image=perl --"
#~ "restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'"
#~ msgstr ""
#~ "\n"
#~ "\t\t# Start a single instance of nginx.\n"
#~ "\t\tkubectl run nginx --image=nginx\n"
#~ "\n"
#~ "\t\t# Start a single instance of hazelcast and let the container expose "
#~ "port 5701 .\n"
#~ "\t\tkubectl run hazelcast --image=hazelcast --port=5701\n"
#~ "\n"
#~ "\t\t# Start a single instance of hazelcast and set environment variables "
#~ "\"DNS_DOMAIN=cluster\" and \"POD_NAMESPACE=default\" in the container.\n"
#~ "\t\tkubectl run hazelcast --image=hazelcast --env=\"DNS_DOMAIN=cluster\" --"
#~ "env=\"POD_NAMESPACE=default\"\n"
#~ "\n"
#~ "\t\t# Start a replicated instance of nginx.\n"
#~ "\t\tkubectl run nginx --image=nginx --replicas=5\n"
#~ "\n"
#~ "\t\t# Dry run. Print the corresponding API objects without creating them.\n"
#~ "\t\tkubectl run nginx --image=nginx --dry-run\n"
#~ "\n"
#~ "\t\t# Start a single instance of nginx, but overload the spec of the "
#~ "deployment with a partial set of values parsed from JSON.\n"
#~ "\t\tkubectl run nginx --image=nginx --overrides='{ \"apiVersion\": \"v1\", "
#~ "\"spec\": { ... } }'\n"
#~ "\n"
#~ "\t\t# Start a pod of busybox and keep it in the foreground, don't restart "
#~ "it if it exits.\n"
#~ "\t\tkubectl run -i -t busybox --image=busybox --restart=Never\n"
#~ "\n"
#~ "\t\t# Start the nginx container using the default command, but use custom "
#~ "arguments (arg1 .. argN) for that command.\n"
#~ "\t\tkubectl run nginx --image=nginx -- <arg1> <arg2> ... <argN>\n"
#~ "\n"
#~ "\t\t# Start the nginx container using a different command and custom "
#~ "arguments.\n"
#~ "\t\tkubectl run nginx --image=nginx --command -- <cmd> <arg1> ... <argN>\n"
#~ "\n"
#~ "\t\t# Start the perl container to compute π to 2000 places and print it "
#~ "out.\n"
#~ "\t\tkubectl run pi --image=perl --restart=OnFailure -- perl -Mbignum=bpi -"
#~ "wle 'print bpi(2000)'\n"
#~ "\n"
#~ "\t\t# Start the cron job to compute π to 2000 places and print it out "
#~ "every 5 minutes.\n"
#~ "\t\tkubectl run pi --schedule=\"0/5 * * * ?\" --image=perl --"
#~ "restart=OnFailure -- perl -Mbignum=bpi -wle 'print bpi(2000)'"

#~ msgid ""
#~ "\n"
#~ "\t\t# Update node 'foo' with a taint with key 'dedicated' and value "
#~ "'special-user' and effect 'NoSchedule'.\n"
#~ "\t\t# If a taint with that key and effect already exists, its value is "
#~ "replaced as specified.\n"
#~ "\t\tkubectl taint nodes foo dedicated=special-user:NoSchedule\n"
#~ "\n"
#~ "\t\t# Remove from node 'foo' the taint with key 'dedicated' and effect "
#~ "'NoSchedule' if one exists.\n"
#~ "\t\tkubectl taint nodes foo dedicated:NoSchedule-\n"
#~ "\n"
#~ "\t\t# Remove from node 'foo' all the taints with key 'dedicated'\n"
#~ "\t\tkubectl taint nodes foo dedicated-"
#~ msgstr ""
#~ "\n"
#~ "\t\t# Update node 'foo' with a taint with key 'dedicated' and value "
#~ "'special-user' and effect 'NoSchedule'.\n"
#~ "\t\t# If a taint with that key and effect already exists, its value is "
#~ "replaced as specified.\n"
#~ "\t\tkubectl taint nodes foo dedicated=special-user:NoSchedule\n"
#~ "\n"
#~ "\t\t# Remove from node 'foo' the taint with key 'dedicated' and effect "
#~ "'NoSchedule' if one exists.\n"
#~ "\t\tkubectl taint nodes foo dedicated:NoSchedule-\n"
#~ "\n"
#~ "\t\t# Remove from node 'foo' all the taints with key 'dedicated'\n"
#~ "\t\tkubectl taint nodes foo dedicated-"

#~ msgid ""
#~ "\n"
#~ "\t\t# Update pod 'foo' with the label 'unhealthy' and the value 'true'.\n"
#~ "\t\tkubectl label pods foo unhealthy=true\n"
#~ "\n"
#~ "\t\t# Update pod 'foo' with the label 'status' and the value 'unhealthy', "
#~ "overwriting any existing value.\n"
#~ "\t\tkubectl label --overwrite pods foo status=unhealthy\n"
#~ "\n"
#~ "\t\t# Update all pods in the namespace\n"
#~ "\t\tkubectl label pods --all status=unhealthy\n"
#~ "\n"
#~ "\t\t# Update a pod identified by the type and name in \"pod.json\"\n"
#~ "\t\tkubectl label -f pod.json status=unhealthy\n"
#~ "\n"
#~ "\t\t# Update pod 'foo' only if the resource is unchanged from version 1.\n"
#~ "\t\tkubectl label pods foo status=unhealthy --resource-version=1\n"
#~ "\n"
#~ "\t\t# Update pod 'foo' by removing a label named 'bar' if it exists.\n"
#~ "\t\t# Does not require the --overwrite flag.\n"
#~ "\t\tkubectl label pods foo bar-"
#~ msgstr ""
#~ "\n"
#~ "\t\t# Update pod 'foo' with the label 'unhealthy' and the value 'true'.\n"
#~ "\t\tkubectl label pods foo unhealthy=true\n"
#~ "\n"
#~ "\t\t# Update pod 'foo' with the label 'status' and the value 'unhealthy', "
#~ "overwriting any existing value.\n"
#~ "\t\tkubectl label --overwrite pods foo status=unhealthy\n"
#~ "\n"
#~ "\t\t# Update all pods in the namespace\n"
#~ "\t\tkubectl label pods --all status=unhealthy\n"
#~ "\n"
#~ "\t\t# Update a pod identified by the type and name in \"pod.json\"\n"
#~ "\t\tkubectl label -f pod.json status=unhealthy\n"
#~ "\n"
#~ "\t\t# Update pod 'foo' only if the resource is unchanged from version 1.\n"
#~ "\t\tkubectl label pods foo status=unhealthy --resource-version=1\n"
#~ "\n"
#~ "\t\t# Update pod 'foo' by removing a label named 'bar' if it exists.\n"
#~ "\t\t# Does not require the --overwrite flag.\n"
#~ "\t\tkubectl label pods foo bar-"

#~ msgid ""
#~ "\n"
#~ "\t\t# Update pods of frontend-v1 using new replication controller data in "
#~ "frontend-v2.json.\n"
#~ "\t\tkubectl rolling-update frontend-v1 -f frontend-v2.json\n"
#~ "\n"
#~ "\t\t# Update pods of frontend-v1 using JSON data passed into stdin.\n"
#~ "\t\tcat frontend-v2.json | kubectl rolling-update frontend-v1 -f -\n"
#~ "\n"
#~ "\t\t# Update the pods of frontend-v1 to frontend-v2 by just changing the "
#~ "image, and switching the\n"
#~ "\t\t# name of the replication controller.\n"
#~ "\t\tkubectl rolling-update frontend-v1 frontend-v2 --image=image:v2\n"
#~ "\n"
#~ "\t\t# Update the pods of frontend by just changing the image, and keeping "
#~ "the old name.\n"
#~ "\t\tkubectl rolling-update frontend --image=image:v2\n"
#~ "\n"
#~ "\t\t# Abort and reverse an existing rollout in progress (from frontend-v1 "
#~ "to frontend-v2).\n"
#~ "\t\tkubectl rolling-update frontend-v1 frontend-v2 --rollback"
#~ msgstr ""
#~ "\n"
#~ "\t\t# Update pods of frontend-v1 using new replication controller data in "
#~ "frontend-v2.json.\n"
#~ "\t\tkubectl rolling-update frontend-v1 -f frontend-v2.json\n"
#~ "\n"
#~ "\t\t# Update pods of frontend-v1 using JSON data passed into stdin.\n"
#~ "\t\tcat frontend-v2.json | kubectl rolling-update frontend-v1 -f -\n"
#~ "\n"
#~ "\t\t# Update the pods of frontend-v1 to frontend-v2 by just changing the "
#~ "image, and switching the\n"
#~ "\t\t# name of the replication controller.\n"
#~ "\t\tkubectl rolling-update frontend-v1 frontend-v2 --image=image:v2\n"
#~ "\n"
#~ "\t\t# Update the pods of frontend by just changing the image, and keeping "
#~ "the old name.\n"
#~ "\t\tkubectl rolling-update frontend --image=image:v2\n"
#~ "\n"
#~ "\t\t# Abort and reverse an existing rollout in progress (from frontend-v1 "
#~ "to frontend-v2).\n"
#~ "\t\tkubectl rolling-update frontend-v1 frontend-v2 --rollback"

#~ msgid ""
#~ "\n"
#~ "\t\t# View the last-applied-configuration annotations by type/name in "
#~ "YAML.\n"
#~ "\t\tkubectl apply view-last-applied deployment/nginx\n"
#~ "\n"
#~ "\t\t# View the last-applied-configuration annotations by file in JSON\n"
#~ "\t\tkubectl apply view-last-applied -f deploy.yaml -o json"
#~ msgstr ""
#~ "\n"
#~ "\t\t# View the last-applied-configuration annotations by type/name in "
#~ "YAML.\n"
#~ "\t\tkubectl apply view-last-applied deployment/nginx\n"
#~ "\n"
#~ "\t\t# View the last-applied-configuration annotations by file in JSON\n"
#~ "\t\tkubectl apply view-last-applied -f deploy.yaml -o json"

#~ msgid ""
#~ "\n"
#~ "\t\tApply a configuration to a resource by filename or stdin.\n"
#~ "\t\tThis resource will be created if it doesn't exist yet.\n"
#~ "\t\tTo use 'apply', always create the resource initially with either "
#~ "'apply' or 'create --save-config'.\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted.\n"
#~ "\n"
#~ "\t\tAlpha Disclaimer: the --prune functionality is not yet complete. Do "
#~ "not use unless you are aware of what the current state is. See https://"
#~ "issues.k8s.io/34274."
#~ msgstr ""
#~ "\n"
#~ "\t\t通过文件名或标准输入流(stdin)对资源进行配置.\n"
#~ "\t\tThis resource will be created if it doesn't exist yet.\n"
#~ "\t\tTo use 'apply', always create the resource initially with either "
#~ "'apply' or 'create --save-config'.\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted.\n"
#~ "\n"
#~ "\t\tAlpha Disclaimer: the --prune functionality is not yet complete. Do "
#~ "not use unless you are aware of what the current state is. See https://"
#~ "issues.k8s.io/34274."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L68
#~ msgid ""
#~ "\n"
#~ "\t\tCreate a ClusterRole."
#~ msgstr ""
#~ "\n"
#~ "\t\t创建一个 ClusterRole."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_clusterrolebinding.go#L43
#~ msgid ""
#~ "\n"
#~ "\t\tCreate a ClusterRoleBinding for a particular ClusterRole."
#~ msgstr ""
#~ "\n"
#~ "\t\t 为指定的 ClusterRole 创建一个 ClusterRoleBinding."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_rolebinding.go#L43
#~ msgid ""
#~ "\n"
#~ "\t\tCreate a RoleBinding for a particular Role or ClusterRole."
#~ msgstr ""
#~ "\n"
#~ "\t\t为指定的 Role 或者 ClusterRole 创建一个 RoleBinding."

#~ msgid ""
#~ "\n"
#~ "\t\tCreate a TLS secret from the given public/private key pair.\n"
#~ "\n"
#~ "\t\tThe public/private key pair must exist before hand. The public key "
#~ "certificate must be .PEM encoded and match the given private key."
#~ msgstr ""
#~ "\n"
#~ "\t\t为指定的 public/private key pair 创建一个 TLS secret.\n"
#~ "\n"
#~ "\t\tpublic/private key pair 必须在传递前存在. public key certificate 必须"
#~ "以 .PEM 被编码且匹配指定的 private key."

#~ msgid ""
#~ "\n"
#~ "\t\tCreate a configmap based on a file, directory, or specified literal "
#~ "value.\n"
#~ "\n"
#~ "\t\tA single configmap may package one or more key/value pairs.\n"
#~ "\n"
#~ "\t\tWhen creating a configmap based on a file, the key will default to the "
#~ "basename of the file, and the value will\n"
#~ "\t\tdefault to the file content.  If the basename is an invalid key, you "
#~ "may specify an alternate key.\n"
#~ "\n"
#~ "\t\tWhen creating a configmap based on a directory, each file whose "
#~ "basename is a valid key in the directory will be\n"
#~ "\t\tpackaged into the configmap.  Any directory entries except regular "
#~ "files are ignored (e.g. subdirectories,\n"
#~ "\t\tsymlinks, devices, pipes, etc)."
#~ msgstr ""
#~ "\n"
#~ "\t\tCreate a configmap based on a file, directory, or specified literal "
#~ "value.\n"
#~ "\n"
#~ "\t\tA single configmap may package one or more key/value pairs.\n"
#~ "\n"
#~ "\t\tWhen creating a configmap based on a file, the key will default to the "
#~ "basename of the file, and the value will\n"
#~ "\t\tdefault to the file content.  If the basename is an invalid key, you "
#~ "may specify an alternate key.\n"
#~ "\n"
#~ "\t\tWhen creating a configmap based on a directory, each file whose "
#~ "basename is a valid key in the directory will be\n"
#~ "\t\tpackaged into the configmap.  Any directory entries except regular "
#~ "files are ignored (e.g. subdirectories,\n"
#~ "\t\tsymlinks, devices, pipes, etc)."

#~ msgid ""
#~ "\n"
#~ "\t\tCreate a new secret for use with Docker registries.\n"
#~ "\n"
#~ "\t\tDockercfg secrets are used to authenticate against Docker registries.\n"
#~ "\n"
#~ "\t\tWhen using the Docker command line to push images, you can "
#~ "authenticate to a given registry by running\n"
#~ "\n"
#~ "\t\t    $ docker login DOCKER_REGISTRY_SERVER --username=DOCKER_USER --"
#~ "password=DOCKER_PASSWORD --email=DOCKER_EMAIL'.\n"
#~ "\n"
#~ "    That produces a ~/.dockercfg file that is used by subsequent 'docker "
#~ "push' and 'docker pull' commands to\n"
#~ "\t\tauthenticate to the registry. The email address is optional.\n"
#~ "\n"
#~ "\t\tWhen creating applications, you may have a Docker registry that "
#~ "requires authentication.  In order for the\n"
#~ "\t\tnodes to pull images on your behalf, they have to have the "
#~ "credentials.  You can provide this information\n"
#~ "\t\tby creating a dockercfg secret and attaching it to your service "
#~ "account."
#~ msgstr ""
#~ "\n"
#~ "\t\tCreate a new secret for use with Docker registries.\n"
#~ "\n"
#~ "\t\tDockercfg secrets are used to authenticate against Docker registries.\n"
#~ "\n"
#~ "\t\tWhen using the Docker command line to push images, you can "
#~ "authenticate to a given registry by running\n"
#~ "\n"
#~ "\t\t    $ docker login DOCKER_REGISTRY_SERVER --username=DOCKER_USER --"
#~ "password=DOCKER_PASSWORD --email=DOCKER_EMAIL'.\n"
#~ "\n"
#~ "    That produces a ~/.dockercfg file that is used by subsequent 'docker "
#~ "push' and 'docker pull' commands to\n"
#~ "\t\tauthenticate to the registry. The email address is optional.\n"
#~ "\n"
#~ "\t\tWhen creating applications, you may have a Docker registry that "
#~ "requires authentication.  In order for the\n"
#~ "\t\tnodes to pull images on your behalf, they have to have the "
#~ "credentials.  You can provide this information\n"
#~ "\t\tby creating a dockercfg secret and attaching it to your service "
#~ "account."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_pdb.go#L49
#~ msgid ""
#~ "\n"
#~ "\t\tCreate a pod disruption budget with the specified name, selector, and "
#~ "desired minimum available pods"
#~ msgstr ""
#~ "\n"
#~ "\t\tCreate a pod disruption budget with the specified name, selector, and "
#~ "desired minimum available pods"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create.go#L56
#~ msgid ""
#~ "\n"
#~ "\t\tCreate a resource by filename or stdin.\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted."
#~ msgstr ""
#~ "\n"
#~ "\t\t通过文件名或者标准输入流(stdin)创建一个资源.\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L47
#~ msgid ""
#~ "\n"
#~ "\t\tCreate a resourcequota with the specified name, hard limits and "
#~ "optional scopes"
#~ msgstr ""
#~ "\n"
#~ "\t\tCreate a resourcequota with the specified name, hard limits and "
#~ "optional scopes"

#~ msgid ""
#~ "\n"
#~ "\t\tCreate a secret based on a file, directory, or specified literal "
#~ "value.\n"
#~ "\n"
#~ "\t\tA single secret may package one or more key/value pairs.\n"
#~ "\n"
#~ "\t\tWhen creating a secret based on a file, the key will default to the "
#~ "basename of the file, and the value will\n"
#~ "\t\tdefault to the file content.  If the basename is an invalid key, you "
#~ "may specify an alternate key.\n"
#~ "\n"
#~ "\t\tWhen creating a secret based on a directory, each file whose basename "
#~ "is a valid key in the directory will be\n"
#~ "\t\tpackaged into the secret.  Any directory entries except regular files "
#~ "are ignored (e.g. subdirectories,\n"
#~ "\t\tsymlinks, devices, pipes, etc)."
#~ msgstr ""
#~ "\n"
#~ "\t\tCreate a secret based on a file, directory, or specified literal "
#~ "value.\n"
#~ "\n"
#~ "\t\tA single secret may package one or more key/value pairs.\n"
#~ "\n"
#~ "\t\tWhen creating a secret based on a file, the key will default to the "
#~ "basename of the file, and the value will\n"
#~ "\t\tdefault to the file content.  If the basename is an invalid key, you "
#~ "may specify an alternate key.\n"
#~ "\n"
#~ "\t\tWhen creating a secret based on a directory, each file whose basename "
#~ "is a valid key in the directory will be\n"
#~ "\t\tpackaged into the secret.  Any directory entries except regular files "
#~ "are ignored (e.g. subdirectories,\n"
#~ "\t\tsymlinks, devices, pipes, etc)."

#~ msgid ""
#~ "\n"
#~ "\t\tCreate and run a particular image, possibly replicated.\n"
#~ "\n"
#~ "\t\tCreates a deployment or job to manage the created container(s)."
#~ msgstr ""
#~ "\n"
#~ "\t\tCreate and run a particular image, possibly replicated.\n"
#~ "\n"
#~ "\t\tCreates a deployment or job to manage the created container(s)."

#~ msgid ""
#~ "\n"
#~ "\t\tCreates an autoscaler that automatically chooses and sets the number "
#~ "of pods that run in a kubernetes cluster.\n"
#~ "\n"
#~ "\t\tLooks up a Deployment, ReplicaSet, or ReplicationController by name "
#~ "and creates an autoscaler that uses the given resource as a reference.\n"
#~ "\t\tAn autoscaler can automatically increase or decrease number of pods "
#~ "deployed within the system as needed."
#~ msgstr ""
#~ "\n"
#~ "\t\tCreates an autoscaler that automatically chooses and sets the number "
#~ "of pods that run in a kubernetes cluster.\n"
#~ "\n"
#~ "\t\tLooks up a Deployment, ReplicaSet, or ReplicationController by name "
#~ "and creates an autoscaler that uses the given resource as a reference.\n"
#~ "\t\tAn autoscaler can automatically increase or decrease number of pods "
#~ "deployed within the system as needed."

#~ msgid ""
#~ "\n"
#~ "\t\tDelete resources by filenames, stdin, resources and names, or by "
#~ "resources and label selector.\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted. Only one type of the arguments may "
#~ "be specified: filenames,\n"
#~ "\t\tresources and names, or resources and label selector.\n"
#~ "\n"
#~ "\t\tSome resources, such as pods, support graceful deletion. These "
#~ "resources define a default period\n"
#~ "\t\tbefore they are forcibly terminated (the grace period) but you may "
#~ "override that value with\n"
#~ "\t\tthe --grace-period flag, or pass --now to set a grace-period of 1. "
#~ "Because these resources often\n"
#~ "\t\trepresent entities in the cluster, deletion may not be acknowledged "
#~ "immediately. If the node\n"
#~ "\t\thosting a pod is down or cannot reach the API server, termination may "
#~ "take significantly longer\n"
#~ "\t\tthan the grace period. To force delete a resource,\tyou must pass a "
#~ "grace\tperiod of 0 and specify\n"
#~ "\t\tthe --force flag.\n"
#~ "\n"
#~ "\t\tIMPORTANT: Force deleting pods does not wait for confirmation that the "
#~ "pod's processes have been\n"
#~ "\t\tterminated, which can leave those processes running until the node "
#~ "detects the deletion and\n"
#~ "\t\tcompletes graceful deletion. If your processes use shared storage or "
#~ "talk to a remote API and\n"
#~ "\t\tdepend on the name of the pod to identify themselves, force deleting "
#~ "those pods may result in\n"
#~ "\t\tmultiple processes running on different machines using the same "
#~ "identification which may lead\n"
#~ "\t\tto data corruption or inconsistency. Only force delete pods when you "
#~ "are sure the pod is\n"
#~ "\t\tterminated, or if your application can tolerate multiple copies of the "
#~ "same pod running at once.\n"
#~ "\t\tAlso, if you force delete pods the scheduler may place new pods on "
#~ "those nodes before the node\n"
#~ "\t\thas released those resources and causing those pods to be evicted "
#~ "immediately.\n"
#~ "\n"
#~ "\t\tNote that the delete command does NOT do resource version checks, so "
#~ "if someone\n"
#~ "\t\tsubmits an update to a resource right when you submit a delete, their "
#~ "update\n"
#~ "\t\twill be lost along with the rest of the resource."
#~ msgstr ""
#~ "\n"
#~ "\t\tDelete resources by filenames, stdin, resources and names, or by "
#~ "resources and label selector.\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted. Only one type of the arguments may "
#~ "be specified: filenames,\n"
#~ "\t\tresources and names, or resources and label selector.\n"
#~ "\n"
#~ "\t\tSome resources, such as pods, support graceful deletion. These "
#~ "resources define a default period\n"
#~ "\t\tbefore they are forcibly terminated (the grace period) but you may "
#~ "override that value with\n"
#~ "\t\tthe --grace-period flag, or pass --now to set a grace-period of 1. "
#~ "Because these resources often\n"
#~ "\t\trepresent entities in the cluster, deletion may not be acknowledged "
#~ "immediately. If the node\n"
#~ "\t\thosting a pod is down or cannot reach the API server, termination may "
#~ "take significantly longer\n"
#~ "\t\tthan the grace period. To force delete a resource,\tyou must pass a "
#~ "grace\tperiod of 0 and specify\n"
#~ "\t\tthe --force flag.\n"
#~ "\n"
#~ "\t\tIMPORTANT: Force deleting pods does not wait for confirmation that the "
#~ "pod's processes have been\n"
#~ "\t\tterminated, which can leave those processes running until the node "
#~ "detects the deletion and\n"
#~ "\t\tcompletes graceful deletion. If your processes use shared storage or "
#~ "talk to a remote API and\n"
#~ "\t\tdepend on the name of the pod to identify themselves, force deleting "
#~ "those pods may result in\n"
#~ "\t\tmultiple processes running on different machines using the same "
#~ "identification which may lead\n"
#~ "\t\tto data corruption or inconsistency. Only force delete pods when you "
#~ "are sure the pod is\n"
#~ "\t\tterminated, or if your application can tolerate multiple copies of the "
#~ "same pod running at once.\n"
#~ "\t\tAlso, if you force delete pods the scheduler may place new pods on "
#~ "those nodes before the node\n"
#~ "\t\thas released those resources and causing those pods to be evicted "
#~ "immediately.\n"
#~ "\n"
#~ "\t\tNote that the delete command does NOT do resource version checks, so "
#~ "if someone\n"
#~ "\t\tsubmits an update to a resource right when you submit a delete, their "
#~ "update\n"
#~ "\t\twill be lost along with the rest of the resource."

#~ msgid ""
#~ "\n"
#~ "\t\tDeprecated: Gracefully shut down a resource by name or filename.\n"
#~ "\n"
#~ "\t\tThe stop command is deprecated, all its functionalities are covered by "
#~ "delete command.\n"
#~ "\t\tSee 'kubectl delete --help' for more details.\n"
#~ "\n"
#~ "\t\tAttempts to shut down and delete a resource that supports graceful "
#~ "termination.\n"
#~ "\t\tIf the resource is scalable it will be scaled to 0 before deletion."
#~ msgstr ""
#~ "\n"
#~ "\t\tDeprecated: Gracefully shut down a resource by name or filename.\n"
#~ "\n"
#~ "\t\tThe stop command is deprecated, all its functionalities are covered by "
#~ "delete command.\n"
#~ "\t\tSee 'kubectl delete --help' for more details.\n"
#~ "\n"
#~ "\t\tAttempts to shut down and delete a resource that supports graceful "
#~ "termination.\n"
#~ "\t\tIf the resource is scalable it will be scaled to 0 before deletion."

#~ msgid ""
#~ "\n"
#~ "\t\tDisplay Resource (CPU/Memory/Storage) usage of nodes.\n"
#~ "\n"
#~ "\t\tThe top-node command allows you to see the resource consumption of "
#~ "nodes."
#~ msgstr ""
#~ "\n"
#~ "\t\t显示 node 的资源(CPU/Memory/Storage)使用.\n"
#~ "\n"
#~ "\t\tThe top-node command allows you to see the resource consumption of "
#~ "nodes."

#~ msgid ""
#~ "\n"
#~ "\t\tDisplay Resource (CPU/Memory/Storage) usage of pods.\n"
#~ "\n"
#~ "\t\tThe 'top pod' command allows you to see the resource consumption of "
#~ "pods.\n"
#~ "\n"
#~ "\t\tDue to the metrics pipeline delay, they may be unavailable for a few "
#~ "minutes\n"
#~ "\t\tsince pod creation."
#~ msgstr ""
#~ "\n"
#~ "\t\t显示 pods 资源(CPU/Memory/Storage)使用.\n"
#~ "\n"
#~ "\t\tThe 'top pod' command allows you to see the resource consumption of "
#~ "pods.\n"
#~ "\n"
#~ "\t\tDue to the metrics pipeline delay, they may be unavailable for a few "
#~ "minutes\n"
#~ "\t\tsince pod creation."

#~ msgid ""
#~ "\n"
#~ "\t\tDisplay Resource (CPU/Memory/Storage) usage.\n"
#~ "\n"
#~ "\t\tThe top command allows you to see the resource consumption for nodes "
#~ "or pods.\n"
#~ "\n"
#~ "\t\tThis command requires Heapster to be correctly configured and working "
#~ "on the server. "
#~ msgstr ""
#~ "\n"
#~ "\t\t显示资源(CPU/Memory/Storage)使用.\n"
#~ "\n"
#~ "\t\tThe top command allows you to see the resource consumption for nodes "
#~ "or pods.\n"
#~ "\n"
#~ "\t\tThis command requires Heapster to be correctly configured and working "
#~ "on the server. "

#~ msgid ""
#~ "\n"
#~ "\t\tDrain node in preparation for maintenance.\n"
#~ "\n"
#~ "\t\tThe given node will be marked unschedulable to prevent new pods from "
#~ "arriving.\n"
#~ "\t\t'drain' evicts the pods if the APIServer supports eviction\n"
#~ "\t\t(http://kubernetes.io/docs/admin/disruptions/). Otherwise, it will use "
#~ "normal DELETE\n"
#~ "\t\tto delete the pods.\n"
#~ "\t\tThe 'drain' evicts or deletes all pods except mirror pods (which "
#~ "cannot be deleted through\n"
#~ "\t\tthe API server).  If there are DaemonSet-managed pods, drain will not "
#~ "proceed\n"
#~ "\t\twithout --ignore-daemonsets, and regardless it will not delete any\n"
#~ "\t\tDaemonSet-managed pods, because those pods would be immediately "
#~ "replaced by the\n"
#~ "\t\tDaemonSet controller, which ignores unschedulable markings.  If there "
#~ "are any\n"
#~ "\t\tpods that are neither mirror pods nor managed by "
#~ "ReplicationController,\n"
#~ "\t\tReplicaSet, DaemonSet, StatefulSet or Job, then drain will not delete "
#~ "any pods unless you\n"
#~ "\t\tuse --force.  --force will also allow deletion to proceed if the "
#~ "managing resource of one\n"
#~ "\t\tor more pods is missing.\n"
#~ "\n"
#~ "\t\t'drain' waits for graceful termination. You should not operate on the "
#~ "machine until\n"
#~ "\t\tthe command completes.\n"
#~ "\n"
#~ "\t\tWhen you are ready to put the node back into service, use kubectl "
#~ "uncordon, which\n"
#~ "\t\twill make the node schedulable again.\n"
#~ "\n"
#~ "\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_drain.svg)"
#~ msgstr ""
#~ "\n"
#~ "\t\t清理节点为节点维护做准备.\n"
#~ "\n"
#~ "\t\tThe given node will be marked unschedulable to prevent new pods from "
#~ "arriving.\n"
#~ "\t\t'drain' evicts the pods if the APIServer supports eviction\n"
#~ "\t\t(http://kubernetes.io/docs/admin/disruptions/). Otherwise, it will use "
#~ "normal DELETE\n"
#~ "\t\tto delete the pods.\n"
#~ "\t\tThe 'drain' evicts or deletes all pods except mirror pods (which "
#~ "cannot be deleted through\n"
#~ "\t\tthe API server).  If there are DaemonSet-managed pods, drain will not "
#~ "proceed\n"
#~ "\t\twithout --ignore-daemonsets, and regardless it will not delete any\n"
#~ "\t\tDaemonSet-managed pods, because those pods would be immediately "
#~ "replaced by the\n"
#~ "\t\tDaemonSet controller, which ignores unschedulable markings.  If there "
#~ "are any\n"
#~ "\t\tpods that are neither mirror pods nor managed by "
#~ "ReplicationController,\n"
#~ "\t\tReplicaSet, DaemonSet, StatefulSet or Job, then drain will not delete "
#~ "any pods unless you\n"
#~ "\t\tuse --force.  --force will also allow deletion to proceed if the "
#~ "managing resource of one\n"
#~ "\t\tor more pods is missing.\n"
#~ "\n"
#~ "\t\t'drain' waits for graceful termination. You should not operate on the "
#~ "machine until\n"
#~ "\t\tthe command completes.\n"
#~ "\n"
#~ "\t\tWhen you are ready to put the node back into service, use kubectl "
#~ "uncordon, which\n"
#~ "\t\twill make the node schedulable again.\n"
#~ "\n"
#~ "\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_drain.svg)"

#~ msgid ""
#~ "\n"
#~ "\t\tEdit a resource from the default editor.\n"
#~ "\n"
#~ "\t\tThe edit command allows you to directly edit any API resource you can "
#~ "retrieve via the\n"
#~ "\t\tcommand line tools. It will open the editor defined by your "
#~ "KUBE_EDITOR, or EDITOR\n"
#~ "\t\tenvironment variables, or fall back to 'vi' for Linux or 'notepad' for "
#~ "Windows.\n"
#~ "\t\tYou can edit multiple objects, although changes are applied one at a "
#~ "time. The command\n"
#~ "\t\taccepts filenames as well as command line arguments, although the "
#~ "files you point to must\n"
#~ "\t\tbe previously saved versions of resources.\n"
#~ "\n"
#~ "\t\tEditing is done with the API version used to fetch the resource.\n"
#~ "\t\tTo edit using a specific API version, fully-qualify the resource, "
#~ "version, and group.\n"
#~ "\n"
#~ "\t\tThe default format is YAML. To edit in JSON, specify \"-o json\".\n"
#~ "\n"
#~ "\t\tThe flag --windows-line-endings can be used to force Windows line "
#~ "endings,\n"
#~ "\t\totherwise the default for your operating system will be used.\n"
#~ "\n"
#~ "\t\tIn the event an error occurs while updating, a temporary file will be "
#~ "created on disk\n"
#~ "\t\tthat contains your unapplied changes. The most common error when "
#~ "updating a resource\n"
#~ "\t\tis another editor changing the resource on the server. When this "
#~ "occurs, you will have\n"
#~ "\t\tto apply your changes to the newer version of the resource, or update "
#~ "your temporary\n"
#~ "\t\tsaved copy to include the latest resource version."
#~ msgstr ""
#~ "\n"
#~ "\t\t使用默认的编辑器修改资源.\n"
#~ "\n"
#~ "\t\tedit 命令允许你通过命令行直接修改 API 资源.\n"
#~ "\t\t它会打开你在 KUBE_EDITOR 或者EDITOR 环境变量中定义的编辑器\n"
#~ "\t\t或者回滚到 Linux vi 编辑器或者 Windows notepad.\n"
#~ "\t\t你可以修改多个对象, 虽然每次只能修改一次. 这个命令\n"
#~ "\t\t同时也接受文件名作为命令行参数, 尽管这些文件你指出必须是\n"
#~ "\t\t你之前保存的资源版本.\n"
#~ "\n"
#~ "\t\tEditing 是通过用于获取资源的API版本完成的.\n"
#~ "\t\t为了能通过指定的 API 版本修改, 请完全限定 resource, version 和 group.\n"
#~ "\n"
#~ "\t\t默认是 YAML 格式. 想在 JSON 中修改, 指定 \"-o json\".\n"
#~ "\n"
#~ "\t\t--windows-line-endings 命令行参数可以用来强制使用 Windows line "
#~ "endings,\n"
#~ "\t\t否则会使用你操作系统的默认值.\n"
#~ "\n"
#~ "\t\t如果更新时发生错误，将在磁盘上创建一个临时文件\n"
#~ "\t\t里面包含您未应用的更改. 更新资源时最常见的错误\n"
#~ "\t\t是另一个编辑器也在服务器中修改这个资源. 当发生这种情况时, 你将\n"
#~ "\t\t需要应用你的修改到资源的最新版本, 或者更新你被保存的临时文件\n"
#~ "\t\t复制它并使用最新的版本."

#~ msgid ""
#~ "\n"
#~ "\t\tOutput shell completion code for the specified shell (bash or zsh).\n"
#~ "\t\tThe shell code must be evaluated to provide interactive\n"
#~ "\t\tcompletion of kubectl commands.  This can be done by sourcing it from\n"
#~ "\t\tthe .bash_profile.\n"
#~ "\n"
#~ "\t\tNote: this requires the bash-completion framework, which is not "
#~ "installed\n"
#~ "\t\tby default on Mac.  This can be installed by using homebrew:\n"
#~ "\n"
#~ "\t\t    $ brew install bash-completion\n"
#~ "\n"
#~ "\t\tOnce installed, bash_completion must be evaluated.  This can be done "
#~ "by adding the\n"
#~ "\t\tfollowing line to the .bash_profile\n"
#~ "\n"
#~ "\t\t    $ source $(brew --prefix)/etc/bash_completion\n"
#~ "\n"
#~ "\t\tNote for zsh users: [1] zsh completions are only supported in versions "
#~ "of zsh >= 5.2"
#~ msgstr ""
#~ "\n"
#~ "\t\tOutput shell completion code for the specified shell (bash or zsh).\n"
#~ "\t\tThe shell code must be evaluated to provide interactive\n"
#~ "\t\tcompletion of kubectl commands.  This can be done by sourcing it from\n"
#~ "\t\tthe .bash_profile.\n"
#~ "\n"
#~ "\t\tNote: this requires the bash-completion framework, which is not "
#~ "installed\n"
#~ "\t\tby default on Mac.  This can be installed by using homebrew:\n"
#~ "\n"
#~ "\t\t    $ brew install bash-completion\n"
#~ "\n"
#~ "\t\tOnce installed, bash_completion must be evaluated.  This can be done "
#~ "by adding the\n"
#~ "\t\tfollowing line to the .bash_profile\n"
#~ "\n"
#~ "\t\t    $ source $(brew --prefix)/etc/bash_completion\n"
#~ "\n"
#~ "\t\tNote for zsh users: [1] zsh completions are only supported in versions "
#~ "of zsh >= 5.2"

#~ msgid ""
#~ "\n"
#~ "\t\tPerform a rolling update of the given ReplicationController.\n"
#~ "\n"
#~ "\t\tReplaces the specified replication controller with a new replication "
#~ "controller by updating one pod at a time to use the\n"
#~ "\t\tnew PodTemplate. The new-controller.json must specify the same "
#~ "namespace as the\n"
#~ "\t\texisting replication controller and overwrite at least one (common) "
#~ "label in its replicaSelector.\n"
#~ "\n"
#~ "\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_rollingupdate.svg)"
#~ msgstr ""
#~ "\n"
#~ "\t\t完成指定的 ReplicationController 的滚动升级.\n"
#~ "\n"
#~ "\t\tReplaces the specified replication controller with a new replication "
#~ "controller by updating one pod at a time to use the\n"
#~ "\t\tnew PodTemplate. The new-controller.json must specify the same "
#~ "namespace as the\n"
#~ "\t\texisting replication controller and overwrite at least one (common) "
#~ "label in its replicaSelector.\n"
#~ "\n"
#~ "\t\t![Workflow](http://kubernetes.io/images/docs/kubectl_rollingupdate.svg)"

#~ msgid ""
#~ "\n"
#~ "\t\tReplace a resource by filename or stdin.\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted. If replacing an existing resource, "
#~ "the\n"
#~ "\t\tcomplete resource spec must be provided. This can be obtained by\n"
#~ "\n"
#~ "\t\t    $ kubectl get TYPE NAME -o yaml\n"
#~ msgstr ""
#~ "\n"
#~ "\t\tReplace a resource by filename or stdin.\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted. If replacing an existing resource, "
#~ "the\n"
#~ "\t\tcomplete resource spec must be provided. This can be obtained by\n"
#~ "\n"
#~ "\t\t    $ kubectl get TYPE NAME -o yaml\n"

#~ msgid ""
#~ "\n"
#~ "\t\tSet a new size for a Deployment, ReplicaSet, Replication Controller, "
#~ "or Job.\n"
#~ "\n"
#~ "\t\tScale also allows users to specify one or more preconditions for the "
#~ "scale action.\n"
#~ "\n"
#~ "\t\tIf --current-replicas or --resource-version is specified, it is "
#~ "validated before the\n"
#~ "\t\tscale is attempted, and it is guaranteed that the precondition holds "
#~ "true when the\n"
#~ "\t\tscale is sent to the server."
#~ msgstr ""
#~ "\n"
#~ "\t\tSet a new size for a Deployment, ReplicaSet, Replication Controller, "
#~ "or Job.\n"
#~ "\n"
#~ "\t\tScale also allows users to specify one or more preconditions for the "
#~ "scale action.\n"
#~ "\n"
#~ "\t\tIf --current-replicas or --resource-version is specified, it is "
#~ "validated before the\n"
#~ "\t\tscale is attempted, and it is guaranteed that the precondition holds "
#~ "true when the\n"
#~ "\t\tscale is sent to the server."

#~ msgid ""
#~ "\n"
#~ "\t\tTo proxy all of the kubernetes api and nothing else, use:\n"
#~ "\n"
#~ "\t\t    $ kubectl proxy --api-prefix=/\n"
#~ "\n"
#~ "\t\tTo proxy only part of the kubernetes api and also some static files:\n"
#~ "\n"
#~ "\t\t    $ kubectl proxy --www=/my/files --www-prefix=/static/ --api-"
#~ "prefix=/api/\n"
#~ "\n"
#~ "\t\tThe above lets you 'curl localhost:8001/api/v1/pods'.\n"
#~ "\n"
#~ "\t\tTo proxy the entire kubernetes api at a different root, use:\n"
#~ "\n"
#~ "\t\t    $ kubectl proxy --api-prefix=/custom/\n"
#~ "\n"
#~ "\t\tThe above lets you 'curl localhost:8001/custom/api/v1/pods'"
#~ msgstr ""
#~ "\n"
#~ "\t\tTo proxy all of the kubernetes api and nothing else, use:\n"
#~ "\n"
#~ "\t\t    $ kubectl proxy --api-prefix=/\n"
#~ "\n"
#~ "\t\tTo proxy only part of the kubernetes api and also some static files:\n"
#~ "\n"
#~ "\t\t    $ kubectl proxy --www=/my/files --www-prefix=/static/ --api-"
#~ "prefix=/api/\n"
#~ "\n"
#~ "\t\tThe above lets you 'curl localhost:8001/api/v1/pods'.\n"
#~ "\n"
#~ "\t\tTo proxy the entire kubernetes api at a different root, use:\n"
#~ "\n"
#~ "\t\t    $ kubectl proxy --api-prefix=/custom/\n"
#~ "\n"
#~ "\t\tThe above lets you 'curl localhost:8001/custom/api/v1/pods'"

#~ msgid ""
#~ "\n"
#~ "\t\tUpdate field(s) of a resource using strategic merge patch\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted.\n"
#~ msgstr ""
#~ "\n"
#~ "\t\tUpdate field(s) of a resource using strategic merge patch\n"
#~ "\n"
#~ "\t\tJSON and YAML formats are accepted.\n"

#, c-format
#~ msgid ""
#~ "\n"
#~ "\t\tUpdate the labels on a resource.\n"
#~ "\n"
#~ "\t\t* A label must begin with a letter or number, and may contain letters, "
#~ "numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
#~ "\t\t* If --overwrite is true, then existing labels can be overwritten, "
#~ "otherwise attempting to overwrite a label will result in an error.\n"
#~ "\t\t* If --resource-version is specified, then updates will use this "
#~ "resource version, otherwise the existing resource-version will be used."
#~ msgstr ""
#~ "\n"
#~ "\t\tUpdate the labels on a resource.\n"
#~ "\n"
#~ "\t\t* A label must begin with a letter or number, and may contain letters, "
#~ "numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
#~ "\t\t* If --overwrite is true, then existing labels can be overwritten, "
#~ "otherwise attempting to overwrite a label will result in an error.\n"
#~ "\t\t* If --resource-version is specified, then updates will use this "
#~ "resource version, otherwise the existing resource-version will be used."

#, c-format
#~ msgid ""
#~ "\n"
#~ "\t\tUpdate the taints on one or more nodes.\n"
#~ "\n"
#~ "\t\t* A taint consists of a key, value, and effect. As an argument here, "
#~ "it is expressed as key=value:effect.\n"
#~ "\t\t* The key must begin with a letter or number, and may contain letters, "
#~ "numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
#~ "\t\t* The value must begin with a letter or number, and may contain "
#~ "letters, numbers, hyphens, dots, and underscores, up to %[2]d characters.\n"
#~ "\t\t* The effect must be NoSchedule, PreferNoSchedule or NoExecute.\n"
#~ "\t\t* Currently taint can only apply to node."
#~ msgstr ""
#~ "\n"
#~ "\t\t更新一个或者多个 node 上的 taints.\n"
#~ "\n"
#~ "\t\t* A taint consists of a key, value, and effect. As an argument here, "
#~ "it is expressed as key=value:effect.\n"
#~ "\t\t* The key must begin with a letter or number, and may contain letters, "
#~ "numbers, hyphens, dots, and underscores, up to %[1]d characters.\n"
#~ "\t\t* The value must begin with a letter or number, and may contain "
#~ "letters, numbers, hyphens, dots, and underscores, up to %[2]d characters.\n"
#~ "\t\t* The effect must be NoSchedule, PreferNoSchedule or NoExecute.\n"
#~ "\t\t* Currently taint can only apply to node."

#~ msgid ""
#~ "\n"
#~ "\t\tView the latest last-applied-configuration annotations by type/name or "
#~ "file.\n"
#~ "\n"
#~ "\t\tThe default output will be printed to stdout in YAML format. One can "
#~ "use -o option\n"
#~ "\t\tto change output format."
#~ msgstr ""
#~ "\n"
#~ "\t\tView the latest last-applied-configuration annotations by type/name or "
#~ "file.\n"
#~ "\n"
#~ "\t\tThe default output will be printed to stdout in YAML format. One can "
#~ "use -o option\n"
#~ "\t\tto change output format."

#~ msgid ""
#~ "\n"
#~ "\t    # !!!Important Note!!!\n"
#~ "\t    # Requires that the 'tar' binary is present in your container\n"
#~ "\t    # image.  If 'tar' is not present, 'kubectl cp' will fail.\n"
#~ "\n"
#~ "\t    # Copy /tmp/foo_dir local directory to /tmp/bar_dir in a remote pod "
#~ "in the default namespace\n"
#~ "\t\tkubectl cp /tmp/foo_dir <some-pod>:/tmp/bar_dir\n"
#~ "\n"
#~ "        # Copy /tmp/foo local file to /tmp/bar in a remote pod in a "
#~ "specific container\n"
#~ "\t\tkubectl cp /tmp/foo <some-pod>:/tmp/bar -c <specific-container>\n"
#~ "\n"
#~ "\t\t# Copy /tmp/foo local file to /tmp/bar in a remote pod in namespace "
#~ "<some-namespace>\n"
#~ "\t\tkubectl cp /tmp/foo <some-namespace>/<some-pod>:/tmp/bar\n"
#~ "\n"
#~ "\t\t# Copy /tmp/foo from a remote pod to /tmp/bar locally\n"
#~ "\t\tkubectl cp <some-namespace>/<some-pod>:/tmp/foo /tmp/bar"
#~ msgstr ""
#~ "\n"
#~ "\t    # !!!注意!!!\n"
#~ "\t    # 要求容器中有 'tar' 命令\n"
#~ "\t    # image.  If 'tar' is not present, 'kubectl cp' will fail.\n"
#~ "\n"
#~ "\t    # 复制本地目录 /tmp/foo_dir 到 default namespace 下的远程 pod 的 /"
#~ "tmp/bar_dir 路径 \n"
#~ "\t\tkubectl cp /tmp/foo_dir <some-pod>:/tmp/bar_dir\n"
#~ "\n"
#~ "        # 复制 /tmp/foo local 本地文件到指定远程 pod 的指定容器的 /tmp/bar "
#~ "路径\n"
#~ "\t\tkubectl cp /tmp/foo <some-pod>:/tmp/bar -c <specific-container>\n"
#~ "\n"
#~ "\t\t# 复制 /tmp/foo 本地文件到在 namespace <some-namespace> 下的某个 pod "
#~ "的 /tmp/bar 路径\n"
#~ "\t\tkubectl cp /tmp/foo <some-namespace>/<some-pod>:/tmp/bar\n"
#~ "\n"
#~ "\t\t# 从一个远程的 pod 的 /tmp/foo 路径复制到本地 /tmp/bar 路径\n"
#~ "\t\tkubectl cp <some-namespace>/<some-pod>:/tmp/foo /tmp/bar"

#~ msgid ""
#~ "\n"
#~ "\t  # Create a new TLS secret named tls-secret with the given key pair:\n"
#~ "\t  kubectl create secret tls tls-secret --cert=path/to/tls.cert --"
#~ "key=path/to/tls.key"
#~ msgstr ""
#~ "\n"
#~ "\t  # 使用提供的 key pair 名称为tls-secret 的 secret:\n"
#~ "\t  kubectl create secret tls tls-secret --cert=path/to/tls.cert --"
#~ "key=path/to/tls.key"

#~ msgid ""
#~ "\n"
#~ "\t  # Create a new secret named my-secret with keys for each file in "
#~ "folder bar\n"
#~ "\t  kubectl create secret generic my-secret --from-file=path/to/bar\n"
#~ "\n"
#~ "\t  # Create a new secret named my-secret with specified keys instead of "
#~ "names on disk\n"
#~ "\t  kubectl create secret generic my-secret --from-file=ssh-privatekey=~/."
#~ "ssh/id_rsa --from-file=ssh-publickey=~/.ssh/id_rsa.pub\n"
#~ "\n"
#~ "\t  # Create a new secret named my-secret with key1=supersecret and "
#~ "key2=topsecret\n"
#~ "\t  kubectl create secret generic my-secret --from-"
#~ "literal=key1=supersecret --from-literal=key2=topsecret"
#~ msgstr ""
#~ "\n"
#~ "\t  # Create a new secret named my-secret with keys for each file in "
#~ "folder bar\n"
#~ "\t  kubectl create secret generic my-secret --from-file=path/to/bar\n"
#~ "\n"
#~ "\t  # Create a new secret named my-secret with specified keys instead of "
#~ "names on disk\n"
#~ "\t  kubectl create secret generic my-secret --from-file=ssh-privatekey=~/."
#~ "ssh/id_rsa --from-file=ssh-publickey=~/.ssh/id_rsa.pub\n"
#~ "\n"
#~ "\t  # Create a new secret named my-secret with key1=supersecret and "
#~ "key2=topsecret\n"
#~ "\t  kubectl create secret generic my-secret --from-"
#~ "literal=key1=supersecret --from-literal=key2=topsecret"

#~ msgid ""
#~ "\n"
#~ "\t# Create a new ExternalName service named my-ns \n"
#~ "\tkubectl create service externalname my-ns --external-name bar.com"
#~ msgstr ""
#~ "\n"
#~ "\t# Create a new ExternalName service named my-ns \n"
#~ "\tkubectl create service externalname my-ns --external-name bar.com"

#~ msgid ""
#~ "\n"
#~ "    # Create a new clusterIP service named my-cs\n"
#~ "    kubectl create service clusterip my-cs --tcp=5678:8080\n"
#~ "\n"
#~ "    # Create a new clusterIP service named my-cs (in headless mode)\n"
#~ "    kubectl create service clusterip my-cs --clusterip=\"None\""
#~ msgstr ""
#~ "\n"
#~ "    # 创建一个名称为 my-cs 的 clusterIP service\n"
#~ "    kubectl create service clusterip my-cs --tcp=5678:8080\n"
#~ "\n"
#~ "    # 创建一个名称为 my-cs 的 clusterIP service (在 headless 模式)\n"
#~ "    kubectl create service clusterip my-cs --clusterip=\"None\""

#~ msgid ""
#~ "\n"
#~ "    # Create a new deployment named my-dep that runs the busybox image.\n"
#~ "    kubectl create deployment my-dep --image=busybox"
#~ msgstr ""
#~ "\n"
#~ "    # 创建一个名称为 my-dep 的 deployment 并运行 busybox image.\n"
#~ "    kubectl create deployment my-dep --image=busybox"

#~ msgid ""
#~ "\n"
#~ "    # Create a new nodeport service named my-ns\n"
#~ "    kubectl create service nodeport my-ns --tcp=5678:8080"
#~ msgstr ""
#~ "\n"
#~ "    # 创建一个名称为 my-ns 的 nodeport service\n"
#~ "    kubectl create service nodeport my-ns --tcp=5678:8080"

#~ msgid ""
#~ "\n"
#~ "    # Update pod 'foo' with the annotation 'description' and the value 'my "
#~ "frontend'.\n"
#~ "    # If the same annotation is set multiple times, only the last value "
#~ "will be applied\n"
#~ "    kubectl annotate pods foo description='my frontend'\n"
#~ "\n"
#~ "    # Update a pod identified by type and name in \"pod.json\"\n"
#~ "    kubectl annotate -f pod.json description='my frontend'\n"
#~ "\n"
#~ "    # Update pod 'foo' with the annotation 'description' and the value 'my "
#~ "frontend running nginx', overwriting any existing value.\n"
#~ "    kubectl annotate --overwrite pods foo description='my frontend running "
#~ "nginx'\n"
#~ "\n"
#~ "    # Update all pods in the namespace\n"
#~ "    kubectl annotate pods --all description='my frontend running nginx'\n"
#~ "\n"
#~ "    # Update pod 'foo' only if the resource is unchanged from version 1.\n"
#~ "    kubectl annotate pods foo description='my frontend running nginx' --"
#~ "resource-version=1\n"
#~ "\n"
#~ "    # Update pod 'foo' by removing an annotation named 'description' if it "
#~ "exists.\n"
#~ "    # Does not require the --overwrite flag.\n"
#~ "    kubectl annotate pods foo description-"
#~ msgstr ""
#~ "\n"
#~ "    # Update pod 'foo' with the annotation 'description' and the value 'my "
#~ "frontend'.\n"
#~ "    # If the same annotation is set multiple times, only the last value "
#~ "will be applied\n"
#~ "    kubectl annotate pods foo description='my frontend'\n"
#~ "\n"
#~ "    # Update a pod identified by type and name in \"pod.json\"\n"
#~ "    kubectl annotate -f pod.json description='my frontend'\n"
#~ "\n"
#~ "    # Update pod 'foo' with the annotation 'description' and the value 'my "
#~ "frontend running nginx', overwriting any existing value.\n"
#~ "    kubectl annotate --overwrite pods foo description='my frontend running "
#~ "nginx'\n"
#~ "\n"
#~ "    # Update all pods in the namespace\n"
#~ "    kubectl annotate pods --all description='my frontend running nginx'\n"
#~ "\n"
#~ "    # Update pod 'foo' only if the resource is unchanged from version 1.\n"
#~ "    kubectl annotate pods foo description='my frontend running nginx' --"
#~ "resource-version=1\n"
#~ "\n"
#~ "    # 更新名称为 'foo' 的 pod, 删除一个名称为 'description' 的 annotation "
#~ "如果它存在. \n"
#~ "    # 不要求使用 --overwrite flag.\n"
#~ "    kubectl annotate pods foo description-"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_serviceaccount.go#L44
#~ msgid ""
#~ "\n"
#~ "    Create a clusterIP service with the specified name."
#~ msgstr ""
#~ "\n"
#~ "    使用一个指定的名称创建一个 clusterIP service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_deployment.go#L44
#~ msgid ""
#~ "\n"
#~ "    Create a deployment with the specified name."
#~ msgstr ""
#~ "\n"
#~ "    使用一个指定的名称创建一个 deployment."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_deployment.go#L44
#~ msgid ""
#~ "\n"
#~ "    Create a nodeport service with the specified name."
#~ msgstr ""
#~ "\n"
#~ "    使用一个指定的名称创建一个 nodeport service."

#~ msgid ""
#~ "\n"
#~ "    Dumps cluster info out suitable for debugging and diagnosing cluster "
#~ "problems.  By default, dumps everything to\n"
#~ "    stdout. You can optionally specify a directory with --output-"
#~ "directory.  If you specify a directory, kubernetes will\n"
#~ "    build a set of files in that directory.  By default only dumps things "
#~ "in the 'kube-system' namespace, but you can\n"
#~ "    switch to a different namespace with the --namespaces flag, or specify "
#~ "--all-namespaces to dump all namespaces.\n"
#~ "\n"
#~ "    The command also dumps the logs of all of the pods in the cluster, "
#~ "these logs are dumped into different directories\n"
#~ "    based on namespace and pod name."
#~ msgstr ""
#~ "\n"
#~ "    Dumps cluster info out suitable for debugging and diagnosing cluster "
#~ "problems.  By default, dumps everything to\n"
#~ "    stdout. You can optionally specify a directory with --output-"
#~ "directory.  If you specify a directory, kubernetes will\n"
#~ "    build a set of files in that directory.  By default only dumps things "
#~ "in the 'kube-system' namespace, but you can\n"
#~ "    switch to a different namespace with the --namespaces flag, or specify "
#~ "--all-namespaces to dump all namespaces.\n"
#~ "\n"
#~ "    The command also dumps the logs of all of the pods in the cluster, "
#~ "these logs are dumped into different directories\n"
#~ "    based on namespace and pod name."

#~ msgid ""
#~ "\n"
#~ "  Display addresses of the master and services with label kubernetes.io/"
#~ "cluster-service=true\n"
#~ "  To further debug and diagnose cluster problems, use 'kubectl cluster-"
#~ "info dump'."
#~ msgstr ""
#~ "\n"
#~ "  Display addresses of the master and services with label kubernetes.io/"
#~ "cluster-service=true\n"
#~ "  To further debug and diagnose cluster problems, use 'kubectl cluster-"
#~ "info dump'."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L136
#~ msgid "A schedule in the Cron format the job should be run with."
#~ msgstr "A schedule in the Cron format the job should be run with."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L134
#~ msgid ""
#~ "An inline JSON override for the generated service object. If this is non-"
#~ "empty, it is used to override the generated object. Requires that the "
#~ "object supply a valid apiVersion field.  Only used if --expose is true."
#~ msgstr ""
#~ "An inline JSON override for the generated service object. If this is non-"
#~ "empty, it is used to override the generated object. Requires that the "
#~ "object supply a valid apiVersion field.  Only used if --expose is true."

#~ msgid "Apply a configuration to a resource by filename or stdin"
#~ msgstr "通过文件名或标准输入流(stdin)对资源进行配置"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/autoscale.go#L55
#~ msgid "Auto-scale a Deployment, ReplicaSet, or ReplicationController"
#~ msgstr ""
#~ "自动调整一个 Deployment, ReplicaSet, 或者 ReplicationController 的副本数量"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L101
#~ msgid ""
#~ "Container name which will have its image upgraded. Only relevant when --"
#~ "image is specified, ignored otherwise. Required when using --image on a "
#~ "multi-container pod"
#~ msgstr ""
#~ "Container name which will have its image upgraded. Only relevant when --"
#~ "image is specified, ignored otherwise. Required when using --image on a "
#~ "multi-container pod"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_clusterrolebinding.go#L43
#~ msgid "Create a ClusterRoleBinding for a particular ClusterRole"
#~ msgstr "为一个指定的 ClusterRole 创建一个 ClusterRoleBinding"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L181
#~ msgid "Create a LoadBalancer service."
#~ msgstr "创建一个 LoadBalancer service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L124
#~ msgid "Create a NodePort service."
#~ msgstr "创建一个 NodePort service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_rolebinding.go#L43
#~ msgid "Create a RoleBinding for a particular Role or ClusterRole"
#~ msgstr "为一个指定的 Role 或者 ClusterRole创建一个 RoleBinding"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L68
#~ msgid "Create a clusterIP service."
#~ msgstr "创建一个 clusterIP service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_configmap.go#L59
#~ msgid "Create a configmap from a local file, directory or literal value"
#~ msgstr "从本地 file, directory 或者 literal value 创建一个 configmap"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_deployment.go#L44
#~ msgid "Create a deployment with the specified name."
#~ msgstr "创建一个指定名称的 deployment."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_pdb.go#L49
#~ msgid "Create a pod disruption budget with the specified name."
#~ msgstr "创建一个指定名称的 pod disruption budget."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_quota.go#L47
#~ msgid "Create a quota with the specified name."
#~ msgstr "创建一个指定名称的 quota."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create.go#L56
#~ msgid "Create a resource by filename or stdin"
#~ msgstr "通过文件名或者标准输入流(stdin)创建一个资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_secret.go#L73
#~ msgid "Create a secret from a local file, directory or literal value"
#~ msgstr "从本地 file, directory 或者 literal value 创建一个 secret"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L36
#~ msgid "Create a service using specified subcommand."
#~ msgstr "使用指定的 subcommand 创建一个 service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L240
#~ msgid "Create an ExternalName service."
#~ msgstr "Create an ExternalName service."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/delete.go#L130
#~ msgid ""
#~ "Delete resources by filenames, stdin, resources and names, or by resources "
#~ "and label selector"
#~ msgstr ""
#~ "Delete resources by filenames, stdin, resources and names, or by resources "
#~ "and label selector"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/stop.go#L58
#~ msgid "Deprecated: Gracefully shut down a resource by name or filename"
#~ msgstr "Deprecated: Gracefully shut down a resource by name or filename"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/top_node.go#L77
#~ msgid "Display Resource (CPU/Memory) usage of nodes"
#~ msgstr "显示 nodes 的 Resource (CPU/Memory) 使用"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/top_pod.go#L79
#~ msgid "Display Resource (CPU/Memory) usage of pods"
#~ msgstr "显示 pods 的 Resource (CPU/Memory) 使用"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/top.go#L43
#~ msgid "Display Resource (CPU/Memory) usage."
#~ msgstr "显示 Resource (CPU/Memory) 使用."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/clusterinfo.go#L49
#~ msgid "Display cluster info"
#~ msgstr "显示集群信息"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/current_context.go#L48
#~ msgid "Displays the current-context"
#~ msgstr "显示当前的 context"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/explain.go#L50
#~ msgid "Documentation of resources"
#~ msgstr "查看资源的文档"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/clusterinfo_dump.go#L37
#~ msgid "Dump lots of relevant info for debugging and diagnosis"
#~ msgstr "Dump lots of relevant info for debugging and diagnosis"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L102
#~ msgid ""
#~ "Explicit policy for when to pull container images. Required when --image "
#~ "is same as existing image, ignored otherwise."
#~ msgstr ""
#~ "Explicit policy for when to pull container images. Required when --image "
#~ "is same as existing image, ignored otherwise."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L105
#~ msgid ""
#~ "IP to assign to the Load Balancer. If empty, an ephemeral IP will be "
#~ "created and used (cloud-provider specific)."
#~ msgstr ""
#~ "IP to assign to the Load Balancer. If empty, an ephemeral IP will be "
#~ "created and used (cloud-provider specific)."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L98
#~ msgid ""
#~ "Image to use for upgrading the replication controller. Must be distinct "
#~ "from the existing image (either new image or new image tag).  Can not be "
#~ "used with --filename/-f"
#~ msgstr ""
#~ "Image to use for upgrading the replication controller. Must be distinct "
#~ "from the existing image (either new image or new image tag).  Can not be "
#~ "used with --filename/-f"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollout/rollout.go#L46
#~ msgid "Manage a deployment rollout"
#~ msgstr "管理一个 deployment 的 rollout"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/edit.go#L115
#~ msgid ""
#~ "Output the formatted object with the given group version (for ex: "
#~ "'extensions/v1beta1').)"
#~ msgstr ""
#~ "Output the formatted object with the given group version (for ex: "
#~ "'extensions/v1beta1').)"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L84
#~ msgid "Perform a rolling update of the given ReplicationController"
#~ msgstr "完成指定的 ReplicationController 的滚动升级"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/replace.go#L70
#~ msgid "Replace a resource by filename or stdin"
#~ msgstr "通过 filename 或者 stdin替换一个资源"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/scale.go#L71
#~ msgid ""
#~ "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job"
#~ msgstr ""
#~ "为 Deployment, ReplicaSet, Replication Controller 或者 Job 设置一个新的副本"
#~ "数量"

#~ msgid ""
#~ "Set the last-applied-configuration annotation on a live object to match "
#~ "the contents of a file."
#~ msgstr ""
#~ "Set the last-applied-configuration annotation on a live object to match "
#~ "the contents of a file."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/create_cluster.go#L67
#~ msgid "Sets a cluster entry in kubeconfig"
#~ msgstr "设置 kubeconfig 文件中的一个集群条目"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/create_context.go#L57
#~ msgid "Sets a context entry in kubeconfig"
#~ msgstr "设置 kubeconfig 文件中的一个 context 条目"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/create_authinfo.go#L103
#~ msgid "Sets a user entry in kubeconfig"
#~ msgstr "设置 kubeconfig 文件中的一个用户条目"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/set.go#L59
#~ msgid "Sets an individual value in a kubeconfig file"
#~ msgstr "设置 kubeconfig 文件中的一个单个值"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/use_context.go#L48
#~ msgid "Sets the current-context in a kubeconfig file"
#~ msgstr "设置 kubeconfig 文件中的当前上下文"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L87
#~ msgid ""
#~ "Take a replication controller, service, deployment or pod and expose it as "
#~ "a new Kubernetes Service"
#~ msgstr ""
#~ "使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 "
#~ "新的 Kubernetes Service"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/rollingupdate.go#L100
#~ msgid ""
#~ "The key to use to differentiate between two different controllers, default "
#~ "'deployment'.  Only relevant when --image is specified, ignored otherwise"
#~ msgstr ""
#~ "这个 key 使用有区别在两个不同的 controllers, 默认 'deployment'. 只有当 --"
#~ "image 指定值, 否则忽略"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L113
#~ msgid ""
#~ "The name of the API generator to use, see http://kubernetes.io/docs/user-"
#~ "guide/kubectl-conventions/#generators for a list."
#~ msgstr ""
#~ "使用 API generator 的名字, 在 http://kubernetes.io/docs/user-guide/kubectl-"
#~ "conventions/#generators 查看列表."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/autoscale.go#L66
#~ msgid ""
#~ "The name of the API generator to use. Currently there is only 1 generator."
#~ msgstr "使用 API generator 的名字. 目前只有 1 个 generator."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L133
#~ msgid ""
#~ "The name of the generator to use for creating a service.  Only used if --"
#~ "expose is true"
#~ msgstr ""
#~ "使用 gnerator 的名称创建一个 service.  只有在 --expose 为 true 的时候使用"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L121
#~ msgid ""
#~ "The port that this container exposes.  If --expose is true, this is also "
#~ "the port used by the service that is created."
#~ msgstr ""
#~ "The port that this container exposes.  If --expose is true, this is also "
#~ "the port used by the service that is created."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L128
#~ msgid ""
#~ "The restart policy for this Pod.  Legal values [Always, OnFailure, "
#~ "Never].  If set to 'Always' a deployment is created, if set to 'OnFailure' "
#~ "a job is created, if set to 'Never', a regular pod is created. For the "
#~ "latter two --replicas must be 1.  Default 'Always', for CronJobs `Never`."
#~ msgstr ""
#~ "这个 Pod 的 restart policy.  Legal values [Always, OnFailure, Never]. 如果"
#~ "设置为 'Always' 一个 deployment 被创建, 如果设置为 ’OnFailure' 一个 job 被"
#~ "创建, 如果设置为 'Never', 一个普通的 pod 被创建. 对于后面两个 --replicas 必"
#~ "须为 1.  默认 'Always', 为 CronJobs 设置为 `Never`."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/expose.go#L101
#~ msgid ""
#~ "Type for this service: ClusterIP, NodePort, or LoadBalancer. Default is "
#~ "'ClusterIP'."
#~ msgstr ""
#~ "对于服务的类型: ClusterIP, NodePort, 或者 LoadBalancer. 默认是 'ClusterIP’."

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/config/unset.go#L47
#~ msgid "Unsets an individual value in a kubeconfig file"
#~ msgstr "取消设置 kubeconfig 文件中的一个单个值"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/patch.go#L91
#~ msgid "Update field(s) of a resource using strategic merge patch"
#~ msgstr "使用 strategic merge patch 更新一个资源的 field(s)"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/set/set_image.go#L94
#~ msgid "Update image of a pod template"
#~ msgstr "更新一个 pod template 的镜像"

#~ msgid ""
#~ "View latest last-applied-configuration annotations of a resource/object"
#~ msgstr "显示最后的 resource/object 的 last-applied-configuration annotations"

# https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/create_service.go#L253
#~ msgid "external name of service"
#~ msgstr "服务的外部名称"

#~ msgid ""
#~ "watch is only supported on individual resources and resource collections - "
#~ "%d resources were found"
#~ msgid_plural ""
#~ "watch is only supported on individual resources and resource collections - "
#~ "%d resources were found"
#~ msgstr[0] ""
#~ "watch 仅支持单独的资源或者资源集合 - 找到了 %d 个资源watch is only "
#~ "supported on individual resources and resource collections - %d resource "
#~ "was found"
#~ msgstr[1] ""
#~ "watch 仅支持单独的资源或者资源集合 - 找到了 %d 个资源watch is only "
#~ "supported on individual resources and resource collections - %d resources "
#~ "were found"
