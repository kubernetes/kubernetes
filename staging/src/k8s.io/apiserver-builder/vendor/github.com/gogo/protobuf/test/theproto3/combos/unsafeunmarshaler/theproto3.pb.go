// Code generated by protoc-gen-gogo.
// source: combos/unsafeunmarshaler/theproto3.proto
// DO NOT EDIT!

/*
	Package theproto3 is a generated protocol buffer package.

	It is generated from these files:
		combos/unsafeunmarshaler/theproto3.proto

	It has these top-level messages:
		Message
		Nested
		AllMaps
		AllMapsOrdered
		MessageWithMap
		FloatingPoint
		Uint128Pair
		ContainsNestedMap
*/
package theproto3

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import test "github.com/gogo/protobuf/test/combos/both"

import github_com_gogo_protobuf_test_custom "github.com/gogo/protobuf/test/custom"

import github_com_gogo_protobuf_protoc_gen_gogo_descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import compress_gzip "compress/gzip"
import bytes "bytes"
import io_ioutil "io/ioutil"

import strconv "strconv"

import strings "strings"
import sort "sort"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"
import unsafe "unsafe"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type MapEnum int32

const (
	MA MapEnum = 0
	MB MapEnum = 1
	MC MapEnum = 2
)

var MapEnum_name = map[int32]string{
	0: "MA",
	1: "MB",
	2: "MC",
}
var MapEnum_value = map[string]int32{
	"MA": 0,
	"MB": 1,
	"MC": 2,
}

func (MapEnum) EnumDescriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{0} }

type Message_Humour int32

const (
	UNKNOWN     Message_Humour = 0
	PUNS        Message_Humour = 1
	SLAPSTICK   Message_Humour = 2
	BILL_BAILEY Message_Humour = 3
)

var Message_Humour_name = map[int32]string{
	0: "UNKNOWN",
	1: "PUNS",
	2: "SLAPSTICK",
	3: "BILL_BAILEY",
}
var Message_Humour_value = map[string]int32{
	"UNKNOWN":     0,
	"PUNS":        1,
	"SLAPSTICK":   2,
	"BILL_BAILEY": 3,
}

func (Message_Humour) EnumDescriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{0, 0} }

type Message struct {
	Name         string                     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Hilarity     Message_Humour             `protobuf:"varint,2,opt,name=hilarity,proto3,enum=theproto3.Message_Humour" json:"hilarity,omitempty"`
	HeightInCm   uint32                     `protobuf:"varint,3,opt,name=height_in_cm,json=heightInCm,proto3" json:"height_in_cm,omitempty"`
	Data         []byte                     `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	ResultCount  int64                      `protobuf:"varint,7,opt,name=result_count,json=resultCount,proto3" json:"result_count,omitempty"`
	TrueScotsman bool                       `protobuf:"varint,8,opt,name=true_scotsman,json=trueScotsman,proto3" json:"true_scotsman,omitempty"`
	Score        float32                    `protobuf:"fixed32,9,opt,name=score,proto3" json:"score,omitempty"`
	Key          []uint64                   `protobuf:"varint,5,rep,name=key" json:"key,omitempty"`
	Nested       *Nested                    `protobuf:"bytes,6,opt,name=nested" json:"nested,omitempty"`
	Terrain      map[int64]*Nested          `protobuf:"bytes,10,rep,name=terrain" json:"terrain,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Proto2Field  *test.NinOptNative         `protobuf:"bytes,11,opt,name=proto2_field,json=proto2Field" json:"proto2_field,omitempty"`
	Proto2Value  map[int64]*test.NinOptEnum `protobuf:"bytes,13,rep,name=proto2_value,json=proto2Value" json:"proto2_value,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{0} }

type Nested struct {
	Bunny string `protobuf:"bytes,1,opt,name=bunny,proto3" json:"bunny,omitempty"`
}

func (m *Nested) Reset()                    { *m = Nested{} }
func (*Nested) ProtoMessage()               {}
func (*Nested) Descriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{1} }

type AllMaps struct {
	StringToDoubleMap map[string]float64        `protobuf:"bytes,1,rep,name=StringToDoubleMap,json=stringToDoubleMap" json:"StringToDoubleMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	StringToFloatMap  map[string]float32        `protobuf:"bytes,2,rep,name=StringToFloatMap,json=stringToFloatMap" json:"StringToFloatMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Int32Map          map[int32]int32           `protobuf:"bytes,3,rep,name=Int32Map,json=int32Map" json:"Int32Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Int64Map          map[int64]int64           `protobuf:"bytes,4,rep,name=Int64Map,json=int64Map" json:"Int64Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Uint32Map         map[uint32]uint32         `protobuf:"bytes,5,rep,name=Uint32Map,json=uint32Map" json:"Uint32Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Uint64Map         map[uint64]uint64         `protobuf:"bytes,6,rep,name=Uint64Map,json=uint64Map" json:"Uint64Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Sint32Map         map[int32]int32           `protobuf:"bytes,7,rep,name=Sint32Map,json=sint32Map" json:"Sint32Map,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	Sint64Map         map[int64]int64           `protobuf:"bytes,8,rep,name=Sint64Map,json=sint64Map" json:"Sint64Map,omitempty" protobuf_key:"zigzag64,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	Fixed32Map        map[uint32]uint32         `protobuf:"bytes,9,rep,name=Fixed32Map,json=fixed32Map" json:"Fixed32Map,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Sfixed32Map       map[int32]int32           `protobuf:"bytes,10,rep,name=Sfixed32Map,json=sfixed32Map" json:"Sfixed32Map,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Fixed64Map        map[uint64]uint64         `protobuf:"bytes,11,rep,name=Fixed64Map,json=fixed64Map" json:"Fixed64Map,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	Sfixed64Map       map[int64]int64           `protobuf:"bytes,12,rep,name=Sfixed64Map,json=sfixed64Map" json:"Sfixed64Map,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	BoolMap           map[bool]bool             `protobuf:"bytes,13,rep,name=BoolMap,json=boolMap" json:"BoolMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	StringMap         map[string]string         `protobuf:"bytes,14,rep,name=StringMap,json=stringMap" json:"StringMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StringToBytesMap  map[string][]byte         `protobuf:"bytes,15,rep,name=StringToBytesMap,json=stringToBytesMap" json:"StringToBytesMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StringToEnumMap   map[string]MapEnum        `protobuf:"bytes,16,rep,name=StringToEnumMap,json=stringToEnumMap" json:"StringToEnumMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=theproto3.MapEnum"`
	StringToMsgMap    map[string]*FloatingPoint `protobuf:"bytes,17,rep,name=StringToMsgMap,json=stringToMsgMap" json:"StringToMsgMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AllMaps) Reset()                    { *m = AllMaps{} }
func (*AllMaps) ProtoMessage()               {}
func (*AllMaps) Descriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{2} }

type AllMapsOrdered struct {
	StringToDoubleMap map[string]float64        `protobuf:"bytes,1,rep,name=StringToDoubleMap,json=stringToDoubleMap" json:"StringToDoubleMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	StringToFloatMap  map[string]float32        `protobuf:"bytes,2,rep,name=StringToFloatMap,json=stringToFloatMap" json:"StringToFloatMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Int32Map          map[int32]int32           `protobuf:"bytes,3,rep,name=Int32Map,json=int32Map" json:"Int32Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Int64Map          map[int64]int64           `protobuf:"bytes,4,rep,name=Int64Map,json=int64Map" json:"Int64Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Uint32Map         map[uint32]uint32         `protobuf:"bytes,5,rep,name=Uint32Map,json=uint32Map" json:"Uint32Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Uint64Map         map[uint64]uint64         `protobuf:"bytes,6,rep,name=Uint64Map,json=uint64Map" json:"Uint64Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Sint32Map         map[int32]int32           `protobuf:"bytes,7,rep,name=Sint32Map,json=sint32Map" json:"Sint32Map,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	Sint64Map         map[int64]int64           `protobuf:"bytes,8,rep,name=Sint64Map,json=sint64Map" json:"Sint64Map,omitempty" protobuf_key:"zigzag64,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	Fixed32Map        map[uint32]uint32         `protobuf:"bytes,9,rep,name=Fixed32Map,json=fixed32Map" json:"Fixed32Map,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Sfixed32Map       map[int32]int32           `protobuf:"bytes,10,rep,name=Sfixed32Map,json=sfixed32Map" json:"Sfixed32Map,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Fixed64Map        map[uint64]uint64         `protobuf:"bytes,11,rep,name=Fixed64Map,json=fixed64Map" json:"Fixed64Map,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	Sfixed64Map       map[int64]int64           `protobuf:"bytes,12,rep,name=Sfixed64Map,json=sfixed64Map" json:"Sfixed64Map,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	BoolMap           map[bool]bool             `protobuf:"bytes,13,rep,name=BoolMap,json=boolMap" json:"BoolMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	StringMap         map[string]string         `protobuf:"bytes,14,rep,name=StringMap,json=stringMap" json:"StringMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StringToBytesMap  map[string][]byte         `protobuf:"bytes,15,rep,name=StringToBytesMap,json=stringToBytesMap" json:"StringToBytesMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StringToEnumMap   map[string]MapEnum        `protobuf:"bytes,16,rep,name=StringToEnumMap,json=stringToEnumMap" json:"StringToEnumMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=theproto3.MapEnum"`
	StringToMsgMap    map[string]*FloatingPoint `protobuf:"bytes,17,rep,name=StringToMsgMap,json=stringToMsgMap" json:"StringToMsgMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AllMapsOrdered) Reset()                    { *m = AllMapsOrdered{} }
func (*AllMapsOrdered) ProtoMessage()               {}
func (*AllMapsOrdered) Descriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{3} }

type MessageWithMap struct {
	NameMapping map[int32]string         `protobuf:"bytes,1,rep,name=name_mapping,json=nameMapping" json:"name_mapping,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MsgMapping  map[int64]*FloatingPoint `protobuf:"bytes,2,rep,name=msg_mapping,json=msgMapping" json:"msg_mapping,omitempty" protobuf_key:"zigzag64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	ByteMapping map[bool][]byte          `protobuf:"bytes,3,rep,name=byte_mapping,json=byteMapping" json:"byte_mapping,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MessageWithMap) Reset()                    { *m = MessageWithMap{} }
func (*MessageWithMap) ProtoMessage()               {}
func (*MessageWithMap) Descriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{4} }

type FloatingPoint struct {
	F float64 `protobuf:"fixed64,1,opt,name=f,proto3" json:"f,omitempty"`
}

func (m *FloatingPoint) Reset()                    { *m = FloatingPoint{} }
func (*FloatingPoint) ProtoMessage()               {}
func (*FloatingPoint) Descriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{5} }

type Uint128Pair struct {
	Left  github_com_gogo_protobuf_test_custom.Uint128  `protobuf:"bytes,1,opt,name=left,proto3,customtype=github.com/gogo/protobuf/test/custom.Uint128" json:"left"`
	Right *github_com_gogo_protobuf_test_custom.Uint128 `protobuf:"bytes,2,opt,name=right,proto3,customtype=github.com/gogo/protobuf/test/custom.Uint128" json:"right,omitempty"`
}

func (m *Uint128Pair) Reset()                    { *m = Uint128Pair{} }
func (*Uint128Pair) ProtoMessage()               {}
func (*Uint128Pair) Descriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{6} }

type ContainsNestedMap struct {
}

func (m *ContainsNestedMap) Reset()                    { *m = ContainsNestedMap{} }
func (*ContainsNestedMap) ProtoMessage()               {}
func (*ContainsNestedMap) Descriptor() ([]byte, []int) { return fileDescriptorTheproto3, []int{7} }

type ContainsNestedMap_NestedMap struct {
	NestedMapField map[string]float64 `protobuf:"bytes,1,rep,name=NestedMapField,json=nestedMapField" json:"NestedMapField,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
}

func (m *ContainsNestedMap_NestedMap) Reset()      { *m = ContainsNestedMap_NestedMap{} }
func (*ContainsNestedMap_NestedMap) ProtoMessage() {}
func (*ContainsNestedMap_NestedMap) Descriptor() ([]byte, []int) {
	return fileDescriptorTheproto3, []int{7, 0}
}

func init() {
	proto.RegisterType((*Message)(nil), "theproto3.Message")
	proto.RegisterType((*Nested)(nil), "theproto3.Nested")
	proto.RegisterType((*AllMaps)(nil), "theproto3.AllMaps")
	proto.RegisterType((*AllMapsOrdered)(nil), "theproto3.AllMapsOrdered")
	proto.RegisterType((*MessageWithMap)(nil), "theproto3.MessageWithMap")
	proto.RegisterType((*FloatingPoint)(nil), "theproto3.FloatingPoint")
	proto.RegisterType((*Uint128Pair)(nil), "theproto3.Uint128Pair")
	proto.RegisterType((*ContainsNestedMap)(nil), "theproto3.ContainsNestedMap")
	proto.RegisterType((*ContainsNestedMap_NestedMap)(nil), "theproto3.ContainsNestedMap.NestedMap")
	proto.RegisterEnum("theproto3.MapEnum", MapEnum_name, MapEnum_value)
	proto.RegisterEnum("theproto3.Message_Humour", Message_Humour_name, Message_Humour_value)
}
func (this *Message) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *Nested) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *AllMaps) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *AllMapsOrdered) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *MessageWithMap) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *FloatingPoint) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *Uint128Pair) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *ContainsNestedMap) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *ContainsNestedMap_NestedMap) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func Theproto3Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	d := &github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet{}
	var gzipped = []byte{
		// 7462 bytes of a gzipped FileDescriptorSet
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x7d, 0x7b, 0x6c, 0x63, 0xd7,
		0x79, 0xe7, 0x90, 0x97, 0x94, 0xa8, 0x8f, 0x14, 0x45, 0xdd, 0xd1, 0xc8, 0xb4, 0x3c, 0x9e, 0x07,
		0x3d, 0x1e, 0xcb, 0x8a, 0xad, 0xd1, 0x68, 0x34, 0x0f, 0xd3, 0xaf, 0x15, 0x29, 0x6a, 0xac, 0x89,
		0x5e, 0xb9, 0x92, 0xfc, 0x88, 0x17, 0x4b, 0x50, 0xe4, 0x95, 0x44, 0x9b, 0xba, 0xd4, 0xf2, 0x92,
		0xb6, 0x27, 0x7f, 0x2c, 0xb2, 0xc9, 0x6e, 0x36, 0xd9, 0xc5, 0xee, 0xb6, 0x4d, 0x8b, 0xe6, 0x1d,
		0x3b, 0x45, 0x1a, 0x27, 0x7d, 0x25, 0x69, 0x1a, 0x14, 0x41, 0xd1, 0xb8, 0x28, 0x92, 0x4e, 0xfb,
		0x47, 0xe1, 0xa6, 0xff, 0x14, 0x45, 0x61, 0xe4, 0x05, 0x34, 0x6d, 0xd3, 0x36, 0x01, 0x0c, 0x24,
		0x40, 0xf2, 0x47, 0xcf, 0xfb, 0x9e, 0x73, 0x78, 0x2f, 0x2f, 0x35, 0x63, 0xc7, 0xf9, 0xc3, 0x06,
		0x38, 0x22, 0xcf, 0xf9, 0x7e, 0xdf, 0xf9, 0xce, 0xf7, 0x3a, 0xdf, 0x3d, 0xe7, 0xde, 0x6b, 0xf8,
		0xf3, 0xf3, 0x70, 0x6a, 0xb7, 0xd9, 0xdc, 0x6d, 0xd8, 0xe7, 0x0e, 0x5a, 0xcd, 0x76, 0x73, 0xbb,
		0xb3, 0x73, 0xae, 0x66, 0xbb, 0xd5, 0x56, 0xfd, 0xa0, 0xdd, 0x6c, 0x4d, 0x93, 0x36, 0x73, 0x84,
		0x52, 0x4c, 0x73, 0x8a, 0xdc, 0x0a, 0x8c, 0x2e, 0xd6, 0x1b, 0xf6, 0x82, 0x20, 0xdc, 0xb0, 0xdb,
		0xe6, 0x15, 0x88, 0xed, 0xa0, 0xc6, 0x6c, 0xe4, 0x94, 0x31, 0x99, 0x9c, 0x3d, 0x33, 0xad, 0x81,
		0xa6, 0x55, 0xc4, 0x3a, 0x6e, 0xb6, 0x08, 0x22, 0xf7, 0xfd, 0x18, 0x1c, 0xf5, 0xe9, 0x35, 0x4d,
		0x88, 0x39, 0x95, 0x7d, 0xcc, 0x31, 0x32, 0x39, 0x64, 0x91, 0xef, 0x66, 0x16, 0x06, 0x0f, 0x2a,
		0xd5, 0x67, 0x2b, 0xbb, 0x76, 0x36, 0x4a, 0x9a, 0xf9, 0x4f, 0xf3, 0x04, 0x40, 0xcd, 0x3e, 0xb0,
		0x9d, 0x9a, 0xed, 0x54, 0xaf, 0x67, 0x0d, 0x24, 0xc5, 0x90, 0x25, 0xb5, 0x98, 0xef, 0x80, 0xd1,
		0x83, 0xce, 0x76, 0xa3, 0x5e, 0x2d, 0x4b, 0x64, 0x80, 0xc8, 0xe2, 0x56, 0x86, 0x76, 0x2c, 0x78,
		0xc4, 0xf7, 0xc0, 0xc8, 0xf3, 0x76, 0xe5, 0x59, 0x99, 0x34, 0x49, 0x48, 0xd3, 0xb8, 0x59, 0x22,
		0x2c, 0x42, 0x6a, 0xdf, 0x76, 0x5d, 0x24, 0x40, 0xb9, 0x7d, 0xfd, 0xc0, 0xce, 0xc6, 0xc8, 0xec,
		0x4f, 0x75, 0xcd, 0x5e, 0x9f, 0x79, 0x92, 0xa1, 0x36, 0x11, 0xc8, 0x9c, 0x87, 0x21, 0xdb, 0xe9,
		0xec, 0x53, 0x0e, 0xf1, 0x00, 0xfd, 0x95, 0x10, 0x85, 0xce, 0x25, 0x81, 0x61, 0x8c, 0xc5, 0xa0,
		0x6b, 0xb7, 0x9e, 0xab, 0x57, 0xed, 0xec, 0x00, 0x61, 0x70, 0x4f, 0x17, 0x83, 0x0d, 0xda, 0xaf,
		0xf3, 0xe0, 0x38, 0x34, 0x95, 0x21, 0xfb, 0x85, 0xb6, 0xed, 0xb8, 0xf5, 0xa6, 0x93, 0x1d, 0x24,
		0x4c, 0xee, 0xf6, 0xb1, 0xa2, 0xdd, 0xa8, 0xe9, 0x2c, 0x3c, 0x9c, 0x79, 0x09, 0x06, 0x9b, 0x07,
		0x6d, 0xf4, 0xcd, 0xcd, 0x26, 0x90, 0x7d, 0x92, 0xb3, 0xc7, 0x7d, 0x1d, 0x61, 0x8d, 0xd2, 0x58,
		0x9c, 0xd8, 0x5c, 0x82, 0x8c, 0xdb, 0xec, 0xb4, 0xaa, 0x76, 0xb9, 0xda, 0xac, 0xd9, 0xe5, 0xba,
		0xb3, 0xd3, 0xcc, 0x0e, 0x11, 0x06, 0x27, 0xbb, 0x27, 0x42, 0x08, 0x8b, 0x88, 0x6e, 0x09, 0x91,
		0x59, 0x69, 0x57, 0xf9, 0x6d, 0x8e, 0xc3, 0x80, 0x7b, 0xdd, 0x69, 0x57, 0x5e, 0xc8, 0xa6, 0x88,
		0x87, 0xb0, 0x5f, 0xb9, 0x9f, 0xc4, 0x61, 0xa4, 0x1f, 0x17, 0x7b, 0x10, 0xe2, 0x3b, 0x78, 0x96,
		0xc8, 0xc1, 0x0e, 0xa1, 0x03, 0x8a, 0x51, 0x95, 0x38, 0x70, 0x93, 0x4a, 0x9c, 0x87, 0xa4, 0x63,
		0xbb, 0x6d, 0xbb, 0x46, 0x3d, 0xc2, 0xe8, 0xd3, 0xa7, 0x80, 0x82, 0xba, 0x5d, 0x2a, 0x76, 0x53,
		0x2e, 0xf5, 0x24, 0x8c, 0x08, 0x91, 0xca, 0xad, 0x8a, 0xb3, 0xcb, 0x7d, 0xf3, 0x5c, 0x98, 0x24,
		0xd3, 0x25, 0x8e, 0xb3, 0x30, 0xcc, 0x4a, 0xdb, 0xca, 0x6f, 0x73, 0x01, 0xa0, 0xe9, 0xd8, 0xcd,
		0x1d, 0x14, 0x5e, 0xd5, 0x06, 0xf2, 0x13, 0x7f, 0x2d, 0xad, 0x61, 0x92, 0x2e, 0x2d, 0x35, 0x69,
		0x6b, 0xb5, 0x61, 0x3e, 0xe0, 0xb9, 0xda, 0x60, 0x80, 0xa7, 0xac, 0xd0, 0x20, 0xeb, 0xf2, 0xb6,
		0x2d, 0x48, 0xb7, 0x6c, 0xec, 0xf7, 0x48, 0xc5, 0x74, 0x66, 0x43, 0x44, 0x88, 0xe9, 0xd0, 0x99,
		0x59, 0x0c, 0x46, 0x27, 0x36, 0xdc, 0x92, 0x7f, 0x9a, 0x77, 0x81, 0x68, 0x28, 0x13, 0xb7, 0x02,
		0x92, 0x85, 0x52, 0xbc, 0x71, 0x15, 0xb5, 0x4d, 0x5c, 0x81, 0xb4, 0xaa, 0x1e, 0x73, 0x0c, 0xe2,
		0x6e, 0xbb, 0xd2, 0x6a, 0x13, 0x2f, 0x8c, 0x5b, 0xf4, 0x87, 0x99, 0x01, 0x03, 0x25, 0x19, 0x92,
		0xe5, 0xe2, 0x16, 0xfe, 0x3a, 0x71, 0x19, 0x86, 0x95, 0xe1, 0xfb, 0x05, 0xe6, 0x3e, 0x32, 0x00,
		0x63, 0x7e, 0x3e, 0xe7, 0xeb, 0xfe, 0x28, 0x7c, 0x90, 0x07, 0x6c, 0xdb, 0x2d, 0xe4, 0x77, 0x98,
		0x03, 0xfb, 0x85, 0x3c, 0x2a, 0xde, 0xa8, 0x6c, 0xdb, 0x0d, 0xe4, 0x4d, 0x91, 0xc9, 0xf4, 0xec,
		0x3b, 0xfa, 0xf2, 0xea, 0xe9, 0x65, 0x0c, 0xb1, 0x28, 0xd2, 0x7c, 0x04, 0x62, 0x2c, 0xc5, 0x61,
		0x0e, 0x53, 0xfd, 0x71, 0xc0, 0xbe, 0x68, 0x11, 0x9c, 0x79, 0x07, 0x0c, 0xe1, 0xbf, 0x54, 0xb7,
		0x03, 0x44, 0xe6, 0x04, 0x6e, 0xc0, 0x7a, 0x35, 0x27, 0x20, 0x41, 0xdc, 0xac, 0x66, 0xf3, 0xa5,
		0x41, 0xfc, 0xc6, 0x86, 0xa9, 0xd9, 0x3b, 0x95, 0x4e, 0xa3, 0x5d, 0x7e, 0xae, 0xd2, 0xe8, 0xd8,
		0xc4, 0x61, 0x90, 0x61, 0x58, 0xe3, 0xe3, 0xb8, 0xcd, 0x3c, 0x09, 0x49, 0xea, 0x95, 0x75, 0x84,
		0x79, 0x81, 0x64, 0x9f, 0xb8, 0x45, 0x1d, 0x75, 0x09, 0xb7, 0xe0, 0xe1, 0x9f, 0x71, 0x51, 0x2c,
		0x30, 0xd3, 0x92, 0x21, 0x70, 0x03, 0x19, 0xfe, 0xb2, 0x9e, 0xf8, 0xee, 0xf4, 0x9f, 0x9e, 0xee,
		0x8b, 0xb9, 0xaf, 0x46, 0x21, 0x46, 0xe2, 0x6d, 0x04, 0x92, 0x9b, 0x4f, 0xad, 0x97, 0xca, 0x0b,
		0x6b, 0x5b, 0x85, 0xe5, 0x52, 0x26, 0x62, 0xa6, 0x01, 0x48, 0xc3, 0xe2, 0xf2, 0xda, 0xfc, 0x66,
		0x26, 0x2a, 0x7e, 0x2f, 0xad, 0x6e, 0x5e, 0x9a, 0xcb, 0x18, 0x02, 0xb0, 0x45, 0x1b, 0x62, 0x32,
		0xc1, 0x85, 0xd9, 0x4c, 0x1c, 0x79, 0x42, 0x8a, 0x32, 0x58, 0x7a, 0xb2, 0xb4, 0x80, 0x28, 0x06,
		0xd4, 0x16, 0x44, 0x33, 0x68, 0x0e, 0xc3, 0x10, 0x69, 0x29, 0xac, 0xad, 0x2d, 0x67, 0x12, 0x82,
		0xe7, 0xc6, 0xa6, 0xb5, 0xb4, 0x7a, 0x35, 0x33, 0x24, 0x78, 0x5e, 0xb5, 0xd6, 0xb6, 0xd6, 0x33,
		0x20, 0x38, 0xac, 0x94, 0x36, 0x36, 0xe6, 0xaf, 0x96, 0x32, 0x49, 0x41, 0x51, 0x78, 0x6a, 0xb3,
		0xb4, 0x91, 0x49, 0x29, 0x62, 0xa1, 0x21, 0x86, 0xc5, 0x10, 0xa5, 0xd5, 0xad, 0x95, 0x4c, 0xda,
		0x1c, 0x85, 0x61, 0x3a, 0x04, 0x17, 0x62, 0x44, 0x6b, 0x42, 0x92, 0x66, 0x3c, 0x41, 0x28, 0x97,
		0x51, 0xa5, 0x01, 0x51, 0x98, 0xb9, 0x22, 0xc4, 0x89, 0x77, 0x21, 0x2f, 0x4e, 0x2f, 0xcf, 0x17,
		0x4a, 0xcb, 0xe5, 0xb5, 0xf5, 0xcd, 0xa5, 0xb5, 0xd5, 0xf9, 0x65, 0xa4, 0x3b, 0xd1, 0x66, 0x95,
		0xde, 0xb5, 0xb5, 0x64, 0x95, 0x16, 0x90, 0xfe, 0xa4, 0xb6, 0xf5, 0xd2, 0xfc, 0x26, 0x6a, 0x33,
		0x72, 0x53, 0x30, 0xe6, 0x97, 0x67, 0xfc, 0x22, 0x23, 0xf7, 0x99, 0x08, 0x1c, 0xf5, 0x49, 0x99,
		0xbe, 0x51, 0xf4, 0x28, 0xc4, 0xa9, 0xa7, 0xd1, 0x45, 0xe4, 0x5e, 0xdf, 0xdc, 0x4b, 0xfc, 0xae,
		0x6b, 0x21, 0x21, 0x38, 0x79, 0x21, 0x35, 0x02, 0x16, 0x52, 0xcc, 0xa2, 0xcb, 0x9d, 0xde, 0x1f,
		0x81, 0x6c, 0x10, 0xef, 0x90, 0x78, 0x8f, 0x2a, 0xf1, 0xfe, 0xa0, 0x2e, 0xc0, 0xe9, 0xe0, 0x39,
		0x74, 0x49, 0xf1, 0xb9, 0x08, 0x8c, 0xfb, 0xd7, 0x1b, 0xbe, 0x32, 0x3c, 0x02, 0x03, 0xfb, 0x76,
		0x7b, 0xaf, 0xc9, 0xd7, 0xdc, 0xb3, 0x3e, 0x99, 0x1c, 0x77, 0xeb, 0xba, 0x62, 0x28, 0x79, 0x29,
		0x30, 0x82, 0x8a, 0x06, 0x2a, 0x4d, 0x97, 0xa4, 0x1f, 0x8a, 0xc2, 0x31, 0x5f, 0xe6, 0xbe, 0x82,
		0xde, 0x09, 0x50, 0x77, 0x0e, 0x3a, 0x6d, 0xba, 0xae, 0xd2, 0x34, 0x33, 0x44, 0x5a, 0x48, 0x08,
		0xe3, 0x14, 0xd2, 0x69, 0x8b, 0x7e, 0x83, 0xf4, 0x03, 0x6d, 0x22, 0x04, 0x57, 0x3c, 0x41, 0x63,
		0x44, 0xd0, 0x13, 0x01, 0x33, 0xed, 0x5a, 0xb2, 0x66, 0x20, 0x53, 0x6d, 0xd4, 0x6d, 0xa7, 0x5d,
		0x76, 0xdb, 0x2d, 0xbb, 0xb2, 0x5f, 0x77, 0x76, 0x49, 0x1e, 0x4d, 0xe4, 0xe3, 0x3b, 0x95, 0x86,
		0x6b, 0x5b, 0x23, 0xb4, 0x7b, 0x83, 0xf7, 0x62, 0x04, 0x59, 0x2c, 0x5a, 0x12, 0x62, 0x40, 0x41,
		0xd0, 0x6e, 0x81, 0xc8, 0x7d, 0x6b, 0x10, 0x92, 0x52, 0x75, 0x66, 0x9e, 0x86, 0xd4, 0x33, 0x95,
		0xe7, 0x2a, 0x65, 0x5e, 0x71, 0x53, 0x4d, 0x24, 0x71, 0xdb, 0x3a, 0xab, 0xba, 0x67, 0x60, 0x8c,
		0x90, 0xa0, 0x39, 0xa2, 0x81, 0xaa, 0x8d, 0x8a, 0xeb, 0x12, 0xa5, 0x25, 0x08, 0xa9, 0x89, 0xfb,
		0xd6, 0x70, 0x57, 0x91, 0xf7, 0x98, 0x17, 0xe1, 0x28, 0x41, 0xec, 0xa3, 0xc4, 0x5b, 0x3f, 0x68,
		0xd8, 0x65, 0x7c, 0x0d, 0xe0, 0x92, 0x7c, 0x2a, 0x24, 0x1b, 0xc5, 0x14, 0x2b, 0x8c, 0x00, 0x4b,
		0xe4, 0x9a, 0x57, 0xe1, 0x4e, 0x02, 0xdb, 0xb5, 0x1d, 0xbb, 0x55, 0x69, 0xdb, 0x65, 0xfb, 0xbf,
		0x76, 0x10, 0x6d, 0xb9, 0xe2, 0xd4, 0xca, 0x7b, 0x15, 0x77, 0x2f, 0x3b, 0x26, 0x33, 0xb8, 0x1d,
		0xd3, 0x5e, 0x65, 0xa4, 0x25, 0x42, 0x39, 0xef, 0xd4, 0x1e, 0x43, 0x74, 0x66, 0x1e, 0xc6, 0x09,
		0x23, 0xa4, 0x14, 0x34, 0xe7, 0x72, 0x75, 0xcf, 0xae, 0x3e, 0x5b, 0xee, 0xb4, 0x77, 0xae, 0x64,
		0xef, 0x90, 0x39, 0x10, 0x21, 0x37, 0x08, 0x4d, 0x11, 0x93, 0x6c, 0x21, 0x0a, 0x73, 0x03, 0x52,
		0xd8, 0x1e, 0xfb, 0xf5, 0xf7, 0x20, 0xb1, 0x9b, 0x2d, 0xb2, 0x46, 0xa4, 0x7d, 0x82, 0x5b, 0x52,
		0xe2, 0xf4, 0x1a, 0x03, 0xac, 0xa0, 0xfa, 0x34, 0x1f, 0xdf, 0x58, 0x2f, 0x95, 0x16, 0xac, 0x24,
		0xe7, 0xb2, 0xd8, 0x6c, 0x61, 0x9f, 0xda, 0x6d, 0x0a, 0x1d, 0x27, 0xa9, 0x4f, 0xed, 0x36, 0xb9,
		0x86, 0x91, 0xbe, 0xaa, 0x55, 0x3a, 0x6d, 0x74, 0xed, 0xc2, 0x8a, 0x75, 0x37, 0x9b, 0x51, 0xf4,
		0x55, 0xad, 0x5e, 0xa5, 0x04, 0xcc, 0xcd, 0x5d, 0x14, 0x12, 0xc7, 0x3c, 0x7d, 0xc9, 0xc0, 0xd1,
		0xae, 0x59, 0xea, 0x50, 0x34, 0xe2, 0xc1, 0xf5, 0x6e, 0xa0, 0xa9, 0x8c, 0x78, 0x70, 0x5d, 0x87,
		0xdd, 0x4d, 0x2e, 0xc0, 0x5a, 0x76, 0x15, 0xa9, 0xbc, 0x96, 0xbd, 0x4d, 0xa6, 0x96, 0x3a, 0xcc,
		0x73, 0xc8, 0x91, 0xab, 0x65, 0xdb, 0xa9, 0x6c, 0x23, 0xdb, 0x57, 0x5a, 0xe8, 0x8b, 0x9b, 0x3d,
		0x29, 0x13, 0xa7, 0xab, 0xd5, 0x12, 0xe9, 0x9d, 0x27, 0x9d, 0xe6, 0x14, 0x8c, 0x36, 0xb7, 0x9f,
		0xa9, 0x52, 0xe7, 0x2a, 0x23, 0x3e, 0x3b, 0xf5, 0x17, 0xb2, 0x67, 0x88, 0x9a, 0x46, 0x70, 0x07,
		0x71, 0xad, 0x75, 0xd2, 0x6c, 0xde, 0x8b, 0x98, 0xbb, 0x7b, 0x95, 0xd6, 0x01, 0x59, 0xa4, 0x5d,
		0xa4, 0x54, 0x3b, 0x7b, 0x37, 0x25, 0xa5, 0xed, 0xab, 0xbc, 0xd9, 0x2c, 0xc1, 0x49, 0x3c, 0x79,
		0xa7, 0xe2, 0x34, 0xcb, 0x1d, 0xd7, 0x2e, 0x7b, 0x22, 0x0a, 0x5b, 0x9c, 0xc5, 0x62, 0x59, 0xc7,
		0x39, 0xd9, 0x96, 0x8b, 0x92, 0x19, 0x27, 0xe2, 0xe6, 0x79, 0x12, 0xc6, 0x3a, 0x4e, 0xdd, 0x41,
		0x2e, 0x8e, 0x7a, 0x30, 0x98, 0x06, 0x6c, 0xf6, 0x1f, 0x07, 0x03, 0x8a, 0xee, 0x2d, 0x99, 0x9a,
		0x3a, 0x89, 0x75, 0xb4, 0xd3, 0xdd, 0x98, 0xcb, 0x43, 0x4a, 0xf6, 0x1d, 0x73, 0x08, 0xa8, 0xf7,
		0xa0, 0xd5, 0x0d, 0xad, 0xa8, 0xc5, 0xb5, 0x05, 0xbc, 0x16, 0xbe, 0xbb, 0x84, 0x16, 0x36, 0xb4,
		0x26, 0x2f, 0x2f, 0x6d, 0x96, 0xca, 0xd6, 0xd6, 0xea, 0xe6, 0xd2, 0x4a, 0x29, 0x63, 0x4c, 0x0d,
		0x25, 0x7e, 0x30, 0x98, 0x79, 0x2f, 0xfa, 0x2f, 0x9a, 0xfb, 0x46, 0x14, 0xd2, 0x6a, 0x1d, 0x6c,
		0x3e, 0x04, 0xb7, 0xf1, 0x8b, 0x56, 0xd7, 0x6e, 0x97, 0x9f, 0xaf, 0xb7, 0x88, 0x3b, 0xef, 0x57,
		0x68, 0x25, 0x29, 0x2c, 0x31, 0xc6, 0xa8, 0xd0, 0xe5, 0xfd, 0x13, 0x88, 0x66, 0x91, 0x90, 0x98,
		0xcb, 0x70, 0x12, 0xa9, 0x0c, 0xd5, 0x9a, 0x4e, 0xad, 0xd2, 0xaa, 0x95, 0xbd, 0xed, 0x82, 0x72,
		0xa5, 0x8a, 0xfc, 0xc0, 0x6d, 0xd2, 0x95, 0x44, 0x70, 0x39, 0xee, 0x34, 0x37, 0x18, 0xb1, 0x97,
		0x62, 0xe7, 0x19, 0xa9, 0xe6, 0x35, 0x46, 0x90, 0xd7, 0xa0, 0xda, 0x6b, 0xbf, 0x72, 0x80, 0xdc,
		0xa6, 0xdd, 0xba, 0x4e, 0xaa, 0xb7, 0x84, 0x95, 0x40, 0x0d, 0x25, 0xfc, 0xfb, 0xcd, 0xb3, 0x81,
		0xac, 0xc7, 0x7f, 0x30, 0x20, 0x25, 0x57, 0x70, 0xb8, 0x20, 0xae, 0x92, 0x34, 0x1f, 0x21, 0x59,
		0xe0, 0xae, 0x9e, 0xf5, 0xde, 0x74, 0x11, 0xe7, 0xff, 0xfc, 0x00, 0xad, 0xab, 0x2c, 0x8a, 0xc4,
		0x6b, 0x2f, 0xf6, 0x35, 0x9b, 0x56, 0xeb, 0x09, 0x8b, 0xfd, 0x42, 0xc9, 0x6e, 0xe0, 0x19, 0x97,
		0xf0, 0x1e, 0x20, 0xbc, 0xcf, 0xf4, 0xe6, 0x7d, 0x6d, 0x83, 0x30, 0x1f, 0xba, 0xb6, 0x51, 0x5e,
		0x5d, 0xb3, 0x56, 0xe6, 0x97, 0x2d, 0x06, 0x37, 0x6f, 0x87, 0x58, 0xa3, 0xf2, 0x9e, 0xeb, 0xea,
		0x4a, 0x41, 0x9a, 0xfa, 0x55, 0x3c, 0xe2, 0x80, 0xb7, 0x3c, 0xd4, 0xfc, 0x4c, 0x9a, 0xde, 0x44,
		0xd7, 0x3f, 0x07, 0x71, 0xa2, 0x2f, 0x13, 0x80, 0x69, 0x2c, 0x73, 0xc4, 0x4c, 0x40, 0xac, 0xb8,
		0x66, 0x61, 0xf7, 0x47, 0xfe, 0x4e, 0x5b, 0xcb, 0xeb, 0x4b, 0xa5, 0x22, 0x8a, 0x80, 0xdc, 0x45,
		0x18, 0xa0, 0x4a, 0xc0, 0xa1, 0x21, 0xd4, 0x80, 0x40, 0xf4, 0x27, 0xe3, 0x11, 0xe1, 0xbd, 0x5b,
		0x2b, 0x85, 0x92, 0x95, 0x89, 0xca, 0xe6, 0xfd, 0x5a, 0x04, 0x92, 0x52, 0x41, 0x85, 0x97, 0xf2,
		0x4a, 0xa3, 0xd1, 0x7c, 0xbe, 0x5c, 0x69, 0xd4, 0x51, 0x86, 0xa2, 0xf6, 0x01, 0xd2, 0x34, 0x8f,
		0x5b, 0xfa, 0xd5, 0xdf, 0x2f, 0xc4, 0x37, 0x3f, 0x15, 0x81, 0x8c, 0x5e, 0x8c, 0x69, 0x02, 0x46,
		0xde, 0x52, 0x01, 0x3f, 0x11, 0x81, 0xb4, 0x5a, 0x81, 0x69, 0xe2, 0x9d, 0x7e, 0x4b, 0xc5, 0xfb,
		0x78, 0x04, 0x86, 0x95, 0xba, 0xeb, 0x97, 0x4a, 0xba, 0x8f, 0x19, 0x70, 0xd4, 0x07, 0x87, 0x12,
		0x10, 0x2d, 0x50, 0x69, 0xcd, 0x7c, 0x7f, 0x3f, 0x63, 0x4d, 0xe3, 0xf5, 0x6f, 0xbd, 0xd2, 0x6a,
		0xb3, 0x7a, 0x16, 0xad, 0x97, 0xf5, 0x1a, 0x4a, 0xaa, 0xf5, 0x9d, 0x3a, 0x2a, 0xdf, 0xe8, 0x15,
		0x0b, 0xad, 0x5a, 0x47, 0xbc, 0x76, 0x7a, 0x79, 0x7c, 0x1f, 0x98, 0x07, 0x4d, 0xb7, 0xde, 0xae,
		0x3f, 0x87, 0xb7, 0xe7, 0xf8, 0x85, 0x34, 0xae, 0x62, 0x63, 0x56, 0x86, 0xf7, 0x2c, 0x39, 0x6d,
		0x41, 0xed, 0xd8, 0xbb, 0x15, 0x8d, 0x1a, 0xa7, 0x21, 0xc3, 0xca, 0xf0, 0x1e, 0x41, 0x8d, 0x0a,
		0xcd, 0x5a, 0xb3, 0x83, 0x0b, 0x02, 0x4a, 0x87, 0xb3, 0x5e, 0xc4, 0x4a, 0xd2, 0x36, 0x41, 0xc2,
		0x2a, 0x36, 0xef, 0x0a, 0x3e, 0x65, 0x25, 0x69, 0x1b, 0x25, 0xb9, 0x07, 0x46, 0x2a, 0xbb, 0xbb,
		0x2d, 0xcc, 0x9c, 0x33, 0xa2, 0x65, 0x68, 0x5a, 0x34, 0x13, 0xc2, 0x89, 0x6b, 0x90, 0xe0, 0x7a,
		0xc0, 0x0b, 0x0b, 0xd6, 0x04, 0x5a, 0xf3, 0xc9, 0x3e, 0x4a, 0x14, 0x5f, 0xd4, 0x3b, 0xbc, 0x13,
		0x0d, 0x5a, 0x77, 0xcb, 0xde, 0x86, 0x5e, 0x14, 0xf5, 0x27, 0xac, 0x64, 0xdd, 0x15, 0x3b, 0x38,
		0xb9, 0xcf, 0xa1, 0xe5, 0x55, 0xdd, 0x90, 0x34, 0x17, 0x20, 0xd1, 0x68, 0x22, 0xff, 0xc0, 0x08,
		0xba, 0x1b, 0x3e, 0x19, 0xb2, 0x87, 0x39, 0xbd, 0xcc, 0xe8, 0x2d, 0x81, 0x9c, 0xf8, 0xeb, 0x08,
		0x24, 0x78, 0x33, 0x5a, 0x28, 0x62, 0x07, 0x95, 0xf6, 0x1e, 0x61, 0x17, 0x2f, 0x44, 0x33, 0x11,
		0x8b, 0xfc, 0xc6, 0xed, 0xa8, 0x9a, 0x71, 0x88, 0x0b, 0xb0, 0x76, 0xfc, 0x1b, 0xdb, 0xb5, 0x61,
		0x57, 0x6a, 0xa4, 0xc0, 0x6d, 0xee, 0xef, 0x23, 0x4b, 0xba, 0xdc, 0xae, 0xac, 0xbd, 0xc8, 0x9a,
		0xf1, 0xbe, 0x78, 0xbb, 0x55, 0xa9, 0x37, 0x14, 0xda, 0x18, 0xa1, 0xcd, 0xf0, 0x0e, 0x41, 0x9c,
		0x87, 0xdb, 0x39, 0xdf, 0x9a, 0xdd, 0xae, 0xa0, 0xe2, 0xb9, 0xe6, 0x81, 0x06, 0xc8, 0x6e, 0xd7,
		0x6d, 0x8c, 0x60, 0x81, 0xf5, 0x73, 0x6c, 0xe1, 0x49, 0x54, 0xc8, 0x36, 0xf7, 0x75, 0x4d, 0x14,
		0x32, 0xda, 0x75, 0x97, 0xfb, 0x58, 0xe4, 0xdd, 0xe0, 0x15, 0x15, 0x9f, 0x89, 0x1a, 0x57, 0xd7,
		0x0b, 0x5f, 0x88, 0x4e, 0x5c, 0xa5, 0xb8, 0x75, 0xae, 0x41, 0xcb, 0xde, 0x69, 0xd8, 0x55, 0xac,
		0x1d, 0x78, 0xe9, 0x2e, 0xb8, 0x7f, 0xb7, 0xde, 0xde, 0xeb, 0x6c, 0x4f, 0xa3, 0x11, 0xce, 0xed,
		0x36, 0x77, 0x9b, 0xde, 0x71, 0x06, 0xfe, 0x45, 0x7e, 0x90, 0x6f, 0xec, 0x48, 0x63, 0x48, 0xb4,
		0x4e, 0x84, 0x9e, 0x7f, 0xe4, 0x57, 0xe1, 0x28, 0x23, 0x2e, 0x93, 0x3d, 0x55, 0x5a, 0x82, 0x9a,
		0x3d, 0x2f, 0xc8, 0xb3, 0x5f, 0xfa, 0x3e, 0x59, 0x12, 0xac, 0x51, 0x06, 0xc5, 0x7d, 0xb4, 0x48,
		0xcd, 0x5b, 0x70, 0x4c, 0xe1, 0x47, 0x7d, 0x18, 0x5d, 0x72, 0xf7, 0xe6, 0xf8, 0x0d, 0xc6, 0xf1,
		0xa8, 0xc4, 0x71, 0x83, 0x41, 0xf3, 0x45, 0x18, 0x3e, 0x0c, 0xaf, 0x6f, 0x32, 0x5e, 0x29, 0x5b,
		0x66, 0x72, 0x15, 0x46, 0x08, 0x93, 0x6a, 0xc7, 0x6d, 0x37, 0xf7, 0x49, 0x82, 0xe8, 0xcd, 0xe6,
		0x2f, 0xbe, 0x4f, 0x9d, 0x2a, 0x8d, 0x61, 0x45, 0x81, 0xca, 0x3f, 0x0e, 0x63, 0xb8, 0x85, 0xc4,
		0xa0, 0xcc, 0x2d, 0x7c, 0x0b, 0x21, 0xfb, 0x37, 0xef, 0xa7, 0xbe, 0x77, 0x54, 0x30, 0x90, 0xf8,
		0x4a, 0x96, 0xd8, 0xb5, 0xdb, 0x28, 0xb7, 0xa1, 0xeb, 0xbf, 0x46, 0xc3, 0xec, 0x79, 0xc6, 0x90,
		0xfd, 0xe8, 0x0f, 0x55, 0x4b, 0x5c, 0xa5, 0xc8, 0xf9, 0x46, 0x23, 0xbf, 0x05, 0xb7, 0xf9, 0x58,
		0xb6, 0x0f, 0x9e, 0x1f, 0x63, 0x3c, 0xc7, 0xba, 0xac, 0x8b, 0xd9, 0xae, 0x03, 0x6f, 0x17, 0xf6,
		0xe8, 0x83, 0xe7, 0xc7, 0x19, 0x4f, 0x93, 0x61, 0xb9, 0x59, 0x30, 0xc7, 0x6b, 0x30, 0x8a, 0xae,
		0xd4, 0xb7, 0x9b, 0x2e, 0xbb, 0xee, 0xed, 0x83, 0xdd, 0x27, 0x18, 0xbb, 0x11, 0x06, 0x24, 0x57,
		0xc1, 0x98, 0xd7, 0x03, 0x90, 0xd8, 0x41, 0x17, 0x40, 0x7d, 0xb0, 0xf8, 0x24, 0x63, 0x31, 0x88,
		0xe9, 0x31, 0x74, 0x1e, 0x52, 0xbb, 0x4d, 0x96, 0x86, 0xc3, 0xe1, 0x9f, 0x62, 0xf0, 0x24, 0xc7,
		0x30, 0x16, 0x07, 0xcd, 0x83, 0x4e, 0x03, 0xe7, 0xe8, 0x70, 0x16, 0x9f, 0xe6, 0x2c, 0x38, 0x86,
		0xb1, 0x38, 0x84, 0x5a, 0x5f, 0xe4, 0x2c, 0x5c, 0x49, 0x9f, 0x8f, 0xe2, 0xbd, 0xde, 0xc6, 0xf5,
		0xa6, 0xd3, 0x8f, 0x10, 0x2f, 0x31, 0x0e, 0xc0, 0x20, 0x98, 0xc1, 0x83, 0x30, 0xd4, 0xaf, 0x21,
		0x3e, 0xcb, 0xe0, 0x09, 0x9b, 0x5b, 0x00, 0xc5, 0x19, 0x4f, 0x32, 0xf8, 0x6c, 0x25, 0x9c, 0xc5,
		0x6f, 0x33, 0x16, 0x69, 0x09, 0xc6, 0xa6, 0xd1, 0xb6, 0xdd, 0x36, 0xba, 0x54, 0xef, 0x83, 0xc9,
		0xe7, 0xf8, 0x34, 0x18, 0x84, 0xa9, 0x72, 0xdb, 0x76, 0xaa, 0x7b, 0xfd, 0x71, 0x78, 0x99, 0xab,
		0x92, 0x63, 0x30, 0x0b, 0x94, 0x79, 0xf6, 0x2b, 0x2d, 0x74, 0x71, 0xdd, 0xe8, 0xcb, 0x1c, 0x9f,
		0x67, 0x3c, 0x52, 0x02, 0xc4, 0x34, 0xd2, 0x71, 0x0e, 0xc3, 0xe6, 0x0b, 0x5c, 0x23, 0x12, 0x8c,
		0x85, 0x1e, 0xba, 0x32, 0xc5, 0x95, 0xc4, 0x61, 0xb8, 0xfd, 0x0e, 0x0f, 0x3d, 0x8a, 0x5d, 0x91,
		0x39, 0x22, 0x4b, 0xbb, 0xe8, 0x12, 0xbc, 0x1f, 0x36, 0xbf, 0xcb, 0x2d, 0x4d, 0x00, 0x18, 0xfc,
		0x14, 0xdc, 0xee, 0x9b, 0xea, 0xfb, 0x60, 0xf6, 0x7b, 0x8c, 0xd9, 0xb8, 0x4f, 0xba, 0x67, 0x29,
		0xe1, 0xb0, 0x2c, 0x7f, 0x9f, 0xa7, 0x04, 0x5b, 0xe3, 0xb5, 0x8e, 0xcb, 0x58, 0xb7, 0xb2, 0x73,
		0x38, 0xad, 0xfd, 0x01, 0xd7, 0x1a, 0xc5, 0x2a, 0x5a, 0xdb, 0x84, 0x71, 0xc6, 0xf1, 0x70, 0x76,
		0xfd, 0x22, 0x4f, 0xac, 0x14, 0xbd, 0xa5, 0x5a, 0xf7, 0x69, 0x98, 0x10, 0xea, 0xe4, 0x15, 0x98,
		0x5b, 0xc6, 0x1b, 0x03, 0xe1, 0x9c, 0xbf, 0xc4, 0x38, 0xf3, 0x8c, 0x2f, 0x4a, 0x38, 0x77, 0xa5,
		0x72, 0x80, 0x99, 0x3f, 0x09, 0x59, 0xce, 0xbc, 0xe3, 0xa0, 0x02, 0xbf, 0xb9, 0xeb, 0x20, 0x33,
		0xd6, 0xfa, 0x60, 0xfd, 0x65, 0xcd, 0x54, 0x5b, 0x12, 0x1c, 0x73, 0x5e, 0x82, 0x8c, 0xa8, 0x37,
		0xca, 0xf5, 0xfd, 0x83, 0x26, 0x2a, 0x2d, 0x7b, 0x73, 0xfc, 0x43, 0x6e, 0x29, 0x81, 0x5b, 0x22,
		0xb0, 0x7c, 0x09, 0xd2, 0xe4, 0x67, 0xbf, 0x2e, 0xf9, 0x15, 0xc6, 0x68, 0xd8, 0x43, 0xb1, 0xc4,
		0x81, 0x2a, 0x25, 0x54, 0xf3, 0xf6, 0x93, 0xff, 0xfe, 0x88, 0x27, 0x0e, 0x06, 0xa1, 0xde, 0x37,
		0xa2, 0xad, 0xc4, 0x66, 0xd8, 0xf1, 0x6b, 0xf6, 0xbf, 0xbf, 0xce, 0x62, 0x56, 0x5d, 0x88, 0xf3,
		0xcb, 0x58, 0x3d, 0xea, 0x72, 0x19, 0xce, 0xec, 0xfd, 0xaf, 0x0b, 0x0d, 0x29, 0xab, 0x65, 0x7e,
		0x11, 0x86, 0x95, 0xa5, 0x32, 0x9c, 0xd5, 0xff, 0x60, 0xac, 0x52, 0xf2, 0x4a, 0x99, 0xbf, 0x08,
		0x31, 0xbc, 0xec, 0x85, 0xc3, 0xff, 0x27, 0x83, 0x13, 0xf2, 0xfc, 0xc3, 0x90, 0xe0, 0xcb, 0x5d,
		0x38, 0xf4, 0x03, 0x0c, 0x2a, 0x20, 0x18, 0xce, 0x97, 0xba, 0x70, 0xf8, 0xff, 0xe2, 0x70, 0x0e,
		0xc1, 0xf0, 0xfe, 0x55, 0xf8, 0xca, 0xff, 0x89, 0xb1, 0x74, 0xc5, 0x75, 0x87, 0xcf, 0x7c, 0xe8,
		0x1a, 0x17, 0x8e, 0xfe, 0x10, 0x1b, 0x9c, 0x23, 0xf2, 0x97, 0x21, 0xde, 0xa7, 0xc2, 0xff, 0x2f,
		0x83, 0x52, 0x7a, 0xb4, 0x82, 0x24, 0xa5, 0x75, 0x2d, 0x1c, 0xfe, 0xff, 0x18, 0x5c, 0x46, 0x61,
		0xd1, 0xd9, 0xba, 0x16, 0xce, 0xe0, 0xff, 0x73, 0xd1, 0x19, 0x02, 0xab, 0x8d, 0x2f, 0x69, 0xe1,
		0xe8, 0x5f, 0xe1, 0x5a, 0xe7, 0x10, 0x14, 0x4d, 0x43, 0x22, 0x4d, 0x85, 0xe3, 0x7f, 0x95, 0xe1,
		0x3d, 0x0c, 0xd6, 0x80, 0x94, 0x26, 0xc3, 0x59, 0xfc, 0x1a, 0xd7, 0x80, 0x84, 0xc2, 0x61, 0xa4,
		0x2f, 0x7d, 0xe1, 0x9c, 0x3e, 0xcc, 0xc3, 0x48, 0x5b, 0xf9, 0xb0, 0x35, 0x49, 0xb6, 0x08, 0x67,
		0xf1, 0xeb, 0xdc, 0x9a, 0x84, 0x1e, 0x8b, 0xa1, 0xaf, 0x25, 0xe1, 0x3c, 0x7e, 0x93, 0x8b, 0xa1,
		0x2d, 0x25, 0x68, 0x65, 0x32, 0xbb, 0xd7, 0x91, 0x70, 0x7e, 0x1f, 0x61, 0xfc, 0x46, 0xbb, 0x96,
		0x91, 0xfc, 0x13, 0x30, 0xee, 0xbf, 0x86, 0x84, 0x73, 0xfd, 0xe8, 0xeb, 0x5a, 0xd5, 0x2f, 0x2f,
		0x21, 0x68, 0xc9, 0x1b, 0xf3, 0x5b, 0x3f, 0xc2, 0xd9, 0x7e, 0xec, 0x75, 0xf5, 0xc2, 0x4e, 0x5e,
		0x3e, 0x50, 0x85, 0x06, 0x5e, 0xea, 0x0e, 0xe7, 0xf5, 0x09, 0xc6, 0x4b, 0x02, 0xe1, 0xd0, 0x60,
		0x99, 0x3b, 0x1c, 0xff, 0x49, 0x1e, 0x1a, 0x0c, 0x81, 0xc0, 0x09, 0xa7, 0xd3, 0x68, 0x60, 0xe7,
		0x30, 0x7b, 0xdf, 0xd2, 0x90, 0xfd, 0xa7, 0x9f, 0xb1, 0xc0, 0xe0, 0x00, 0x94, 0x43, 0xe3, 0xf6,
		0xfe, 0x36, 0xd2, 0x41, 0x08, 0xf2, 0x9f, 0x7f, 0xc6, 0x13, 0x02, 0xa6, 0x46, 0xf1, 0x04, 0xf4,
		0xa2, 0x91, 0xec, 0x61, 0x87, 0x60, 0xff, 0xe5, 0x67, 0xec, 0x98, 0xd5, 0x83, 0x78, 0x0c, 0xe8,
		0xa1, 0x6d, 0x6f, 0x06, 0x3f, 0x54, 0x19, 0x90, 0x0b, 0xcd, 0x07, 0x60, 0x10, 0xdf, 0xd9, 0xd1,
		0xae, 0xec, 0x86, 0xa1, 0xff, 0x95, 0xa1, 0x39, 0x3d, 0x56, 0xd8, 0x7e, 0xb3, 0x65, 0xa3, 0xaf,
		0x6e, 0x18, 0xf6, 0xdf, 0x18, 0x56, 0x00, 0x30, 0xb8, 0x5a, 0x71, 0xdb, 0xfd, 0xcc, 0xfb, 0xdf,
		0x39, 0x98, 0x03, 0xb0, 0xd0, 0xf8, 0xfb, 0xb3, 0xf6, 0xf5, 0x30, 0xec, 0x8f, 0xb8, 0xd0, 0x8c,
		0x1e, 0x25, 0xc0, 0x21, 0xfc, 0x95, 0xde, 0x7a, 0x10, 0x02, 0xfe, 0x31, 0x03, 0x7b, 0x88, 0xc2,
		0x69, 0xff, 0xad, 0x1d, 0xb8, 0xda, 0xbc, 0xda, 0xa4, 0x9b, 0x3a, 0xf0, 0xcd, 0x3a, 0x5c, 0x0e,
		0xdc, 0xa3, 0xc1, 0x79, 0xf8, 0x1c, 0x6a, 0x46, 0xab, 0xef, 0xb9, 0xed, 0x66, 0x7b, 0xef, 0x5c,
		0x7b, 0xcf, 0xc6, 0x6d, 0x6c, 0xb7, 0x26, 0x86, 0xbf, 0x4f, 0x1c, 0x6e, 0x8b, 0x87, 0x9c, 0xd7,
		0xac, 0xd6, 0xb1, 0xd4, 0xab, 0x64, 0xb3, 0xd1, 0x3c, 0x0e, 0x03, 0x64, 0x1e, 0xe7, 0xc9, 0x5e,
		0x78, 0xa4, 0x10, 0xbb, 0xf1, 0xda, 0xc9, 0x23, 0xd6, 0x00, 0xb9, 0x6f, 0xef, 0xbc, 0xe8, 0x9d,
		0x25, 0x5b, 0xfd, 0x51, 0xa5, 0x77, 0x56, 0xf4, 0x5e, 0xa0, 0x37, 0x45, 0x29, 0xbd, 0x17, 0x44,
		0xef, 0x1c, 0xd9, 0x37, 0x33, 0x94, 0xde, 0x39, 0xd1, 0x7b, 0x91, 0x6c, 0x7f, 0x0e, 0x2b, 0xbd,
		0x17, 0x45, 0xef, 0x25, 0xb2, 0xe9, 0x19, 0x53, 0x7a, 0x2f, 0x89, 0xde, 0xcb, 0x64, 0xbf, 0x73,
		0x54, 0xe9, 0xbd, 0x2c, 0x7a, 0xaf, 0x90, 0x7d, 0x4e, 0x53, 0xe9, 0xbd, 0x22, 0x7a, 0x1f, 0x20,
		0xc7, 0xd4, 0x83, 0x4a, 0xef, 0x03, 0xe6, 0x09, 0x18, 0xa4, 0xda, 0x98, 0x21, 0x47, 0x3b, 0x23,
		0xac, 0x7b, 0x90, 0xaa, 0x63, 0xc6, 0xeb, 0x3f, 0x4f, 0x8e, 0xa4, 0x07, 0xd4, 0xfe, 0xf3, 0x5e,
		0xff, 0x2c, 0xb9, 0xcd, 0x32, 0xa3, 0xf6, 0xcf, 0x7a, 0xfd, 0x17, 0xb2, 0xc3, 0x38, 0xb6, 0xd5,
		0xfe, 0x0b, 0x5e, 0xff, 0x5c, 0x36, 0x8d, 0xdd, 0x49, 0xed, 0x9f, 0xf3, 0xfa, 0x2f, 0x66, 0x47,
		0xf0, 0x56, 0xaf, 0xda, 0x7f, 0x31, 0xf7, 0x3e, 0x62, 0x5e, 0xc7, 0x33, 0xef, 0xb8, 0x6a, 0x5e,
		0x61, 0xd8, 0x71, 0xd5, 0xb0, 0xc2, 0xa4, 0xe3, 0xaa, 0x49, 0x85, 0x31, 0xc7, 0x55, 0x63, 0x0a,
		0x33, 0x8e, 0xab, 0x66, 0x14, 0x06, 0x1c, 0x57, 0x0d, 0x28, 0x4c, 0x37, 0xae, 0x9a, 0x4e, 0x18,
		0x6d, 0x5c, 0x35, 0x9a, 0x30, 0xd7, 0xb8, 0x6a, 0x2e, 0x61, 0xa8, 0xac, 0x66, 0x28, 0xcf, 0x44,
		0x59, 0xcd, 0x44, 0x9e, 0x71, 0xb2, 0x9a, 0x71, 0x3c, 0xb3, 0x64, 0x35, 0xb3, 0x78, 0x06, 0xc9,
		0x6a, 0x06, 0xf1, 0x4c, 0x91, 0xd5, 0x4c, 0xe1, 0x19, 0x81, 0xc5, 0x98, 0x65, 0x1f, 0xf8, 0xc4,
		0x98, 0xd1, 0x33, 0xc6, 0x8c, 0x9e, 0x31, 0x66, 0xf4, 0x8c, 0x31, 0xa3, 0x67, 0x8c, 0x19, 0x3d,
		0x63, 0xcc, 0xe8, 0x19, 0x63, 0x46, 0xcf, 0x18, 0x33, 0x7a, 0xc6, 0x98, 0xd1, 0x3b, 0xc6, 0x8c,
		0x90, 0x18, 0x33, 0x42, 0x62, 0xcc, 0x08, 0x89, 0x31, 0x23, 0x24, 0xc6, 0x8c, 0x90, 0x18, 0x33,
		0x02, 0x63, 0xcc, 0x33, 0xef, 0xb8, 0x6a, 0x5e, 0xdf, 0x18, 0x33, 0x02, 0x62, 0xcc, 0x08, 0x88,
		0x31, 0x23, 0x20, 0xc6, 0x8c, 0x80, 0x18, 0x33, 0x02, 0x62, 0xcc, 0x08, 0x88, 0x31, 0x23, 0x20,
		0xc6, 0x8c, 0xa0, 0x18, 0x33, 0x02, 0x63, 0xcc, 0x08, 0x8c, 0x31, 0x23, 0x30, 0xc6, 0x8c, 0xc0,
		0x18, 0x33, 0x02, 0x63, 0xcc, 0x90, 0x63, 0xec, 0x4f, 0x0c, 0x30, 0x69, 0x8c, 0xad, 0x93, 0x9b,
		0x03, 0x98, 0x29, 0x4e, 0x68, 0x91, 0x36, 0x80, 0x4d, 0x97, 0xf1, 0x4c, 0x72, 0x42, 0x8b, 0x35,
		0xb5, 0x7f, 0x56, 0xf4, 0xf3, 0x68, 0x53, 0xfb, 0x2f, 0x88, 0x7e, 0x1e, 0x6f, 0x6a, 0xff, 0x9c,
		0xe8, 0xe7, 0x11, 0xa7, 0xf6, 0x5f, 0x14, 0xfd, 0x3c, 0xe6, 0xd4, 0xfe, 0x4b, 0xa2, 0x9f, 0x47,
		0x9d, 0xda, 0x7f, 0x59, 0xf4, 0xf3, 0xb8, 0x53, 0xfb, 0xaf, 0x88, 0x7e, 0x1e, 0x79, 0x6a, 0xff,
		0x03, 0xe6, 0x29, 0x3d, 0xf6, 0x38, 0x81, 0x30, 0xed, 0x29, 0x3d, 0xfa, 0x34, 0x8a, 0xf3, 0x1e,
		0x05, 0x8f, 0x3f, 0x8d, 0x62, 0xd6, 0xa3, 0xe0, 0x11, 0xa8, 0x51, 0x5c, 0xc8, 0x7d, 0x90, 0x98,
		0xcf, 0xd1, 0xcd, 0x37, 0xa1, 0x99, 0x2f, 0x2a, 0x99, 0x6e, 0x42, 0x33, 0x5d, 0x54, 0x32, 0xdb,
		0x84, 0x66, 0xb6, 0xa8, 0x64, 0xb2, 0x09, 0xcd, 0x64, 0x51, 0xc9, 0x5c, 0x13, 0x9a, 0xb9, 0xa2,
		0x92, 0xa9, 0x26, 0x34, 0x53, 0x45, 0x25, 0x33, 0x4d, 0x68, 0x66, 0x8a, 0x4a, 0x26, 0x9a, 0xd0,
		0x4c, 0x14, 0x95, 0xcc, 0x33, 0xa1, 0x99, 0x27, 0x2a, 0x99, 0xe6, 0xb8, 0x6e, 0x9a, 0xa8, 0x6c,
		0x96, 0xe3, 0xba, 0x59, 0xa2, 0xb2, 0x49, 0x8e, 0xeb, 0x26, 0x89, 0xca, 0xe6, 0x38, 0xae, 0x9b,
		0x23, 0x2a, 0x9b, 0xe2, 0xe7, 0x51, 0x5e, 0x11, 0x6e, 0xb4, 0x5b, 0x9d, 0x6a, 0xfb, 0x96, 0x2a,
		0xc2, 0x19, 0xa5, 0x7c, 0x48, 0xce, 0x9a, 0xd3, 0xa4, 0x60, 0x95, 0x2b, 0x4e, 0x6d, 0x05, 0x9b,
		0x51, 0x0a, 0x0b, 0x09, 0xe1, 0xf8, 0x23, 0xe6, 0x6e, 0xa9, 0x36, 0x9c, 0x51, 0xca, 0x8c, 0x70,
		0xf9, 0xae, 0xbc, 0xe9, 0x15, 0xdb, 0x2b, 0x51, 0x5e, 0xb1, 0x31, 0xf5, 0x1f, 0xb6, 0x62, 0x9b,
		0x0a, 0x57, 0xb9, 0x50, 0xf6, 0x54, 0xb8, 0xb2, 0xbb, 0x56, 0x9d, 0x7e, 0x2b, 0xb8, 0xa9, 0x70,
		0xd5, 0x0a, 0xa5, 0xbe, 0xb1, 0xf5, 0x16, 0xf3, 0x60, 0x94, 0x4c, 0x7c, 0x3c, 0xf8, 0xb0, 0xf5,
		0xd6, 0x8c, 0x92, 0x4a, 0x0e, 0xeb, 0xc1, 0xc6, 0xa1, 0x3d, 0xf8, 0xb0, 0x95, 0xd7, 0x8c, 0x92,
		0x5e, 0x0e, 0xed, 0xc1, 0x6f, 0x42, 0x3d, 0xc4, 0x3c, 0xd8, 0x53, 0xff, 0x61, 0xeb, 0xa1, 0xa9,
		0x70, 0x95, 0xfb, 0x7a, 0xb0, 0x71, 0x08, 0x0f, 0xee, 0xa7, 0x3e, 0x9a, 0x0a, 0x57, 0xad, 0xbf,
		0x07, 0xdf, 0x72, 0x35, 0xf3, 0xe9, 0x08, 0x8c, 0xa2, 0x61, 0x4a, 0x78, 0x9f, 0xa7, 0x66, 0xd7,
		0x98, 0x1e, 0x67, 0x94, 0x4c, 0x10, 0x60, 0xea, 0x57, 0x5f, 0x3b, 0xe9, 0x69, 0xf8, 0x22, 0x24,
		0xa8, 0x86, 0x67, 0x66, 0xb2, 0x37, 0x22, 0x21, 0x19, 0x2e, 0xb1, 0xc3, 0x48, 0xcd, 0xd3, 0x1c,
		0x86, 0xd6, 0x9e, 0x6f, 0x45, 0xa4, 0x2c, 0xc7, 0x48, 0xce, 0xcf, 0xe4, 0x3e, 0x4c, 0x24, 0x74,
		0x6e, 0x59, 0xc2, 0x73, 0x7d, 0x49, 0x28, 0xc9, 0x76, 0x47, 0x97, 0x6c, 0x92, 0x54, 0x1d, 0x18,
		0x41, 0xb0, 0x55, 0xf2, 0x80, 0x5f, 0x3f, 0x22, 0x51, 0x1a, 0x2d, 0x1f, 0xcc, 0x28, 0x6e, 0x29,
		0x23, 0x84, 0x4b, 0xab, 0x39, 0x22, 0x57, 0xc7, 0xc3, 0x3a, 0xca, 0xb0, 0x53, 0x41, 0xc3, 0x7a,
		0x99, 0x5d, 0x0c, 0x38, 0x15, 0x34, 0xa0, 0x17, 0x43, 0x62, 0xa8, 0x17, 0xf8, 0xe2, 0x4c, 0xef,
		0xf7, 0x40, 0xc9, 0x21, 0xba, 0x44, 0x6f, 0x5b, 0x4c, 0x15, 0x52, 0x58, 0xa8, 0xbf, 0x7f, 0xed,
		0x64, 0x6c, 0xab, 0x83, 0x64, 0x8d, 0xd6, 0x6b, 0xe6, 0x35, 0x88, 0x3f, 0xce, 0x9e, 0xaf, 0xc1,
		0x04, 0x73, 0x8c, 0xe0, 0xbe, 0x90, 0x2d, 0x26, 0xc2, 0x7a, 0x7a, 0xab, 0xee, 0xb4, 0xcf, 0xcf,
		0x5e, 0x61, 0x8f, 0xda, 0xe4, 0xfe, 0x33, 0x00, 0x1d, 0x73, 0x01, 0x3f, 0x1f, 0xb0, 0xca, 0x39,
		0xd3, 0xa1, 0xaf, 0x20, 0xae, 0x73, 0xfd, 0x70, 0xbd, 0xbf, 0x86, 0xd0, 0xf7, 0xe3, 0x8d, 0xb8,
		0xe9, 0xc2, 0x75, 0xd4, 0xce, 0xb9, 0x1f, 0xf0, 0x55, 0x8f, 0xcd, 0x2b, 0x2b, 0xcd, 0x2b, 0xa1,
		0xcc, 0x69, 0x51, 0x9d, 0xd3, 0xcc, 0xcd, 0xce, 0xe7, 0x05, 0xbe, 0x48, 0x68, 0x9a, 0x34, 0xc2,
		0x34, 0x69, 0xdc, 0xaa, 0x26, 0x0f, 0x78, 0x7e, 0xd4, 0xe6, 0x6a, 0xf4, 0x9a, 0xab, 0x71, 0x2b,
		0x73, 0xfd, 0x09, 0x8d, 0x56, 0x11, 0x4f, 0x5b, 0x0e, 0xbd, 0x5d, 0xee, 0x97, 0x6b, 0x2f, 0xe8,
		0x0d, 0xad, 0x02, 0xf2, 0xb1, 0x1b, 0x2f, 0x9e, 0x8c, 0xe4, 0x3e, 0x1d, 0xe5, 0x33, 0xa7, 0x81,
		0x74, 0x73, 0x33, 0xff, 0x65, 0xa9, 0xa9, 0xde, 0x0c, 0x0d, 0x7d, 0x2a, 0x02, 0xe3, 0x5d, 0x99,
		0x9c, 0xaa, 0xe9, 0x8d, 0x4d, 0xe7, 0xce, 0x61, 0xd3, 0x39, 0x13, 0xf0, 0x2b, 0x11, 0x18, 0xd3,
		0xd2, 0x2b, 0x15, 0xef, 0x9c, 0x26, 0xde, 0x6d, 0xdd, 0x23, 0x11, 0x42, 0x49, 0x3a, 0xd9, 0xbc,
		0x1a, 0x40, 0xe2, 0x2c, 0xec, 0x3e, 0xa7, 0xd9, 0xfd, 0xb8, 0x00, 0xf8, 0xa8, 0x8b, 0x7b, 0x00,
		0x13, 0xbb, 0x09, 0xb1, 0xcd, 0x96, 0x8d, 0xb7, 0x20, 0xa2, 0x6b, 0x2d, 0x26, 0x61, 0x9a, 0xe2,
		0xd7, 0x5a, 0x85, 0x56, 0xc5, 0xa9, 0xee, 0x59, 0xd1, 0x66, 0x0b, 0x2d, 0xb6, 0xc6, 0x3c, 0x7b,
		0x10, 0x39, 0x39, 0x3b, 0x42, 0x09, 0x50, 0x03, 0xa3, 0x30, 0x2a, 0x4e, 0x0d, 0xb1, 0x88, 0x2d,
		0xdb, 0x95, 0x1d, 0x26, 0x04, 0x50, 0x1a, 0xdc, 0x62, 0xc5, 0x1a, 0xe8, 0x5f, 0x36, 0xe0, 0x93,
		0x90, 0xe0, 0x8c, 0xcd, 0x33, 0x18, 0xb1, 0xd3, 0x66, 0xc3, 0x32, 0x04, 0x16, 0x87, 0xad, 0x5c,
		0x08, 0xb7, 0xd3, 0x36, 0xcf, 0x42, 0xdc, 0xaa, 0xef, 0xee, 0xb5, 0xd9, 0xe0, 0xdd, 0x64, 0xf1,
		0x16, 0xee, 0xce, 0x3d, 0x05, 0x43, 0x42, 0xa2, 0x37, 0x98, 0xf5, 0x02, 0x9d, 0x1a, 0xba, 0x12,
		0x96, 0xd6, 0x13, 0xbe, 0x6f, 0xc9, 0x1e, 0xf2, 0x3c, 0x05, 0x09, 0xa4, 0x66, 0x2f, 0xe9, 0xf3,
		0x8a, 0x14, 0x9f, 0xc8, 0x93, 0xd6, 0xdc, 0xfb, 0x22, 0x90, 0x58, 0xb0, 0xed, 0x03, 0xa2, 0xf0,
		0xbb, 0x21, 0xb6, 0xd0, 0x7c, 0xde, 0x61, 0x02, 0x8e, 0x32, 0x8d, 0xe2, 0x6e, 0xa6, 0xd3, 0x58,
		0x0d, 0x75, 0x23, 0x32, 0x49, 0xef, 0x47, 0x85, 0xde, 0x25, 0x3a, 0xa2, 0xfb, 0x9c, 0xa2, 0x7b,
		0x66, 0x40, 0x4c, 0xd4, 0xa5, 0xff, 0xcb, 0x90, 0x94, 0x46, 0x31, 0x27, 0x99, 0x18, 0x51, 0x1d,
		0x28, 0xeb, 0x0a, 0x4b, 0x92, 0xb3, 0x61, 0x58, 0x19, 0x18, 0x43, 0x25, 0x15, 0x07, 0x40, 0x89,
		0x9a, 0xa7, 0x54, 0x35, 0xfb, 0x93, 0x32, 0x55, 0xcf, 0x50, 0x1d, 0x11, 0x75, 0x9f, 0xa1, 0xce,
		0x19, 0x6c, 0xc4, 0x36, 0xfa, 0x9e, 0x8b, 0x83, 0xb1, 0x5a, 0x6f, 0xe4, 0x1e, 0x06, 0xa0, 0x21,
		0x8f, 0x6f, 0xae, 0xd2, 0xa2, 0x2e, 0xcd, 0x15, 0xbc, 0xb9, 0x67, 0x6f, 0xa2, 0xbf, 0x98, 0x44,
		0xad, 0xa7, 0x70, 0x82, 0x01, 0x1a, 0x62, 0x04, 0x7f, 0x6f, 0x28, 0xde, 0xb7, 0x12, 0xc3, 0xa4,
		0x59, 0x4a, 0xfa, 0x94, 0xdd, 0x9e, 0x77, 0x9a, 0xed, 0x3d, 0xbb, 0xa5, 0x21, 0x66, 0xcd, 0x0b,
		0x4a, 0xc0, 0xa6, 0x67, 0xef, 0x10, 0x88, 0x40, 0xd0, 0x85, 0xdc, 0x17, 0x89, 0x80, 0xb8, 0x14,
		0xe8, 0x9a, 0xa0, 0xd1, 0xc7, 0x04, 0xcd, 0x4b, 0x4a, 0xfd, 0xd6, 0x43, 0x4c, 0xed, 0xd2, 0xf2,
		0x01, 0xe5, 0x3a, 0xa7, 0xb7, 0xb0, 0xea, 0x35, 0x26, 0xd7, 0x29, 0x17, 0xf9, 0xde, 0x50, 0x91,
		0x03, 0xaa, 0xdb, 0xc3, 0xea, 0xd4, 0xe8, 0x57, 0xa7, 0x5f, 0x13, 0x15, 0x07, 0x7d, 0x16, 0x9c,
		0xbc, 0x41, 0xc0, 0xbc, 0x2f, 0xd4, 0xf6, 0xf9, 0x48, 0x51, 0x88, 0x3a, 0xd7, 0xaf, 0xf9, 0xf3,
		0xd1, 0x42, 0x41, 0x88, 0x7b, 0xf9, 0x10, 0x2e, 0x90, 0x8f, 0x16, 0x8b, 0x22, 0x6d, 0x27, 0x3e,
		0x88, 0xa2, 0xf8, 0xe5, 0x17, 0x4f, 0x1e, 0xc9, 0x7d, 0x1e, 0x09, 0xcf, 0x28, 0x25, 0xc7, 0xbd,
		0x5f, 0x13, 0xfe, 0x18, 0xcf, 0x19, 0x7e, 0x1a, 0xf8, 0x85, 0x39, 0xef, 0x37, 0x22, 0x90, 0xed,
		0x92, 0x95, 0xeb, 0x7b, 0xa6, 0x2f, 0x91, 0xf3, 0x91, 0xd2, 0x5b, 0xaf, 0xf3, 0xa7, 0x20, 0xbe,
		0x59, 0xdf, 0xb7, 0x5b, 0x78, 0x25, 0xc0, 0x5f, 0xa8, 0xc8, 0xfc, 0x30, 0x27, 0xde, 0xc6, 0x4d,
		0xbc, 0x8f, 0x0a, 0xa7, 0xf4, 0xe1, 0xf3, 0x84, 0xd8, 0x42, 0xa5, 0x5d, 0x21, 0x12, 0xa4, 0x44,
		0x7e, 0x45, 0x2d, 0xb9, 0x0b, 0x90, 0x5a, 0xb9, 0x4e, 0xee, 0x42, 0xa9, 0x91, 0x1b, 0x34, 0xd4,
		0xea, 0x8f, 0xd7, 0xab, 0xe7, 0xa7, 0xe2, 0x89, 0x5a, 0xe6, 0x46, 0x24, 0x1f, 0x23, 0xf2, 0x3c,
		0x07, 0xe9, 0x35, 0x2c, 0x36, 0xc1, 0x11, 0xd8, 0x29, 0x88, 0xac, 0xa8, 0x85, 0x90, 0xcc, 0xd5,
		0x8a, 0xec, 0x6b, 0xe5, 0xa3, 0x21, 0xd4, 0xa3, 0x95, 0x6d, 0x86, 0x28, 0xdb, 0xa6, 0x62, 0x89,
		0x74, 0x66, 0x14, 0xfd, 0x0b, 0x99, 0x61, 0x36, 0xee, 0x5f, 0x1a, 0x90, 0xa1, 0xa5, 0x0e, 0x32,
		0x62, 0xdd, 0xa9, 0xb7, 0xbb, 0xeb, 0x55, 0x21, 0xb1, 0xf9, 0x28, 0x0c, 0x61, 0x95, 0x2e, 0xb2,
		0x17, 0xf1, 0x60, 0xd5, 0x9f, 0x66, 0x25, 0x8a, 0xc6, 0x82, 0x35, 0x10, 0xd7, 0x21, 0xef, 0xbc,
		0x21, 0x18, 0x74, 0x81, 0x61, 0xac, 0xae, 0xae, 0xb0, 0xc5, 0x6d, 0xae, 0x27, 0x94, 0xdd, 0x02,
		0xc3, 0x7e, 0xb1, 0x36, 0x77, 0xd7, 0x32, 0x9c, 0xd5, 0x15, 0xe4, 0x36, 0x51, 0xc4, 0x86, 0x16,
		0xbc, 0x67, 0xfa, 0x61, 0x63, 0x45, 0x9d, 0x95, 0x89, 0x3f, 0x8d, 0xc0, 0xb0, 0xd2, 0x8a, 0x56,
		0xdb, 0x14, 0x6d, 0x90, 0xa6, 0x3b, 0x60, 0xa5, 0x1c, 0xa9, 0x8d, 0xcb, 0x1c, 0xbd, 0x45, 0x99,
		0x27, 0xe6, 0xd1, 0x55, 0xbb, 0xda, 0x6e, 0x4e, 0x83, 0x29, 0x37, 0x31, 0x21, 0xe8, 0x4b, 0x4c,
		0x4c, 0xa7, 0xab, 0x27, 0x77, 0x27, 0xca, 0xc2, 0x42, 0xaf, 0xe2, 0xdd, 0x1b, 0xab, 0xa5, 0x0d,
		0xfc, 0xda, 0x8c, 0x48, 0xee, 0xab, 0x11, 0x48, 0xb2, 0xb2, 0xb5, 0xda, 0x3c, 0xb0, 0xcd, 0x02,
		0x44, 0xe6, 0x99, 0x07, 0xdd, 0x9c, 0xdc, 0x91, 0x0a, 0x5a, 0x9d, 0x22, 0x85, 0xfe, 0x4d, 0x1d,
		0xd9, 0x36, 0x67, 0x21, 0x52, 0x64, 0x06, 0xee, 0xcf, 0x32, 0x91, 0x6a, 0xee, 0xc7, 0x06, 0x1c,
		0x95, 0xcb, 0x68, 0x9e, 0x4f, 0x4e, 0xab, 0xd7, 0x4d, 0xf9, 0xa1, 0xf3, 0xb3, 0x17, 0xe6, 0xa6,
		0xf1, 0x3f, 0xc2, 0x25, 0x4f, 0xab, 0x97, 0x50, 0xdd, 0x24, 0x5d, 0xb7, 0x89, 0xe4, 0x63, 0x52,
		0x6f, 0xd7, 0x6d, 0x22, 0x4a, 0x6f, 0xd7, 0x6d, 0x22, 0x4a, 0x6f, 0xd7, 0x6d, 0x22, 0x4a, 0x6f,
		0xd7, 0x51, 0x80, 0xd2, 0xdb, 0x75, 0x9b, 0x88, 0xd2, 0xdb, 0x75, 0x9b, 0x88, 0xd2, 0xdb, 0x7d,
		0x9b, 0x08, 0xeb, 0x0e, 0xbc, 0x4d, 0x44, 0xed, 0xef, 0xbe, 0x4d, 0x44, 0xed, 0xef, 0xbe, 0x4d,
		0x24, 0x8f, 0xea, 0xb3, 0x8e, 0x1d, 0x7c, 0xe8, 0xa0, 0xe2, 0x7b, 0x5d, 0x03, 0x7a, 0x09, 0x78,
		0x0d, 0x46, 0xe8, 0x7e, 0x44, 0x11, 0xdf, 0xa1, 0x55, 0x77, 0x50, 0x2a, 0x7e, 0x08, 0x52, 0xb4,
		0x89, 0x5e, 0xe5, 0xf8, 0x5d, 0x05, 0xd2, 0x7e, 0x96, 0x6e, 0x53, 0x55, 0x89, 0x3a, 0xf7, 0xf3,
		0x18, 0x8c, 0xd3, 0x6e, 0xfc, 0x18, 0xa1, 0x72, 0x93, 0xd1, 0x59, 0xed, 0x48, 0x29, 0x8d, 0xe1,
		0xdf, 0x7d, 0xed, 0x24, 0x6d, 0x9d, 0x17, 0xce, 0x74, 0x56, 0x3b, 0x5c, 0x52, 0xe9, 0xbc, 0xf5,
		0xe7, 0xac, 0x76, 0xe3, 0x91, 0x4a, 0x27, 0x96, 0x1b, 0x41, 0xc7, 0x6f, 0x41, 0x52, 0xe9, 0x16,
		0x84, 0x97, 0x9d, 0xd5, 0x6e, 0x46, 0x52, 0xe9, 0x4a, 0xc2, 0xdf, 0xce, 0x6a, 0x47, 0x4f, 0x2a,
		0xdd, 0xa2, 0xf0, 0xbc, 0xb3, 0xda, 0x21, 0x94, 0x4a, 0x77, 0x55, 0xf8, 0xe0, 0x59, 0xed, 0x56,
		0x25, 0x95, 0xee, 0x31, 0xe1, 0x8d, 0x67, 0xb5, 0x9b, 0x96, 0x54, 0xba, 0x25, 0xe1, 0x97, 0x93,
		0xfa, 0xed, 0x4b, 0x2a, 0xe1, 0x35, 0xcf, 0x43, 0x27, 0xf5, 0x1b, 0x99, 0x54, 0xca, 0x77, 0x7a,
		0xbe, 0x3a, 0xa9, 0xdf, 0xd2, 0xa4, 0x52, 0x2e, 0x7b, 0x5e, 0x3b, 0xa9, 0x1f, 0x95, 0xa9, 0x94,
		0x2b, 0x9e, 0xff, 0x4e, 0xea, 0x87, 0x66, 0x2a, 0xe5, 0xaa, 0xe7, 0xc9, 0x93, 0xfa, 0xf1, 0x99,
		0x4a, 0xb9, 0xe6, 0xed, 0xa1, 0x7f, 0x5d, 0x73, 0x3f, 0xe9, 0x26, 0xa8, 0x9c, 0xe6, 0x7e, 0xe0,
		0xe3, 0x7a, 0x39, 0xcd, 0xf5, 0xc0, 0xc7, 0xed, 0x72, 0x9a, 0xdb, 0x81, 0x8f, 0xcb, 0xe5, 0x34,
		0x97, 0x03, 0x1f, 0x77, 0xcb, 0x69, 0xee, 0x06, 0x3e, 0xae, 0x96, 0xd3, 0x5c, 0x0d, 0x7c, 0xdc,
		0x2c, 0xa7, 0xb9, 0x19, 0xf8, 0xb8, 0x58, 0x4e, 0x73, 0x31, 0xf0, 0x71, 0xaf, 0x9c, 0xe6, 0x5e,
		0xe0, 0xe3, 0x5a, 0x67, 0x74, 0xd7, 0x02, 0x3f, 0xb7, 0x3a, 0xa3, 0xbb, 0x15, 0xf8, 0xb9, 0xd4,
		0x5d, 0xba, 0x4b, 0x0d, 0x21, 0xaa, 0x38, 0x6e, 0x92, 0xbc, 0xe9, 0x8c, 0xee, 0x4d, 0xe0, 0xe7,
		0x49, 0x67, 0x74, 0x4f, 0x02, 0x3f, 0x2f, 0x3a, 0xa3, 0x7b, 0x11, 0xf8, 0x79, 0xd0, 0x2b, 0xba,
		0x07, 0x79, 0xb7, 0xf8, 0xe4, 0xb4, 0x13, 0xc5, 0x30, 0x0f, 0x32, 0xfa, 0xf0, 0x20, 0xa3, 0x0f,
		0x0f, 0x32, 0xfa, 0xf0, 0x20, 0xa3, 0x0f, 0x0f, 0x32, 0xfa, 0xf0, 0x20, 0xa3, 0x0f, 0x0f, 0x32,
		0xfa, 0xf0, 0x20, 0xa3, 0x1f, 0x0f, 0x32, 0xfa, 0xf2, 0x20, 0x23, 0xc8, 0x83, 0xce, 0xe8, 0x37,
		0x3c, 0x80, 0x5f, 0x42, 0x3a, 0xa3, 0x9f, 0x7c, 0x86, 0xbb, 0x90, 0xd1, 0x97, 0x0b, 0x19, 0x41,
		0x2e, 0xf4, 0x75, 0x54, 0x48, 0x29, 0x2e, 0xc4, 0x8e, 0x87, 0xde, 0xa8, 0x0c, 0x74, 0xa9, 0x8f,
		0xfb, 0x2b, 0xfc, 0x7c, 0xea, 0x52, 0x1f, 0x67, 0xd4, 0xbd, 0xfc, 0xac, 0x3b, 0x0b, 0x95, 0xfa,
		0xc8, 0x42, 0x8b, 0xc2, 0x87, 0x2e, 0xf5, 0x71, 0xdf, 0x45, 0xb7, 0xef, 0x5d, 0xe9, 0x95, 0x04,
		0x1e, 0xeb, 0x2b, 0x09, 0x2c, 0xf5, 0x95, 0x04, 0xae, 0x79, 0x16, 0xfc, 0x40, 0x14, 0xc6, 0x3c,
		0x0b, 0xd2, 0x6f, 0xe4, 0x15, 0x2a, 0x39, 0xe9, 0x84, 0xca, 0xe4, 0xa7, 0x36, 0x92, 0x19, 0xf1,
		0xf9, 0xcd, 0xba, 0x7a, 0x56, 0x95, 0x3f, 0xec, 0xf9, 0x8d, 0x64, 0x71, 0xb6, 0x17, 0x7a, 0x06,
		0x8c, 0xa5, 0x9a, 0x4b, 0xb2, 0x85, 0xdf, 0xb0, 0x45, 0xcb, 0xa8, 0xd7, 0x5c, 0xd3, 0x82, 0x01,
		0x32, 0xae, 0x4b, 0xcc, 0x7b, 0x2b, 0x03, 0x23, 0xd3, 0x93, 0x81, 0xdd, 0xdc, 0x2b, 0x11, 0x38,
		0xa5, 0xb8, 0xf2, 0x1b, 0x73, 0x62, 0xf0, 0x60, 0x5f, 0x27, 0x06, 0x4a, 0x80, 0x78, 0xa7, 0x07,
		0xf7, 0x74, 0x1f, 0x54, 0xcb, 0x51, 0xa2, 0x9f, 0x24, 0xfc, 0x37, 0x48, 0x7b, 0x33, 0x20, 0x97,
		0x6c, 0x17, 0xc3, 0x37, 0x33, 0xfd, 0x42, 0xf3, 0xa2, 0xb6, 0x89, 0xd6, 0x13, 0x26, 0xa2, 0x35,
		0x97, 0x47, 0x57, 0x9c, 0xea, 0xe3, 0x30, 0x61, 0x7b, 0x11, 0x09, 0x5c, 0x9a, 0xdf, 0x78, 0x09,
		0x95, 0xe7, 0xf7, 0x41, 0x4a, 0x7e, 0xe2, 0x45, 0x03, 0x0e, 0x71, 0x60, 0x3e, 0xf6, 0x2a, 0xa6,
		0xfe, 0x8d, 0x08, 0x1c, 0x93, 0xc9, 0x9f, 0x40, 0xb6, 0x5f, 0x72, 0x70, 0x4d, 0xff, 0x30, 0x24,
		0x6c, 0x66, 0x38, 0xf6, 0xda, 0x0d, 0x76, 0x19, 0xe9, 0x4b, 0x3e, 0x4d, 0xfe, 0xb5, 0x04, 0x44,
		0xdb, 0xe2, 0xe0, 0xc3, 0xce, 0x4e, 0xdc, 0x0d, 0x71, 0xca, 0x5f, 0x95, 0x6b, 0x58, 0x93, 0xeb,
		0xb3, 0x3e, 0x72, 0x11, 0x3f, 0x32, 0xaf, 0x29, 0x72, 0x49, 0x57, 0xab, 0xbe, 0xe4, 0xd3, 0xdc,
		0xf9, 0x0a, 0x09, 0x5c, 0xff, 0x11, 0x8f, 0x0a, 0x17, 0x72, 0x12, 0x12, 0x25, 0x9d, 0xc6, 0x5f,
		0xce, 0x05, 0x88, 0xad, 0xe2, 0xb7, 0x89, 0x8d, 0xb1, 0xb7, 0x67, 0x32, 0x25, 0xb3, 0x37, 0xb4,
		0x9e, 0x85, 0x44, 0x71, 0xaf, 0xde, 0xa8, 0xb5, 0x6c, 0x87, 0x1d, 0xd9, 0xb3, 0x1d, 0x74, 0x8c,
		0xb1, 0x12, 0x55, 0xd6, 0x37, 0x95, 0x83, 0xa4, 0xe4, 0x12, 0x66, 0x1c, 0x5d, 0xfe, 0x67, 0x8e,
		0xe0, 0x3f, 0x85, 0x4c, 0x04, 0xff, 0x29, 0x66, 0xa2, 0x53, 0x77, 0xc3, 0x88, 0xb6, 0x41, 0x86,
		0x7b, 0x16, 0x32, 0x80, 0xff, 0x94, 0x32, 0xc9, 0x89, 0xd8, 0x07, 0x7f, 0xeb, 0xc4, 0x91, 0xa9,
		0x07, 0xc1, 0xec, 0xde, 0x4a, 0x33, 0x07, 0x20, 0x3a, 0x8f, 0x59, 0xde, 0x06, 0xd1, 0x02, 0xe2,
		0x39, 0x31, 0xf2, 0xbf, 0x3f, 0x79, 0x2a, 0x59, 0x20, 0x0f, 0x8c, 0x22, 0xea, 0x42, 0x81, 0x81,
		0x1f, 0x81, 0x63, 0xbe, 0x5b, 0x71, 0x18, 0x5f, 0x2c, 0x52, 0xfc, 0xc2, 0x42, 0x17, 0x7e, 0x61,
		0x81, 0xe0, 0x23, 0x79, 0x7e, 0xa4, 0x39, 0x6f, 0xfa, 0x6c, 0x7c, 0x65, 0x6b, 0xd2, 0x11, 0xea,
		0x7c, 0xfe, 0x11, 0x46, 0x5b, 0xf0, 0xa5, 0xb5, 0x43, 0x8e, 0x44, 0x0b, 0xf9, 0x22, 0xc3, 0x17,
		0x7d, 0xf1, 0x3b, 0xda, 0xb9, 0x9d, 0x9a, 0x83, 0x18, 0x93, 0xa2, 0x10, 0x78, 0xc1, 0x97, 0xc9,
		0x9e, 0x74, 0x37, 0xf5, 0x82, 0x10, 0xb8, 0xe4, 0x4b, 0x5b, 0x0f, 0xb9, 0xab, 0xa8, 0x94, 0x3f,
		0xc7, 0x96, 0x91, 0xf9, 0xf3, 0xe6, 0x31, 0xee, 0x05, 0x4a, 0x8c, 0x33, 0x05, 0xd1, 0x15, 0x65,
		0xfe, 0x3c, 0x9a, 0x21, 0x05, 0x14, 0x02, 0x01, 0xc1, 0x5a, 0xa2, 0x4c, 0x0a, 0xe7, 0xf3, 0x8f,
		0x31, 0x26, 0xc5, 0x40, 0x26, 0x21, 0xaa, 0xa2, 0x9c, 0x8a, 0xe7, 0x0b, 0x9b, 0x37, 0xbe, 0x73,
		0xe2, 0xc8, 0xab, 0xe8, 0xf3, 0x77, 0xe8, 0xf3, 0xed, 0xef, 0x9c, 0x88, 0xfc, 0x00, 0x7d, 0x7e,
		0x84, 0x3e, 0x3f, 0x45, 0x9f, 0xf7, 0x7e, 0xf7, 0x44, 0xe4, 0x65, 0xf4, 0xf9, 0x22, 0xfa, 0xfc,
		0x31, 0xfa, 0xbc, 0x82, 0x3e, 0x37, 0xd0, 0xe7, 0x55, 0xf4, 0xf9, 0x36, 0xfa, 0xfc, 0xe0, 0xbb,
		0x27, 0x8e, 0xfc, 0x08, 0xfd, 0xfd, 0x29, 0xfa, 0xfb, 0xde, 0xef, 0x9d, 0x38, 0xf2, 0x22, 0xfa,
		0xbc, 0xfc, 0xbd, 0x13, 0x11, 0xf8, 0xab, 0x39, 0x98, 0x64, 0x8f, 0x2a, 0xd1, 0x87, 0x0b, 0xa5,
		0x07, 0x13, 0xf1, 0x73, 0x4b, 0x64, 0xf1, 0xb9, 0xc0, 0xdf, 0x33, 0x23, 0x1a, 0x0e, 0xf9, 0xf8,
		0xd2, 0xc4, 0xcd, 0x3e, 0x2c, 0x95, 0xfb, 0xb3, 0x38, 0x0c, 0xf2, 0x4d, 0x47, 0xbf, 0x57, 0x98,
		0x5e, 0x84, 0x04, 0x8a, 0xe2, 0x4a, 0xab, 0xde, 0xbe, 0xce, 0x76, 0xdb, 0x6e, 0x9f, 0xf6, 0xc4,
		0xe6, 0xfb, 0x73, 0x8f, 0x75, 0xf6, 0x9b, 0x1d, 0x94, 0x1e, 0x39, 0xa9, 0x79, 0x0a, 0x52, 0x7b,
		0x36, 0x3e, 0x6d, 0x2b, 0xd7, 0x9d, 0x72, 0x75, 0x9f, 0x54, 0x65, 0xc3, 0x16, 0xd0, 0xb6, 0x25,
		0xa7, 0xb8, 0x8f, 0x07, 0xc3, 0x9b, 0xd2, 0xe4, 0x6a, 0x30, 0x45, 0x37, 0xa8, 0xf1, 0x0b, 0x94,
		0x5a, 0xb6, 0x8b, 0xdf, 0xbb, 0x5c, 0x6d, 0x76, 0x9c, 0x36, 0xa9, 0x9b, 0x0c, 0x2b, 0x49, 0xdb,
		0x8a, 0xb8, 0x09, 0xbf, 0x9b, 0x19, 0x6f, 0xf9, 0x94, 0xdd, 0x6a, 0xb3, 0xed, 0xee, 0x57, 0x1c,
		0x52, 0x37, 0x25, 0xac, 0x14, 0x6e, 0xdc, 0x60, 0x6d, 0xe4, 0x4d, 0xd7, 0xd5, 0x66, 0xcb, 0x26,
		0x97, 0x6d, 0x51, 0x8b, 0xfe, 0xc0, 0x6f, 0xba, 0x7e, 0xd6, 0xbe, 0x4e, 0x2e, 0x0c, 0x62, 0x16,
		0xfe, 0x8a, 0x8f, 0x8b, 0xe8, 0x66, 0x26, 0xa9, 0xe2, 0xc8, 0x19, 0xa9, 0x98, 0x1a, 0xdd, 0x0b,
		0xb4, 0x18, 0x01, 0x7e, 0x67, 0x2c, 0x4a, 0x06, 0xad, 0x4a, 0xdd, 0x21, 0x45, 0x3a, 0x7e, 0x67,
		0x6c, 0xb7, 0x1a, 0x36, 0x29, 0x05, 0x79, 0xcd, 0xa0, 0xc5, 0xe9, 0x91, 0x0a, 0x53, 0x84, 0x6e,
		0xb6, 0x4c, 0x5f, 0x14, 0x9f, 0x0c, 0xf4, 0xea, 0x24, 0xa5, 0xe3, 0x5b, 0xd2, 0x1c, 0x46, 0x5f,
		0x4e, 0x35, 0x4c, 0x86, 0xbd, 0xcb, 0x67, 0x58, 0xf2, 0xcc, 0xdc, 0x2c, 0x29, 0x74, 0xe8, 0xd0,
		0x8c, 0x0f, 0x7d, 0x7d, 0xd5, 0x0a, 0xa4, 0x64, 0xb9, 0xb8, 0x1a, 0xe8, 0x32, 0x4b, 0xd4, 0x70,
		0x8f, 0xf7, 0xf6, 0xe1, 0x00, 0x2d, 0xd0, 0xfe, 0x7c, 0xf4, 0x4a, 0x64, 0x62, 0x1d, 0x32, 0xfa,
		0x78, 0x3e, 0x2c, 0xcf, 0xaa, 0x2c, 0x33, 0xf2, 0x64, 0xc9, 0x86, 0xac, 0xc7, 0x31, 0xf7, 0x28,
		0x0c, 0x50, 0xff, 0x31, 0x93, 0x30, 0xb8, 0xb5, 0xfa, 0xce, 0xd5, 0xb5, 0x27, 0x56, 0xe9, 0x0b,
		0xfc, 0xd6, 0xb7, 0x56, 0x37, 0xe8, 0x6b, 0xf8, 0x36, 0x96, 0xe7, 0xd7, 0x37, 0x36, 0x97, 0x8a,
		0xef, 0xcc, 0x44, 0xf1, 0xf6, 0x72, 0x61, 0x69, 0x79, 0xb9, 0x5c, 0x98, 0x5f, 0x5a, 0x2e, 0x3d,
		0x95, 0x31, 0x72, 0x27, 0x60, 0x80, 0xca, 0x89, 0x0d, 0xbf, 0xdd, 0x71, 0x9c, 0xeb, 0x7c, 0x99,
		0x22, 0x3f, 0x72, 0x5f, 0x36, 0x61, 0x70, 0xbe, 0xd1, 0x40, 0xc9, 0xc0, 0x35, 0x9f, 0x80, 0x51,
		0xfa, 0xec, 0xff, 0x66, 0x73, 0x81, 0xbc, 0x2f, 0x0c, 0xa7, 0x88, 0x08, 0x7b, 0xeb, 0xb2, 0x37,
		0x6f, 0x46, 0x3e, 0xdd, 0x45, 0x4b, 0x15, 0x3c, 0xea, 0xea, 0xed, 0xe6, 0x26, 0x64, 0x38, 0xf1,
		0x62, 0xa3, 0x59, 0x69, 0x63, 0xbe, 0x51, 0xf6, 0x3a, 0xaf, 0x60, 0xbe, 0x9c, 0x94, 0xb2, 0xcd,
		0xb8, 0x5a, 0xb3, 0xf9, 0x10, 0x24, 0x96, 0x9c, 0xf6, 0x85, 0x59, 0xcc, 0x8d, 0xbf, 0xd8, 0xbf,
		0x9b, 0x1b, 0x27, 0xa1, 0x5c, 0x12, 0x75, 0xf6, 0x93, 0xa1, 0x2f, 0xcd, 0x61, 0x74, 0xac, 0x17,
		0x9a, 0x90, 0x78, 0x68, 0xf2, 0x13, 0x1f, 0xaa, 0x6c, 0x71, 0x56, 0xec, 0x5d, 0xfe, 0xa7, 0x7d,
		0xe0, 0x82, 0x86, 0xe2, 0x87, 0x3a, 0x62, 0x78, 0xc6, 0x80, 0x8e, 0x3f, 0xd0, 0x93, 0x81, 0x24,
		0x00, 0x61, 0x20, 0x24, 0xd8, 0x10, 0x12, 0x0c, 0x06, 0x32, 0xd8, 0xd0, 0x24, 0x70, 0x65, 0x09,
		0x36, 0x84, 0x04, 0x89, 0x9e, 0x0c, 0x64, 0x09, 0x5c, 0x21, 0x41, 0x01, 0x60, 0xb1, 0xfe, 0x82,
		0x5d, 0xa3, 0x22, 0xd0, 0xd7, 0xfe, 0xe7, 0x7c, 0x38, 0x78, 0x44, 0x94, 0x05, 0xec, 0x88, 0x06,
		0xb3, 0x04, 0xc9, 0x0d, 0xef, 0x27, 0x4b, 0x1f, 0x77, 0xf9, 0x89, 0xb1, 0xa3, 0x71, 0x49, 0xba,
		0x12, 0x1b, 0x2e, 0x0a, 0x9d, 0x4c, 0xb2, 0xb7, 0x28, 0xd2, 0x6c, 0xa8, 0x28, 0x74, 0x3a, 0x42,
		0x14, 0xca, 0x24, 0x15, 0x22, 0x8a, 0xc4, 0x85, 0x89, 0x42, 0xd9, 0xa0, 0x64, 0x58, 0x68, 0x36,
		0x31, 0x25, 0xcb, 0x4a, 0x27, 0x7d, 0x58, 0x30, 0x0a, 0x96, 0x0c, 0xb7, 0xe9, 0x2f, 0x62, 0x11,
		0xe2, 0xe4, 0x18, 0x9c, 0x0e, 0xb6, 0x08, 0xa7, 0xe1, 0x16, 0xe1, 0xbf, 0xe5, 0x38, 0x23, 0x37,
		0x4e, 0x62, 0x3e, 0x23, 0xa1, 0x71, 0xc6, 0x49, 0xb5, 0x38, 0xe3, 0xcd, 0xe6, 0xbb, 0x60, 0x84,
		0x93, 0xe2, 0xf4, 0x84, 0x99, 0x66, 0xd8, 0xff, 0x18, 0x25, 0x98, 0x29, 0xa3, 0xa4, 0x3c, 0x47,
		0x5c, 0xb5, 0xd5, 0x5c, 0x85, 0x34, 0x27, 0x5c, 0x71, 0xc9, 0x74, 0x47, 0xd9, 0xdb, 0xca, 0x83,
		0x39, 0x52, 0x42, 0xca, 0x30, 0xed, 0x2a, 0x8d, 0x13, 0x0b, 0x30, 0xee, 0x9f, 0x8d, 0xe4, 0xf4,
		0x3b, 0x44, 0xd3, 0xef, 0x98, 0x9c, 0x7e, 0x23, 0x72, 0xfa, 0x2e, 0xc2, 0x31, 0xdf, 0xdc, 0x13,
		0xc6, 0x24, 0x2a, 0x33, 0x79, 0x10, 0x86, 0x95, 0x94, 0x23, 0x83, 0xe3, 0x3e, 0xe0, 0x78, 0x37,
		0xd8, 0x73, 0x2d, 0x9f, 0xd5, 0x43, 0x01, 0x1b, 0x32, 0xf8, 0x21, 0x48, 0xab, 0xf9, 0x46, 0x46,
		0x0f, 0xfb, 0xa0, 0x87, 0x7d, 0xd0, 0xfe, 0x63, 0xc7, 0x7c, 0xd0, 0x31, 0x0d, 0xbd, 0x11, 0x38,
		0xf6, 0xa8, 0x0f, 0x7a, 0xd4, 0x07, 0xed, 0x3f, 0xb6, 0xe9, 0x83, 0x36, 0x65, 0xf4, 0xc3, 0x30,
		0xa2, 0xa5, 0x18, 0x19, 0x3e, 0xe8, 0x03, 0x1f, 0x94, 0xe1, 0x8f, 0xa0, 0xa0, 0xd9, 0x09, 0xc6,
		0x8f, 0xf8, 0xe0, 0x47, 0xfc, 0x86, 0xf7, 0x97, 0x7e, 0xc0, 0x07, 0x3e, 0xe0, 0x3b, 0xbc, 0x3f,
		0x3e, 0xe3, 0x83, 0xcf, 0xc8, 0xf8, 0x3c, 0xa4, 0xe4, 0x6c, 0x22, 0x63, 0x13, 0x3e, 0xd8, 0x84,
		0xae, 0x77, 0x25, 0x99, 0x84, 0x79, 0xfa, 0x50, 0x40, 0xb8, 0x28, 0x29, 0x24, 0x8c, 0x49, 0x4a,
		0x66, 0xf2, 0x38, 0x8c, 0xf9, 0xa5, 0x0c, 0x1f, 0x1e, 0x93, 0x32, 0x8f, 0x34, 0xae, 0x11, 0xbd,
		0x62, 0xaf, 0x72, 0xa0, 0x15, 0x4e, 0x13, 0x4f, 0xc3, 0x51, 0x9f, 0xc4, 0xe1, 0xc3, 0x76, 0x5a,
		0xad, 0xc6, 0xb2, 0x12, 0x5b, 0x92, 0x04, 0x10, 0x8b, 0xf5, 0x26, 0x72, 0x4e, 0xb9, 0x2a, 0xfb,
		0xea, 0x51, 0x48, 0xb3, 0xf4, 0xb4, 0xd6, 0xaa, 0xd9, 0x2d, 0x54, 0x5d, 0xfd, 0x97, 0xe0, 0xda,
		0x69, 0xa6, 0x3b, 0xa9, 0x31, 0xd4, 0x21, 0x4a, 0xa8, 0xa7, 0x03, 0x4b, 0xa8, 0x73, 0xe1, 0xec,
		0xc3, 0x2a, 0xa9, 0x62, 0x57, 0x25, 0x75, 0x4f, 0x30, 0xd3, 0xa0, 0x82, 0xaa, 0xd8, 0x55, 0x50,
		0xf5, 0x66, 0xe2, 0x5b, 0x57, 0x2d, 0x76, 0xd7, 0x55, 0x93, 0xc1, 0x5c, 0x82, 0xcb, 0xab, 0xc5,
		0xee, 0xf2, 0x2a, 0x84, 0x8f, 0x7f, 0x95, 0xb5, 0xd8, 0x5d, 0x65, 0xf5, 0xe0, 0x13, 0x5c, 0x6c,
		0x2d, 0x76, 0x17, 0x5b, 0x21, 0x7c, 0xfc, 0x6b, 0xae, 0x25, 0x9f, 0x9a, 0xeb, 0xde, 0x60, 0x46,
		0xbd, 0x4a, 0xaf, 0x65, 0xbf, 0xd2, 0x6b, 0xaa, 0x87, 0x50, 0x3d, 0x2b, 0xb0, 0x25, 0x9f, 0x0a,
		0x2c, 0x4c, 0xb0, 0x80, 0x42, 0x6c, 0xd9, 0xaf, 0x10, 0x0b, 0x15, 0x2c, 0xa8, 0x1e, 0xfb, 0x4f,
		0x7a, 0x3d, 0x76, 0x36, 0x98, 0x93, 0x7f, 0x59, 0xb6, 0xd8, 0x5d, 0x96, 0x4d, 0x86, 0xc5, 0x9c,
		0x5f, 0x75, 0xf6, 0x74, 0x60, 0x75, 0xd6, 0x47, 0x08, 0x87, 0x15, 0x69, 0x4f, 0x06, 0x15, 0x69,
		0xd3, 0xe1, 0xbc, 0x7b, 0xd7, 0x6a, 0x5b, 0x01, 0xb5, 0xda, 0xfd, 0xe1, 0x8c, 0xdf, 0x2e, 0xd9,
		0xde, 0x2e, 0xd9, 0xde, 0x2e, 0xd9, 0xde, 0x2e, 0xd9, 0xde, 0xfa, 0x92, 0x2d, 0x1f, 0xfb, 0xc8,
		0x4b, 0x27, 0x23, 0xb9, 0xbf, 0x35, 0xc4, 0xff, 0xc1, 0x05, 0x1f, 0x13, 0xe1, 0xf4, 0xb6, 0x02,
		0x29, 0xf2, 0xd6, 0xfa, 0xfd, 0xca, 0xc1, 0x01, 0xfe, 0xff, 0x3a, 0x45, 0xba, 0x96, 0x1b, 0x15,
		0x40, 0xde, 0xfb, 0xbf, 0x42, 0x89, 0xd9, 0x72, 0xe3, 0x78, 0x2d, 0xe6, 0x35, 0x48, 0xee, 0xbb,
		0xbb, 0x82, 0x5b, 0xb4, 0x6b, 0x21, 0xd4, 0xb8, 0xd1, 0x99, 0x7a, 0xcc, 0x60, 0x5f, 0x34, 0x60,
		0xd1, 0xb6, 0x91, 0x95, 0x04, 0x33, 0x23, 0x4c, 0x34, 0x6c, 0x53, 0x55, 0xb4, 0x6d, 0xaf, 0x05,
		0xbb, 0xad, 0x2e, 0x7b, 0x58, 0xa6, 0x53, 0x9c, 0xe7, 0x09, 0x18, 0xd1, 0xa4, 0xf5, 0x89, 0xf9,
		0x9b, 0xb0, 0x0d, 0x16, 0x4c, 0x97, 0x3c, 0x2c, 0x26, 0x64, 0x87, 0xcc, 0xdd, 0x09, 0xc3, 0x0a,
		0x6f, 0x33, 0x05, 0x91, 0x1d, 0xf6, 0xd4, 0x5e, 0x64, 0x07, 0x3f, 0x28, 0x9d, 0x64, 0x47, 0xd6,
		0xeb, 0x95, 0x7a, 0xcb, 0x7c, 0x0c, 0xc8, 0x73, 0x31, 0xec, 0x58, 0xfe, 0xe6, 0x9e, 0xd2, 0xa4,
		0x4f, 0xd6, 0x2c, 0x02, 0x7d, 0x6c, 0xe6, 0xe6, 0x1f, 0x33, 0xa5, 0x4f, 0xdd, 0xdc, 0x88, 0xc0,
		0x28, 0xbb, 0xa3, 0xd2, 0x65, 0xf7, 0xd9, 0xa2, 0x15, 0xf2, 0xcb, 0x11, 0x18, 0x12, 0xbf, 0xcc,
		0x6d, 0x48, 0x8b, 0x1f, 0xf4, 0x5e, 0x6e, 0xea, 0xa9, 0x79, 0x49, 0xc3, 0x5d, 0x3c, 0xa6, 0x7d,
		0xbe, 0xd1, 0x83, 0x2c, 0xba, 0x26, 0x3b, 0x4a, 0xe3, 0xc4, 0x3c, 0x1c, 0xf5, 0x21, 0x3b, 0xcc,
		0x82, 0x3c, 0x75, 0x1a, 0x06, 0x59, 0x68, 0xe3, 0x83, 0xc3, 0x15, 0x7c, 0xf0, 0x88, 0xff, 0xe2,
		0xc3, 0x4c, 0xfc, 0xb7, 0x98, 0x89, 0x16, 0x96, 0x6f, 0xe2, 0x30, 0xe9, 0xc8, 0xab, 0xe8, 0xe3,
		0x73, 0x98, 0x14, 0xd9, 0x1e, 0xa0, 0x73, 0xff, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa4, 0x53,
		0xbe, 0xfe, 0x80, 0x79, 0x00, 0x00,
	}
	r := bytes.NewReader(gzipped)
	gzipr, err := compress_gzip.NewReader(r)
	if err != nil {
		panic(err)
	}
	ungzipped, err := io_ioutil.ReadAll(gzipr)
	if err != nil {
		panic(err)
	}
	if err := github_com_gogo_protobuf_proto.Unmarshal(ungzipped, d); err != nil {
		panic(err)
	}
	return d
}
func (x MapEnum) String() string {
	s, ok := MapEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Message_Humour) String() string {
	s, ok := Message_Humour_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Message) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Message")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Message but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Message but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Hilarity != that1.Hilarity {
		return fmt.Errorf("Hilarity this(%v) Not Equal that(%v)", this.Hilarity, that1.Hilarity)
	}
	if this.HeightInCm != that1.HeightInCm {
		return fmt.Errorf("HeightInCm this(%v) Not Equal that(%v)", this.HeightInCm, that1.HeightInCm)
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if this.ResultCount != that1.ResultCount {
		return fmt.Errorf("ResultCount this(%v) Not Equal that(%v)", this.ResultCount, that1.ResultCount)
	}
	if this.TrueScotsman != that1.TrueScotsman {
		return fmt.Errorf("TrueScotsman this(%v) Not Equal that(%v)", this.TrueScotsman, that1.TrueScotsman)
	}
	if this.Score != that1.Score {
		return fmt.Errorf("Score this(%v) Not Equal that(%v)", this.Score, that1.Score)
	}
	if len(this.Key) != len(that1.Key) {
		return fmt.Errorf("Key this(%v) Not Equal that(%v)", len(this.Key), len(that1.Key))
	}
	for i := range this.Key {
		if this.Key[i] != that1.Key[i] {
			return fmt.Errorf("Key this[%v](%v) Not Equal that[%v](%v)", i, this.Key[i], i, that1.Key[i])
		}
	}
	if !this.Nested.Equal(that1.Nested) {
		return fmt.Errorf("Nested this(%v) Not Equal that(%v)", this.Nested, that1.Nested)
	}
	if len(this.Terrain) != len(that1.Terrain) {
		return fmt.Errorf("Terrain this(%v) Not Equal that(%v)", len(this.Terrain), len(that1.Terrain))
	}
	for i := range this.Terrain {
		if !this.Terrain[i].Equal(that1.Terrain[i]) {
			return fmt.Errorf("Terrain this[%v](%v) Not Equal that[%v](%v)", i, this.Terrain[i], i, that1.Terrain[i])
		}
	}
	if !this.Proto2Field.Equal(that1.Proto2Field) {
		return fmt.Errorf("Proto2Field this(%v) Not Equal that(%v)", this.Proto2Field, that1.Proto2Field)
	}
	if len(this.Proto2Value) != len(that1.Proto2Value) {
		return fmt.Errorf("Proto2Value this(%v) Not Equal that(%v)", len(this.Proto2Value), len(that1.Proto2Value))
	}
	for i := range this.Proto2Value {
		if !this.Proto2Value[i].Equal(that1.Proto2Value[i]) {
			return fmt.Errorf("Proto2Value this[%v](%v) Not Equal that[%v](%v)", i, this.Proto2Value[i], i, that1.Proto2Value[i])
		}
	}
	return nil
}
func (this *Message) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Hilarity != that1.Hilarity {
		return false
	}
	if this.HeightInCm != that1.HeightInCm {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if this.ResultCount != that1.ResultCount {
		return false
	}
	if this.TrueScotsman != that1.TrueScotsman {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if len(this.Key) != len(that1.Key) {
		return false
	}
	for i := range this.Key {
		if this.Key[i] != that1.Key[i] {
			return false
		}
	}
	if !this.Nested.Equal(that1.Nested) {
		return false
	}
	if len(this.Terrain) != len(that1.Terrain) {
		return false
	}
	for i := range this.Terrain {
		if !this.Terrain[i].Equal(that1.Terrain[i]) {
			return false
		}
	}
	if !this.Proto2Field.Equal(that1.Proto2Field) {
		return false
	}
	if len(this.Proto2Value) != len(that1.Proto2Value) {
		return false
	}
	for i := range this.Proto2Value {
		if !this.Proto2Value[i].Equal(that1.Proto2Value[i]) {
			return false
		}
	}
	return true
}
func (this *Nested) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Nested)
	if !ok {
		that2, ok := that.(Nested)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Nested")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Nested but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Nested but is not nil && this == nil")
	}
	if this.Bunny != that1.Bunny {
		return fmt.Errorf("Bunny this(%v) Not Equal that(%v)", this.Bunny, that1.Bunny)
	}
	return nil
}
func (this *Nested) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Nested)
	if !ok {
		that2, ok := that.(Nested)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Bunny != that1.Bunny {
		return false
	}
	return true
}
func (this *AllMaps) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AllMaps)
	if !ok {
		that2, ok := that.(AllMaps)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AllMaps")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AllMaps but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AllMaps but is not nil && this == nil")
	}
	if len(this.StringToDoubleMap) != len(that1.StringToDoubleMap) {
		return fmt.Errorf("StringToDoubleMap this(%v) Not Equal that(%v)", len(this.StringToDoubleMap), len(that1.StringToDoubleMap))
	}
	for i := range this.StringToDoubleMap {
		if this.StringToDoubleMap[i] != that1.StringToDoubleMap[i] {
			return fmt.Errorf("StringToDoubleMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToDoubleMap[i], i, that1.StringToDoubleMap[i])
		}
	}
	if len(this.StringToFloatMap) != len(that1.StringToFloatMap) {
		return fmt.Errorf("StringToFloatMap this(%v) Not Equal that(%v)", len(this.StringToFloatMap), len(that1.StringToFloatMap))
	}
	for i := range this.StringToFloatMap {
		if this.StringToFloatMap[i] != that1.StringToFloatMap[i] {
			return fmt.Errorf("StringToFloatMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToFloatMap[i], i, that1.StringToFloatMap[i])
		}
	}
	if len(this.Int32Map) != len(that1.Int32Map) {
		return fmt.Errorf("Int32Map this(%v) Not Equal that(%v)", len(this.Int32Map), len(that1.Int32Map))
	}
	for i := range this.Int32Map {
		if this.Int32Map[i] != that1.Int32Map[i] {
			return fmt.Errorf("Int32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Int32Map[i], i, that1.Int32Map[i])
		}
	}
	if len(this.Int64Map) != len(that1.Int64Map) {
		return fmt.Errorf("Int64Map this(%v) Not Equal that(%v)", len(this.Int64Map), len(that1.Int64Map))
	}
	for i := range this.Int64Map {
		if this.Int64Map[i] != that1.Int64Map[i] {
			return fmt.Errorf("Int64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Int64Map[i], i, that1.Int64Map[i])
		}
	}
	if len(this.Uint32Map) != len(that1.Uint32Map) {
		return fmt.Errorf("Uint32Map this(%v) Not Equal that(%v)", len(this.Uint32Map), len(that1.Uint32Map))
	}
	for i := range this.Uint32Map {
		if this.Uint32Map[i] != that1.Uint32Map[i] {
			return fmt.Errorf("Uint32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Uint32Map[i], i, that1.Uint32Map[i])
		}
	}
	if len(this.Uint64Map) != len(that1.Uint64Map) {
		return fmt.Errorf("Uint64Map this(%v) Not Equal that(%v)", len(this.Uint64Map), len(that1.Uint64Map))
	}
	for i := range this.Uint64Map {
		if this.Uint64Map[i] != that1.Uint64Map[i] {
			return fmt.Errorf("Uint64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Uint64Map[i], i, that1.Uint64Map[i])
		}
	}
	if len(this.Sint32Map) != len(that1.Sint32Map) {
		return fmt.Errorf("Sint32Map this(%v) Not Equal that(%v)", len(this.Sint32Map), len(that1.Sint32Map))
	}
	for i := range this.Sint32Map {
		if this.Sint32Map[i] != that1.Sint32Map[i] {
			return fmt.Errorf("Sint32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sint32Map[i], i, that1.Sint32Map[i])
		}
	}
	if len(this.Sint64Map) != len(that1.Sint64Map) {
		return fmt.Errorf("Sint64Map this(%v) Not Equal that(%v)", len(this.Sint64Map), len(that1.Sint64Map))
	}
	for i := range this.Sint64Map {
		if this.Sint64Map[i] != that1.Sint64Map[i] {
			return fmt.Errorf("Sint64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sint64Map[i], i, that1.Sint64Map[i])
		}
	}
	if len(this.Fixed32Map) != len(that1.Fixed32Map) {
		return fmt.Errorf("Fixed32Map this(%v) Not Equal that(%v)", len(this.Fixed32Map), len(that1.Fixed32Map))
	}
	for i := range this.Fixed32Map {
		if this.Fixed32Map[i] != that1.Fixed32Map[i] {
			return fmt.Errorf("Fixed32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Fixed32Map[i], i, that1.Fixed32Map[i])
		}
	}
	if len(this.Sfixed32Map) != len(that1.Sfixed32Map) {
		return fmt.Errorf("Sfixed32Map this(%v) Not Equal that(%v)", len(this.Sfixed32Map), len(that1.Sfixed32Map))
	}
	for i := range this.Sfixed32Map {
		if this.Sfixed32Map[i] != that1.Sfixed32Map[i] {
			return fmt.Errorf("Sfixed32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sfixed32Map[i], i, that1.Sfixed32Map[i])
		}
	}
	if len(this.Fixed64Map) != len(that1.Fixed64Map) {
		return fmt.Errorf("Fixed64Map this(%v) Not Equal that(%v)", len(this.Fixed64Map), len(that1.Fixed64Map))
	}
	for i := range this.Fixed64Map {
		if this.Fixed64Map[i] != that1.Fixed64Map[i] {
			return fmt.Errorf("Fixed64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Fixed64Map[i], i, that1.Fixed64Map[i])
		}
	}
	if len(this.Sfixed64Map) != len(that1.Sfixed64Map) {
		return fmt.Errorf("Sfixed64Map this(%v) Not Equal that(%v)", len(this.Sfixed64Map), len(that1.Sfixed64Map))
	}
	for i := range this.Sfixed64Map {
		if this.Sfixed64Map[i] != that1.Sfixed64Map[i] {
			return fmt.Errorf("Sfixed64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sfixed64Map[i], i, that1.Sfixed64Map[i])
		}
	}
	if len(this.BoolMap) != len(that1.BoolMap) {
		return fmt.Errorf("BoolMap this(%v) Not Equal that(%v)", len(this.BoolMap), len(that1.BoolMap))
	}
	for i := range this.BoolMap {
		if this.BoolMap[i] != that1.BoolMap[i] {
			return fmt.Errorf("BoolMap this[%v](%v) Not Equal that[%v](%v)", i, this.BoolMap[i], i, that1.BoolMap[i])
		}
	}
	if len(this.StringMap) != len(that1.StringMap) {
		return fmt.Errorf("StringMap this(%v) Not Equal that(%v)", len(this.StringMap), len(that1.StringMap))
	}
	for i := range this.StringMap {
		if this.StringMap[i] != that1.StringMap[i] {
			return fmt.Errorf("StringMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringMap[i], i, that1.StringMap[i])
		}
	}
	if len(this.StringToBytesMap) != len(that1.StringToBytesMap) {
		return fmt.Errorf("StringToBytesMap this(%v) Not Equal that(%v)", len(this.StringToBytesMap), len(that1.StringToBytesMap))
	}
	for i := range this.StringToBytesMap {
		if !bytes.Equal(this.StringToBytesMap[i], that1.StringToBytesMap[i]) {
			return fmt.Errorf("StringToBytesMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToBytesMap[i], i, that1.StringToBytesMap[i])
		}
	}
	if len(this.StringToEnumMap) != len(that1.StringToEnumMap) {
		return fmt.Errorf("StringToEnumMap this(%v) Not Equal that(%v)", len(this.StringToEnumMap), len(that1.StringToEnumMap))
	}
	for i := range this.StringToEnumMap {
		if this.StringToEnumMap[i] != that1.StringToEnumMap[i] {
			return fmt.Errorf("StringToEnumMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToEnumMap[i], i, that1.StringToEnumMap[i])
		}
	}
	if len(this.StringToMsgMap) != len(that1.StringToMsgMap) {
		return fmt.Errorf("StringToMsgMap this(%v) Not Equal that(%v)", len(this.StringToMsgMap), len(that1.StringToMsgMap))
	}
	for i := range this.StringToMsgMap {
		if !this.StringToMsgMap[i].Equal(that1.StringToMsgMap[i]) {
			return fmt.Errorf("StringToMsgMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToMsgMap[i], i, that1.StringToMsgMap[i])
		}
	}
	return nil
}
func (this *AllMaps) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AllMaps)
	if !ok {
		that2, ok := that.(AllMaps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.StringToDoubleMap) != len(that1.StringToDoubleMap) {
		return false
	}
	for i := range this.StringToDoubleMap {
		if this.StringToDoubleMap[i] != that1.StringToDoubleMap[i] {
			return false
		}
	}
	if len(this.StringToFloatMap) != len(that1.StringToFloatMap) {
		return false
	}
	for i := range this.StringToFloatMap {
		if this.StringToFloatMap[i] != that1.StringToFloatMap[i] {
			return false
		}
	}
	if len(this.Int32Map) != len(that1.Int32Map) {
		return false
	}
	for i := range this.Int32Map {
		if this.Int32Map[i] != that1.Int32Map[i] {
			return false
		}
	}
	if len(this.Int64Map) != len(that1.Int64Map) {
		return false
	}
	for i := range this.Int64Map {
		if this.Int64Map[i] != that1.Int64Map[i] {
			return false
		}
	}
	if len(this.Uint32Map) != len(that1.Uint32Map) {
		return false
	}
	for i := range this.Uint32Map {
		if this.Uint32Map[i] != that1.Uint32Map[i] {
			return false
		}
	}
	if len(this.Uint64Map) != len(that1.Uint64Map) {
		return false
	}
	for i := range this.Uint64Map {
		if this.Uint64Map[i] != that1.Uint64Map[i] {
			return false
		}
	}
	if len(this.Sint32Map) != len(that1.Sint32Map) {
		return false
	}
	for i := range this.Sint32Map {
		if this.Sint32Map[i] != that1.Sint32Map[i] {
			return false
		}
	}
	if len(this.Sint64Map) != len(that1.Sint64Map) {
		return false
	}
	for i := range this.Sint64Map {
		if this.Sint64Map[i] != that1.Sint64Map[i] {
			return false
		}
	}
	if len(this.Fixed32Map) != len(that1.Fixed32Map) {
		return false
	}
	for i := range this.Fixed32Map {
		if this.Fixed32Map[i] != that1.Fixed32Map[i] {
			return false
		}
	}
	if len(this.Sfixed32Map) != len(that1.Sfixed32Map) {
		return false
	}
	for i := range this.Sfixed32Map {
		if this.Sfixed32Map[i] != that1.Sfixed32Map[i] {
			return false
		}
	}
	if len(this.Fixed64Map) != len(that1.Fixed64Map) {
		return false
	}
	for i := range this.Fixed64Map {
		if this.Fixed64Map[i] != that1.Fixed64Map[i] {
			return false
		}
	}
	if len(this.Sfixed64Map) != len(that1.Sfixed64Map) {
		return false
	}
	for i := range this.Sfixed64Map {
		if this.Sfixed64Map[i] != that1.Sfixed64Map[i] {
			return false
		}
	}
	if len(this.BoolMap) != len(that1.BoolMap) {
		return false
	}
	for i := range this.BoolMap {
		if this.BoolMap[i] != that1.BoolMap[i] {
			return false
		}
	}
	if len(this.StringMap) != len(that1.StringMap) {
		return false
	}
	for i := range this.StringMap {
		if this.StringMap[i] != that1.StringMap[i] {
			return false
		}
	}
	if len(this.StringToBytesMap) != len(that1.StringToBytesMap) {
		return false
	}
	for i := range this.StringToBytesMap {
		if !bytes.Equal(this.StringToBytesMap[i], that1.StringToBytesMap[i]) {
			return false
		}
	}
	if len(this.StringToEnumMap) != len(that1.StringToEnumMap) {
		return false
	}
	for i := range this.StringToEnumMap {
		if this.StringToEnumMap[i] != that1.StringToEnumMap[i] {
			return false
		}
	}
	if len(this.StringToMsgMap) != len(that1.StringToMsgMap) {
		return false
	}
	for i := range this.StringToMsgMap {
		if !this.StringToMsgMap[i].Equal(that1.StringToMsgMap[i]) {
			return false
		}
	}
	return true
}
func (this *AllMapsOrdered) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AllMapsOrdered)
	if !ok {
		that2, ok := that.(AllMapsOrdered)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AllMapsOrdered")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AllMapsOrdered but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AllMapsOrdered but is not nil && this == nil")
	}
	if len(this.StringToDoubleMap) != len(that1.StringToDoubleMap) {
		return fmt.Errorf("StringToDoubleMap this(%v) Not Equal that(%v)", len(this.StringToDoubleMap), len(that1.StringToDoubleMap))
	}
	for i := range this.StringToDoubleMap {
		if this.StringToDoubleMap[i] != that1.StringToDoubleMap[i] {
			return fmt.Errorf("StringToDoubleMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToDoubleMap[i], i, that1.StringToDoubleMap[i])
		}
	}
	if len(this.StringToFloatMap) != len(that1.StringToFloatMap) {
		return fmt.Errorf("StringToFloatMap this(%v) Not Equal that(%v)", len(this.StringToFloatMap), len(that1.StringToFloatMap))
	}
	for i := range this.StringToFloatMap {
		if this.StringToFloatMap[i] != that1.StringToFloatMap[i] {
			return fmt.Errorf("StringToFloatMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToFloatMap[i], i, that1.StringToFloatMap[i])
		}
	}
	if len(this.Int32Map) != len(that1.Int32Map) {
		return fmt.Errorf("Int32Map this(%v) Not Equal that(%v)", len(this.Int32Map), len(that1.Int32Map))
	}
	for i := range this.Int32Map {
		if this.Int32Map[i] != that1.Int32Map[i] {
			return fmt.Errorf("Int32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Int32Map[i], i, that1.Int32Map[i])
		}
	}
	if len(this.Int64Map) != len(that1.Int64Map) {
		return fmt.Errorf("Int64Map this(%v) Not Equal that(%v)", len(this.Int64Map), len(that1.Int64Map))
	}
	for i := range this.Int64Map {
		if this.Int64Map[i] != that1.Int64Map[i] {
			return fmt.Errorf("Int64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Int64Map[i], i, that1.Int64Map[i])
		}
	}
	if len(this.Uint32Map) != len(that1.Uint32Map) {
		return fmt.Errorf("Uint32Map this(%v) Not Equal that(%v)", len(this.Uint32Map), len(that1.Uint32Map))
	}
	for i := range this.Uint32Map {
		if this.Uint32Map[i] != that1.Uint32Map[i] {
			return fmt.Errorf("Uint32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Uint32Map[i], i, that1.Uint32Map[i])
		}
	}
	if len(this.Uint64Map) != len(that1.Uint64Map) {
		return fmt.Errorf("Uint64Map this(%v) Not Equal that(%v)", len(this.Uint64Map), len(that1.Uint64Map))
	}
	for i := range this.Uint64Map {
		if this.Uint64Map[i] != that1.Uint64Map[i] {
			return fmt.Errorf("Uint64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Uint64Map[i], i, that1.Uint64Map[i])
		}
	}
	if len(this.Sint32Map) != len(that1.Sint32Map) {
		return fmt.Errorf("Sint32Map this(%v) Not Equal that(%v)", len(this.Sint32Map), len(that1.Sint32Map))
	}
	for i := range this.Sint32Map {
		if this.Sint32Map[i] != that1.Sint32Map[i] {
			return fmt.Errorf("Sint32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sint32Map[i], i, that1.Sint32Map[i])
		}
	}
	if len(this.Sint64Map) != len(that1.Sint64Map) {
		return fmt.Errorf("Sint64Map this(%v) Not Equal that(%v)", len(this.Sint64Map), len(that1.Sint64Map))
	}
	for i := range this.Sint64Map {
		if this.Sint64Map[i] != that1.Sint64Map[i] {
			return fmt.Errorf("Sint64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sint64Map[i], i, that1.Sint64Map[i])
		}
	}
	if len(this.Fixed32Map) != len(that1.Fixed32Map) {
		return fmt.Errorf("Fixed32Map this(%v) Not Equal that(%v)", len(this.Fixed32Map), len(that1.Fixed32Map))
	}
	for i := range this.Fixed32Map {
		if this.Fixed32Map[i] != that1.Fixed32Map[i] {
			return fmt.Errorf("Fixed32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Fixed32Map[i], i, that1.Fixed32Map[i])
		}
	}
	if len(this.Sfixed32Map) != len(that1.Sfixed32Map) {
		return fmt.Errorf("Sfixed32Map this(%v) Not Equal that(%v)", len(this.Sfixed32Map), len(that1.Sfixed32Map))
	}
	for i := range this.Sfixed32Map {
		if this.Sfixed32Map[i] != that1.Sfixed32Map[i] {
			return fmt.Errorf("Sfixed32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sfixed32Map[i], i, that1.Sfixed32Map[i])
		}
	}
	if len(this.Fixed64Map) != len(that1.Fixed64Map) {
		return fmt.Errorf("Fixed64Map this(%v) Not Equal that(%v)", len(this.Fixed64Map), len(that1.Fixed64Map))
	}
	for i := range this.Fixed64Map {
		if this.Fixed64Map[i] != that1.Fixed64Map[i] {
			return fmt.Errorf("Fixed64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Fixed64Map[i], i, that1.Fixed64Map[i])
		}
	}
	if len(this.Sfixed64Map) != len(that1.Sfixed64Map) {
		return fmt.Errorf("Sfixed64Map this(%v) Not Equal that(%v)", len(this.Sfixed64Map), len(that1.Sfixed64Map))
	}
	for i := range this.Sfixed64Map {
		if this.Sfixed64Map[i] != that1.Sfixed64Map[i] {
			return fmt.Errorf("Sfixed64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sfixed64Map[i], i, that1.Sfixed64Map[i])
		}
	}
	if len(this.BoolMap) != len(that1.BoolMap) {
		return fmt.Errorf("BoolMap this(%v) Not Equal that(%v)", len(this.BoolMap), len(that1.BoolMap))
	}
	for i := range this.BoolMap {
		if this.BoolMap[i] != that1.BoolMap[i] {
			return fmt.Errorf("BoolMap this[%v](%v) Not Equal that[%v](%v)", i, this.BoolMap[i], i, that1.BoolMap[i])
		}
	}
	if len(this.StringMap) != len(that1.StringMap) {
		return fmt.Errorf("StringMap this(%v) Not Equal that(%v)", len(this.StringMap), len(that1.StringMap))
	}
	for i := range this.StringMap {
		if this.StringMap[i] != that1.StringMap[i] {
			return fmt.Errorf("StringMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringMap[i], i, that1.StringMap[i])
		}
	}
	if len(this.StringToBytesMap) != len(that1.StringToBytesMap) {
		return fmt.Errorf("StringToBytesMap this(%v) Not Equal that(%v)", len(this.StringToBytesMap), len(that1.StringToBytesMap))
	}
	for i := range this.StringToBytesMap {
		if !bytes.Equal(this.StringToBytesMap[i], that1.StringToBytesMap[i]) {
			return fmt.Errorf("StringToBytesMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToBytesMap[i], i, that1.StringToBytesMap[i])
		}
	}
	if len(this.StringToEnumMap) != len(that1.StringToEnumMap) {
		return fmt.Errorf("StringToEnumMap this(%v) Not Equal that(%v)", len(this.StringToEnumMap), len(that1.StringToEnumMap))
	}
	for i := range this.StringToEnumMap {
		if this.StringToEnumMap[i] != that1.StringToEnumMap[i] {
			return fmt.Errorf("StringToEnumMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToEnumMap[i], i, that1.StringToEnumMap[i])
		}
	}
	if len(this.StringToMsgMap) != len(that1.StringToMsgMap) {
		return fmt.Errorf("StringToMsgMap this(%v) Not Equal that(%v)", len(this.StringToMsgMap), len(that1.StringToMsgMap))
	}
	for i := range this.StringToMsgMap {
		if !this.StringToMsgMap[i].Equal(that1.StringToMsgMap[i]) {
			return fmt.Errorf("StringToMsgMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToMsgMap[i], i, that1.StringToMsgMap[i])
		}
	}
	return nil
}
func (this *AllMapsOrdered) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AllMapsOrdered)
	if !ok {
		that2, ok := that.(AllMapsOrdered)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.StringToDoubleMap) != len(that1.StringToDoubleMap) {
		return false
	}
	for i := range this.StringToDoubleMap {
		if this.StringToDoubleMap[i] != that1.StringToDoubleMap[i] {
			return false
		}
	}
	if len(this.StringToFloatMap) != len(that1.StringToFloatMap) {
		return false
	}
	for i := range this.StringToFloatMap {
		if this.StringToFloatMap[i] != that1.StringToFloatMap[i] {
			return false
		}
	}
	if len(this.Int32Map) != len(that1.Int32Map) {
		return false
	}
	for i := range this.Int32Map {
		if this.Int32Map[i] != that1.Int32Map[i] {
			return false
		}
	}
	if len(this.Int64Map) != len(that1.Int64Map) {
		return false
	}
	for i := range this.Int64Map {
		if this.Int64Map[i] != that1.Int64Map[i] {
			return false
		}
	}
	if len(this.Uint32Map) != len(that1.Uint32Map) {
		return false
	}
	for i := range this.Uint32Map {
		if this.Uint32Map[i] != that1.Uint32Map[i] {
			return false
		}
	}
	if len(this.Uint64Map) != len(that1.Uint64Map) {
		return false
	}
	for i := range this.Uint64Map {
		if this.Uint64Map[i] != that1.Uint64Map[i] {
			return false
		}
	}
	if len(this.Sint32Map) != len(that1.Sint32Map) {
		return false
	}
	for i := range this.Sint32Map {
		if this.Sint32Map[i] != that1.Sint32Map[i] {
			return false
		}
	}
	if len(this.Sint64Map) != len(that1.Sint64Map) {
		return false
	}
	for i := range this.Sint64Map {
		if this.Sint64Map[i] != that1.Sint64Map[i] {
			return false
		}
	}
	if len(this.Fixed32Map) != len(that1.Fixed32Map) {
		return false
	}
	for i := range this.Fixed32Map {
		if this.Fixed32Map[i] != that1.Fixed32Map[i] {
			return false
		}
	}
	if len(this.Sfixed32Map) != len(that1.Sfixed32Map) {
		return false
	}
	for i := range this.Sfixed32Map {
		if this.Sfixed32Map[i] != that1.Sfixed32Map[i] {
			return false
		}
	}
	if len(this.Fixed64Map) != len(that1.Fixed64Map) {
		return false
	}
	for i := range this.Fixed64Map {
		if this.Fixed64Map[i] != that1.Fixed64Map[i] {
			return false
		}
	}
	if len(this.Sfixed64Map) != len(that1.Sfixed64Map) {
		return false
	}
	for i := range this.Sfixed64Map {
		if this.Sfixed64Map[i] != that1.Sfixed64Map[i] {
			return false
		}
	}
	if len(this.BoolMap) != len(that1.BoolMap) {
		return false
	}
	for i := range this.BoolMap {
		if this.BoolMap[i] != that1.BoolMap[i] {
			return false
		}
	}
	if len(this.StringMap) != len(that1.StringMap) {
		return false
	}
	for i := range this.StringMap {
		if this.StringMap[i] != that1.StringMap[i] {
			return false
		}
	}
	if len(this.StringToBytesMap) != len(that1.StringToBytesMap) {
		return false
	}
	for i := range this.StringToBytesMap {
		if !bytes.Equal(this.StringToBytesMap[i], that1.StringToBytesMap[i]) {
			return false
		}
	}
	if len(this.StringToEnumMap) != len(that1.StringToEnumMap) {
		return false
	}
	for i := range this.StringToEnumMap {
		if this.StringToEnumMap[i] != that1.StringToEnumMap[i] {
			return false
		}
	}
	if len(this.StringToMsgMap) != len(that1.StringToMsgMap) {
		return false
	}
	for i := range this.StringToMsgMap {
		if !this.StringToMsgMap[i].Equal(that1.StringToMsgMap[i]) {
			return false
		}
	}
	return true
}
func (this *MessageWithMap) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MessageWithMap)
	if !ok {
		that2, ok := that.(MessageWithMap)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MessageWithMap")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MessageWithMap but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MessageWithMap but is not nil && this == nil")
	}
	if len(this.NameMapping) != len(that1.NameMapping) {
		return fmt.Errorf("NameMapping this(%v) Not Equal that(%v)", len(this.NameMapping), len(that1.NameMapping))
	}
	for i := range this.NameMapping {
		if this.NameMapping[i] != that1.NameMapping[i] {
			return fmt.Errorf("NameMapping this[%v](%v) Not Equal that[%v](%v)", i, this.NameMapping[i], i, that1.NameMapping[i])
		}
	}
	if len(this.MsgMapping) != len(that1.MsgMapping) {
		return fmt.Errorf("MsgMapping this(%v) Not Equal that(%v)", len(this.MsgMapping), len(that1.MsgMapping))
	}
	for i := range this.MsgMapping {
		if !this.MsgMapping[i].Equal(that1.MsgMapping[i]) {
			return fmt.Errorf("MsgMapping this[%v](%v) Not Equal that[%v](%v)", i, this.MsgMapping[i], i, that1.MsgMapping[i])
		}
	}
	if len(this.ByteMapping) != len(that1.ByteMapping) {
		return fmt.Errorf("ByteMapping this(%v) Not Equal that(%v)", len(this.ByteMapping), len(that1.ByteMapping))
	}
	for i := range this.ByteMapping {
		if !bytes.Equal(this.ByteMapping[i], that1.ByteMapping[i]) {
			return fmt.Errorf("ByteMapping this[%v](%v) Not Equal that[%v](%v)", i, this.ByteMapping[i], i, that1.ByteMapping[i])
		}
	}
	return nil
}
func (this *MessageWithMap) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MessageWithMap)
	if !ok {
		that2, ok := that.(MessageWithMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.NameMapping) != len(that1.NameMapping) {
		return false
	}
	for i := range this.NameMapping {
		if this.NameMapping[i] != that1.NameMapping[i] {
			return false
		}
	}
	if len(this.MsgMapping) != len(that1.MsgMapping) {
		return false
	}
	for i := range this.MsgMapping {
		if !this.MsgMapping[i].Equal(that1.MsgMapping[i]) {
			return false
		}
	}
	if len(this.ByteMapping) != len(that1.ByteMapping) {
		return false
	}
	for i := range this.ByteMapping {
		if !bytes.Equal(this.ByteMapping[i], that1.ByteMapping[i]) {
			return false
		}
	}
	return true
}
func (this *FloatingPoint) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FloatingPoint)
	if !ok {
		that2, ok := that.(FloatingPoint)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FloatingPoint")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FloatingPoint but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FloatingPoint but is not nil && this == nil")
	}
	if this.F != that1.F {
		return fmt.Errorf("F this(%v) Not Equal that(%v)", this.F, that1.F)
	}
	return nil
}
func (this *FloatingPoint) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FloatingPoint)
	if !ok {
		that2, ok := that.(FloatingPoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.F != that1.F {
		return false
	}
	return true
}
func (this *Uint128Pair) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Uint128Pair)
	if !ok {
		that2, ok := that.(Uint128Pair)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Uint128Pair")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Uint128Pair but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Uint128Pair but is not nil && this == nil")
	}
	if !this.Left.Equal(that1.Left) {
		return fmt.Errorf("Left this(%v) Not Equal that(%v)", this.Left, that1.Left)
	}
	if that1.Right == nil {
		if this.Right != nil {
			return fmt.Errorf("this.Right != nil && that1.Right == nil")
		}
	} else if !this.Right.Equal(*that1.Right) {
		return fmt.Errorf("Right this(%v) Not Equal that(%v)", this.Right, that1.Right)
	}
	return nil
}
func (this *Uint128Pair) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Uint128Pair)
	if !ok {
		that2, ok := that.(Uint128Pair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Left.Equal(that1.Left) {
		return false
	}
	if that1.Right == nil {
		if this.Right != nil {
			return false
		}
	} else if !this.Right.Equal(*that1.Right) {
		return false
	}
	return true
}
func (this *ContainsNestedMap) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainsNestedMap)
	if !ok {
		that2, ok := that.(ContainsNestedMap)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainsNestedMap")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainsNestedMap but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainsNestedMap but is not nil && this == nil")
	}
	return nil
}
func (this *ContainsNestedMap) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainsNestedMap)
	if !ok {
		that2, ok := that.(ContainsNestedMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}
func (this *ContainsNestedMap_NestedMap) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainsNestedMap_NestedMap)
	if !ok {
		that2, ok := that.(ContainsNestedMap_NestedMap)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainsNestedMap_NestedMap")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainsNestedMap_NestedMap but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainsNestedMap_NestedMap but is not nil && this == nil")
	}
	if len(this.NestedMapField) != len(that1.NestedMapField) {
		return fmt.Errorf("NestedMapField this(%v) Not Equal that(%v)", len(this.NestedMapField), len(that1.NestedMapField))
	}
	for i := range this.NestedMapField {
		if this.NestedMapField[i] != that1.NestedMapField[i] {
			return fmt.Errorf("NestedMapField this[%v](%v) Not Equal that[%v](%v)", i, this.NestedMapField[i], i, that1.NestedMapField[i])
		}
	}
	return nil
}
func (this *ContainsNestedMap_NestedMap) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ContainsNestedMap_NestedMap)
	if !ok {
		that2, ok := that.(ContainsNestedMap_NestedMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.NestedMapField) != len(that1.NestedMapField) {
		return false
	}
	for i := range this.NestedMapField {
		if this.NestedMapField[i] != that1.NestedMapField[i] {
			return false
		}
	}
	return true
}

type MessageFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetName() string
	GetHilarity() Message_Humour
	GetHeightInCm() uint32
	GetData() []byte
	GetResultCount() int64
	GetTrueScotsman() bool
	GetScore() float32
	GetKey() []uint64
	GetNested() *Nested
	GetTerrain() map[int64]*Nested
	GetProto2Field() *test.NinOptNative
	GetProto2Value() map[int64]*test.NinOptEnum
}

func (this *Message) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *Message) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewMessageFromFace(this)
}

func (this *Message) GetName() string {
	return this.Name
}

func (this *Message) GetHilarity() Message_Humour {
	return this.Hilarity
}

func (this *Message) GetHeightInCm() uint32 {
	return this.HeightInCm
}

func (this *Message) GetData() []byte {
	return this.Data
}

func (this *Message) GetResultCount() int64 {
	return this.ResultCount
}

func (this *Message) GetTrueScotsman() bool {
	return this.TrueScotsman
}

func (this *Message) GetScore() float32 {
	return this.Score
}

func (this *Message) GetKey() []uint64 {
	return this.Key
}

func (this *Message) GetNested() *Nested {
	return this.Nested
}

func (this *Message) GetTerrain() map[int64]*Nested {
	return this.Terrain
}

func (this *Message) GetProto2Field() *test.NinOptNative {
	return this.Proto2Field
}

func (this *Message) GetProto2Value() map[int64]*test.NinOptEnum {
	return this.Proto2Value
}

func NewMessageFromFace(that MessageFace) *Message {
	this := &Message{}
	this.Name = that.GetName()
	this.Hilarity = that.GetHilarity()
	this.HeightInCm = that.GetHeightInCm()
	this.Data = that.GetData()
	this.ResultCount = that.GetResultCount()
	this.TrueScotsman = that.GetTrueScotsman()
	this.Score = that.GetScore()
	this.Key = that.GetKey()
	this.Nested = that.GetNested()
	this.Terrain = that.GetTerrain()
	this.Proto2Field = that.GetProto2Field()
	this.Proto2Value = that.GetProto2Value()
	return this
}

type NestedFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetBunny() string
}

func (this *Nested) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *Nested) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewNestedFromFace(this)
}

func (this *Nested) GetBunny() string {
	return this.Bunny
}

func NewNestedFromFace(that NestedFace) *Nested {
	this := &Nested{}
	this.Bunny = that.GetBunny()
	return this
}

type AllMapsFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetStringToDoubleMap() map[string]float64
	GetStringToFloatMap() map[string]float32
	GetInt32Map() map[int32]int32
	GetInt64Map() map[int64]int64
	GetUint32Map() map[uint32]uint32
	GetUint64Map() map[uint64]uint64
	GetSint32Map() map[int32]int32
	GetSint64Map() map[int64]int64
	GetFixed32Map() map[uint32]uint32
	GetSfixed32Map() map[int32]int32
	GetFixed64Map() map[uint64]uint64
	GetSfixed64Map() map[int64]int64
	GetBoolMap() map[bool]bool
	GetStringMap() map[string]string
	GetStringToBytesMap() map[string][]byte
	GetStringToEnumMap() map[string]MapEnum
	GetStringToMsgMap() map[string]*FloatingPoint
}

func (this *AllMaps) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *AllMaps) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewAllMapsFromFace(this)
}

func (this *AllMaps) GetStringToDoubleMap() map[string]float64 {
	return this.StringToDoubleMap
}

func (this *AllMaps) GetStringToFloatMap() map[string]float32 {
	return this.StringToFloatMap
}

func (this *AllMaps) GetInt32Map() map[int32]int32 {
	return this.Int32Map
}

func (this *AllMaps) GetInt64Map() map[int64]int64 {
	return this.Int64Map
}

func (this *AllMaps) GetUint32Map() map[uint32]uint32 {
	return this.Uint32Map
}

func (this *AllMaps) GetUint64Map() map[uint64]uint64 {
	return this.Uint64Map
}

func (this *AllMaps) GetSint32Map() map[int32]int32 {
	return this.Sint32Map
}

func (this *AllMaps) GetSint64Map() map[int64]int64 {
	return this.Sint64Map
}

func (this *AllMaps) GetFixed32Map() map[uint32]uint32 {
	return this.Fixed32Map
}

func (this *AllMaps) GetSfixed32Map() map[int32]int32 {
	return this.Sfixed32Map
}

func (this *AllMaps) GetFixed64Map() map[uint64]uint64 {
	return this.Fixed64Map
}

func (this *AllMaps) GetSfixed64Map() map[int64]int64 {
	return this.Sfixed64Map
}

func (this *AllMaps) GetBoolMap() map[bool]bool {
	return this.BoolMap
}

func (this *AllMaps) GetStringMap() map[string]string {
	return this.StringMap
}

func (this *AllMaps) GetStringToBytesMap() map[string][]byte {
	return this.StringToBytesMap
}

func (this *AllMaps) GetStringToEnumMap() map[string]MapEnum {
	return this.StringToEnumMap
}

func (this *AllMaps) GetStringToMsgMap() map[string]*FloatingPoint {
	return this.StringToMsgMap
}

func NewAllMapsFromFace(that AllMapsFace) *AllMaps {
	this := &AllMaps{}
	this.StringToDoubleMap = that.GetStringToDoubleMap()
	this.StringToFloatMap = that.GetStringToFloatMap()
	this.Int32Map = that.GetInt32Map()
	this.Int64Map = that.GetInt64Map()
	this.Uint32Map = that.GetUint32Map()
	this.Uint64Map = that.GetUint64Map()
	this.Sint32Map = that.GetSint32Map()
	this.Sint64Map = that.GetSint64Map()
	this.Fixed32Map = that.GetFixed32Map()
	this.Sfixed32Map = that.GetSfixed32Map()
	this.Fixed64Map = that.GetFixed64Map()
	this.Sfixed64Map = that.GetSfixed64Map()
	this.BoolMap = that.GetBoolMap()
	this.StringMap = that.GetStringMap()
	this.StringToBytesMap = that.GetStringToBytesMap()
	this.StringToEnumMap = that.GetStringToEnumMap()
	this.StringToMsgMap = that.GetStringToMsgMap()
	return this
}

type AllMapsOrderedFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetStringToDoubleMap() map[string]float64
	GetStringToFloatMap() map[string]float32
	GetInt32Map() map[int32]int32
	GetInt64Map() map[int64]int64
	GetUint32Map() map[uint32]uint32
	GetUint64Map() map[uint64]uint64
	GetSint32Map() map[int32]int32
	GetSint64Map() map[int64]int64
	GetFixed32Map() map[uint32]uint32
	GetSfixed32Map() map[int32]int32
	GetFixed64Map() map[uint64]uint64
	GetSfixed64Map() map[int64]int64
	GetBoolMap() map[bool]bool
	GetStringMap() map[string]string
	GetStringToBytesMap() map[string][]byte
	GetStringToEnumMap() map[string]MapEnum
	GetStringToMsgMap() map[string]*FloatingPoint
}

func (this *AllMapsOrdered) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *AllMapsOrdered) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewAllMapsOrderedFromFace(this)
}

func (this *AllMapsOrdered) GetStringToDoubleMap() map[string]float64 {
	return this.StringToDoubleMap
}

func (this *AllMapsOrdered) GetStringToFloatMap() map[string]float32 {
	return this.StringToFloatMap
}

func (this *AllMapsOrdered) GetInt32Map() map[int32]int32 {
	return this.Int32Map
}

func (this *AllMapsOrdered) GetInt64Map() map[int64]int64 {
	return this.Int64Map
}

func (this *AllMapsOrdered) GetUint32Map() map[uint32]uint32 {
	return this.Uint32Map
}

func (this *AllMapsOrdered) GetUint64Map() map[uint64]uint64 {
	return this.Uint64Map
}

func (this *AllMapsOrdered) GetSint32Map() map[int32]int32 {
	return this.Sint32Map
}

func (this *AllMapsOrdered) GetSint64Map() map[int64]int64 {
	return this.Sint64Map
}

func (this *AllMapsOrdered) GetFixed32Map() map[uint32]uint32 {
	return this.Fixed32Map
}

func (this *AllMapsOrdered) GetSfixed32Map() map[int32]int32 {
	return this.Sfixed32Map
}

func (this *AllMapsOrdered) GetFixed64Map() map[uint64]uint64 {
	return this.Fixed64Map
}

func (this *AllMapsOrdered) GetSfixed64Map() map[int64]int64 {
	return this.Sfixed64Map
}

func (this *AllMapsOrdered) GetBoolMap() map[bool]bool {
	return this.BoolMap
}

func (this *AllMapsOrdered) GetStringMap() map[string]string {
	return this.StringMap
}

func (this *AllMapsOrdered) GetStringToBytesMap() map[string][]byte {
	return this.StringToBytesMap
}

func (this *AllMapsOrdered) GetStringToEnumMap() map[string]MapEnum {
	return this.StringToEnumMap
}

func (this *AllMapsOrdered) GetStringToMsgMap() map[string]*FloatingPoint {
	return this.StringToMsgMap
}

func NewAllMapsOrderedFromFace(that AllMapsOrderedFace) *AllMapsOrdered {
	this := &AllMapsOrdered{}
	this.StringToDoubleMap = that.GetStringToDoubleMap()
	this.StringToFloatMap = that.GetStringToFloatMap()
	this.Int32Map = that.GetInt32Map()
	this.Int64Map = that.GetInt64Map()
	this.Uint32Map = that.GetUint32Map()
	this.Uint64Map = that.GetUint64Map()
	this.Sint32Map = that.GetSint32Map()
	this.Sint64Map = that.GetSint64Map()
	this.Fixed32Map = that.GetFixed32Map()
	this.Sfixed32Map = that.GetSfixed32Map()
	this.Fixed64Map = that.GetFixed64Map()
	this.Sfixed64Map = that.GetSfixed64Map()
	this.BoolMap = that.GetBoolMap()
	this.StringMap = that.GetStringMap()
	this.StringToBytesMap = that.GetStringToBytesMap()
	this.StringToEnumMap = that.GetStringToEnumMap()
	this.StringToMsgMap = that.GetStringToMsgMap()
	return this
}

type MessageWithMapFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetNameMapping() map[int32]string
	GetMsgMapping() map[int64]*FloatingPoint
	GetByteMapping() map[bool][]byte
}

func (this *MessageWithMap) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *MessageWithMap) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewMessageWithMapFromFace(this)
}

func (this *MessageWithMap) GetNameMapping() map[int32]string {
	return this.NameMapping
}

func (this *MessageWithMap) GetMsgMapping() map[int64]*FloatingPoint {
	return this.MsgMapping
}

func (this *MessageWithMap) GetByteMapping() map[bool][]byte {
	return this.ByteMapping
}

func NewMessageWithMapFromFace(that MessageWithMapFace) *MessageWithMap {
	this := &MessageWithMap{}
	this.NameMapping = that.GetNameMapping()
	this.MsgMapping = that.GetMsgMapping()
	this.ByteMapping = that.GetByteMapping()
	return this
}

type FloatingPointFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetF() float64
}

func (this *FloatingPoint) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *FloatingPoint) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewFloatingPointFromFace(this)
}

func (this *FloatingPoint) GetF() float64 {
	return this.F
}

func NewFloatingPointFromFace(that FloatingPointFace) *FloatingPoint {
	this := &FloatingPoint{}
	this.F = that.GetF()
	return this
}

type Uint128PairFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetLeft() github_com_gogo_protobuf_test_custom.Uint128
	GetRight() *github_com_gogo_protobuf_test_custom.Uint128
}

func (this *Uint128Pair) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *Uint128Pair) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewUint128PairFromFace(this)
}

func (this *Uint128Pair) GetLeft() github_com_gogo_protobuf_test_custom.Uint128 {
	return this.Left
}

func (this *Uint128Pair) GetRight() *github_com_gogo_protobuf_test_custom.Uint128 {
	return this.Right
}

func NewUint128PairFromFace(that Uint128PairFace) *Uint128Pair {
	this := &Uint128Pair{}
	this.Left = that.GetLeft()
	this.Right = that.GetRight()
	return this
}

type ContainsNestedMapFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
}

func (this *ContainsNestedMap) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *ContainsNestedMap) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewContainsNestedMapFromFace(this)
}

func NewContainsNestedMapFromFace(that ContainsNestedMapFace) *ContainsNestedMap {
	this := &ContainsNestedMap{}
	return this
}

type ContainsNestedMap_NestedMapFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetNestedMapField() map[string]float64
}

func (this *ContainsNestedMap_NestedMap) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *ContainsNestedMap_NestedMap) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewContainsNestedMap_NestedMapFromFace(this)
}

func (this *ContainsNestedMap_NestedMap) GetNestedMapField() map[string]float64 {
	return this.NestedMapField
}

func NewContainsNestedMap_NestedMapFromFace(that ContainsNestedMap_NestedMapFace) *ContainsNestedMap_NestedMap {
	this := &ContainsNestedMap_NestedMap{}
	this.NestedMapField = that.GetNestedMapField()
	return this
}

func (this *Message) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&theproto3.Message{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Hilarity: "+fmt.Sprintf("%#v", this.Hilarity)+",\n")
	s = append(s, "HeightInCm: "+fmt.Sprintf("%#v", this.HeightInCm)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "ResultCount: "+fmt.Sprintf("%#v", this.ResultCount)+",\n")
	s = append(s, "TrueScotsman: "+fmt.Sprintf("%#v", this.TrueScotsman)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Nested != nil {
		s = append(s, "Nested: "+fmt.Sprintf("%#v", this.Nested)+",\n")
	}
	keysForTerrain := make([]int64, 0, len(this.Terrain))
	for k := range this.Terrain {
		keysForTerrain = append(keysForTerrain, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForTerrain)
	mapStringForTerrain := "map[int64]*Nested{"
	for _, k := range keysForTerrain {
		mapStringForTerrain += fmt.Sprintf("%#v: %#v,", k, this.Terrain[k])
	}
	mapStringForTerrain += "}"
	if this.Terrain != nil {
		s = append(s, "Terrain: "+mapStringForTerrain+",\n")
	}
	if this.Proto2Field != nil {
		s = append(s, "Proto2Field: "+fmt.Sprintf("%#v", this.Proto2Field)+",\n")
	}
	keysForProto2Value := make([]int64, 0, len(this.Proto2Value))
	for k := range this.Proto2Value {
		keysForProto2Value = append(keysForProto2Value, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForProto2Value)
	mapStringForProto2Value := "map[int64]*test.NinOptEnum{"
	for _, k := range keysForProto2Value {
		mapStringForProto2Value += fmt.Sprintf("%#v: %#v,", k, this.Proto2Value[k])
	}
	mapStringForProto2Value += "}"
	if this.Proto2Value != nil {
		s = append(s, "Proto2Value: "+mapStringForProto2Value+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Nested) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&theproto3.Nested{")
	s = append(s, "Bunny: "+fmt.Sprintf("%#v", this.Bunny)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllMaps) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&theproto3.AllMaps{")
	keysForStringToDoubleMap := make([]string, 0, len(this.StringToDoubleMap))
	for k := range this.StringToDoubleMap {
		keysForStringToDoubleMap = append(keysForStringToDoubleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToDoubleMap)
	mapStringForStringToDoubleMap := "map[string]float64{"
	for _, k := range keysForStringToDoubleMap {
		mapStringForStringToDoubleMap += fmt.Sprintf("%#v: %#v,", k, this.StringToDoubleMap[k])
	}
	mapStringForStringToDoubleMap += "}"
	if this.StringToDoubleMap != nil {
		s = append(s, "StringToDoubleMap: "+mapStringForStringToDoubleMap+",\n")
	}
	keysForStringToFloatMap := make([]string, 0, len(this.StringToFloatMap))
	for k := range this.StringToFloatMap {
		keysForStringToFloatMap = append(keysForStringToFloatMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToFloatMap)
	mapStringForStringToFloatMap := "map[string]float32{"
	for _, k := range keysForStringToFloatMap {
		mapStringForStringToFloatMap += fmt.Sprintf("%#v: %#v,", k, this.StringToFloatMap[k])
	}
	mapStringForStringToFloatMap += "}"
	if this.StringToFloatMap != nil {
		s = append(s, "StringToFloatMap: "+mapStringForStringToFloatMap+",\n")
	}
	keysForInt32Map := make([]int32, 0, len(this.Int32Map))
	for k := range this.Int32Map {
		keysForInt32Map = append(keysForInt32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInt32Map)
	mapStringForInt32Map := "map[int32]int32{"
	for _, k := range keysForInt32Map {
		mapStringForInt32Map += fmt.Sprintf("%#v: %#v,", k, this.Int32Map[k])
	}
	mapStringForInt32Map += "}"
	if this.Int32Map != nil {
		s = append(s, "Int32Map: "+mapStringForInt32Map+",\n")
	}
	keysForInt64Map := make([]int64, 0, len(this.Int64Map))
	for k := range this.Int64Map {
		keysForInt64Map = append(keysForInt64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForInt64Map)
	mapStringForInt64Map := "map[int64]int64{"
	for _, k := range keysForInt64Map {
		mapStringForInt64Map += fmt.Sprintf("%#v: %#v,", k, this.Int64Map[k])
	}
	mapStringForInt64Map += "}"
	if this.Int64Map != nil {
		s = append(s, "Int64Map: "+mapStringForInt64Map+",\n")
	}
	keysForUint32Map := make([]uint32, 0, len(this.Uint32Map))
	for k := range this.Uint32Map {
		keysForUint32Map = append(keysForUint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForUint32Map)
	mapStringForUint32Map := "map[uint32]uint32{"
	for _, k := range keysForUint32Map {
		mapStringForUint32Map += fmt.Sprintf("%#v: %#v,", k, this.Uint32Map[k])
	}
	mapStringForUint32Map += "}"
	if this.Uint32Map != nil {
		s = append(s, "Uint32Map: "+mapStringForUint32Map+",\n")
	}
	keysForUint64Map := make([]uint64, 0, len(this.Uint64Map))
	for k := range this.Uint64Map {
		keysForUint64Map = append(keysForUint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForUint64Map)
	mapStringForUint64Map := "map[uint64]uint64{"
	for _, k := range keysForUint64Map {
		mapStringForUint64Map += fmt.Sprintf("%#v: %#v,", k, this.Uint64Map[k])
	}
	mapStringForUint64Map += "}"
	if this.Uint64Map != nil {
		s = append(s, "Uint64Map: "+mapStringForUint64Map+",\n")
	}
	keysForSint32Map := make([]int32, 0, len(this.Sint32Map))
	for k := range this.Sint32Map {
		keysForSint32Map = append(keysForSint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSint32Map)
	mapStringForSint32Map := "map[int32]int32{"
	for _, k := range keysForSint32Map {
		mapStringForSint32Map += fmt.Sprintf("%#v: %#v,", k, this.Sint32Map[k])
	}
	mapStringForSint32Map += "}"
	if this.Sint32Map != nil {
		s = append(s, "Sint32Map: "+mapStringForSint32Map+",\n")
	}
	keysForSint64Map := make([]int64, 0, len(this.Sint64Map))
	for k := range this.Sint64Map {
		keysForSint64Map = append(keysForSint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSint64Map)
	mapStringForSint64Map := "map[int64]int64{"
	for _, k := range keysForSint64Map {
		mapStringForSint64Map += fmt.Sprintf("%#v: %#v,", k, this.Sint64Map[k])
	}
	mapStringForSint64Map += "}"
	if this.Sint64Map != nil {
		s = append(s, "Sint64Map: "+mapStringForSint64Map+",\n")
	}
	keysForFixed32Map := make([]uint32, 0, len(this.Fixed32Map))
	for k := range this.Fixed32Map {
		keysForFixed32Map = append(keysForFixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFixed32Map)
	mapStringForFixed32Map := "map[uint32]uint32{"
	for _, k := range keysForFixed32Map {
		mapStringForFixed32Map += fmt.Sprintf("%#v: %#v,", k, this.Fixed32Map[k])
	}
	mapStringForFixed32Map += "}"
	if this.Fixed32Map != nil {
		s = append(s, "Fixed32Map: "+mapStringForFixed32Map+",\n")
	}
	keysForSfixed32Map := make([]int32, 0, len(this.Sfixed32Map))
	for k := range this.Sfixed32Map {
		keysForSfixed32Map = append(keysForSfixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSfixed32Map)
	mapStringForSfixed32Map := "map[int32]int32{"
	for _, k := range keysForSfixed32Map {
		mapStringForSfixed32Map += fmt.Sprintf("%#v: %#v,", k, this.Sfixed32Map[k])
	}
	mapStringForSfixed32Map += "}"
	if this.Sfixed32Map != nil {
		s = append(s, "Sfixed32Map: "+mapStringForSfixed32Map+",\n")
	}
	keysForFixed64Map := make([]uint64, 0, len(this.Fixed64Map))
	for k := range this.Fixed64Map {
		keysForFixed64Map = append(keysForFixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForFixed64Map)
	mapStringForFixed64Map := "map[uint64]uint64{"
	for _, k := range keysForFixed64Map {
		mapStringForFixed64Map += fmt.Sprintf("%#v: %#v,", k, this.Fixed64Map[k])
	}
	mapStringForFixed64Map += "}"
	if this.Fixed64Map != nil {
		s = append(s, "Fixed64Map: "+mapStringForFixed64Map+",\n")
	}
	keysForSfixed64Map := make([]int64, 0, len(this.Sfixed64Map))
	for k := range this.Sfixed64Map {
		keysForSfixed64Map = append(keysForSfixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSfixed64Map)
	mapStringForSfixed64Map := "map[int64]int64{"
	for _, k := range keysForSfixed64Map {
		mapStringForSfixed64Map += fmt.Sprintf("%#v: %#v,", k, this.Sfixed64Map[k])
	}
	mapStringForSfixed64Map += "}"
	if this.Sfixed64Map != nil {
		s = append(s, "Sfixed64Map: "+mapStringForSfixed64Map+",\n")
	}
	keysForBoolMap := make([]bool, 0, len(this.BoolMap))
	for k := range this.BoolMap {
		keysForBoolMap = append(keysForBoolMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForBoolMap)
	mapStringForBoolMap := "map[bool]bool{"
	for _, k := range keysForBoolMap {
		mapStringForBoolMap += fmt.Sprintf("%#v: %#v,", k, this.BoolMap[k])
	}
	mapStringForBoolMap += "}"
	if this.BoolMap != nil {
		s = append(s, "BoolMap: "+mapStringForBoolMap+",\n")
	}
	keysForStringMap := make([]string, 0, len(this.StringMap))
	for k := range this.StringMap {
		keysForStringMap = append(keysForStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringMap)
	mapStringForStringMap := "map[string]string{"
	for _, k := range keysForStringMap {
		mapStringForStringMap += fmt.Sprintf("%#v: %#v,", k, this.StringMap[k])
	}
	mapStringForStringMap += "}"
	if this.StringMap != nil {
		s = append(s, "StringMap: "+mapStringForStringMap+",\n")
	}
	keysForStringToBytesMap := make([]string, 0, len(this.StringToBytesMap))
	for k := range this.StringToBytesMap {
		keysForStringToBytesMap = append(keysForStringToBytesMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToBytesMap)
	mapStringForStringToBytesMap := "map[string][]byte{"
	for _, k := range keysForStringToBytesMap {
		mapStringForStringToBytesMap += fmt.Sprintf("%#v: %#v,", k, this.StringToBytesMap[k])
	}
	mapStringForStringToBytesMap += "}"
	if this.StringToBytesMap != nil {
		s = append(s, "StringToBytesMap: "+mapStringForStringToBytesMap+",\n")
	}
	keysForStringToEnumMap := make([]string, 0, len(this.StringToEnumMap))
	for k := range this.StringToEnumMap {
		keysForStringToEnumMap = append(keysForStringToEnumMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToEnumMap)
	mapStringForStringToEnumMap := "map[string]MapEnum{"
	for _, k := range keysForStringToEnumMap {
		mapStringForStringToEnumMap += fmt.Sprintf("%#v: %#v,", k, this.StringToEnumMap[k])
	}
	mapStringForStringToEnumMap += "}"
	if this.StringToEnumMap != nil {
		s = append(s, "StringToEnumMap: "+mapStringForStringToEnumMap+",\n")
	}
	keysForStringToMsgMap := make([]string, 0, len(this.StringToMsgMap))
	for k := range this.StringToMsgMap {
		keysForStringToMsgMap = append(keysForStringToMsgMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToMsgMap)
	mapStringForStringToMsgMap := "map[string]*FloatingPoint{"
	for _, k := range keysForStringToMsgMap {
		mapStringForStringToMsgMap += fmt.Sprintf("%#v: %#v,", k, this.StringToMsgMap[k])
	}
	mapStringForStringToMsgMap += "}"
	if this.StringToMsgMap != nil {
		s = append(s, "StringToMsgMap: "+mapStringForStringToMsgMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllMapsOrdered) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&theproto3.AllMapsOrdered{")
	keysForStringToDoubleMap := make([]string, 0, len(this.StringToDoubleMap))
	for k := range this.StringToDoubleMap {
		keysForStringToDoubleMap = append(keysForStringToDoubleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToDoubleMap)
	mapStringForStringToDoubleMap := "map[string]float64{"
	for _, k := range keysForStringToDoubleMap {
		mapStringForStringToDoubleMap += fmt.Sprintf("%#v: %#v,", k, this.StringToDoubleMap[k])
	}
	mapStringForStringToDoubleMap += "}"
	if this.StringToDoubleMap != nil {
		s = append(s, "StringToDoubleMap: "+mapStringForStringToDoubleMap+",\n")
	}
	keysForStringToFloatMap := make([]string, 0, len(this.StringToFloatMap))
	for k := range this.StringToFloatMap {
		keysForStringToFloatMap = append(keysForStringToFloatMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToFloatMap)
	mapStringForStringToFloatMap := "map[string]float32{"
	for _, k := range keysForStringToFloatMap {
		mapStringForStringToFloatMap += fmt.Sprintf("%#v: %#v,", k, this.StringToFloatMap[k])
	}
	mapStringForStringToFloatMap += "}"
	if this.StringToFloatMap != nil {
		s = append(s, "StringToFloatMap: "+mapStringForStringToFloatMap+",\n")
	}
	keysForInt32Map := make([]int32, 0, len(this.Int32Map))
	for k := range this.Int32Map {
		keysForInt32Map = append(keysForInt32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInt32Map)
	mapStringForInt32Map := "map[int32]int32{"
	for _, k := range keysForInt32Map {
		mapStringForInt32Map += fmt.Sprintf("%#v: %#v,", k, this.Int32Map[k])
	}
	mapStringForInt32Map += "}"
	if this.Int32Map != nil {
		s = append(s, "Int32Map: "+mapStringForInt32Map+",\n")
	}
	keysForInt64Map := make([]int64, 0, len(this.Int64Map))
	for k := range this.Int64Map {
		keysForInt64Map = append(keysForInt64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForInt64Map)
	mapStringForInt64Map := "map[int64]int64{"
	for _, k := range keysForInt64Map {
		mapStringForInt64Map += fmt.Sprintf("%#v: %#v,", k, this.Int64Map[k])
	}
	mapStringForInt64Map += "}"
	if this.Int64Map != nil {
		s = append(s, "Int64Map: "+mapStringForInt64Map+",\n")
	}
	keysForUint32Map := make([]uint32, 0, len(this.Uint32Map))
	for k := range this.Uint32Map {
		keysForUint32Map = append(keysForUint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForUint32Map)
	mapStringForUint32Map := "map[uint32]uint32{"
	for _, k := range keysForUint32Map {
		mapStringForUint32Map += fmt.Sprintf("%#v: %#v,", k, this.Uint32Map[k])
	}
	mapStringForUint32Map += "}"
	if this.Uint32Map != nil {
		s = append(s, "Uint32Map: "+mapStringForUint32Map+",\n")
	}
	keysForUint64Map := make([]uint64, 0, len(this.Uint64Map))
	for k := range this.Uint64Map {
		keysForUint64Map = append(keysForUint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForUint64Map)
	mapStringForUint64Map := "map[uint64]uint64{"
	for _, k := range keysForUint64Map {
		mapStringForUint64Map += fmt.Sprintf("%#v: %#v,", k, this.Uint64Map[k])
	}
	mapStringForUint64Map += "}"
	if this.Uint64Map != nil {
		s = append(s, "Uint64Map: "+mapStringForUint64Map+",\n")
	}
	keysForSint32Map := make([]int32, 0, len(this.Sint32Map))
	for k := range this.Sint32Map {
		keysForSint32Map = append(keysForSint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSint32Map)
	mapStringForSint32Map := "map[int32]int32{"
	for _, k := range keysForSint32Map {
		mapStringForSint32Map += fmt.Sprintf("%#v: %#v,", k, this.Sint32Map[k])
	}
	mapStringForSint32Map += "}"
	if this.Sint32Map != nil {
		s = append(s, "Sint32Map: "+mapStringForSint32Map+",\n")
	}
	keysForSint64Map := make([]int64, 0, len(this.Sint64Map))
	for k := range this.Sint64Map {
		keysForSint64Map = append(keysForSint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSint64Map)
	mapStringForSint64Map := "map[int64]int64{"
	for _, k := range keysForSint64Map {
		mapStringForSint64Map += fmt.Sprintf("%#v: %#v,", k, this.Sint64Map[k])
	}
	mapStringForSint64Map += "}"
	if this.Sint64Map != nil {
		s = append(s, "Sint64Map: "+mapStringForSint64Map+",\n")
	}
	keysForFixed32Map := make([]uint32, 0, len(this.Fixed32Map))
	for k := range this.Fixed32Map {
		keysForFixed32Map = append(keysForFixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFixed32Map)
	mapStringForFixed32Map := "map[uint32]uint32{"
	for _, k := range keysForFixed32Map {
		mapStringForFixed32Map += fmt.Sprintf("%#v: %#v,", k, this.Fixed32Map[k])
	}
	mapStringForFixed32Map += "}"
	if this.Fixed32Map != nil {
		s = append(s, "Fixed32Map: "+mapStringForFixed32Map+",\n")
	}
	keysForSfixed32Map := make([]int32, 0, len(this.Sfixed32Map))
	for k := range this.Sfixed32Map {
		keysForSfixed32Map = append(keysForSfixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSfixed32Map)
	mapStringForSfixed32Map := "map[int32]int32{"
	for _, k := range keysForSfixed32Map {
		mapStringForSfixed32Map += fmt.Sprintf("%#v: %#v,", k, this.Sfixed32Map[k])
	}
	mapStringForSfixed32Map += "}"
	if this.Sfixed32Map != nil {
		s = append(s, "Sfixed32Map: "+mapStringForSfixed32Map+",\n")
	}
	keysForFixed64Map := make([]uint64, 0, len(this.Fixed64Map))
	for k := range this.Fixed64Map {
		keysForFixed64Map = append(keysForFixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForFixed64Map)
	mapStringForFixed64Map := "map[uint64]uint64{"
	for _, k := range keysForFixed64Map {
		mapStringForFixed64Map += fmt.Sprintf("%#v: %#v,", k, this.Fixed64Map[k])
	}
	mapStringForFixed64Map += "}"
	if this.Fixed64Map != nil {
		s = append(s, "Fixed64Map: "+mapStringForFixed64Map+",\n")
	}
	keysForSfixed64Map := make([]int64, 0, len(this.Sfixed64Map))
	for k := range this.Sfixed64Map {
		keysForSfixed64Map = append(keysForSfixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSfixed64Map)
	mapStringForSfixed64Map := "map[int64]int64{"
	for _, k := range keysForSfixed64Map {
		mapStringForSfixed64Map += fmt.Sprintf("%#v: %#v,", k, this.Sfixed64Map[k])
	}
	mapStringForSfixed64Map += "}"
	if this.Sfixed64Map != nil {
		s = append(s, "Sfixed64Map: "+mapStringForSfixed64Map+",\n")
	}
	keysForBoolMap := make([]bool, 0, len(this.BoolMap))
	for k := range this.BoolMap {
		keysForBoolMap = append(keysForBoolMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForBoolMap)
	mapStringForBoolMap := "map[bool]bool{"
	for _, k := range keysForBoolMap {
		mapStringForBoolMap += fmt.Sprintf("%#v: %#v,", k, this.BoolMap[k])
	}
	mapStringForBoolMap += "}"
	if this.BoolMap != nil {
		s = append(s, "BoolMap: "+mapStringForBoolMap+",\n")
	}
	keysForStringMap := make([]string, 0, len(this.StringMap))
	for k := range this.StringMap {
		keysForStringMap = append(keysForStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringMap)
	mapStringForStringMap := "map[string]string{"
	for _, k := range keysForStringMap {
		mapStringForStringMap += fmt.Sprintf("%#v: %#v,", k, this.StringMap[k])
	}
	mapStringForStringMap += "}"
	if this.StringMap != nil {
		s = append(s, "StringMap: "+mapStringForStringMap+",\n")
	}
	keysForStringToBytesMap := make([]string, 0, len(this.StringToBytesMap))
	for k := range this.StringToBytesMap {
		keysForStringToBytesMap = append(keysForStringToBytesMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToBytesMap)
	mapStringForStringToBytesMap := "map[string][]byte{"
	for _, k := range keysForStringToBytesMap {
		mapStringForStringToBytesMap += fmt.Sprintf("%#v: %#v,", k, this.StringToBytesMap[k])
	}
	mapStringForStringToBytesMap += "}"
	if this.StringToBytesMap != nil {
		s = append(s, "StringToBytesMap: "+mapStringForStringToBytesMap+",\n")
	}
	keysForStringToEnumMap := make([]string, 0, len(this.StringToEnumMap))
	for k := range this.StringToEnumMap {
		keysForStringToEnumMap = append(keysForStringToEnumMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToEnumMap)
	mapStringForStringToEnumMap := "map[string]MapEnum{"
	for _, k := range keysForStringToEnumMap {
		mapStringForStringToEnumMap += fmt.Sprintf("%#v: %#v,", k, this.StringToEnumMap[k])
	}
	mapStringForStringToEnumMap += "}"
	if this.StringToEnumMap != nil {
		s = append(s, "StringToEnumMap: "+mapStringForStringToEnumMap+",\n")
	}
	keysForStringToMsgMap := make([]string, 0, len(this.StringToMsgMap))
	for k := range this.StringToMsgMap {
		keysForStringToMsgMap = append(keysForStringToMsgMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToMsgMap)
	mapStringForStringToMsgMap := "map[string]*FloatingPoint{"
	for _, k := range keysForStringToMsgMap {
		mapStringForStringToMsgMap += fmt.Sprintf("%#v: %#v,", k, this.StringToMsgMap[k])
	}
	mapStringForStringToMsgMap += "}"
	if this.StringToMsgMap != nil {
		s = append(s, "StringToMsgMap: "+mapStringForStringToMsgMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageWithMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&theproto3.MessageWithMap{")
	keysForNameMapping := make([]int32, 0, len(this.NameMapping))
	for k := range this.NameMapping {
		keysForNameMapping = append(keysForNameMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNameMapping)
	mapStringForNameMapping := "map[int32]string{"
	for _, k := range keysForNameMapping {
		mapStringForNameMapping += fmt.Sprintf("%#v: %#v,", k, this.NameMapping[k])
	}
	mapStringForNameMapping += "}"
	if this.NameMapping != nil {
		s = append(s, "NameMapping: "+mapStringForNameMapping+",\n")
	}
	keysForMsgMapping := make([]int64, 0, len(this.MsgMapping))
	for k := range this.MsgMapping {
		keysForMsgMapping = append(keysForMsgMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForMsgMapping)
	mapStringForMsgMapping := "map[int64]*FloatingPoint{"
	for _, k := range keysForMsgMapping {
		mapStringForMsgMapping += fmt.Sprintf("%#v: %#v,", k, this.MsgMapping[k])
	}
	mapStringForMsgMapping += "}"
	if this.MsgMapping != nil {
		s = append(s, "MsgMapping: "+mapStringForMsgMapping+",\n")
	}
	keysForByteMapping := make([]bool, 0, len(this.ByteMapping))
	for k := range this.ByteMapping {
		keysForByteMapping = append(keysForByteMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForByteMapping)
	mapStringForByteMapping := "map[bool][]byte{"
	for _, k := range keysForByteMapping {
		mapStringForByteMapping += fmt.Sprintf("%#v: %#v,", k, this.ByteMapping[k])
	}
	mapStringForByteMapping += "}"
	if this.ByteMapping != nil {
		s = append(s, "ByteMapping: "+mapStringForByteMapping+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FloatingPoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&theproto3.FloatingPoint{")
	s = append(s, "F: "+fmt.Sprintf("%#v", this.F)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Uint128Pair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&theproto3.Uint128Pair{")
	s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainsNestedMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&theproto3.ContainsNestedMap{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainsNestedMap_NestedMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&theproto3.ContainsNestedMap_NestedMap{")
	keysForNestedMapField := make([]string, 0, len(this.NestedMapField))
	for k := range this.NestedMapField {
		keysForNestedMapField = append(keysForNestedMapField, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForNestedMapField)
	mapStringForNestedMapField := "map[string]float64{"
	for _, k := range keysForNestedMapField {
		mapStringForNestedMapField += fmt.Sprintf("%#v: %#v,", k, this.NestedMapField[k])
	}
	mapStringForNestedMapField += "}"
	if this.NestedMapField != nil {
		s = append(s, "NestedMapField: "+mapStringForNestedMapField+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTheproto3(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringTheproto3(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func NewPopulatedMessage(r randyTheproto3, easy bool) *Message {
	this := &Message{}
	this.Name = randStringTheproto3(r)
	this.Hilarity = Message_Humour([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.HeightInCm = uint32(r.Uint32())
	v1 := r.Intn(100)
	this.Data = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	this.ResultCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ResultCount *= -1
	}
	this.TrueScotsman = bool(bool(r.Intn(2) == 0))
	this.Score = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Score *= -1
	}
	v2 := r.Intn(10)
	this.Key = make([]uint64, v2)
	for i := 0; i < v2; i++ {
		this.Key[i] = uint64(uint64(r.Uint32()))
	}
	if r.Intn(10) != 0 {
		this.Nested = NewPopulatedNested(r, easy)
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.Terrain = make(map[int64]*Nested)
		for i := 0; i < v3; i++ {
			this.Terrain[int64(r.Int63())] = NewPopulatedNested(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Proto2Field = test.NewPopulatedNinOptNative(r, easy)
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Proto2Value = make(map[int64]*test.NinOptEnum)
		for i := 0; i < v4; i++ {
			this.Proto2Value[int64(r.Int63())] = test.NewPopulatedNinOptEnum(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNested(r randyTheproto3, easy bool) *Nested {
	this := &Nested{}
	this.Bunny = randStringTheproto3(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAllMaps(r randyTheproto3, easy bool) *AllMaps {
	this := &AllMaps{}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.StringToDoubleMap = make(map[string]float64)
		for i := 0; i < v5; i++ {
			v6 := randStringTheproto3(r)
			this.StringToDoubleMap[v6] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.StringToDoubleMap[v6] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.StringToFloatMap = make(map[string]float32)
		for i := 0; i < v7; i++ {
			v8 := randStringTheproto3(r)
			this.StringToFloatMap[v8] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.StringToFloatMap[v8] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(10)
		this.Int32Map = make(map[int32]int32)
		for i := 0; i < v9; i++ {
			v10 := int32(r.Int31())
			this.Int32Map[v10] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Int32Map[v10] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(10)
		this.Int64Map = make(map[int64]int64)
		for i := 0; i < v11; i++ {
			v12 := int64(r.Int63())
			this.Int64Map[v12] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Int64Map[v12] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v13 := r.Intn(10)
		this.Uint32Map = make(map[uint32]uint32)
		for i := 0; i < v13; i++ {
			v14 := uint32(r.Uint32())
			this.Uint32Map[v14] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v15 := r.Intn(10)
		this.Uint64Map = make(map[uint64]uint64)
		for i := 0; i < v15; i++ {
			v16 := uint64(uint64(r.Uint32()))
			this.Uint64Map[v16] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v17 := r.Intn(10)
		this.Sint32Map = make(map[int32]int32)
		for i := 0; i < v17; i++ {
			v18 := int32(r.Int31())
			this.Sint32Map[v18] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Sint32Map[v18] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(10)
		this.Sint64Map = make(map[int64]int64)
		for i := 0; i < v19; i++ {
			v20 := int64(r.Int63())
			this.Sint64Map[v20] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Sint64Map[v20] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v21 := r.Intn(10)
		this.Fixed32Map = make(map[uint32]uint32)
		for i := 0; i < v21; i++ {
			v22 := uint32(r.Uint32())
			this.Fixed32Map[v22] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(10)
		this.Sfixed32Map = make(map[int32]int32)
		for i := 0; i < v23; i++ {
			v24 := int32(r.Int31())
			this.Sfixed32Map[v24] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Sfixed32Map[v24] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v25 := r.Intn(10)
		this.Fixed64Map = make(map[uint64]uint64)
		for i := 0; i < v25; i++ {
			v26 := uint64(uint64(r.Uint32()))
			this.Fixed64Map[v26] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v27 := r.Intn(10)
		this.Sfixed64Map = make(map[int64]int64)
		for i := 0; i < v27; i++ {
			v28 := int64(r.Int63())
			this.Sfixed64Map[v28] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Sfixed64Map[v28] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v29 := r.Intn(10)
		this.BoolMap = make(map[bool]bool)
		for i := 0; i < v29; i++ {
			v30 := bool(bool(r.Intn(2) == 0))
			this.BoolMap[v30] = bool(bool(r.Intn(2) == 0))
		}
	}
	if r.Intn(10) != 0 {
		v31 := r.Intn(10)
		this.StringMap = make(map[string]string)
		for i := 0; i < v31; i++ {
			this.StringMap[randStringTheproto3(r)] = randStringTheproto3(r)
		}
	}
	if r.Intn(10) != 0 {
		v32 := r.Intn(10)
		this.StringToBytesMap = make(map[string][]byte)
		for i := 0; i < v32; i++ {
			v33 := r.Intn(100)
			v34 := randStringTheproto3(r)
			this.StringToBytesMap[v34] = make([]byte, v33)
			for i := 0; i < v33; i++ {
				this.StringToBytesMap[v34][i] = byte(r.Intn(256))
			}
		}
	}
	if r.Intn(10) != 0 {
		v35 := r.Intn(10)
		this.StringToEnumMap = make(map[string]MapEnum)
		for i := 0; i < v35; i++ {
			this.StringToEnumMap[randStringTheproto3(r)] = MapEnum([]int32{0, 1, 2}[r.Intn(3)])
		}
	}
	if r.Intn(10) != 0 {
		v36 := r.Intn(10)
		this.StringToMsgMap = make(map[string]*FloatingPoint)
		for i := 0; i < v36; i++ {
			this.StringToMsgMap[randStringTheproto3(r)] = NewPopulatedFloatingPoint(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAllMapsOrdered(r randyTheproto3, easy bool) *AllMapsOrdered {
	this := &AllMapsOrdered{}
	if r.Intn(10) != 0 {
		v37 := r.Intn(10)
		this.StringToDoubleMap = make(map[string]float64)
		for i := 0; i < v37; i++ {
			v38 := randStringTheproto3(r)
			this.StringToDoubleMap[v38] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.StringToDoubleMap[v38] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v39 := r.Intn(10)
		this.StringToFloatMap = make(map[string]float32)
		for i := 0; i < v39; i++ {
			v40 := randStringTheproto3(r)
			this.StringToFloatMap[v40] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.StringToFloatMap[v40] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v41 := r.Intn(10)
		this.Int32Map = make(map[int32]int32)
		for i := 0; i < v41; i++ {
			v42 := int32(r.Int31())
			this.Int32Map[v42] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Int32Map[v42] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v43 := r.Intn(10)
		this.Int64Map = make(map[int64]int64)
		for i := 0; i < v43; i++ {
			v44 := int64(r.Int63())
			this.Int64Map[v44] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Int64Map[v44] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v45 := r.Intn(10)
		this.Uint32Map = make(map[uint32]uint32)
		for i := 0; i < v45; i++ {
			v46 := uint32(r.Uint32())
			this.Uint32Map[v46] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v47 := r.Intn(10)
		this.Uint64Map = make(map[uint64]uint64)
		for i := 0; i < v47; i++ {
			v48 := uint64(uint64(r.Uint32()))
			this.Uint64Map[v48] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v49 := r.Intn(10)
		this.Sint32Map = make(map[int32]int32)
		for i := 0; i < v49; i++ {
			v50 := int32(r.Int31())
			this.Sint32Map[v50] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Sint32Map[v50] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v51 := r.Intn(10)
		this.Sint64Map = make(map[int64]int64)
		for i := 0; i < v51; i++ {
			v52 := int64(r.Int63())
			this.Sint64Map[v52] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Sint64Map[v52] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v53 := r.Intn(10)
		this.Fixed32Map = make(map[uint32]uint32)
		for i := 0; i < v53; i++ {
			v54 := uint32(r.Uint32())
			this.Fixed32Map[v54] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v55 := r.Intn(10)
		this.Sfixed32Map = make(map[int32]int32)
		for i := 0; i < v55; i++ {
			v56 := int32(r.Int31())
			this.Sfixed32Map[v56] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Sfixed32Map[v56] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v57 := r.Intn(10)
		this.Fixed64Map = make(map[uint64]uint64)
		for i := 0; i < v57; i++ {
			v58 := uint64(uint64(r.Uint32()))
			this.Fixed64Map[v58] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v59 := r.Intn(10)
		this.Sfixed64Map = make(map[int64]int64)
		for i := 0; i < v59; i++ {
			v60 := int64(r.Int63())
			this.Sfixed64Map[v60] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Sfixed64Map[v60] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v61 := r.Intn(10)
		this.BoolMap = make(map[bool]bool)
		for i := 0; i < v61; i++ {
			v62 := bool(bool(r.Intn(2) == 0))
			this.BoolMap[v62] = bool(bool(r.Intn(2) == 0))
		}
	}
	if r.Intn(10) != 0 {
		v63 := r.Intn(10)
		this.StringMap = make(map[string]string)
		for i := 0; i < v63; i++ {
			this.StringMap[randStringTheproto3(r)] = randStringTheproto3(r)
		}
	}
	if r.Intn(10) != 0 {
		v64 := r.Intn(10)
		this.StringToBytesMap = make(map[string][]byte)
		for i := 0; i < v64; i++ {
			v65 := r.Intn(100)
			v66 := randStringTheproto3(r)
			this.StringToBytesMap[v66] = make([]byte, v65)
			for i := 0; i < v65; i++ {
				this.StringToBytesMap[v66][i] = byte(r.Intn(256))
			}
		}
	}
	if r.Intn(10) != 0 {
		v67 := r.Intn(10)
		this.StringToEnumMap = make(map[string]MapEnum)
		for i := 0; i < v67; i++ {
			this.StringToEnumMap[randStringTheproto3(r)] = MapEnum([]int32{0, 1, 2}[r.Intn(3)])
		}
	}
	if r.Intn(10) != 0 {
		v68 := r.Intn(10)
		this.StringToMsgMap = make(map[string]*FloatingPoint)
		for i := 0; i < v68; i++ {
			this.StringToMsgMap[randStringTheproto3(r)] = NewPopulatedFloatingPoint(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMessageWithMap(r randyTheproto3, easy bool) *MessageWithMap {
	this := &MessageWithMap{}
	if r.Intn(10) != 0 {
		v69 := r.Intn(10)
		this.NameMapping = make(map[int32]string)
		for i := 0; i < v69; i++ {
			this.NameMapping[int32(r.Int31())] = randStringTheproto3(r)
		}
	}
	if r.Intn(10) != 0 {
		v70 := r.Intn(10)
		this.MsgMapping = make(map[int64]*FloatingPoint)
		for i := 0; i < v70; i++ {
			this.MsgMapping[int64(r.Int63())] = NewPopulatedFloatingPoint(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v71 := r.Intn(10)
		this.ByteMapping = make(map[bool][]byte)
		for i := 0; i < v71; i++ {
			v72 := r.Intn(100)
			v73 := bool(bool(r.Intn(2) == 0))
			this.ByteMapping[v73] = make([]byte, v72)
			for i := 0; i < v72; i++ {
				this.ByteMapping[v73][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedFloatingPoint(r randyTheproto3, easy bool) *FloatingPoint {
	this := &FloatingPoint{}
	this.F = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.F *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUint128Pair(r randyTheproto3, easy bool) *Uint128Pair {
	this := &Uint128Pair{}
	v74 := github_com_gogo_protobuf_test_custom.NewPopulatedUint128(r)
	this.Left = *v74
	this.Right = github_com_gogo_protobuf_test_custom.NewPopulatedUint128(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainsNestedMap(r randyTheproto3, easy bool) *ContainsNestedMap {
	this := &ContainsNestedMap{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedContainsNestedMap_NestedMap(r randyTheproto3, easy bool) *ContainsNestedMap_NestedMap {
	this := &ContainsNestedMap_NestedMap{}
	if r.Intn(10) != 0 {
		v75 := r.Intn(10)
		this.NestedMapField = make(map[string]float64)
		for i := 0; i < v75; i++ {
			v76 := randStringTheproto3(r)
			this.NestedMapField[v76] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.NestedMapField[v76] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTheproto3 interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTheproto3(r randyTheproto3) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTheproto3(r randyTheproto3) string {
	v77 := r.Intn(100)
	tmps := make([]rune, v77)
	for i := 0; i < v77; i++ {
		tmps[i] = randUTF8RuneTheproto3(r)
	}
	return string(tmps)
}
func randUnrecognizedTheproto3(r randyTheproto3, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldTheproto3(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldTheproto3(data []byte, r randyTheproto3, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateTheproto3(data, uint64(key))
		v78 := r.Int63()
		if r.Intn(2) == 0 {
			v78 *= -1
		}
		data = encodeVarintPopulateTheproto3(data, uint64(v78))
	case 1:
		data = encodeVarintPopulateTheproto3(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateTheproto3(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateTheproto3(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateTheproto3(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateTheproto3(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Message) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if m.Hilarity != 0 {
		n += 1 + sovTheproto3(uint64(m.Hilarity))
	}
	if m.HeightInCm != 0 {
		n += 1 + sovTheproto3(uint64(m.HeightInCm))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if m.ResultCount != 0 {
		n += 1 + sovTheproto3(uint64(m.ResultCount))
	}
	if m.TrueScotsman {
		n += 2
	}
	if m.Score != 0 {
		n += 5
	}
	if len(m.Key) > 0 {
		for _, e := range m.Key {
			n += 1 + sovTheproto3(uint64(e))
		}
	}
	if m.Nested != nil {
		l = m.Nested.Size()
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if len(m.Terrain) > 0 {
		for k, v := range m.Terrain {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + l + sovTheproto3(uint64(l))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if m.Proto2Field != nil {
		l = m.Proto2Field.Size()
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if len(m.Proto2Value) > 0 {
		for k, v := range m.Proto2Value {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + l + sovTheproto3(uint64(l))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Nested) Size() (n int) {
	var l int
	_ = l
	l = len(m.Bunny)
	if l > 0 {
		n += 1 + l + sovTheproto3(uint64(l))
	}
	return n
}

func (m *AllMaps) Size() (n int) {
	var l int
	_ = l
	if len(m.StringToDoubleMap) > 0 {
		for k, v := range m.StringToDoubleMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToFloatMap) > 0 {
		for k, v := range m.StringToFloatMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Int32Map) > 0 {
		for k, v := range m.Int32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Int64Map) > 0 {
		for k, v := range m.Int64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Uint32Map) > 0 {
		for k, v := range m.Uint32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Uint64Map) > 0 {
		for k, v := range m.Uint64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sint32Map) > 0 {
		for k, v := range m.Sint32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + sozTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sint64Map) > 0 {
		for k, v := range m.Sint64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + sozTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Fixed32Map) > 0 {
		for k, v := range m.Fixed32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sfixed32Map) > 0 {
		for k, v := range m.Sfixed32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Fixed64Map) > 0 {
		for k, v := range m.Fixed64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sfixed64Map) > 0 {
		for k, v := range m.Sfixed64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.BoolMap) > 0 {
		for k, v := range m.BoolMap {
			_ = k
			_ = v
			mapEntrySize := 1 + 1 + 1 + 1
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringMap) > 0 {
		for k, v := range m.StringMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToBytesMap) > 0 {
		for k, v := range m.StringToBytesMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToEnumMap) > 0 {
		for k, v := range m.StringToEnumMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 2 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToMsgMap) > 0 {
		for k, v := range m.StringToMsgMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + l + sovTheproto3(uint64(l))
			n += mapEntrySize + 2 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AllMapsOrdered) Size() (n int) {
	var l int
	_ = l
	if len(m.StringToDoubleMap) > 0 {
		for k, v := range m.StringToDoubleMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToFloatMap) > 0 {
		for k, v := range m.StringToFloatMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Int32Map) > 0 {
		for k, v := range m.Int32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Int64Map) > 0 {
		for k, v := range m.Int64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Uint32Map) > 0 {
		for k, v := range m.Uint32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Uint64Map) > 0 {
		for k, v := range m.Uint64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sint32Map) > 0 {
		for k, v := range m.Sint32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + sozTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sint64Map) > 0 {
		for k, v := range m.Sint64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + sozTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Fixed32Map) > 0 {
		for k, v := range m.Fixed32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sfixed32Map) > 0 {
		for k, v := range m.Sfixed32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Fixed64Map) > 0 {
		for k, v := range m.Fixed64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sfixed64Map) > 0 {
		for k, v := range m.Sfixed64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.BoolMap) > 0 {
		for k, v := range m.BoolMap {
			_ = k
			_ = v
			mapEntrySize := 1 + 1 + 1 + 1
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringMap) > 0 {
		for k, v := range m.StringMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToBytesMap) > 0 {
		for k, v := range m.StringToBytesMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToEnumMap) > 0 {
		for k, v := range m.StringToEnumMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 2 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToMsgMap) > 0 {
		for k, v := range m.StringToMsgMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + l + sovTheproto3(uint64(l))
			n += mapEntrySize + 2 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MessageWithMap) Size() (n int) {
	var l int
	_ = l
	if len(m.NameMapping) > 0 {
		for k, v := range m.NameMapping {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.MsgMapping) > 0 {
		for k, v := range m.MsgMapping {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + l + sovTheproto3(uint64(l))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.ByteMapping) > 0 {
		for k, v := range m.ByteMapping {
			_ = k
			_ = v
			mapEntrySize := 1 + 1 + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FloatingPoint) Size() (n int) {
	var l int
	_ = l
	if m.F != 0 {
		n += 9
	}
	return n
}

func (m *Uint128Pair) Size() (n int) {
	var l int
	_ = l
	l = m.Left.Size()
	n += 1 + l + sovTheproto3(uint64(l))
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovTheproto3(uint64(l))
	}
	return n
}

func (m *ContainsNestedMap) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ContainsNestedMap_NestedMap) Size() (n int) {
	var l int
	_ = l
	if len(m.NestedMapField) > 0 {
		for k, v := range m.NestedMapField {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	return n
}

func sovTheproto3(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTheproto3(x uint64) (n int) {
	return sovTheproto3(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Message) String() string {
	if this == nil {
		return "nil"
	}
	keysForTerrain := make([]int64, 0, len(this.Terrain))
	for k := range this.Terrain {
		keysForTerrain = append(keysForTerrain, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForTerrain)
	mapStringForTerrain := "map[int64]*Nested{"
	for _, k := range keysForTerrain {
		mapStringForTerrain += fmt.Sprintf("%v: %v,", k, this.Terrain[k])
	}
	mapStringForTerrain += "}"
	keysForProto2Value := make([]int64, 0, len(this.Proto2Value))
	for k := range this.Proto2Value {
		keysForProto2Value = append(keysForProto2Value, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForProto2Value)
	mapStringForProto2Value := "map[int64]*test.NinOptEnum{"
	for _, k := range keysForProto2Value {
		mapStringForProto2Value += fmt.Sprintf("%v: %v,", k, this.Proto2Value[k])
	}
	mapStringForProto2Value += "}"
	s := strings.Join([]string{`&Message{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Hilarity:` + fmt.Sprintf("%v", this.Hilarity) + `,`,
		`HeightInCm:` + fmt.Sprintf("%v", this.HeightInCm) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`ResultCount:` + fmt.Sprintf("%v", this.ResultCount) + `,`,
		`TrueScotsman:` + fmt.Sprintf("%v", this.TrueScotsman) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Nested:` + strings.Replace(fmt.Sprintf("%v", this.Nested), "Nested", "Nested", 1) + `,`,
		`Terrain:` + mapStringForTerrain + `,`,
		`Proto2Field:` + strings.Replace(fmt.Sprintf("%v", this.Proto2Field), "NinOptNative", "test.NinOptNative", 1) + `,`,
		`Proto2Value:` + mapStringForProto2Value + `,`,
		`}`,
	}, "")
	return s
}
func (this *Nested) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Nested{`,
		`Bunny:` + fmt.Sprintf("%v", this.Bunny) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllMaps) String() string {
	if this == nil {
		return "nil"
	}
	keysForStringToDoubleMap := make([]string, 0, len(this.StringToDoubleMap))
	for k := range this.StringToDoubleMap {
		keysForStringToDoubleMap = append(keysForStringToDoubleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToDoubleMap)
	mapStringForStringToDoubleMap := "map[string]float64{"
	for _, k := range keysForStringToDoubleMap {
		mapStringForStringToDoubleMap += fmt.Sprintf("%v: %v,", k, this.StringToDoubleMap[k])
	}
	mapStringForStringToDoubleMap += "}"
	keysForStringToFloatMap := make([]string, 0, len(this.StringToFloatMap))
	for k := range this.StringToFloatMap {
		keysForStringToFloatMap = append(keysForStringToFloatMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToFloatMap)
	mapStringForStringToFloatMap := "map[string]float32{"
	for _, k := range keysForStringToFloatMap {
		mapStringForStringToFloatMap += fmt.Sprintf("%v: %v,", k, this.StringToFloatMap[k])
	}
	mapStringForStringToFloatMap += "}"
	keysForInt32Map := make([]int32, 0, len(this.Int32Map))
	for k := range this.Int32Map {
		keysForInt32Map = append(keysForInt32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInt32Map)
	mapStringForInt32Map := "map[int32]int32{"
	for _, k := range keysForInt32Map {
		mapStringForInt32Map += fmt.Sprintf("%v: %v,", k, this.Int32Map[k])
	}
	mapStringForInt32Map += "}"
	keysForInt64Map := make([]int64, 0, len(this.Int64Map))
	for k := range this.Int64Map {
		keysForInt64Map = append(keysForInt64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForInt64Map)
	mapStringForInt64Map := "map[int64]int64{"
	for _, k := range keysForInt64Map {
		mapStringForInt64Map += fmt.Sprintf("%v: %v,", k, this.Int64Map[k])
	}
	mapStringForInt64Map += "}"
	keysForUint32Map := make([]uint32, 0, len(this.Uint32Map))
	for k := range this.Uint32Map {
		keysForUint32Map = append(keysForUint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForUint32Map)
	mapStringForUint32Map := "map[uint32]uint32{"
	for _, k := range keysForUint32Map {
		mapStringForUint32Map += fmt.Sprintf("%v: %v,", k, this.Uint32Map[k])
	}
	mapStringForUint32Map += "}"
	keysForUint64Map := make([]uint64, 0, len(this.Uint64Map))
	for k := range this.Uint64Map {
		keysForUint64Map = append(keysForUint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForUint64Map)
	mapStringForUint64Map := "map[uint64]uint64{"
	for _, k := range keysForUint64Map {
		mapStringForUint64Map += fmt.Sprintf("%v: %v,", k, this.Uint64Map[k])
	}
	mapStringForUint64Map += "}"
	keysForSint32Map := make([]int32, 0, len(this.Sint32Map))
	for k := range this.Sint32Map {
		keysForSint32Map = append(keysForSint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSint32Map)
	mapStringForSint32Map := "map[int32]int32{"
	for _, k := range keysForSint32Map {
		mapStringForSint32Map += fmt.Sprintf("%v: %v,", k, this.Sint32Map[k])
	}
	mapStringForSint32Map += "}"
	keysForSint64Map := make([]int64, 0, len(this.Sint64Map))
	for k := range this.Sint64Map {
		keysForSint64Map = append(keysForSint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSint64Map)
	mapStringForSint64Map := "map[int64]int64{"
	for _, k := range keysForSint64Map {
		mapStringForSint64Map += fmt.Sprintf("%v: %v,", k, this.Sint64Map[k])
	}
	mapStringForSint64Map += "}"
	keysForFixed32Map := make([]uint32, 0, len(this.Fixed32Map))
	for k := range this.Fixed32Map {
		keysForFixed32Map = append(keysForFixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFixed32Map)
	mapStringForFixed32Map := "map[uint32]uint32{"
	for _, k := range keysForFixed32Map {
		mapStringForFixed32Map += fmt.Sprintf("%v: %v,", k, this.Fixed32Map[k])
	}
	mapStringForFixed32Map += "}"
	keysForSfixed32Map := make([]int32, 0, len(this.Sfixed32Map))
	for k := range this.Sfixed32Map {
		keysForSfixed32Map = append(keysForSfixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSfixed32Map)
	mapStringForSfixed32Map := "map[int32]int32{"
	for _, k := range keysForSfixed32Map {
		mapStringForSfixed32Map += fmt.Sprintf("%v: %v,", k, this.Sfixed32Map[k])
	}
	mapStringForSfixed32Map += "}"
	keysForFixed64Map := make([]uint64, 0, len(this.Fixed64Map))
	for k := range this.Fixed64Map {
		keysForFixed64Map = append(keysForFixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForFixed64Map)
	mapStringForFixed64Map := "map[uint64]uint64{"
	for _, k := range keysForFixed64Map {
		mapStringForFixed64Map += fmt.Sprintf("%v: %v,", k, this.Fixed64Map[k])
	}
	mapStringForFixed64Map += "}"
	keysForSfixed64Map := make([]int64, 0, len(this.Sfixed64Map))
	for k := range this.Sfixed64Map {
		keysForSfixed64Map = append(keysForSfixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSfixed64Map)
	mapStringForSfixed64Map := "map[int64]int64{"
	for _, k := range keysForSfixed64Map {
		mapStringForSfixed64Map += fmt.Sprintf("%v: %v,", k, this.Sfixed64Map[k])
	}
	mapStringForSfixed64Map += "}"
	keysForBoolMap := make([]bool, 0, len(this.BoolMap))
	for k := range this.BoolMap {
		keysForBoolMap = append(keysForBoolMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForBoolMap)
	mapStringForBoolMap := "map[bool]bool{"
	for _, k := range keysForBoolMap {
		mapStringForBoolMap += fmt.Sprintf("%v: %v,", k, this.BoolMap[k])
	}
	mapStringForBoolMap += "}"
	keysForStringMap := make([]string, 0, len(this.StringMap))
	for k := range this.StringMap {
		keysForStringMap = append(keysForStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringMap)
	mapStringForStringMap := "map[string]string{"
	for _, k := range keysForStringMap {
		mapStringForStringMap += fmt.Sprintf("%v: %v,", k, this.StringMap[k])
	}
	mapStringForStringMap += "}"
	keysForStringToBytesMap := make([]string, 0, len(this.StringToBytesMap))
	for k := range this.StringToBytesMap {
		keysForStringToBytesMap = append(keysForStringToBytesMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToBytesMap)
	mapStringForStringToBytesMap := "map[string][]byte{"
	for _, k := range keysForStringToBytesMap {
		mapStringForStringToBytesMap += fmt.Sprintf("%v: %v,", k, this.StringToBytesMap[k])
	}
	mapStringForStringToBytesMap += "}"
	keysForStringToEnumMap := make([]string, 0, len(this.StringToEnumMap))
	for k := range this.StringToEnumMap {
		keysForStringToEnumMap = append(keysForStringToEnumMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToEnumMap)
	mapStringForStringToEnumMap := "map[string]MapEnum{"
	for _, k := range keysForStringToEnumMap {
		mapStringForStringToEnumMap += fmt.Sprintf("%v: %v,", k, this.StringToEnumMap[k])
	}
	mapStringForStringToEnumMap += "}"
	keysForStringToMsgMap := make([]string, 0, len(this.StringToMsgMap))
	for k := range this.StringToMsgMap {
		keysForStringToMsgMap = append(keysForStringToMsgMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToMsgMap)
	mapStringForStringToMsgMap := "map[string]*FloatingPoint{"
	for _, k := range keysForStringToMsgMap {
		mapStringForStringToMsgMap += fmt.Sprintf("%v: %v,", k, this.StringToMsgMap[k])
	}
	mapStringForStringToMsgMap += "}"
	s := strings.Join([]string{`&AllMaps{`,
		`StringToDoubleMap:` + mapStringForStringToDoubleMap + `,`,
		`StringToFloatMap:` + mapStringForStringToFloatMap + `,`,
		`Int32Map:` + mapStringForInt32Map + `,`,
		`Int64Map:` + mapStringForInt64Map + `,`,
		`Uint32Map:` + mapStringForUint32Map + `,`,
		`Uint64Map:` + mapStringForUint64Map + `,`,
		`Sint32Map:` + mapStringForSint32Map + `,`,
		`Sint64Map:` + mapStringForSint64Map + `,`,
		`Fixed32Map:` + mapStringForFixed32Map + `,`,
		`Sfixed32Map:` + mapStringForSfixed32Map + `,`,
		`Fixed64Map:` + mapStringForFixed64Map + `,`,
		`Sfixed64Map:` + mapStringForSfixed64Map + `,`,
		`BoolMap:` + mapStringForBoolMap + `,`,
		`StringMap:` + mapStringForStringMap + `,`,
		`StringToBytesMap:` + mapStringForStringToBytesMap + `,`,
		`StringToEnumMap:` + mapStringForStringToEnumMap + `,`,
		`StringToMsgMap:` + mapStringForStringToMsgMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllMapsOrdered) String() string {
	if this == nil {
		return "nil"
	}
	keysForStringToDoubleMap := make([]string, 0, len(this.StringToDoubleMap))
	for k := range this.StringToDoubleMap {
		keysForStringToDoubleMap = append(keysForStringToDoubleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToDoubleMap)
	mapStringForStringToDoubleMap := "map[string]float64{"
	for _, k := range keysForStringToDoubleMap {
		mapStringForStringToDoubleMap += fmt.Sprintf("%v: %v,", k, this.StringToDoubleMap[k])
	}
	mapStringForStringToDoubleMap += "}"
	keysForStringToFloatMap := make([]string, 0, len(this.StringToFloatMap))
	for k := range this.StringToFloatMap {
		keysForStringToFloatMap = append(keysForStringToFloatMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToFloatMap)
	mapStringForStringToFloatMap := "map[string]float32{"
	for _, k := range keysForStringToFloatMap {
		mapStringForStringToFloatMap += fmt.Sprintf("%v: %v,", k, this.StringToFloatMap[k])
	}
	mapStringForStringToFloatMap += "}"
	keysForInt32Map := make([]int32, 0, len(this.Int32Map))
	for k := range this.Int32Map {
		keysForInt32Map = append(keysForInt32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInt32Map)
	mapStringForInt32Map := "map[int32]int32{"
	for _, k := range keysForInt32Map {
		mapStringForInt32Map += fmt.Sprintf("%v: %v,", k, this.Int32Map[k])
	}
	mapStringForInt32Map += "}"
	keysForInt64Map := make([]int64, 0, len(this.Int64Map))
	for k := range this.Int64Map {
		keysForInt64Map = append(keysForInt64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForInt64Map)
	mapStringForInt64Map := "map[int64]int64{"
	for _, k := range keysForInt64Map {
		mapStringForInt64Map += fmt.Sprintf("%v: %v,", k, this.Int64Map[k])
	}
	mapStringForInt64Map += "}"
	keysForUint32Map := make([]uint32, 0, len(this.Uint32Map))
	for k := range this.Uint32Map {
		keysForUint32Map = append(keysForUint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForUint32Map)
	mapStringForUint32Map := "map[uint32]uint32{"
	for _, k := range keysForUint32Map {
		mapStringForUint32Map += fmt.Sprintf("%v: %v,", k, this.Uint32Map[k])
	}
	mapStringForUint32Map += "}"
	keysForUint64Map := make([]uint64, 0, len(this.Uint64Map))
	for k := range this.Uint64Map {
		keysForUint64Map = append(keysForUint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForUint64Map)
	mapStringForUint64Map := "map[uint64]uint64{"
	for _, k := range keysForUint64Map {
		mapStringForUint64Map += fmt.Sprintf("%v: %v,", k, this.Uint64Map[k])
	}
	mapStringForUint64Map += "}"
	keysForSint32Map := make([]int32, 0, len(this.Sint32Map))
	for k := range this.Sint32Map {
		keysForSint32Map = append(keysForSint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSint32Map)
	mapStringForSint32Map := "map[int32]int32{"
	for _, k := range keysForSint32Map {
		mapStringForSint32Map += fmt.Sprintf("%v: %v,", k, this.Sint32Map[k])
	}
	mapStringForSint32Map += "}"
	keysForSint64Map := make([]int64, 0, len(this.Sint64Map))
	for k := range this.Sint64Map {
		keysForSint64Map = append(keysForSint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSint64Map)
	mapStringForSint64Map := "map[int64]int64{"
	for _, k := range keysForSint64Map {
		mapStringForSint64Map += fmt.Sprintf("%v: %v,", k, this.Sint64Map[k])
	}
	mapStringForSint64Map += "}"
	keysForFixed32Map := make([]uint32, 0, len(this.Fixed32Map))
	for k := range this.Fixed32Map {
		keysForFixed32Map = append(keysForFixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFixed32Map)
	mapStringForFixed32Map := "map[uint32]uint32{"
	for _, k := range keysForFixed32Map {
		mapStringForFixed32Map += fmt.Sprintf("%v: %v,", k, this.Fixed32Map[k])
	}
	mapStringForFixed32Map += "}"
	keysForSfixed32Map := make([]int32, 0, len(this.Sfixed32Map))
	for k := range this.Sfixed32Map {
		keysForSfixed32Map = append(keysForSfixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSfixed32Map)
	mapStringForSfixed32Map := "map[int32]int32{"
	for _, k := range keysForSfixed32Map {
		mapStringForSfixed32Map += fmt.Sprintf("%v: %v,", k, this.Sfixed32Map[k])
	}
	mapStringForSfixed32Map += "}"
	keysForFixed64Map := make([]uint64, 0, len(this.Fixed64Map))
	for k := range this.Fixed64Map {
		keysForFixed64Map = append(keysForFixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForFixed64Map)
	mapStringForFixed64Map := "map[uint64]uint64{"
	for _, k := range keysForFixed64Map {
		mapStringForFixed64Map += fmt.Sprintf("%v: %v,", k, this.Fixed64Map[k])
	}
	mapStringForFixed64Map += "}"
	keysForSfixed64Map := make([]int64, 0, len(this.Sfixed64Map))
	for k := range this.Sfixed64Map {
		keysForSfixed64Map = append(keysForSfixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSfixed64Map)
	mapStringForSfixed64Map := "map[int64]int64{"
	for _, k := range keysForSfixed64Map {
		mapStringForSfixed64Map += fmt.Sprintf("%v: %v,", k, this.Sfixed64Map[k])
	}
	mapStringForSfixed64Map += "}"
	keysForBoolMap := make([]bool, 0, len(this.BoolMap))
	for k := range this.BoolMap {
		keysForBoolMap = append(keysForBoolMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForBoolMap)
	mapStringForBoolMap := "map[bool]bool{"
	for _, k := range keysForBoolMap {
		mapStringForBoolMap += fmt.Sprintf("%v: %v,", k, this.BoolMap[k])
	}
	mapStringForBoolMap += "}"
	keysForStringMap := make([]string, 0, len(this.StringMap))
	for k := range this.StringMap {
		keysForStringMap = append(keysForStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringMap)
	mapStringForStringMap := "map[string]string{"
	for _, k := range keysForStringMap {
		mapStringForStringMap += fmt.Sprintf("%v: %v,", k, this.StringMap[k])
	}
	mapStringForStringMap += "}"
	keysForStringToBytesMap := make([]string, 0, len(this.StringToBytesMap))
	for k := range this.StringToBytesMap {
		keysForStringToBytesMap = append(keysForStringToBytesMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToBytesMap)
	mapStringForStringToBytesMap := "map[string][]byte{"
	for _, k := range keysForStringToBytesMap {
		mapStringForStringToBytesMap += fmt.Sprintf("%v: %v,", k, this.StringToBytesMap[k])
	}
	mapStringForStringToBytesMap += "}"
	keysForStringToEnumMap := make([]string, 0, len(this.StringToEnumMap))
	for k := range this.StringToEnumMap {
		keysForStringToEnumMap = append(keysForStringToEnumMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToEnumMap)
	mapStringForStringToEnumMap := "map[string]MapEnum{"
	for _, k := range keysForStringToEnumMap {
		mapStringForStringToEnumMap += fmt.Sprintf("%v: %v,", k, this.StringToEnumMap[k])
	}
	mapStringForStringToEnumMap += "}"
	keysForStringToMsgMap := make([]string, 0, len(this.StringToMsgMap))
	for k := range this.StringToMsgMap {
		keysForStringToMsgMap = append(keysForStringToMsgMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToMsgMap)
	mapStringForStringToMsgMap := "map[string]*FloatingPoint{"
	for _, k := range keysForStringToMsgMap {
		mapStringForStringToMsgMap += fmt.Sprintf("%v: %v,", k, this.StringToMsgMap[k])
	}
	mapStringForStringToMsgMap += "}"
	s := strings.Join([]string{`&AllMapsOrdered{`,
		`StringToDoubleMap:` + mapStringForStringToDoubleMap + `,`,
		`StringToFloatMap:` + mapStringForStringToFloatMap + `,`,
		`Int32Map:` + mapStringForInt32Map + `,`,
		`Int64Map:` + mapStringForInt64Map + `,`,
		`Uint32Map:` + mapStringForUint32Map + `,`,
		`Uint64Map:` + mapStringForUint64Map + `,`,
		`Sint32Map:` + mapStringForSint32Map + `,`,
		`Sint64Map:` + mapStringForSint64Map + `,`,
		`Fixed32Map:` + mapStringForFixed32Map + `,`,
		`Sfixed32Map:` + mapStringForSfixed32Map + `,`,
		`Fixed64Map:` + mapStringForFixed64Map + `,`,
		`Sfixed64Map:` + mapStringForSfixed64Map + `,`,
		`BoolMap:` + mapStringForBoolMap + `,`,
		`StringMap:` + mapStringForStringMap + `,`,
		`StringToBytesMap:` + mapStringForStringToBytesMap + `,`,
		`StringToEnumMap:` + mapStringForStringToEnumMap + `,`,
		`StringToMsgMap:` + mapStringForStringToMsgMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageWithMap) String() string {
	if this == nil {
		return "nil"
	}
	keysForNameMapping := make([]int32, 0, len(this.NameMapping))
	for k := range this.NameMapping {
		keysForNameMapping = append(keysForNameMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNameMapping)
	mapStringForNameMapping := "map[int32]string{"
	for _, k := range keysForNameMapping {
		mapStringForNameMapping += fmt.Sprintf("%v: %v,", k, this.NameMapping[k])
	}
	mapStringForNameMapping += "}"
	keysForMsgMapping := make([]int64, 0, len(this.MsgMapping))
	for k := range this.MsgMapping {
		keysForMsgMapping = append(keysForMsgMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForMsgMapping)
	mapStringForMsgMapping := "map[int64]*FloatingPoint{"
	for _, k := range keysForMsgMapping {
		mapStringForMsgMapping += fmt.Sprintf("%v: %v,", k, this.MsgMapping[k])
	}
	mapStringForMsgMapping += "}"
	keysForByteMapping := make([]bool, 0, len(this.ByteMapping))
	for k := range this.ByteMapping {
		keysForByteMapping = append(keysForByteMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForByteMapping)
	mapStringForByteMapping := "map[bool][]byte{"
	for _, k := range keysForByteMapping {
		mapStringForByteMapping += fmt.Sprintf("%v: %v,", k, this.ByteMapping[k])
	}
	mapStringForByteMapping += "}"
	s := strings.Join([]string{`&MessageWithMap{`,
		`NameMapping:` + mapStringForNameMapping + `,`,
		`MsgMapping:` + mapStringForMsgMapping + `,`,
		`ByteMapping:` + mapStringForByteMapping + `,`,
		`}`,
	}, "")
	return s
}
func (this *FloatingPoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FloatingPoint{`,
		`F:` + fmt.Sprintf("%v", this.F) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Uint128Pair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Uint128Pair{`,
		`Left:` + fmt.Sprintf("%v", this.Left) + `,`,
		`Right:` + fmt.Sprintf("%v", this.Right) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainsNestedMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainsNestedMap{`,
		`}`,
	}, "")
	return s
}
func (this *ContainsNestedMap_NestedMap) String() string {
	if this == nil {
		return "nil"
	}
	keysForNestedMapField := make([]string, 0, len(this.NestedMapField))
	for k := range this.NestedMapField {
		keysForNestedMapField = append(keysForNestedMapField, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForNestedMapField)
	mapStringForNestedMapField := "map[string]float64{"
	for _, k := range keysForNestedMapField {
		mapStringForNestedMapField += fmt.Sprintf("%v: %v,", k, this.NestedMapField[k])
	}
	mapStringForNestedMapField += "}"
	s := strings.Join([]string{`&ContainsNestedMap_NestedMap{`,
		`NestedMapField:` + mapStringForNestedMapField + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTheproto3(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Message) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hilarity", wireType)
			}
			m.Hilarity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Hilarity |= (Message_Humour(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightInCm", wireType)
			}
			m.HeightInCm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HeightInCm |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultCount", wireType)
			}
			m.ResultCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ResultCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrueScotsman", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrueScotsman = bool(v != 0)
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			if iNdEx+4 > l {
				return io.ErrUnexpectedEOF
			}
			m.Score = *(*float32)(unsafe.Pointer(&data[iNdEx]))
			iNdEx += 4
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Key = append(m.Key, v)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested == nil {
				m.Nested = &Nested{}
			}
			if err := m.Nested.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terrain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Nested{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Terrain == nil {
				m.Terrain = make(map[int64]*Nested)
			}
			m.Terrain[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto2Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proto2Field == nil {
				m.Proto2Field = &test.NinOptNative{}
			}
			if err := m.Proto2Field.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto2Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &test.NinOptEnum{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Proto2Value == nil {
				m.Proto2Value = make(map[int64]*test.NinOptEnum)
			}
			m.Proto2Value[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bunny", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bunny = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllMaps) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllMaps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllMaps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToDoubleMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapvaluetemp = uint64(data[iNdEx-8])
			mapvaluetemp |= uint64(data[iNdEx-7]) << 8
			mapvaluetemp |= uint64(data[iNdEx-6]) << 16
			mapvaluetemp |= uint64(data[iNdEx-5]) << 24
			mapvaluetemp |= uint64(data[iNdEx-4]) << 32
			mapvaluetemp |= uint64(data[iNdEx-3]) << 40
			mapvaluetemp |= uint64(data[iNdEx-2]) << 48
			mapvaluetemp |= uint64(data[iNdEx-1]) << 56
			mapvalue := math.Float64frombits(mapvaluetemp)
			if m.StringToDoubleMap == nil {
				m.StringToDoubleMap = make(map[string]float64)
			}
			m.StringToDoubleMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToFloatMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapvaluetemp = uint32(data[iNdEx-4])
			mapvaluetemp |= uint32(data[iNdEx-3]) << 8
			mapvaluetemp |= uint32(data[iNdEx-2]) << 16
			mapvaluetemp |= uint32(data[iNdEx-1]) << 24
			mapvalue := math.Float32frombits(mapvaluetemp)
			if m.StringToFloatMap == nil {
				m.StringToFloatMap = make(map[string]float32)
			}
			m.StringToFloatMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Int32Map == nil {
				m.Int32Map = make(map[int32]int32)
			}
			m.Int32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Int64Map == nil {
				m.Int64Map = make(map[int64]int64)
			}
			m.Int64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Uint32Map == nil {
				m.Uint32Map = make(map[uint32]uint32)
			}
			m.Uint32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Uint64Map == nil {
				m.Uint64Map = make(map[uint64]uint64)
			}
			m.Uint64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
			mapkey := int32(mapkeytemp)
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvaluetemp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
			mapvalue := int32(mapvaluetemp)
			if m.Sint32Map == nil {
				m.Sint32Map = make(map[int32]int32)
			}
			m.Sint32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
			mapkey := int64(mapkeytemp)
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvaluetemp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
			mapvalue := int64(mapvaluetemp)
			if m.Sint64Map == nil {
				m.Sint64Map = make(map[int64]int64)
			}
			m.Sint64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapkey = uint32(data[iNdEx-4])
			mapkey |= uint32(data[iNdEx-3]) << 8
			mapkey |= uint32(data[iNdEx-2]) << 16
			mapkey |= uint32(data[iNdEx-1]) << 24
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapvalue = uint32(data[iNdEx-4])
			mapvalue |= uint32(data[iNdEx-3]) << 8
			mapvalue |= uint32(data[iNdEx-2]) << 16
			mapvalue |= uint32(data[iNdEx-1]) << 24
			if m.Fixed32Map == nil {
				m.Fixed32Map = make(map[uint32]uint32)
			}
			m.Fixed32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapkey = int32(data[iNdEx-4])
			mapkey |= int32(data[iNdEx-3]) << 8
			mapkey |= int32(data[iNdEx-2]) << 16
			mapkey |= int32(data[iNdEx-1]) << 24
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapvalue = int32(data[iNdEx-4])
			mapvalue |= int32(data[iNdEx-3]) << 8
			mapvalue |= int32(data[iNdEx-2]) << 16
			mapvalue |= int32(data[iNdEx-1]) << 24
			if m.Sfixed32Map == nil {
				m.Sfixed32Map = make(map[int32]int32)
			}
			m.Sfixed32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapvalue = uint64(data[iNdEx-8])
			mapvalue |= uint64(data[iNdEx-7]) << 8
			mapvalue |= uint64(data[iNdEx-6]) << 16
			mapvalue |= uint64(data[iNdEx-5]) << 24
			mapvalue |= uint64(data[iNdEx-4]) << 32
			mapvalue |= uint64(data[iNdEx-3]) << 40
			mapvalue |= uint64(data[iNdEx-2]) << 48
			mapvalue |= uint64(data[iNdEx-1]) << 56
			if m.Fixed64Map == nil {
				m.Fixed64Map = make(map[uint64]uint64)
			}
			m.Fixed64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = int64(data[iNdEx-8])
			mapkey |= int64(data[iNdEx-7]) << 8
			mapkey |= int64(data[iNdEx-6]) << 16
			mapkey |= int64(data[iNdEx-5]) << 24
			mapkey |= int64(data[iNdEx-4]) << 32
			mapkey |= int64(data[iNdEx-3]) << 40
			mapkey |= int64(data[iNdEx-2]) << 48
			mapkey |= int64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapvalue = int64(data[iNdEx-8])
			mapvalue |= int64(data[iNdEx-7]) << 8
			mapvalue |= int64(data[iNdEx-6]) << 16
			mapvalue |= int64(data[iNdEx-5]) << 24
			mapvalue |= int64(data[iNdEx-4]) << 32
			mapvalue |= int64(data[iNdEx-3]) << 40
			mapvalue |= int64(data[iNdEx-2]) << 48
			mapvalue |= int64(data[iNdEx-1]) << 56
			if m.Sfixed64Map == nil {
				m.Sfixed64Map = make(map[int64]int64)
			}
			m.Sfixed64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkey := bool(mapkeytemp != 0)
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvaluetemp |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapvalue := bool(mapvaluetemp != 0)
			if m.BoolMap == nil {
				m.BoolMap = make(map[bool]bool)
			}
			m.BoolMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.StringMap == nil {
				m.StringMap = make(map[string]string)
			}
			m.StringMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToBytesMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.StringToBytesMap == nil {
				m.StringToBytesMap = make(map[string][]byte)
			}
			m.StringToBytesMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToEnumMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue MapEnum
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (MapEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.StringToEnumMap == nil {
				m.StringToEnumMap = make(map[string]MapEnum)
			}
			m.StringToEnumMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToMsgMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &FloatingPoint{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.StringToMsgMap == nil {
				m.StringToMsgMap = make(map[string]*FloatingPoint)
			}
			m.StringToMsgMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllMapsOrdered) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllMapsOrdered: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllMapsOrdered: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToDoubleMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapvaluetemp = uint64(data[iNdEx-8])
			mapvaluetemp |= uint64(data[iNdEx-7]) << 8
			mapvaluetemp |= uint64(data[iNdEx-6]) << 16
			mapvaluetemp |= uint64(data[iNdEx-5]) << 24
			mapvaluetemp |= uint64(data[iNdEx-4]) << 32
			mapvaluetemp |= uint64(data[iNdEx-3]) << 40
			mapvaluetemp |= uint64(data[iNdEx-2]) << 48
			mapvaluetemp |= uint64(data[iNdEx-1]) << 56
			mapvalue := math.Float64frombits(mapvaluetemp)
			if m.StringToDoubleMap == nil {
				m.StringToDoubleMap = make(map[string]float64)
			}
			m.StringToDoubleMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToFloatMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapvaluetemp = uint32(data[iNdEx-4])
			mapvaluetemp |= uint32(data[iNdEx-3]) << 8
			mapvaluetemp |= uint32(data[iNdEx-2]) << 16
			mapvaluetemp |= uint32(data[iNdEx-1]) << 24
			mapvalue := math.Float32frombits(mapvaluetemp)
			if m.StringToFloatMap == nil {
				m.StringToFloatMap = make(map[string]float32)
			}
			m.StringToFloatMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Int32Map == nil {
				m.Int32Map = make(map[int32]int32)
			}
			m.Int32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Int64Map == nil {
				m.Int64Map = make(map[int64]int64)
			}
			m.Int64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Uint32Map == nil {
				m.Uint32Map = make(map[uint32]uint32)
			}
			m.Uint32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Uint64Map == nil {
				m.Uint64Map = make(map[uint64]uint64)
			}
			m.Uint64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
			mapkey := int32(mapkeytemp)
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvaluetemp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
			mapvalue := int32(mapvaluetemp)
			if m.Sint32Map == nil {
				m.Sint32Map = make(map[int32]int32)
			}
			m.Sint32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
			mapkey := int64(mapkeytemp)
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvaluetemp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
			mapvalue := int64(mapvaluetemp)
			if m.Sint64Map == nil {
				m.Sint64Map = make(map[int64]int64)
			}
			m.Sint64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapkey = uint32(data[iNdEx-4])
			mapkey |= uint32(data[iNdEx-3]) << 8
			mapkey |= uint32(data[iNdEx-2]) << 16
			mapkey |= uint32(data[iNdEx-1]) << 24
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapvalue = uint32(data[iNdEx-4])
			mapvalue |= uint32(data[iNdEx-3]) << 8
			mapvalue |= uint32(data[iNdEx-2]) << 16
			mapvalue |= uint32(data[iNdEx-1]) << 24
			if m.Fixed32Map == nil {
				m.Fixed32Map = make(map[uint32]uint32)
			}
			m.Fixed32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapkey = int32(data[iNdEx-4])
			mapkey |= int32(data[iNdEx-3]) << 8
			mapkey |= int32(data[iNdEx-2]) << 16
			mapkey |= int32(data[iNdEx-1]) << 24
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			mapvalue = int32(data[iNdEx-4])
			mapvalue |= int32(data[iNdEx-3]) << 8
			mapvalue |= int32(data[iNdEx-2]) << 16
			mapvalue |= int32(data[iNdEx-1]) << 24
			if m.Sfixed32Map == nil {
				m.Sfixed32Map = make(map[int32]int32)
			}
			m.Sfixed32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapvalue = uint64(data[iNdEx-8])
			mapvalue |= uint64(data[iNdEx-7]) << 8
			mapvalue |= uint64(data[iNdEx-6]) << 16
			mapvalue |= uint64(data[iNdEx-5]) << 24
			mapvalue |= uint64(data[iNdEx-4]) << 32
			mapvalue |= uint64(data[iNdEx-3]) << 40
			mapvalue |= uint64(data[iNdEx-2]) << 48
			mapvalue |= uint64(data[iNdEx-1]) << 56
			if m.Fixed64Map == nil {
				m.Fixed64Map = make(map[uint64]uint64)
			}
			m.Fixed64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = int64(data[iNdEx-8])
			mapkey |= int64(data[iNdEx-7]) << 8
			mapkey |= int64(data[iNdEx-6]) << 16
			mapkey |= int64(data[iNdEx-5]) << 24
			mapkey |= int64(data[iNdEx-4]) << 32
			mapkey |= int64(data[iNdEx-3]) << 40
			mapkey |= int64(data[iNdEx-2]) << 48
			mapkey |= int64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapvalue = int64(data[iNdEx-8])
			mapvalue |= int64(data[iNdEx-7]) << 8
			mapvalue |= int64(data[iNdEx-6]) << 16
			mapvalue |= int64(data[iNdEx-5]) << 24
			mapvalue |= int64(data[iNdEx-4]) << 32
			mapvalue |= int64(data[iNdEx-3]) << 40
			mapvalue |= int64(data[iNdEx-2]) << 48
			mapvalue |= int64(data[iNdEx-1]) << 56
			if m.Sfixed64Map == nil {
				m.Sfixed64Map = make(map[int64]int64)
			}
			m.Sfixed64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkey := bool(mapkeytemp != 0)
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvaluetemp |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapvalue := bool(mapvaluetemp != 0)
			if m.BoolMap == nil {
				m.BoolMap = make(map[bool]bool)
			}
			m.BoolMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.StringMap == nil {
				m.StringMap = make(map[string]string)
			}
			m.StringMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToBytesMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.StringToBytesMap == nil {
				m.StringToBytesMap = make(map[string][]byte)
			}
			m.StringToBytesMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToEnumMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvalue MapEnum
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapvalue |= (MapEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.StringToEnumMap == nil {
				m.StringToEnumMap = make(map[string]MapEnum)
			}
			m.StringToEnumMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToMsgMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &FloatingPoint{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.StringToMsgMap == nil {
				m.StringToMsgMap = make(map[string]*FloatingPoint)
			}
			m.StringToMsgMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageWithMap) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageWithMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageWithMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.NameMapping == nil {
				m.NameMapping = make(map[int32]string)
			}
			m.NameMapping[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
			mapkey := int64(mapkeytemp)
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &FloatingPoint{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.MsgMapping == nil {
				m.MsgMapping = make(map[int64]*FloatingPoint)
			}
			m.MsgMapping[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkeytemp int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkeytemp |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			mapkey := bool(mapkeytemp != 0)
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.ByteMapping == nil {
				m.ByteMapping = make(map[bool][]byte)
			}
			m.ByteMapping[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatingPoint) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatingPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatingPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			if iNdEx+8 > l {
				return io.ErrUnexpectedEOF
			}
			m.F = *(*float64)(unsafe.Pointer(&data[iNdEx]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Uint128Pair) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Uint128Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Uint128Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Left.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_gogo_protobuf_test_custom.Uint128
			m.Right = &v
			if err := m.Right.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainsNestedMap) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainsNestedMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainsNestedMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainsNestedMap_NestedMap) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NestedMapField", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapvaluetemp uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapvaluetemp = uint64(data[iNdEx-8])
			mapvaluetemp |= uint64(data[iNdEx-7]) << 8
			mapvaluetemp |= uint64(data[iNdEx-6]) << 16
			mapvaluetemp |= uint64(data[iNdEx-5]) << 24
			mapvaluetemp |= uint64(data[iNdEx-4]) << 32
			mapvaluetemp |= uint64(data[iNdEx-3]) << 40
			mapvaluetemp |= uint64(data[iNdEx-2]) << 48
			mapvaluetemp |= uint64(data[iNdEx-1]) << 56
			mapvalue := math.Float64frombits(mapvaluetemp)
			if m.NestedMapField == nil {
				m.NestedMapField = make(map[string]float64)
			}
			m.NestedMapField[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3Unsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTheproto3Unsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTheproto3Unsafe(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTheproto3Unsafe
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTheproto3Unsafe
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTheproto3Unsafe
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTheproto3Unsafe
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTheproto3Unsafe(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTheproto3Unsafe = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTheproto3Unsafe   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorTheproto3 = []byte{
	// 1591 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x59, 0x4b, 0x6f, 0xdb, 0xc6,
	0x16, 0x36, 0x25, 0x59, 0x8f, 0xa3, 0x17, 0x3d, 0xc9, 0xbd, 0xd0, 0x35, 0x70, 0x6d, 0x47, 0x01,
	0x12, 0x27, 0xb8, 0x91, 0x73, 0x9d, 0xb4, 0x4d, 0xdd, 0xb4, 0xa9, 0xa5, 0x58, 0x88, 0x1b, 0x5b,
	0x71, 0x25, 0x3b, 0x6e, 0x11, 0xa0, 0x06, 0x65, 0x53, 0x12, 0x51, 0x89, 0x34, 0xf8, 0x08, 0xea,
	0x5d, 0x7e, 0x46, 0x77, 0x45, 0x77, 0x5d, 0x16, 0x59, 0x14, 0x5d, 0xb6, 0x3b, 0x2f, 0x0b, 0x74,
	0x53, 0x74, 0x11, 0x24, 0xe9, 0x26, 0xcb, 0x2c, 0xb3, 0xec, 0x3c, 0x48, 0x6a, 0x48, 0x0d, 0xc5,
	0xa6, 0x9b, 0x6e, 0xbc, 0x18, 0x88, 0x73, 0xf8, 0x7d, 0xdf, 0x9c, 0x19, 0xce, 0x1c, 0x7e, 0xa0,
	0x60, 0xf9, 0xd0, 0x18, 0x75, 0x0d, 0x6b, 0xc5, 0xd1, 0x2d, 0xa5, 0xa7, 0x3a, 0xfa, 0x48, 0x31,
	0xad, 0x81, 0x32, 0x54, 0xcd, 0x15, 0x7b, 0xa0, 0x1e, 0x9b, 0x86, 0x6d, 0xdc, 0xa8, 0xd1, 0x1f,
	0x94, 0xf3, 0x03, 0xf3, 0xd7, 0xfa, 0x9a, 0x3d, 0x70, 0xba, 0x35, 0xcc, 0x5d, 0xe9, 0x1b, 0x7d,
	0x63, 0x85, 0xc6, 0xbb, 0x4e, 0x8f, 0xf6, 0x68, 0x87, 0x5e, 0x31, 0xe6, 0xfc, 0x7b, 0x91, 0x70,
	0x5b, 0xb5, 0xec, 0x15, 0x37, 0x83, 0xae, 0x61, 0x0f, 0xc8, 0xa0, 0x24, 0xc6, 0x88, 0xd5, 0x9f,
	0x67, 0x21, 0xb3, 0xad, 0x5a, 0x96, 0xd2, 0x57, 0x11, 0x82, 0x94, 0xae, 0x8c, 0xd4, 0x8a, 0xb4,
	0x24, 0x2d, 0xe7, 0xda, 0xf4, 0x1a, 0xbd, 0x03, 0xd9, 0x81, 0x36, 0x54, 0x4c, 0xcd, 0x3e, 0xa9,
	0x24, 0x70, 0xbc, 0xb4, 0xfa, 0x9f, 0xda, 0x38, 0x6d, 0x97, 0x59, 0xbb, 0xe7, 0x8c, 0x0c, 0xc7,
	0x6c, 0xfb, 0x50, 0xb4, 0x04, 0x85, 0x81, 0xaa, 0xf5, 0x07, 0xf6, 0x81, 0xa6, 0x1f, 0x1c, 0x8e,
	0x2a, 0x49, 0x4c, 0x2d, 0xb6, 0x81, 0xc5, 0x36, 0xf5, 0xc6, 0x88, 0x0c, 0x76, 0xa4, 0xd8, 0x4a,
	0x25, 0x85, 0xef, 0x14, 0xda, 0xf4, 0x1a, 0x5d, 0x80, 0x82, 0xa9, 0x5a, 0xce, 0xd0, 0x3e, 0x38,
	0x34, 0x1c, 0xdd, 0xae, 0x64, 0xf0, 0xbd, 0x64, 0x3b, 0xcf, 0x62, 0x0d, 0x12, 0x42, 0x17, 0xa1,
	0x68, 0x9b, 0x8e, 0x7a, 0x60, 0x1d, 0x1a, 0xb6, 0x35, 0x52, 0xf4, 0x4a, 0x16, 0x63, 0xb2, 0xed,
	0x02, 0x09, 0x76, 0xdc, 0x18, 0x3a, 0x0f, 0xb3, 0xf8, 0xbe, 0xa9, 0x56, 0x72, 0xf8, 0x66, 0xa2,
	0xcd, 0x3a, 0x48, 0x86, 0xe4, 0x97, 0xea, 0x49, 0x65, 0x76, 0x29, 0xb9, 0x9c, 0x6a, 0x93, 0x4b,
	0x74, 0x05, 0xd2, 0x3a, 0x5e, 0x0a, 0xf5, 0xa8, 0x92, 0xc6, 0xc0, 0xfc, 0xea, 0x1c, 0x37, 0xb5,
	0x16, 0xbd, 0xd1, 0x76, 0x01, 0xe8, 0x7d, 0xc8, 0xd8, 0xaa, 0x69, 0x2a, 0x9a, 0x5e, 0x01, 0x2c,
	0x90, 0x5f, 0x5d, 0x14, 0x2c, 0xc3, 0x2e, 0x43, 0x6c, 0xe8, 0xb6, 0x79, 0xd2, 0xf6, 0xf0, 0x78,
	0x09, 0x0b, 0x14, 0xb7, 0x7a, 0xd0, 0xd3, 0xd4, 0xe1, 0x51, 0x25, 0x4f, 0xc7, 0x42, 0x35, 0xfa,
	0x14, 0x5a, 0x9a, 0xfe, 0xe0, 0xd8, 0x6e, 0x29, 0xb6, 0xf6, 0x58, 0x6d, 0xe7, 0x19, 0xae, 0x49,
	0x60, 0xa8, 0xe9, 0xd3, 0x1e, 0x2b, 0x43, 0x47, 0xad, 0x14, 0xe9, 0xb0, 0x17, 0x05, 0xc3, 0xee,
	0x50, 0xd8, 0x43, 0x82, 0x62, 0x43, 0xbb, 0x3a, 0x34, 0x32, 0xbf, 0x0d, 0x05, 0x3e, 0x2f, 0x6f,
	0x19, 0x24, 0xba, 0xb6, 0x74, 0x19, 0x2e, 0xc3, 0x2c, 0x1b, 0x22, 0x11, 0xb5, 0x0a, 0xec, 0xfe,
	0x5a, 0xe2, 0x96, 0x34, 0xbf, 0x03, 0x72, 0x78, 0x3c, 0x81, 0xe4, 0xa5, 0xa0, 0xa4, 0xcc, 0x4f,
	0x76, 0x43, 0x77, 0x46, 0x9c, 0x62, 0xf5, 0x0e, 0xa4, 0xd9, 0xfe, 0x41, 0x79, 0xc8, 0xec, 0xb5,
	0xee, 0xb7, 0x1e, 0xec, 0xb7, 0xe4, 0x19, 0x94, 0x85, 0xd4, 0xce, 0x5e, 0xab, 0x23, 0x4b, 0xa8,
	0x08, 0xb9, 0xce, 0xd6, 0xfa, 0x4e, 0x67, 0x77, 0xb3, 0x71, 0x5f, 0x4e, 0xa0, 0x32, 0xe4, 0xeb,
	0x9b, 0x5b, 0x5b, 0x07, 0xf5, 0xf5, 0xcd, 0xad, 0x8d, 0xcf, 0xe5, 0x64, 0x75, 0x01, 0xd2, 0x2c,
	0x4f, 0xf2, 0xe0, 0xbb, 0x8e, 0xae, 0x9f, 0xb8, 0x5b, 0x98, 0x75, 0xaa, 0x4f, 0x11, 0x64, 0xd6,
	0x87, 0xc3, 0x6d, 0xe5, 0xd8, 0x42, 0xfb, 0x30, 0xd7, 0xb1, 0x4d, 0x4d, 0xef, 0xef, 0x1a, 0x77,
	0x0d, 0xa7, 0x3b, 0x54, 0x71, 0x14, 0xa3, 0xc9, 0xd2, 0x5e, 0xe1, 0xe6, 0xed, 0xc2, 0x6b, 0x13,
	0x58, 0xb6, 0xc0, 0x73, 0x56, 0x38, 0x8e, 0x76, 0x41, 0xf6, 0xc0, 0xcd, 0xa1, 0xa1, 0xd8, 0x44,
	0x37, 0x41, 0x75, 0x97, 0xa7, 0xe8, 0x7a, 0x50, 0x26, 0x2b, 0x5b, 0xa1, 0x30, 0xba, 0x0d, 0xd9,
	0x4d, 0xdd, 0xbe, 0xb1, 0x4a, 0xd4, 0x92, 0x54, 0x6d, 0x49, 0xa0, 0xe6, 0x41, 0x98, 0x4a, 0x56,
	0x73, 0xbb, 0x2e, 0xfb, 0xdd, 0x9b, 0x84, 0x9d, 0x9a, 0xc6, 0xa6, 0x90, 0x31, 0x9b, 0x76, 0xd1,
	0x1d, 0xc8, 0xed, 0x79, 0x52, 0xf4, 0xd4, 0xe4, 0x57, 0x2f, 0x08, 0xe8, 0x3e, 0x86, 0xf1, 0x73,
	0x8e, 0x3f, 0xbc, 0x2b, 0xc0, 0xc6, 0x4f, 0x4f, 0x15, 0xe0, 0x12, 0xa0, 0x02, 0x7e, 0x06, 0x1d,
	0x3f, 0x83, 0x4c, 0xa4, 0x40, 0x27, 0x94, 0x81, 0xc5, 0x67, 0xd0, 0xf1, 0x33, 0xc8, 0x4e, 0x15,
	0xe0, 0x33, 0xb0, 0xfc, 0x0c, 0xea, 0x00, 0x4d, 0xed, 0x2b, 0xf5, 0x88, 0xa5, 0x90, 0xa3, 0x0a,
	0x55, 0x81, 0xc2, 0x18, 0xc4, 0x24, 0xa0, 0xe7, 0x07, 0xd0, 0x06, 0xe4, 0x3b, 0xe3, 0xae, 0x5b,
	0x3e, 0x2e, 0x8a, 0xd2, 0xe8, 0x85, 0x54, 0xf2, 0x16, 0x27, 0xe3, 0xa5, 0xc2, 0x26, 0x93, 0x9f,
	0x9e, 0x0a, 0x37, 0x1b, 0x96, 0x0a, 0x9b, 0x8e, 0x9f, 0x0a, 0x13, 0x29, 0xc4, 0xa4, 0xc2, 0xa9,
	0xb8, 0xa9, 0x30, 0x19, 0x5c, 0x0c, 0xeb, 0x86, 0x41, 0x90, 0x6e, 0x55, 0x5a, 0x14, 0x48, 0xb8,
	0x08, 0xb7, 0x18, 0x76, 0x59, 0x8f, 0x3e, 0x11, 0xba, 0xc9, 0x09, 0xb9, 0x14, 0xfd, 0x44, 0x3c,
	0x8c, 0xf7, 0x44, 0xbc, 0x3e, 0x7f, 0xce, 0xea, 0x27, 0xb8, 0xaa, 0x10, 0x9d, 0x72, 0xec, 0x39,
	0xf3, 0xa0, 0xa1, 0x73, 0xe6, 0x85, 0xd1, 0xa7, 0x50, 0xf6, 0xa0, 0xa4, 0x3c, 0x11, 0x51, 0x99,
	0x8a, 0x5e, 0x9e, 0x22, 0xea, 0x22, 0x99, 0x66, 0xd9, 0x0a, 0x46, 0x51, 0x0b, 0x4a, 0x1e, 0x70,
	0xdb, 0xa2, 0xd3, 0x9d, 0xa3, 0x8a, 0x97, 0xa6, 0x28, 0x32, 0x20, 0x13, 0x2c, 0x59, 0x81, 0xe0,
	0xfc, 0x5d, 0xf8, 0xb7, 0xb8, 0x1a, 0xf1, 0xe5, 0x37, 0xc7, 0xca, 0xef, 0x79, 0xbe, 0xfc, 0x4a,
	0x7c, 0xf9, 0x6e, 0xc0, 0xbf, 0x84, 0xb5, 0x27, 0x4e, 0x24, 0xc1, 0x8b, 0x7c, 0x00, 0xc5, 0x40,
	0xc9, 0xe1, 0xc9, 0xb3, 0x02, 0xf2, 0xec, 0x24, 0x79, 0xbc, 0xb5, 0x04, 0x6f, 0x8f, 0x00, 0x39,
	0xc9, 0x93, 0x6f, 0x43, 0x29, 0x58, 0x6f, 0x78, 0x76, 0x51, 0xc0, 0x2e, 0x0a, 0xd8, 0xe2, 0xb1,
	0x53, 0x02, 0x76, 0x2a, 0xc4, 0xee, 0x44, 0x8e, 0x3d, 0x27, 0x60, 0xcf, 0x09, 0xd8, 0xe2, 0xb1,
	0x91, 0x80, 0x8d, 0x78, 0xf6, 0x87, 0x50, 0x0e, 0x95, 0x18, 0x9e, 0x9e, 0x11, 0xd0, 0x33, 0x3c,
	0xfd, 0x23, 0x7c, 0x68, 0x7a, 0xd1, 0xfc, 0xb2, 0x80, 0x5f, 0x16, 0x0d, 0x2f, 0xce, 0x3e, 0x2d,
	0xa0, 0xa7, 0x85, 0xc3, 0x8b, 0xf9, 0xb2, 0x80, 0x2f, 0xf3, 0xfc, 0x35, 0x28, 0xf0, 0xd5, 0x84,
	0xe7, 0x66, 0x05, 0xdc, 0x6c, 0x78, 0xdd, 0x03, 0xc5, 0x24, 0x6e, 0xa7, 0xe7, 0x22, 0x8e, 0x4b,
	0xa0, 0x84, 0xc4, 0x89, 0x14, 0x78, 0x91, 0x87, 0x70, 0x5e, 0x54, 0x32, 0x04, 0x1a, 0xcb, 0xbc,
	0x46, 0x89, 0x78, 0xc4, 0xb1, 0xd9, 0x23, 0xac, 0x80, 0x71, 0x9a, 0x7f, 0x04, 0xe7, 0x04, 0x85,
	0x43, 0x20, 0x5b, 0x0b, 0xba, 0xb1, 0x0a, 0x27, 0x4b, 0x8b, 0x00, 0x96, 0xd8, 0x31, 0xf0, 0xe6,
	0xe4, 0x5d, 0xd9, 0x0f, 0xe7, 0xa0, 0xe4, 0x96, 0xa7, 0x07, 0xe6, 0x91, 0x6a, 0x62, 0x77, 0xf5,
	0x45, 0xb4, 0x77, 0xba, 0x3e, 0x59, 0xd4, 0x5c, 0xd6, 0x5b, 0x58, 0xa8, 0x47, 0x91, 0x16, 0x6a,
	0x25, 0x5e, 0x3e, 0xce, 0x49, 0x35, 0x26, 0x9c, 0xd4, 0xe5, 0x68, 0xd1, 0x28, 0x43, 0xd5, 0x98,
	0x30, 0x54, 0xd3, 0x45, 0x84, 0xbe, 0xaa, 0x39, 0xe9, 0xab, 0x96, 0xa3, 0x55, 0xa2, 0xed, 0x55,
	0x73, 0xd2, 0x5e, 0xc5, 0xe8, 0x88, 0x5d, 0x56, 0x73, 0xd2, 0x65, 0x4d, 0xd1, 0x89, 0x36, 0x5b,
	0xcd, 0x49, 0xb3, 0x15, 0xa3, 0x23, 0xf6, 0x5c, 0x9b, 0x02, 0xcf, 0x75, 0x25, 0x5a, 0x68, 0x9a,
	0xf5, 0xda, 0x12, 0x59, 0xaf, 0xab, 0x53, 0x92, 0x9a, 0xea, 0xc0, 0x36, 0x05, 0x0e, 0x2c, 0x2e,
	0xb1, 0x08, 0x23, 0xb6, 0x25, 0x32, 0x62, 0xb1, 0x89, 0x45, 0xf9, 0xb1, 0x8f, 0xc3, 0x7e, 0xec,
	0x52, 0xb4, 0x92, 0xd8, 0x96, 0x35, 0x27, 0x6d, 0xd9, 0x72, 0xdc, 0x99, 0x13, 0xb9, 0xb3, 0x47,
	0x91, 0xee, 0xec, 0x2f, 0x1c, 0xe1, 0x38, 0x93, 0xf6, 0x59, 0x94, 0x49, 0xab, 0xc5, 0x6b, 0x4f,
	0xf7, 0x6a, 0x7b, 0x11, 0x5e, 0xed, 0x5a, 0xbc, 0xf0, 0x99, 0x65, 0x3b, 0xb3, 0x6c, 0x67, 0x96,
	0xed, 0xcc, 0xb2, 0xfd, 0xf3, 0x96, 0x6d, 0x2d, 0xf5, 0xf5, 0xb7, 0x8b, 0x52, 0xf5, 0xd7, 0x24,
	0x94, 0xdc, 0x2f, 0x83, 0xfb, 0x9a, 0x3d, 0x20, 0xe5, 0x6d, 0x1b, 0x0a, 0xe4, 0x63, 0xee, 0xc1,
	0x48, 0x39, 0x3e, 0xc6, 0x44, 0xd7, 0xb3, 0x5d, 0x9d, 0xfc, 0x94, 0xe8, 0x12, 0x6a, 0x2d, 0x8c,
	0xde, 0x66, 0x60, 0xf7, 0x75, 0xa3, 0x8f, 0x23, 0xe8, 0x13, 0xc8, 0x8f, 0xac, 0xbe, 0xaf, 0x96,
	0x98, 0x78, 0x11, 0x86, 0xd4, 0xd8, 0x4c, 0xc7, 0x62, 0x30, 0xf2, 0x03, 0x24, 0xb5, 0x2e, 0x7e,
	0x4a, 0xbe, 0x58, 0x32, 0x2e, 0x35, 0xf2, 0x4c, 0x83, 0xa9, 0x75, 0xc7, 0x11, 0xb2, 0x6d, 0xc3,
	0xb9, 0xc7, 0x55, 0xba, 0xc0, 0xe6, 0xd9, 0x87, 0x72, 0x28, 0x5b, 0xc1, 0x99, 0xff, 0x1b, 0xcf,
	0x86, 0x24, 0x16, 0xce, 0x3c, 0xee, 0x4c, 0xf0, 0x1b, 0xb2, 0xfa, 0x5f, 0x28, 0x06, 0xb4, 0x51,
	0x01, 0xa4, 0x1e, 0xa5, 0x4a, 0x6d, 0xa9, 0x57, 0xfd, 0x46, 0x82, 0x3c, 0xa9, 0x93, 0xff, 0x5f,
	0xbd, 0xb5, 0xa3, 0x68, 0x26, 0xba, 0x07, 0xa9, 0xa1, 0xda, 0xb3, 0x29, 0xa0, 0x50, 0xbf, 0x79,
	0xfa, 0x6c, 0x71, 0xe6, 0xf7, 0x67, 0x8b, 0xff, 0x8b, 0xf9, 0x97, 0xc0, 0xb1, 0x6c, 0x63, 0x54,
	0x73, 0x75, 0xda, 0x54, 0x01, 0x3b, 0x83, 0x59, 0x93, 0x7c, 0xb4, 0x67, 0x29, 0xd5, 0xaf, 0xbf,
	0xb5, 0x0c, 0xa3, 0x57, 0x4f, 0x25, 0x98, 0x6b, 0x18, 0xba, 0xad, 0x68, 0xba, 0xc5, 0xbe, 0xd6,
	0x92, 0x37, 0xe4, 0x53, 0x09, 0x72, 0x7e, 0x0f, 0x75, 0xa1, 0xe4, 0x77, 0xe8, 0x47, 0x70, 0x77,
	0xa7, 0xae, 0x71, 0x2b, 0x3c, 0xa1, 0x51, 0x13, 0x5c, 0x51, 0xb2, 0xfb, 0x4e, 0xd6, 0x03, 0xc1,
	0xf9, 0x75, 0x38, 0x27, 0x80, 0xbd, 0xcd, 0x0b, 0xf9, 0xea, 0x05, 0xc8, 0xb8, 0x47, 0x1b, 0xa5,
	0x21, 0xb1, 0xbd, 0x2e, 0xcf, 0xd0, 0xdf, 0xba, 0x2c, 0xd1, 0xdf, 0x86, 0x9c, 0xa8, 0x6f, 0x9d,
	0xbe, 0x58, 0x98, 0xf9, 0x05, 0xb7, 0xdf, 0x70, 0x7b, 0xfe, 0x62, 0x41, 0x7a, 0x85, 0xdb, 0x6b,
	0xdc, 0xde, 0xe0, 0xf6, 0xe4, 0xe5, 0x82, 0xf4, 0x1d, 0x6e, 0xdf, 0xe3, 0xf6, 0x23, 0x6e, 0x3f,
	0xe1, 0x76, 0xfa, 0x12, 0xe3, 0x71, 0x7b, 0x8e, 0xaf, 0x5f, 0xe1, 0xdf, 0xd7, 0xf8, 0xf7, 0x0d,
	0xfe, 0x7d, 0xf2, 0xc7, 0x82, 0xd4, 0x4d, 0xb3, 0xb9, 0xff, 0x19, 0x00, 0x00, 0xff, 0xff, 0x21,
	0xd6, 0xef, 0xbc, 0x4a, 0x1a, 0x00, 0x00,
}
