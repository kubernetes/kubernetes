// Code generated by protoc-gen-gogo.
// source: packed.proto
// DO NOT EDIT!

/*
	Package packed is a generated protocol buffer package.

	It is generated from these files:
		packed.proto

	It has these top-level messages:
		NinRepNative
		NinRepPackedNative
		NinRepNativeUnsafe
		NinRepPackedNativeUnsafe
*/
package packed

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

import unsafe "unsafe"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type NinRepNative struct {
	Field1           []float64 `protobuf:"fixed64,1,rep,name=Field1,json=field1" json:"Field1,omitempty"`
	Field2           []float32 `protobuf:"fixed32,2,rep,name=Field2,json=field2" json:"Field2,omitempty"`
	Field3           []int32   `protobuf:"varint,3,rep,name=Field3,json=field3" json:"Field3,omitempty"`
	Field4           []int64   `protobuf:"varint,4,rep,name=Field4,json=field4" json:"Field4,omitempty"`
	Field5           []uint32  `protobuf:"varint,5,rep,name=Field5,json=field5" json:"Field5,omitempty"`
	Field6           []uint64  `protobuf:"varint,6,rep,name=Field6,json=field6" json:"Field6,omitempty"`
	Field7           []int32   `protobuf:"zigzag32,7,rep,name=Field7,json=field7" json:"Field7,omitempty"`
	Field8           []int64   `protobuf:"zigzag64,8,rep,name=Field8,json=field8" json:"Field8,omitempty"`
	Field9           []uint32  `protobuf:"fixed32,9,rep,name=Field9,json=field9" json:"Field9,omitempty"`
	Field10          []int32   `protobuf:"fixed32,10,rep,name=Field10,json=field10" json:"Field10,omitempty"`
	Field11          []uint64  `protobuf:"fixed64,11,rep,name=Field11,json=field11" json:"Field11,omitempty"`
	Field12          []int64   `protobuf:"fixed64,12,rep,name=Field12,json=field12" json:"Field12,omitempty"`
	Field13          []bool    `protobuf:"varint,13,rep,name=Field13,json=field13" json:"Field13,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *NinRepNative) Reset()                    { *m = NinRepNative{} }
func (m *NinRepNative) String() string            { return proto.CompactTextString(m) }
func (*NinRepNative) ProtoMessage()               {}
func (*NinRepNative) Descriptor() ([]byte, []int) { return fileDescriptorPacked, []int{0} }

func (m *NinRepNative) GetField1() []float64 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinRepNative) GetField2() []float32 {
	if m != nil {
		return m.Field2
	}
	return nil
}

func (m *NinRepNative) GetField3() []int32 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepNative) GetField4() []int64 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepNative) GetField5() []uint32 {
	if m != nil {
		return m.Field5
	}
	return nil
}

func (m *NinRepNative) GetField6() []uint64 {
	if m != nil {
		return m.Field6
	}
	return nil
}

func (m *NinRepNative) GetField7() []int32 {
	if m != nil {
		return m.Field7
	}
	return nil
}

func (m *NinRepNative) GetField8() []int64 {
	if m != nil {
		return m.Field8
	}
	return nil
}

func (m *NinRepNative) GetField9() []uint32 {
	if m != nil {
		return m.Field9
	}
	return nil
}

func (m *NinRepNative) GetField10() []int32 {
	if m != nil {
		return m.Field10
	}
	return nil
}

func (m *NinRepNative) GetField11() []uint64 {
	if m != nil {
		return m.Field11
	}
	return nil
}

func (m *NinRepNative) GetField12() []int64 {
	if m != nil {
		return m.Field12
	}
	return nil
}

func (m *NinRepNative) GetField13() []bool {
	if m != nil {
		return m.Field13
	}
	return nil
}

type NinRepPackedNative struct {
	Field1           []float64 `protobuf:"fixed64,1,rep,packed,name=Field1,json=field1" json:"Field1,omitempty"`
	Field2           []float32 `protobuf:"fixed32,2,rep,packed,name=Field2,json=field2" json:"Field2,omitempty"`
	Field3           []int32   `protobuf:"varint,3,rep,packed,name=Field3,json=field3" json:"Field3,omitempty"`
	Field4           []int64   `protobuf:"varint,4,rep,packed,name=Field4,json=field4" json:"Field4,omitempty"`
	Field5           []uint32  `protobuf:"varint,5,rep,packed,name=Field5,json=field5" json:"Field5,omitempty"`
	Field6           []uint64  `protobuf:"varint,6,rep,packed,name=Field6,json=field6" json:"Field6,omitempty"`
	Field7           []int32   `protobuf:"zigzag32,7,rep,packed,name=Field7,json=field7" json:"Field7,omitempty"`
	Field8           []int64   `protobuf:"zigzag64,8,rep,packed,name=Field8,json=field8" json:"Field8,omitempty"`
	Field9           []uint32  `protobuf:"fixed32,9,rep,packed,name=Field9,json=field9" json:"Field9,omitempty"`
	Field10          []int32   `protobuf:"fixed32,10,rep,packed,name=Field10,json=field10" json:"Field10,omitempty"`
	Field11          []uint64  `protobuf:"fixed64,11,rep,packed,name=Field11,json=field11" json:"Field11,omitempty"`
	Field12          []int64   `protobuf:"fixed64,12,rep,packed,name=Field12,json=field12" json:"Field12,omitempty"`
	Field13          []bool    `protobuf:"varint,13,rep,packed,name=Field13,json=field13" json:"Field13,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *NinRepPackedNative) Reset()                    { *m = NinRepPackedNative{} }
func (m *NinRepPackedNative) String() string            { return proto.CompactTextString(m) }
func (*NinRepPackedNative) ProtoMessage()               {}
func (*NinRepPackedNative) Descriptor() ([]byte, []int) { return fileDescriptorPacked, []int{1} }

func (m *NinRepPackedNative) GetField1() []float64 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinRepPackedNative) GetField2() []float32 {
	if m != nil {
		return m.Field2
	}
	return nil
}

func (m *NinRepPackedNative) GetField3() []int32 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepPackedNative) GetField4() []int64 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepPackedNative) GetField5() []uint32 {
	if m != nil {
		return m.Field5
	}
	return nil
}

func (m *NinRepPackedNative) GetField6() []uint64 {
	if m != nil {
		return m.Field6
	}
	return nil
}

func (m *NinRepPackedNative) GetField7() []int32 {
	if m != nil {
		return m.Field7
	}
	return nil
}

func (m *NinRepPackedNative) GetField8() []int64 {
	if m != nil {
		return m.Field8
	}
	return nil
}

func (m *NinRepPackedNative) GetField9() []uint32 {
	if m != nil {
		return m.Field9
	}
	return nil
}

func (m *NinRepPackedNative) GetField10() []int32 {
	if m != nil {
		return m.Field10
	}
	return nil
}

func (m *NinRepPackedNative) GetField11() []uint64 {
	if m != nil {
		return m.Field11
	}
	return nil
}

func (m *NinRepPackedNative) GetField12() []int64 {
	if m != nil {
		return m.Field12
	}
	return nil
}

func (m *NinRepPackedNative) GetField13() []bool {
	if m != nil {
		return m.Field13
	}
	return nil
}

type NinRepNativeUnsafe struct {
	Field1           []float64 `protobuf:"fixed64,1,rep,name=Field1,json=field1" json:"Field1,omitempty"`
	Field2           []float32 `protobuf:"fixed32,2,rep,name=Field2,json=field2" json:"Field2,omitempty"`
	Field3           []int32   `protobuf:"varint,3,rep,name=Field3,json=field3" json:"Field3,omitempty"`
	Field4           []int64   `protobuf:"varint,4,rep,name=Field4,json=field4" json:"Field4,omitempty"`
	Field5           []uint32  `protobuf:"varint,5,rep,name=Field5,json=field5" json:"Field5,omitempty"`
	Field6           []uint64  `protobuf:"varint,6,rep,name=Field6,json=field6" json:"Field6,omitempty"`
	Field7           []int32   `protobuf:"zigzag32,7,rep,name=Field7,json=field7" json:"Field7,omitempty"`
	Field8           []int64   `protobuf:"zigzag64,8,rep,name=Field8,json=field8" json:"Field8,omitempty"`
	Field9           []uint32  `protobuf:"fixed32,9,rep,name=Field9,json=field9" json:"Field9,omitempty"`
	Field10          []int32   `protobuf:"fixed32,10,rep,name=Field10,json=field10" json:"Field10,omitempty"`
	Field11          []uint64  `protobuf:"fixed64,11,rep,name=Field11,json=field11" json:"Field11,omitempty"`
	Field12          []int64   `protobuf:"fixed64,12,rep,name=Field12,json=field12" json:"Field12,omitempty"`
	Field13          []bool    `protobuf:"varint,13,rep,name=Field13,json=field13" json:"Field13,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *NinRepNativeUnsafe) Reset()                    { *m = NinRepNativeUnsafe{} }
func (m *NinRepNativeUnsafe) String() string            { return proto.CompactTextString(m) }
func (*NinRepNativeUnsafe) ProtoMessage()               {}
func (*NinRepNativeUnsafe) Descriptor() ([]byte, []int) { return fileDescriptorPacked, []int{2} }

func (m *NinRepNativeUnsafe) GetField1() []float64 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField2() []float32 {
	if m != nil {
		return m.Field2
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField3() []int32 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField4() []int64 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField5() []uint32 {
	if m != nil {
		return m.Field5
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField6() []uint64 {
	if m != nil {
		return m.Field6
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField7() []int32 {
	if m != nil {
		return m.Field7
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField8() []int64 {
	if m != nil {
		return m.Field8
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField9() []uint32 {
	if m != nil {
		return m.Field9
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField10() []int32 {
	if m != nil {
		return m.Field10
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField11() []uint64 {
	if m != nil {
		return m.Field11
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField12() []int64 {
	if m != nil {
		return m.Field12
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField13() []bool {
	if m != nil {
		return m.Field13
	}
	return nil
}

type NinRepPackedNativeUnsafe struct {
	Field1           []float64 `protobuf:"fixed64,1,rep,packed,name=Field1,json=field1" json:"Field1,omitempty"`
	Field2           []float32 `protobuf:"fixed32,2,rep,packed,name=Field2,json=field2" json:"Field2,omitempty"`
	Field3           []int32   `protobuf:"varint,3,rep,packed,name=Field3,json=field3" json:"Field3,omitempty"`
	Field4           []int64   `protobuf:"varint,4,rep,packed,name=Field4,json=field4" json:"Field4,omitempty"`
	Field5           []uint32  `protobuf:"varint,5,rep,packed,name=Field5,json=field5" json:"Field5,omitempty"`
	Field6           []uint64  `protobuf:"varint,6,rep,packed,name=Field6,json=field6" json:"Field6,omitempty"`
	Field7           []int32   `protobuf:"zigzag32,7,rep,packed,name=Field7,json=field7" json:"Field7,omitempty"`
	Field8           []int64   `protobuf:"zigzag64,8,rep,packed,name=Field8,json=field8" json:"Field8,omitempty"`
	Field9           []uint32  `protobuf:"fixed32,9,rep,packed,name=Field9,json=field9" json:"Field9,omitempty"`
	Field10          []int32   `protobuf:"fixed32,10,rep,packed,name=Field10,json=field10" json:"Field10,omitempty"`
	Field11          []uint64  `protobuf:"fixed64,11,rep,packed,name=Field11,json=field11" json:"Field11,omitempty"`
	Field12          []int64   `protobuf:"fixed64,12,rep,packed,name=Field12,json=field12" json:"Field12,omitempty"`
	Field13          []bool    `protobuf:"varint,13,rep,packed,name=Field13,json=field13" json:"Field13,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *NinRepPackedNativeUnsafe) Reset()                    { *m = NinRepPackedNativeUnsafe{} }
func (m *NinRepPackedNativeUnsafe) String() string            { return proto.CompactTextString(m) }
func (*NinRepPackedNativeUnsafe) ProtoMessage()               {}
func (*NinRepPackedNativeUnsafe) Descriptor() ([]byte, []int) { return fileDescriptorPacked, []int{3} }

func (m *NinRepPackedNativeUnsafe) GetField1() []float64 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField2() []float32 {
	if m != nil {
		return m.Field2
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField3() []int32 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField4() []int64 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField5() []uint32 {
	if m != nil {
		return m.Field5
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField6() []uint64 {
	if m != nil {
		return m.Field6
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField7() []int32 {
	if m != nil {
		return m.Field7
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField8() []int64 {
	if m != nil {
		return m.Field8
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField9() []uint32 {
	if m != nil {
		return m.Field9
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField10() []int32 {
	if m != nil {
		return m.Field10
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField11() []uint64 {
	if m != nil {
		return m.Field11
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField12() []int64 {
	if m != nil {
		return m.Field12
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField13() []bool {
	if m != nil {
		return m.Field13
	}
	return nil
}

func init() {
	proto.RegisterType((*NinRepNative)(nil), "packed.NinRepNative")
	proto.RegisterType((*NinRepPackedNative)(nil), "packed.NinRepPackedNative")
	proto.RegisterType((*NinRepNativeUnsafe)(nil), "packed.NinRepNativeUnsafe")
	proto.RegisterType((*NinRepPackedNativeUnsafe)(nil), "packed.NinRepPackedNativeUnsafe")
}
func NewPopulatedNinRepNative(r randyPacked, easy bool) *NinRepNative {
	this := &NinRepNative{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(10)
		this.Field1 = make([]float64, v1)
		for i := 0; i < v1; i++ {
			this.Field1[i] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Field1[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(10)
		this.Field2 = make([]float32, v2)
		for i := 0; i < v2; i++ {
			this.Field2[i] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.Field2[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.Field3 = make([]int32, v3)
		for i := 0; i < v3; i++ {
			this.Field3[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field3[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Field4 = make([]int64, v4)
		for i := 0; i < v4; i++ {
			this.Field4[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field4[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.Field5 = make([]uint32, v5)
		for i := 0; i < v5; i++ {
			this.Field5[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(10)
		this.Field6 = make([]uint64, v6)
		for i := 0; i < v6; i++ {
			this.Field6[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.Field7 = make([]int32, v7)
		for i := 0; i < v7; i++ {
			this.Field7[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field7[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(10)
		this.Field8 = make([]int64, v8)
		for i := 0; i < v8; i++ {
			this.Field8[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field8[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(10)
		this.Field9 = make([]uint32, v9)
		for i := 0; i < v9; i++ {
			this.Field9[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(10)
		this.Field10 = make([]int32, v10)
		for i := 0; i < v10; i++ {
			this.Field10[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field10[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v11 := r.Intn(10)
		this.Field11 = make([]uint64, v11)
		for i := 0; i < v11; i++ {
			this.Field11[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v12 := r.Intn(10)
		this.Field12 = make([]int64, v12)
		for i := 0; i < v12; i++ {
			this.Field12[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field12[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v13 := r.Intn(10)
		this.Field13 = make([]bool, v13)
		for i := 0; i < v13; i++ {
			this.Field13[i] = bool(bool(r.Intn(2) == 0))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPacked(r, 14)
	}
	return this
}

func NewPopulatedNinRepPackedNative(r randyPacked, easy bool) *NinRepPackedNative {
	this := &NinRepPackedNative{}
	if r.Intn(10) != 0 {
		v14 := r.Intn(10)
		this.Field1 = make([]float64, v14)
		for i := 0; i < v14; i++ {
			this.Field1[i] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Field1[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v15 := r.Intn(10)
		this.Field2 = make([]float32, v15)
		for i := 0; i < v15; i++ {
			this.Field2[i] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.Field2[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v16 := r.Intn(10)
		this.Field3 = make([]int32, v16)
		for i := 0; i < v16; i++ {
			this.Field3[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field3[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v17 := r.Intn(10)
		this.Field4 = make([]int64, v17)
		for i := 0; i < v17; i++ {
			this.Field4[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field4[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(10)
		this.Field5 = make([]uint32, v18)
		for i := 0; i < v18; i++ {
			this.Field5[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(10)
		this.Field6 = make([]uint64, v19)
		for i := 0; i < v19; i++ {
			this.Field6[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v20 := r.Intn(10)
		this.Field7 = make([]int32, v20)
		for i := 0; i < v20; i++ {
			this.Field7[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field7[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v21 := r.Intn(10)
		this.Field8 = make([]int64, v21)
		for i := 0; i < v21; i++ {
			this.Field8[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field8[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v22 := r.Intn(10)
		this.Field9 = make([]uint32, v22)
		for i := 0; i < v22; i++ {
			this.Field9[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(10)
		this.Field10 = make([]int32, v23)
		for i := 0; i < v23; i++ {
			this.Field10[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field10[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v24 := r.Intn(10)
		this.Field11 = make([]uint64, v24)
		for i := 0; i < v24; i++ {
			this.Field11[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v25 := r.Intn(10)
		this.Field12 = make([]int64, v25)
		for i := 0; i < v25; i++ {
			this.Field12[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field12[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v26 := r.Intn(10)
		this.Field13 = make([]bool, v26)
		for i := 0; i < v26; i++ {
			this.Field13[i] = bool(bool(r.Intn(2) == 0))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPacked(r, 14)
	}
	return this
}

func NewPopulatedNinRepNativeUnsafe(r randyPacked, easy bool) *NinRepNativeUnsafe {
	this := &NinRepNativeUnsafe{}
	if r.Intn(10) != 0 {
		v27 := r.Intn(10)
		this.Field1 = make([]float64, v27)
		for i := 0; i < v27; i++ {
			this.Field1[i] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Field1[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v28 := r.Intn(10)
		this.Field2 = make([]float32, v28)
		for i := 0; i < v28; i++ {
			this.Field2[i] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.Field2[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v29 := r.Intn(10)
		this.Field3 = make([]int32, v29)
		for i := 0; i < v29; i++ {
			this.Field3[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field3[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v30 := r.Intn(10)
		this.Field4 = make([]int64, v30)
		for i := 0; i < v30; i++ {
			this.Field4[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field4[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v31 := r.Intn(10)
		this.Field5 = make([]uint32, v31)
		for i := 0; i < v31; i++ {
			this.Field5[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v32 := r.Intn(10)
		this.Field6 = make([]uint64, v32)
		for i := 0; i < v32; i++ {
			this.Field6[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v33 := r.Intn(10)
		this.Field7 = make([]int32, v33)
		for i := 0; i < v33; i++ {
			this.Field7[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field7[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v34 := r.Intn(10)
		this.Field8 = make([]int64, v34)
		for i := 0; i < v34; i++ {
			this.Field8[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field8[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v35 := r.Intn(10)
		this.Field9 = make([]uint32, v35)
		for i := 0; i < v35; i++ {
			this.Field9[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v36 := r.Intn(10)
		this.Field10 = make([]int32, v36)
		for i := 0; i < v36; i++ {
			this.Field10[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field10[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v37 := r.Intn(10)
		this.Field11 = make([]uint64, v37)
		for i := 0; i < v37; i++ {
			this.Field11[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v38 := r.Intn(10)
		this.Field12 = make([]int64, v38)
		for i := 0; i < v38; i++ {
			this.Field12[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field12[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v39 := r.Intn(10)
		this.Field13 = make([]bool, v39)
		for i := 0; i < v39; i++ {
			this.Field13[i] = bool(bool(r.Intn(2) == 0))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPacked(r, 14)
	}
	return this
}

func NewPopulatedNinRepPackedNativeUnsafe(r randyPacked, easy bool) *NinRepPackedNativeUnsafe {
	this := &NinRepPackedNativeUnsafe{}
	if r.Intn(10) != 0 {
		v40 := r.Intn(10)
		this.Field1 = make([]float64, v40)
		for i := 0; i < v40; i++ {
			this.Field1[i] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Field1[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v41 := r.Intn(10)
		this.Field2 = make([]float32, v41)
		for i := 0; i < v41; i++ {
			this.Field2[i] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.Field2[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v42 := r.Intn(10)
		this.Field3 = make([]int32, v42)
		for i := 0; i < v42; i++ {
			this.Field3[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field3[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v43 := r.Intn(10)
		this.Field4 = make([]int64, v43)
		for i := 0; i < v43; i++ {
			this.Field4[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field4[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v44 := r.Intn(10)
		this.Field5 = make([]uint32, v44)
		for i := 0; i < v44; i++ {
			this.Field5[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v45 := r.Intn(10)
		this.Field6 = make([]uint64, v45)
		for i := 0; i < v45; i++ {
			this.Field6[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v46 := r.Intn(10)
		this.Field7 = make([]int32, v46)
		for i := 0; i < v46; i++ {
			this.Field7[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field7[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v47 := r.Intn(10)
		this.Field8 = make([]int64, v47)
		for i := 0; i < v47; i++ {
			this.Field8[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field8[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v48 := r.Intn(10)
		this.Field9 = make([]uint32, v48)
		for i := 0; i < v48; i++ {
			this.Field9[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(10) != 0 {
		v49 := r.Intn(10)
		this.Field10 = make([]int32, v49)
		for i := 0; i < v49; i++ {
			this.Field10[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field10[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v50 := r.Intn(10)
		this.Field11 = make([]uint64, v50)
		for i := 0; i < v50; i++ {
			this.Field11[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v51 := r.Intn(10)
		this.Field12 = make([]int64, v51)
		for i := 0; i < v51; i++ {
			this.Field12[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field12[i] *= -1
			}
		}
	}
	if r.Intn(10) != 0 {
		v52 := r.Intn(10)
		this.Field13 = make([]bool, v52)
		for i := 0; i < v52; i++ {
			this.Field13[i] = bool(bool(r.Intn(2) == 0))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPacked(r, 14)
	}
	return this
}

type randyPacked interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RunePacked(r randyPacked) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringPacked(r randyPacked) string {
	v53 := r.Intn(100)
	tmps := make([]rune, v53)
	for i := 0; i < v53; i++ {
		tmps[i] = randUTF8RunePacked(r)
	}
	return string(tmps)
}
func randUnrecognizedPacked(r randyPacked, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldPacked(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldPacked(data []byte, r randyPacked, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulatePacked(data, uint64(key))
		v54 := r.Int63()
		if r.Intn(2) == 0 {
			v54 *= -1
		}
		data = encodeVarintPopulatePacked(data, uint64(v54))
	case 1:
		data = encodeVarintPopulatePacked(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulatePacked(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulatePacked(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulatePacked(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulatePacked(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *NinRepNative) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacked
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NinRepNative: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NinRepNative: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Field1 = append(m.Field1, v2)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			v2 := float32(math.Float32frombits(v))
			m.Field2 = append(m.Field2, v2)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field3 = append(m.Field3, v)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field4 = append(m.Field4, v)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field5 = append(m.Field5, v)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field6 = append(m.Field6, v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Field7 = append(m.Field7, v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Field8 = append(m.Field8, int64(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Field9 = append(m.Field9, v)
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = int32(data[iNdEx-4])
			v |= int32(data[iNdEx-3]) << 8
			v |= int32(data[iNdEx-2]) << 16
			v |= int32(data[iNdEx-1]) << 24
			m.Field10 = append(m.Field10, v)
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Field11 = append(m.Field11, v)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = int64(data[iNdEx-8])
			v |= int64(data[iNdEx-7]) << 8
			v |= int64(data[iNdEx-6]) << 16
			v |= int64(data[iNdEx-5]) << 24
			v |= int64(data[iNdEx-4]) << 32
			v |= int64(data[iNdEx-3]) << 40
			v |= int64(data[iNdEx-2]) << 48
			v |= int64(data[iNdEx-1]) << 56
			m.Field12 = append(m.Field12, v)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field13 = append(m.Field13, bool(v != 0))
		default:
			iNdEx = preIndex
			skippy, err := skipPacked(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPacked
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NinRepPackedNative) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacked
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NinRepPackedNative: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NinRepPackedNative: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Field1 = append(m.Field1, v2)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Field1 = append(m.Field1, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(data[iNdEx-4])
					v |= uint32(data[iNdEx-3]) << 8
					v |= uint32(data[iNdEx-2]) << 16
					v |= uint32(data[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Field2 = append(m.Field2, v2)
				}
			} else if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(data[iNdEx-4])
				v |= uint32(data[iNdEx-3]) << 8
				v |= uint32(data[iNdEx-2]) << 16
				v |= uint32(data[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Field2 = append(m.Field2, v2)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field3 = append(m.Field3, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field3 = append(m.Field3, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
		case 4:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field4 = append(m.Field4, v)
				}
			} else if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field4 = append(m.Field4, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
		case 5:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field5 = append(m.Field5, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field5 = append(m.Field5, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field6 = append(m.Field6, v)
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field6 = append(m.Field6, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
		case 7:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Field7 = append(m.Field7, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Field7 = append(m.Field7, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Field8 = append(m.Field8, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Field8 = append(m.Field8, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
		case 9:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(data[iNdEx-4])
					v |= uint32(data[iNdEx-3]) << 8
					v |= uint32(data[iNdEx-2]) << 16
					v |= uint32(data[iNdEx-1]) << 24
					m.Field9 = append(m.Field9, v)
				}
			} else if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(data[iNdEx-4])
				v |= uint32(data[iNdEx-3]) << 8
				v |= uint32(data[iNdEx-2]) << 16
				v |= uint32(data[iNdEx-1]) << 24
				m.Field9 = append(m.Field9, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
		case 10:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = int32(data[iNdEx-4])
					v |= int32(data[iNdEx-3]) << 8
					v |= int32(data[iNdEx-2]) << 16
					v |= int32(data[iNdEx-1]) << 24
					m.Field10 = append(m.Field10, v)
				}
			} else if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = int32(data[iNdEx-4])
				v |= int32(data[iNdEx-3]) << 8
				v |= int32(data[iNdEx-2]) << 16
				v |= int32(data[iNdEx-1]) << 24
				m.Field10 = append(m.Field10, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
		case 11:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(data[iNdEx-8])
					v |= uint64(data[iNdEx-7]) << 8
					v |= uint64(data[iNdEx-6]) << 16
					v |= uint64(data[iNdEx-5]) << 24
					v |= uint64(data[iNdEx-4]) << 32
					v |= uint64(data[iNdEx-3]) << 40
					v |= uint64(data[iNdEx-2]) << 48
					v |= uint64(data[iNdEx-1]) << 56
					m.Field11 = append(m.Field11, v)
				}
			} else if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(data[iNdEx-8])
				v |= uint64(data[iNdEx-7]) << 8
				v |= uint64(data[iNdEx-6]) << 16
				v |= uint64(data[iNdEx-5]) << 24
				v |= uint64(data[iNdEx-4]) << 32
				v |= uint64(data[iNdEx-3]) << 40
				v |= uint64(data[iNdEx-2]) << 48
				v |= uint64(data[iNdEx-1]) << 56
				m.Field11 = append(m.Field11, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
		case 12:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = int64(data[iNdEx-8])
					v |= int64(data[iNdEx-7]) << 8
					v |= int64(data[iNdEx-6]) << 16
					v |= int64(data[iNdEx-5]) << 24
					v |= int64(data[iNdEx-4]) << 32
					v |= int64(data[iNdEx-3]) << 40
					v |= int64(data[iNdEx-2]) << 48
					v |= int64(data[iNdEx-1]) << 56
					m.Field12 = append(m.Field12, v)
				}
			} else if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = int64(data[iNdEx-8])
				v |= int64(data[iNdEx-7]) << 8
				v |= int64(data[iNdEx-6]) << 16
				v |= int64(data[iNdEx-5]) << 24
				v |= int64(data[iNdEx-4]) << 32
				v |= int64(data[iNdEx-3]) << 40
				v |= int64(data[iNdEx-2]) << 48
				v |= int64(data[iNdEx-1]) << 56
				m.Field12 = append(m.Field12, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
		case 13:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field13 = append(m.Field13, bool(v != 0))
				}
			} else if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field13 = append(m.Field13, bool(v != 0))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacked(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPacked
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPacked(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPacked
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPacked
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPacked(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPacked = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPacked   = fmt.Errorf("proto: integer overflow")
)

func (m *NinRepNativeUnsafe) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPackedUnsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NinRepNativeUnsafe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NinRepNativeUnsafe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
			var v float64
			if iNdEx+8 > l {
				return io.ErrUnexpectedEOF
			}
			v = *(*float64)(unsafe.Pointer(&data[iNdEx]))
			iNdEx += 8
			m.Field1 = append(m.Field1, v)
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
			var v float32
			if iNdEx+4 > l {
				return io.ErrUnexpectedEOF
			}
			v = *(*float32)(unsafe.Pointer(&data[iNdEx]))
			iNdEx += 4
			m.Field2 = append(m.Field2, v)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field3 = append(m.Field3, v)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field4 = append(m.Field4, v)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field5 = append(m.Field5, v)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field6 = append(m.Field6, v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Field7 = append(m.Field7, v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Field8 = append(m.Field8, int64(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
			var v uint32
			if iNdEx+4 > l {
				return io.ErrUnexpectedEOF
			}
			v = *(*uint32)(unsafe.Pointer(&data[iNdEx]))
			iNdEx += 4
			m.Field9 = append(m.Field9, v)
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
			var v int32
			if iNdEx+4 > l {
				return io.ErrUnexpectedEOF
			}
			v = *(*int32)(unsafe.Pointer(&data[iNdEx]))
			iNdEx += 4
			m.Field10 = append(m.Field10, v)
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
			var v uint64
			if iNdEx+8 > l {
				return io.ErrUnexpectedEOF
			}
			v = *(*uint64)(unsafe.Pointer(&data[iNdEx]))
			iNdEx += 8
			m.Field11 = append(m.Field11, v)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
			var v int64
			if iNdEx+8 > l {
				return io.ErrUnexpectedEOF
			}
			v = *(*int64)(unsafe.Pointer(&data[iNdEx]))
			iNdEx += 8
			m.Field12 = append(m.Field12, v)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Field13 = append(m.Field13, bool(v != 0))
		default:
			iNdEx = preIndex
			skippy, err := skipPackedUnsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPackedUnsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NinRepPackedNativeUnsafe) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPackedUnsafe
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NinRepPackedNativeUnsafe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NinRepPackedNativeUnsafe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v float64
					if iNdEx+8 > l {
						return io.ErrUnexpectedEOF
					}
					v = *(*float64)(unsafe.Pointer(&data[iNdEx]))
					iNdEx += 8
					m.Field1 = append(m.Field1, v)
				}
			} else if wireType == 1 {
				var v float64
				if iNdEx+8 > l {
					return io.ErrUnexpectedEOF
				}
				v = *(*float64)(unsafe.Pointer(&data[iNdEx]))
				iNdEx += 8
				m.Field1 = append(m.Field1, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v float32
					if iNdEx+4 > l {
						return io.ErrUnexpectedEOF
					}
					v = *(*float32)(unsafe.Pointer(&data[iNdEx]))
					iNdEx += 4
					m.Field2 = append(m.Field2, v)
				}
			} else if wireType == 5 {
				var v float32
				if iNdEx+4 > l {
					return io.ErrUnexpectedEOF
				}
				v = *(*float32)(unsafe.Pointer(&data[iNdEx]))
				iNdEx += 4
				m.Field2 = append(m.Field2, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
		case 3:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPackedUnsafe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field3 = append(m.Field3, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field3 = append(m.Field3, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
		case 4:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPackedUnsafe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field4 = append(m.Field4, v)
				}
			} else if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field4 = append(m.Field4, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
		case 5:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPackedUnsafe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field5 = append(m.Field5, v)
				}
			} else if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field5 = append(m.Field5, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPackedUnsafe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field6 = append(m.Field6, v)
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field6 = append(m.Field6, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
		case 7:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPackedUnsafe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Field7 = append(m.Field7, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Field7 = append(m.Field7, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
		case 8:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPackedUnsafe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Field8 = append(m.Field8, int64(v))
				}
			} else if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Field8 = append(m.Field8, int64(v))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
		case 9:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if iNdEx+4 > l {
						return io.ErrUnexpectedEOF
					}
					v = *(*uint32)(unsafe.Pointer(&data[iNdEx]))
					iNdEx += 4
					m.Field9 = append(m.Field9, v)
				}
			} else if wireType == 5 {
				var v uint32
				if iNdEx+4 > l {
					return io.ErrUnexpectedEOF
				}
				v = *(*uint32)(unsafe.Pointer(&data[iNdEx]))
				iNdEx += 4
				m.Field9 = append(m.Field9, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
		case 10:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					if iNdEx+4 > l {
						return io.ErrUnexpectedEOF
					}
					v = *(*int32)(unsafe.Pointer(&data[iNdEx]))
					iNdEx += 4
					m.Field10 = append(m.Field10, v)
				}
			} else if wireType == 5 {
				var v int32
				if iNdEx+4 > l {
					return io.ErrUnexpectedEOF
				}
				v = *(*int32)(unsafe.Pointer(&data[iNdEx]))
				iNdEx += 4
				m.Field10 = append(m.Field10, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
		case 11:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if iNdEx+8 > l {
						return io.ErrUnexpectedEOF
					}
					v = *(*uint64)(unsafe.Pointer(&data[iNdEx]))
					iNdEx += 8
					m.Field11 = append(m.Field11, v)
				}
			} else if wireType == 1 {
				var v uint64
				if iNdEx+8 > l {
					return io.ErrUnexpectedEOF
				}
				v = *(*uint64)(unsafe.Pointer(&data[iNdEx]))
				iNdEx += 8
				m.Field11 = append(m.Field11, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
		case 12:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					if iNdEx+8 > l {
						return io.ErrUnexpectedEOF
					}
					v = *(*int64)(unsafe.Pointer(&data[iNdEx]))
					iNdEx += 8
					m.Field12 = append(m.Field12, v)
				}
			} else if wireType == 1 {
				var v int64
				if iNdEx+8 > l {
					return io.ErrUnexpectedEOF
				}
				v = *(*int64)(unsafe.Pointer(&data[iNdEx]))
				iNdEx += 8
				m.Field12 = append(m.Field12, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
		case 13:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPackedUnsafe
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPackedUnsafe
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field13 = append(m.Field13, bool(v != 0))
				}
			} else if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field13 = append(m.Field13, bool(v != 0))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPackedUnsafe(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPackedUnsafe
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPackedUnsafe(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPackedUnsafe
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPackedUnsafe
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPackedUnsafe
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPackedUnsafe
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPackedUnsafe(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPackedUnsafe = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPackedUnsafe   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorPacked = []byte{
	// 383 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x92, 0xbd, 0x4e, 0xc2, 0x50,
	0x14, 0xc7, 0xd3, 0x0f, 0x5a, 0xbc, 0x42, 0xc4, 0x0e, 0xe6, 0x84, 0x10, 0x35, 0x4c, 0x2e, 0x02,
	0x6d, 0xf9, 0x74, 0x64, 0x70, 0x24, 0x86, 0xc4, 0x07, 0xe0, 0xa3, 0x60, 0xa3, 0x52, 0xa2, 0xc5,
	0xc7, 0x30, 0x0e, 0xbe, 0x80, 0x6f, 0xe2, 0x43, 0x38, 0xb9, 0xf9, 0x16, 0x8e, 0x1e, 0x6e, 0x4f,
	0x4f, 0x2f, 0x38, 0x3a, 0xb8, 0xb0, 0x71, 0x7f, 0xbf, 0x30, 0xf4, 0xf7, 0x3f, 0xa2, 0xb0, 0x1c,
	0x4d, 0x6e, 0x83, 0x69, 0x6d, 0xf9, 0x10, 0xc5, 0x91, 0x63, 0x25, 0xaf, 0xf2, 0xf9, 0x3c, 0x8c,
	0x6f, 0x56, 0xe3, 0xda, 0x24, 0xba, 0xaf, 0xcf, 0xa3, 0x79, 0x54, 0x97, 0x7a, 0xbc, 0x9a, 0xc9,
	0x97, 0x7c, 0xc8, 0x5f, 0xc9, 0xdf, 0xaa, 0x1f, 0xba, 0x28, 0x0c, 0xc2, 0xc5, 0x30, 0x58, 0x0e,
	0x46, 0x71, 0xf8, 0x14, 0x38, 0x47, 0xc2, 0xba, 0x0c, 0x83, 0xbb, 0xa9, 0x0b, 0xda, 0xa9, 0x71,
	0xa6, 0x0d, 0xad, 0x99, 0x7c, 0x31, 0xf7, 0x40, 0x47, 0xae, 0x13, 0xf7, 0x98, 0xfb, 0x60, 0x20,
	0xcf, 0x11, 0xf7, 0x99, 0x37, 0xc1, 0x44, 0x6e, 0x10, 0x6f, 0x32, 0x6f, 0x41, 0x0e, 0x79, 0x91,
	0x78, 0x8b, 0x79, 0x1b, 0x2c, 0xe4, 0x26, 0xf1, 0x36, 0xf3, 0x0e, 0xd8, 0xc8, 0x0f, 0x89, 0x77,
	0x98, 0x77, 0x21, 0x8f, 0xdc, 0x21, 0xde, 0x65, 0xde, 0x83, 0x3d, 0xe4, 0x36, 0xf1, 0x9e, 0x03,
	0xc2, 0x4e, 0xbe, 0xab, 0x01, 0x02, 0xc5, 0xc1, 0xd0, 0x4e, 0x3e, 0xac, 0x91, 0x19, 0x17, 0xf6,
	0xd1, 0x58, 0xa9, 0x71, 0x33, 0xe3, 0x41, 0x01, 0x4d, 0x29, 0x35, 0x5e, 0x66, 0x7c, 0x28, 0xa2,
	0xc9, 0xa7, 0xc6, 0xbf, 0x30, 0x5f, 0xde, 0x4e, 0xb4, 0xea, 0xb3, 0x21, 0x9c, 0x24, 0xeb, 0x95,
	0x9c, 0x85, 0xe2, 0x96, 0x37, 0xe3, 0xf6, 0xf5, 0x52, 0x16, 0xb8, 0xbc, 0x19, 0x58, 0x71, 0x1e,
	0x3b, 0x8a, 0xac, 0x38, 0x9f, 0x1d, 0x85, 0x56, 0x5c, 0x93, 0x1d, 0xc5, 0x56, 0x5c, 0x8b, 0x1d,
	0x05, 0x57, 0x5c, 0x9b, 0x1d, 0x45, 0x57, 0x5c, 0x87, 0x1d, 0x85, 0x57, 0x5c, 0x97, 0x1d, 0xc5,
	0x57, 0x5c, 0xcf, 0xa9, 0x6c, 0x0d, 0x20, 0x25, 0x8f, 0x50, 0xd9, 0x1a, 0x41, 0xb5, 0x6e, 0x66,
	0x69, 0x08, 0xd5, 0x7a, 0x99, 0xa5, 0x31, 0x54, 0x9b, 0x0e, 0xf2, 0xa9, 0xa7, 0x83, 0x24, 0x53,
	0x5c, 0x2f, 0x1e, 0x47, 0xb3, 0xdd, 0xb5, 0xff, 0xf9, 0xda, 0xdf, 0xd7, 0x71, 0x5f, 0x0d, 0x01,
	0xbf, 0xaf, 0x9d, 0x12, 0xef, 0x6e, 0xfe, 0x1f, 0x6e, 0x7e, 0x3d, 0x4b, 0xdf, 0xfc, 0xfe, 0x3a,
	0xd6, 0x7e, 0x02, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x4d, 0xb0, 0xaa, 0x27, 0x06, 0x00, 0x00,
}
