/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"errors"
	"fmt"
	"io"
	"sort"
	"strings"

	"k8s.io/code-generator/cmd/validation-gen/validators"
	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/types"
	"k8s.io/klog/v2"
)

var (
	fieldPkg      = "k8s.io/apimachinery/pkg/util/validation/field"
	errorListType = types.Name{Package: fieldPkg, Name: "ErrorList"}
	fieldPathType = types.Name{Package: fieldPkg, Name: "Path"}
	errorfType    = types.Name{Package: "fmt", Name: "Errorf"}
)

// genValidations produces a file with autogenerated validations.
type genValidations struct {
	generator.GoGenerator
	typesPackage            string
	outputPackage           string
	peerPackages            []string
	inputToPkg              map[string]string // Maps input packages to generated validation packages
	initTypes               []*types.Type
	validationFunctionTypes map[*types.Type]*callNode
	imports                 namer.ImportTracker
	declarativeValidator    validators.DeclarativeValidator
}

func NewGenValidations(outputFilename, typesPackage, outputPackage string, initTypes []*types.Type, validationFunctionTypes map[*types.Type]*callNode, peerPkgs []string, inputToPkg map[string]string, declarativeValidator validators.DeclarativeValidator) generator.Generator {
	return &genValidations{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename,
		},
		typesPackage:            typesPackage,
		outputPackage:           outputPackage,
		peerPackages:            peerPkgs,
		inputToPkg:              inputToPkg,
		initTypes:               initTypes,
		validationFunctionTypes: validationFunctionTypes,
		imports:                 generator.NewImportTrackerForPackage(outputPackage),
		declarativeValidator:    declarativeValidator,
	}
}

func (g *genValidations) Namers(_ *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.outputPackage, g.imports),
	}
}

func (g *genValidations) Filter(_ *generator.Context, t *types.Type) bool {
	_, ok := g.validationFunctionTypes[t]
	return ok
}

func (g *genValidations) Imports(_ *generator.Context) (imports []string) {
	var importLines []string
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}

func (g *genValidations) isOtherPackage(pkg string) bool {
	if pkg == g.outputPackage {
		return false
	}
	if strings.HasSuffix(pkg, `"`+g.outputPackage+`"`) {
		return false
	}
	return true
}

//	func RegisterValidations(scheme *runtime.Scheme) error {
//		scheme.AddTypeDefaultingFunc(&v1.StatefulSet{}, func(obj interface{}) { Validate_StatefulSet(obj.(*v1.StatefulSet), nil) })
//		return nil
//	}
func (g *genValidations) Init(c *generator.Context, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")

	scheme := c.Universe.Type(types.Name{Package: "k8s.io/apimachinery/pkg/runtime", Name: "Scheme"})
	schemePtr := &types.Type{
		Kind: types.Pointer,
		Elem: scheme,
	}
	sw.Do("func init() { localSchemeBuilder.Register(RegisterValidations)}\n\n", nil)

	sw.Do("// RegisterValidations adds validation functions to the given scheme.\n", nil)
	sw.Do("// Public to allow building arbitrary schemes.\n", nil)
	sw.Do("func RegisterValidations(scheme $.|raw$) error {\n", schemePtr)
	for _, t := range sortTypes(g.initTypes) {
		callTree, ok := g.validationFunctionTypes[t]
		if !ok {
			continue
		}
		if callTree == nil {
			continue
		}
		specType := t
		var specField string
		if spec, ok := callTree.subresources["spec"]; ok {
			specType = spec.underlyingType
			specField = spec.field
		}
		var statusType *types.Type
		var statusField string
		if status, ok := callTree.subresources["status"]; ok {
			statusType = status.underlyingType
			statusField = status.field
		}
		targs := generator.Args{
			"rootType":    t,
			"specType":    specType,
			"specField":   specField,
			"statusType":  statusType,
			"statusField": statusField,
			"errorList":   c.Universe.Type(errorListType),
			"fieldPath":   c.Universe.Type(fieldPathType),
			"fmtErrorf":   c.Universe.Type(errorfType),
		}
		if isTypeWith(t, []string{"TypeMeta"}) {
			sw.Do("scheme.AddValidationFunc(&$.rootType|raw${}, func(obj, oldObj interface{}, subresources ...string) $.errorList|raw$ {\n", targs)
			sw.Do("  if len(subresources) == 0 {\n", targs)
			if specType != t {
				sw.Do("    root := obj.(*$.rootType|raw$)\n", targs)
				sw.Do("    return $.specType|objectvalidationfn$(&root.$.specField$, nil)\n", targs)
			} else {
				sw.Do("    return $.specType|objectvalidationfn$(obj.(*$.rootType|raw$), nil)\n", targs)
			}
			sw.Do("  }\n", targs)

			if statusType != nil {
				sw.Do("  if len(subresources) == 1 && subresources[0] == \"status\" {\n", targs)
				sw.Do("    root := obj.(*$.rootType|raw$)\n", targs)
				sw.Do("    return $.statusType|objectvalidationfn$(&root.$.statusField$, nil)\n", targs)
				sw.Do("  }\n", targs)
			}
			sw.Do("  return $.errorList|raw${field.InternalError(nil, $.fmtErrorf|raw$(\"No validation found for %T, subresources: %v\", obj, subresources))}\n", targs)
			sw.Do("})\n", targs)
		}

		// TODO: Support update validations
		//       This will require correlating old object.
	}
	sw.Do("return nil\n", nil)
	sw.Do("}\n\n", nil)
	return sw.Error()
}

func (g *genValidations) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	klog.V(5).Infof("generating for type %v", t)

	callTree, ok := g.validationFunctionTypes[t]
	if !ok {
		return fmt.Errorf("unable to find type to generate in map of generated types")
	}
	if callTree == nil {
		klog.V(5).Infof("  no validations defined")
		return nil
	}
	var errs []error

	sw := generator.NewSnippetWriter(w, c, "$", "$")
	g.generateValidationFunction(c, callTree, sw)
	if err := sw.Error(); err != nil {
		errs = append(errs, err)
	}
	return errors.Join(errs...)
}

func (g *genValidations) generateValidationFunction(c *generator.Context, callTree *callNode, sw *generator.SnippetWriter) {
	targs := generator.Args{
		"inType":    callTree.underlyingType,
		"errorList": c.Universe.Type(errorListType),
		"fieldPath": c.Universe.Type(fieldPathType),
	}

	sw.Do("func $.inType|objectvalidationfn$(in *$.inType|raw$, fldPath *$.fieldPath|raw$) (errs $.errorList|raw$) {\n", targs)
	callTree.writeValidationFunctionBody(c, "in", pathPart{}, 0, nil, sw)
	sw.Do("return errs\n", nil)
	sw.Do("}\n\n", nil)
}

// callTreeForType contains fields necessary to build a tree for types.
type callTreeForType struct {
	declarativeValidator   validators.DeclarativeValidator
	inputToPkg             map[string]string
	currentlyBuildingTypes map[*types.Type]bool
	visited                map[*types.Type]*callNode
}

func buildCallTree(declarativeValidator validators.DeclarativeValidator, inputToPkg map[string]string, t *types.Type, visited map[*types.Type]*callNode) (*callNode, error) {
	tree := &callTreeForType{
		declarativeValidator:   declarativeValidator,
		inputToPkg:             inputToPkg,
		currentlyBuildingTypes: make(map[*types.Type]bool),
		visited:                visited,
	}
	return tree.build(t, true)
}

func (c *callTreeForType) findValidationFunction(t *types.Type) (types.Name, bool) {
	pkg, ok := c.inputToPkg[t.Name.Package]
	if !ok {
		return types.Name{}, false
	}
	return types.Name{Package: pkg, Name: "Validate_" + t.Name.Name}, true
}

// build creates a tree of paths to fields (based on how they would be accessed in Go - pointer, elem,
// slice, or key) and the functions that should be invoked on each field. An in-order traversal of the resulting tree
// can be used to generate a Go function that invokes each nested function on the appropriate type. The return
// value may be nil if there are no functions to call on type or the type is a primitive (validation functions are only visited for
// structs today).
func (c *callTreeForType) build(t *types.Type, root bool) (*callNode, error) {
	if v, ok := c.visited[t]; ok {
		return v, nil
	}
	parent := &callNode{}

	if root {
		// the root node is always a pointer
		parent.elem = true
	}

	// if the type already exists, don't build the tree for it and don't generate anything.
	// This is used to avoid recursion for nested recursive types.
	if c.currentlyBuildingTypes[t] {
		return nil, nil
	}
	// if type doesn't exist, mark it as existing
	c.currentlyBuildingTypes[t] = true

	defer func() {
		// The type will now acts as a parent, not a nested recursive type.
		// We can now build the tree for it safely.
		c.currentlyBuildingTypes[t] = false
	}()

	baseT, _ := resolveTypeAndDepth(t)
	switch t.Kind {
	case types.Pointer:
		child, err := c.build(t.Elem, false)
		if err != nil {
			return nil, err
		}
		if child != nil {
			child.elem = true
			parent.children = append(parent.children, *child)
		}
	case types.Slice, types.Array:
		child, err := c.build(t.Elem, false)
		if err != nil {
			return nil, err
		}
		if child != nil {
			child.index = true
			if t.Elem.Kind == types.Pointer {
				child.elem = true
			}
			parent.children = append(parent.children, *child)
		}
	case types.Map:
		child, err := c.build(t.Elem, false)
		if err != nil {
			return nil, err
		}
		if child != nil {
			child.key = true
			parent.children = append(parent.children, *child)
		}

	case types.Struct:
		fn, ok := c.findValidationFunction(t)
		if !ok {
			return nil, nil
		}
		parent.validatorFunction = fn
		parent.underlyingType = t
		parent.t = baseT
		_, err := c.populateValidations(parent, t, t.CommentLines)
		if err != nil {
			return nil, err
		}
		for _, field := range t.Members {
			name := field.Name
			if len(name) == 0 {
				if field.Type.Kind == types.Pointer {
					name = field.Type.Elem.Name.Name
				} else {
					name = field.Type.Name.Name
				}
			}

			jsonName := "<unknown>"
			if tags, ok := lookupJSONTags(field); ok {
				jsonName = tags.name
			}
			child, err := c.build(field.Type, false)
			if err != nil {
				return nil, err
			}
			child, err = c.populateValidations(child, field.Type, field.CommentLines)
			if err != nil {
				return nil, err
			}
			if child != nil {
				child.field = name
				child.jsonName = jsonName
				if root && (child.jsonName == "spec" || child.jsonName == "status") {
					if parent.subresources == nil {
						parent.subresources = map[string]callNode{}
					}
					parent.subresources[child.jsonName] = *child
				}
				// TODO: Add more information to the node about field correlation for use with ValidateUpdate.
				//       In particular, we need to track associative list keys.
				//if isAssociativeList() {}
				parent.children = append(parent.children, *child)
			}
		}
	case types.Alias:
		child, err := c.build(t.Underlying, false)
		if err != nil {
			return nil, err
		}
		if child != nil {
			parent.children = append(parent.children, *child)
		}
	}
	if len(parent.children) == 0 && len(parent.validations) == 0 {
		return nil, nil
	}

	return parent, nil
}

func (c *callTreeForType) populateValidations(node *callNode, t *types.Type, commentLines []string) (*callNode, error) {
	valueValidations, err := c.declarativeValidator.ExtractValidations(t, commentLines)
	if err != nil {
		return nil, err
	}

	baseT, depth := resolveTypeAndDepth(t)
	if depth > 0 && len(valueValidations) == 0 {
		valueValidations, err = c.getNestedValidations(t)
		if err != nil {
			return nil, err
		}
	}

	if len(valueValidations) == 0 {
		return node, nil
	}

	// callNodes are not automatically visited for primitive types. Generate one if the callNode does not exist
	if node == nil {
		node = &callNode{}
	}

	node.isPrimitive = baseT.IsPrimitive()
	node.underlyingType = baseT
	node.t = t
	node.elem = t.Kind == types.Pointer

	node.validations = valueValidations
	return node, nil
}

// getNestedValidations returns the first validation when resolving alias types
func (c *callTreeForType) getNestedValidations(t *types.Type) ([]validators.FunctionGen, error) {
	var prev *types.Type
	var validations []validators.FunctionGen
	for prev != t {
		prev = t
		v, err := c.declarativeValidator.ExtractValidations(t, t.CommentLines)
		if err != nil {
			return nil, err
		}
		// TODO: Find and return all validations?
		if len(v) > 0 {
			return v, nil
		}
		if t.Kind == types.Alias {
			t = t.Underlying
		} else if t.Kind == types.Pointer {
			t = t.Elem
		}
	}
	return validations, nil
}

// resolveType follows pointers and aliases of `t` until reaching the first
// non-pointer type in `t's` hierarchy
func resolveTypeAndDepth(t *types.Type) (*types.Type, int) {
	var prev *types.Type
	depth := 0
	for prev != t {
		prev = t
		if t.Kind == types.Alias {
			t = t.Underlying
		} else if t.Kind == types.Pointer {
			t = t.Elem
			depth += 1
		}
	}
	return t, depth
}

// callNode represents an entry in a tree of Go type accessors - the path from the root to a leaf represents
// how in Go code an access would be performed. For example, if a validation function exists on a container
// lifecycle hook, to invoke that validation correctly would require this Go code:
//
//	for i := range pod.Spec.Containers {
//	  o := &pod.Spec.Containers[i]
//	  if o.LifecycleHook != nil {
//	    errs = append(errs, Validate_LifecycleHook(o.LifecycleHook, fieldPath)...)
//	  }
//	}
//
// That would be represented by a call tree like:
//
//	callNode
//	  field: "Spec"
//	  children:
//	  - field: "Containers"
//	    children:
//	    - index: true
//	      children:
//	      - field: "LifecycleHook"
//	        elem: true
//	        call:
//	        - Validate_LifecycleHook
//
// which we can traverse to build that Go struct (you must call the field Spec, then Containers, then range over
// that field, then check whether the LifecycleHook field is nil, before calling Validate_LifecycleHook on
// the pointer to that field).
type callNode struct {
	// field is the name of the Go member to access
	field string
	// jsonName is the json name of the member to access
	jsonName string

	// key is true if this is a map and we must range over the key and values
	key bool
	// index is true if this is a slice and we must range over the slice values
	index bool
	// elem is true if the previous elements refer to a pointer (typically just field)
	elem bool

	// children is the child call nodes that must also be traversed
	children []callNode

	// validations is the validations for the node
	validations []validators.FunctionGen

	// subresource is a map to subresource nodes.
	// This is only set for "spec" and "status" child nodes of a root resource.
	subresources map[string]callNode

	// isPrimitive tracks if the field is a primitive.
	isPrimitive bool

	// underlyingType is the transitive underlying/element type of the node.
	// The provided default value literal or reference is expected to be
	// convertible to this type.
	//
	// e.g:
	//	node type = *string 			-> 	defaultType = string
	//	node type = StringPointerAlias 	-> 	defaultType = string
	// Only populated if isPrimitive is true
	underlyingType *types.Type

	validatorFunction types.Name

	// t is the final type the value should resolve to
	// This is in contrast to the default type, which resolves aliases and pointers.
	t *types.Type
}

// CallNodeVisitorFunc is a function for visiting a call tree. ancestors is the list of all parents
// of this node to the root of the tree - will be empty at the root.
type CallNodeVisitorFunc func(ancestors []*callNode, node *callNode)

func (n *callNode) VisitInOrder(fn CallNodeVisitorFunc) {
	n.visitInOrder(nil, fn)
}

func (n *callNode) visitInOrder(ancestors []*callNode, fn CallNodeVisitorFunc) {
	fn(ancestors, n)
	ancestors = append(ancestors, n)
	for i := range n.children {
		n.children[i].visitInOrder(ancestors, fn)
	}
}

func (n *callNode) asRootType() *callNode {
	// Create a copy without any field related information grouped onto a node when used as a child node of a struct
	root := &callNode{}
	*root = *n
	root.elem = true
	root.field = ""
	root.jsonName = ""
	root.key = false
	root.index = false
	return root
}

var (
	indexVariables = "ijklmnop"
	localVariables = "abcdefgh"
)

// varsForDepth creates temporary variables guaranteed to be unique within lexical Go scopes
// of this depth in a function. It uses canonical Go loop variables for the first 7 levels
// and then resorts to uglier prefixes.
func varsForDepth(depth int) (index, local string) {
	if depth > len(indexVariables) {
		index = fmt.Sprintf("i%d", depth)
	} else {
		index = indexVariables[depth : depth+1]
	}
	if depth > len(localVariables) {
		local = fmt.Sprintf("local%d", depth)
	} else {
		local = localVariables[depth : depth+1]
	}
	return
}

// writeValidationMethod performs an in-order traversal of the calltree, generating loops and if blocks as necessary
// to correctly turn the call tree into a method body that invokes all calls on all child nodes of the call tree.
// Depth is used to generate local variables at the proper depth.
func (n *callNode) writeValidationFunctionBody(c *generator.Context, varName string, path pathPart, depth int, ancestors []*callNode, sw *generator.SnippetWriter) {
	isCallable := func(n callNode) bool {
		return n.underlyingType != nil && n.underlyingType.Kind == types.Struct && !n.index && !n.key
	}
	isPointer := n.elem && !n.index

	index, local := varsForDepth(depth)
	targs := generator.Args{
		"index": index,
		"local": local,
		"var":   varName,
	}

	if len(ancestors) > 0 {
		if isPointer {
			sw.Do("if $.var$ != nil {\n", targs)
			defer func() {
				sw.Do("}\n", nil)
			}()
		}
		if isCallable(*n) {
			n.writeChildValidatorCall(c, varName, path, isPointer, sw)
			return
		}
	}

	n.writeValidationFunctionCalls(c, varName, path, isPointer, sw)

	switch {
	case n.index:
		sw.Do("for $.index$ := range $.var$ {\n", targs)
		if n.elem {
			sw.Do("$.local$ := $.var$[$.index$]\n", targs)
		} else {
			sw.Do("$.local$ := &$.var$[$.index$]\n", targs)
		}
		if n.underlyingType != nil && n.underlyingType.Kind == types.Struct {
			n.writeChildValidatorCall(c, local, pathPart{Index: index}, true, sw)
		} else {
			for _, child := range n.children {
				child.writeValidationFunctionBody(c, local, pathPart{Index: index}, depth+1, append(ancestors, n), sw)
			}
		}

		sw.Do("}\n", nil)
	case n.key:
		// Map keys are typed and cannot share the same index variable as arrays and other maps
		index = index + "_" + ancestors[len(ancestors)-1].field
		targs["index"] = index
		sw.Do("for $.index$_idx, $.index$ := range $.var$ {\n", targs)
		for _, child := range n.children {
			if n.underlyingType != nil && n.underlyingType.Kind == types.Struct {
				n.writeChildValidatorCall(c, index, pathPart{Key: index + "_idx"}, false, sw)
			} else {
				childVarName := index
				if len(child.field) > 0 {
					childVarName = index + "." + child.field
				}
				child.writeValidationFunctionBody(c, childVarName, pathPart{Key: index + "_idx"}, depth+1, append(ancestors, n), sw)
			}
		}
		sw.Do("}\n", nil)
	default:
		for _, child := range n.children {
			childVarName := varName
			if len(child.field) > 0 {
				childVarName = varName + "." + child.field
			}
			childPath := pathPart{Name: child.jsonName}
			if child.elem && childPath == (pathPart{}) { // TODO: Clean this up. It fixes pointers to structs, but without the empty check, it breaks pointers to enums.
				childPath = path
			}
			child.writeValidationFunctionBody(c, childVarName, childPath, depth+1, append(ancestors, n), sw)
		}
	}
}

// writeChildValidatorCall generates a call to a child generated validation function.
func (n *callNode) writeChildValidatorCall(c *generator.Context, varName string, path pathPart, isVarPointer bool, sw *generator.SnippetWriter) {
	accessor := varName
	if !isVarPointer {
		accessor = "&" + accessor
	}

	targs := generator.Args{
		"var":  accessor,
		"path": path,
		"fn":   c.Universe.Type(n.validatorFunction),
	}
	sw.Do("errs = append(errs, $.fn|raw$($.var$, ", targs)
	if len(path.Key) > 0 {
		sw.Do("fldPath.Key($.path.Key$)", targs)
	} else if len(path.Name) > 0 {
		sw.Do("fldPath.Child(\"$.path.Name$\")", targs)
	} else if len(path.Index) > 0 {
		sw.Do("fldPath.Index($.path.Index$)", targs)
	} else {
		sw.Do("nil", targs)
	}
	sw.Do(")...)\n", targs)
}

// writeValidationFunctionCalls generates calls to validation functions, that is, functions that are called by
// the generated validation functions to perform actual validations.
func (n *callNode) writeValidationFunctionCalls(c *generator.Context, varName string, path pathPart, isVarPointer bool, sw *generator.SnippetWriter) {
	accessor := varName
	if isVarPointer {
		accessor = "*" + accessor
	}

	if len(n.validations) == 0 {
		return
	}

	for _, v := range n.validations {
		fn, extraArgs := v.SignatureAndArgs()
		targs := generator.Args{
			"varName":      accessor,
			"path":         path,
			"validationFn": c.Universe.Type(fn),
		}

		// If default value is a literal then it can be assigned via var stmt
		sw.Do("errs = append(errs, $.validationFn|raw$(", targs)
		if len(path.Key) > 0 {
			sw.Do("fldPath.Key($.path.Key$)", targs)
		} else if len(path.Name) > 0 {
			sw.Do("fldPath.Child(\"$.path.Name$\")", targs)
		} else if len(path.Index) > 0 {
			sw.Do("fldPath.Index($.path.Index$)", targs)
		} else {
			sw.Do("<no-path-part>", targs)
		}
		sw.Do(", $.varName$", targs)
		for _, extraArg := range extraArgs {
			// TODO: We should skip any templating and instead write these values directly. How?
			sw.Do(", "+toGolangSourceDataLiteral(extraArg), nil)
		}
		sw.Do(")...)\n", targs)
	}
}

func toGolangSourceDataLiteral(value any) string {
	// For safety, be strict in what values we output to visited source, and ensure strings
	// are quoted.
	switch value.(type) {
	case uint, uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64, bool:
		return fmt.Sprintf("%v", value)
	case string:
		return fmt.Sprintf("%q", value)
	default:
		panic(fmt.Sprintf("Unsupported extraArg type: %T", value)) // TODO: handle error
	}
}

type pathPart struct {
	Index string
	Key   string
	Name  string
}

func sortTypes(list []*types.Type) []*types.Type {
	sort.Slice(list, func(i int, j int) bool {
		return strings.ToLower(list[i].Name.Name) < strings.ToLower(list[j].Name.Name)
	})
	return list
}
