//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by validation-gen. DO NOT EDIT.

package basics

import (
	context "context"
	fmt "fmt"

	equality "k8s.io/apimachinery/pkg/api/equality"
	operation "k8s.io/apimachinery/pkg/api/operation"
	safe "k8s.io/apimachinery/pkg/api/safe"
	validate "k8s.io/apimachinery/pkg/api/validate"
	field "k8s.io/apimachinery/pkg/util/validation/field"
	testscheme "k8s.io/code-generator/cmd/validation-gen/testscheme"
)

func init() { localSchemeBuilder.Register(RegisterValidations) }

// RegisterValidations adds validation functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterValidations(scheme *testscheme.Scheme) error {
	// type MyObject
	scheme.AddValidationFunc((*MyObject)(nil), func(ctx context.Context, op operation.Operation, obj, oldObj interface{}) field.ErrorList {
		switch op.Request.SubresourcePath() {
		case "/":
			return Validate_MyObject(ctx, op, nil /* fldPath */, obj.(*MyObject), safe.Cast[*MyObject](oldObj))
		}
		return field.ErrorList{field.InternalError(nil, fmt.Errorf("no validation found for %T, subresource: %v", obj, op.Request.SubresourcePath()))}
	})
	return nil
}

// Validate_MyObject validates an instance of MyObject according
// to declarative validation rules in the API schema.
func Validate_MyObject(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *MyObject) (errs field.ErrorList) {
	// field MyObject.TypeMeta has no validation

	// field MyObject.UUIDField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidField"), &obj.UUIDField, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.UUIDField }), oldObj != nil)...)

	// field MyObject.UUIDFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidFieldWithoutDV"), &obj.UUIDFieldWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.UUIDFieldWithoutDV }), oldObj != nil)...)

	// field MyObject.UUIDPtrField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalPointer(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidPtrField"), obj.UUIDPtrField, safe.Field(oldObj, func(oldObj *MyObject) *string { return oldObj.UUIDPtrField }), oldObj != nil)...)

	// field MyObject.UUIDPtrFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalPointer(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidPtrFieldWithoutDV"), obj.UUIDPtrFieldWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *string { return oldObj.UUIDPtrFieldWithoutDV }), oldObj != nil)...)

	// field MyObject.UUIDTypedefField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *UUIDString, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_UUIDString(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidTypedefField"), &obj.UUIDTypedefField, safe.Field(oldObj, func(oldObj *MyObject) *UUIDString { return &oldObj.UUIDTypedefField }), oldObj != nil)...)

	// field MyObject.UUIDTypedefFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *UUIDString, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_UUIDString(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidTypedefFieldWithoutDV"), &obj.UUIDTypedefFieldWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *UUIDString { return &oldObj.UUIDTypedefFieldWithoutDV }), oldObj != nil)...)

	// field MyObject.FieldForLength
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.RequiredValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				errs = append(errs, e...)
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.MaxLength(ctx, op, fldPath, obj, oldObj, 60)...)
			return
		}(fldPath.Child("fieldForLength"), &obj.FieldForLength, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.FieldForLength }), oldObj != nil)...)

	// field MyObject.FieldForLengthWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			errs = append(errs, validate.MaxLength(ctx, op, fldPath, obj, oldObj, 60)...)
			return
		}(fldPath.Child("fieldForLengthWithoutDV"), &obj.FieldForLengthWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.FieldForLengthWithoutDV }), oldObj != nil)...)

	// field MyObject.StableTypeField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("stableTypeField"), &obj.StableTypeField, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return &oldObj.StableTypeField }), oldObj != nil)...)

	// field MyObject.StableTypeFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("stableTypeFieldWithoutDV"), &obj.StableTypeFieldWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return &oldObj.StableTypeFieldWithoutDV }), oldObj != nil)...)

	// field MyObject.StableTypeFieldPointer
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("stableTypeFieldPointer"), obj.StableTypeFieldPointer, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return oldObj.StableTypeFieldPointer }), oldObj != nil)...)

	// field MyObject.StableTypeFieldPointerWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("stableTypeFieldPointerWithoutDV"), obj.StableTypeFieldPointerWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return oldObj.StableTypeFieldPointerWithoutDV }), oldObj != nil)...)

	// field MyObject.StableTypeSlice
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.MaxItems(ctx, op, fldPath, obj, oldObj, 5); len(e) != 0 {
				errs = append(errs, e...)
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			// iterate the list and call the type's validation function
			errs = append(errs, validate.EachSliceVal(ctx, op, fldPath, obj, oldObj, nil, nil, Validate_StableType)...)
			return
		}(fldPath.Child("stableTypeSlice"), obj.StableTypeSlice, safe.Field(oldObj, func(oldObj *MyObject) []StableType { return oldObj.StableTypeSlice }), oldObj != nil)...)

	// field MyObject.StableTypeSliceWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.MaxItems(ctx, op, fldPath, obj, oldObj, 5); len(e) != 0 {
				errs = append(errs, e...)
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			// iterate the list and call the type's validation function
			errs = append(errs, validate.EachSliceVal(ctx, op, fldPath, obj, oldObj, nil, nil, Validate_StableType)...)
			return
		}(fldPath.Child("stableTypeSliceWithoutDV"), obj.StableTypeSliceWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) []StableType { return oldObj.StableTypeSliceWithoutDV }), oldObj != nil)...)

	// field MyObject.SetList
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []string, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			// lists with set semantics require unique values
			errs = append(errs, validate.Unique(ctx, op, fldPath, obj, oldObj, validate.DirectEqual)...)
			return
		}(fldPath.Child("setList"), obj.SetList, safe.Field(oldObj, func(oldObj *MyObject) []string { return oldObj.SetList }), oldObj != nil)...)

	// field MyObject.SetListWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []string, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			// lists with set semantics require unique values
			errs = append(errs, validate.Unique(ctx, op, fldPath, obj, oldObj, validate.DirectEqual)...)
			return
		}(fldPath.Child("setListWithoutDV"), obj.SetListWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) []string { return oldObj.SetListWithoutDV }), oldObj != nil)...)

	// field MyObject.NestedStable
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *NestedStableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_NestedStableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("nestedStable"), &obj.NestedStable, safe.Field(oldObj, func(oldObj *MyObject) *NestedStableType { return &oldObj.NestedStable }), oldObj != nil)...)

	// field MyObject.NestedStableWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *NestedStableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_NestedStableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("nestedStableWithoutDV"), &obj.NestedStableWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *NestedStableType { return &oldObj.NestedStableWithoutDV }), oldObj != nil)...)

	// field MyObject.SubfieldTest
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			func() { // cohort innerField
				errs = append(errs, validate.Subfield(ctx, op, fldPath, obj, oldObj, "innerField", func(o *StableType) *string { return &o.InnerField }, validate.DirectEqualPtr, func(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *string) field.ErrorList {
					return validate.MaxLength(ctx, op, fldPath, obj, oldObj, 5)
				})...)
			}()
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("subfieldTest"), &obj.SubfieldTest, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return &oldObj.SubfieldTest }), oldObj != nil)...)

	// field MyObject.SubfieldTestWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			func() { // cohort innerField
				errs = append(errs, validate.Subfield(ctx, op, fldPath, obj, oldObj, "innerField", func(o *StableType) *string { return &o.InnerField }, validate.DirectEqualPtr, func(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *string) field.ErrorList {
					return validate.MaxLength(ctx, op, fldPath, obj, oldObj, 5)
				})...)
			}()
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("subfieldTestWithoutDV"), &obj.SubfieldTestWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return &oldObj.SubfieldTestWithoutDV }), oldObj != nil)...)

	return errs
}

// Validate_NestedStableType validates an instance of NestedStableType according
// to declarative validation rules in the API schema.
func Validate_NestedStableType(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *NestedStableType) (errs field.ErrorList) {
	// field NestedStableType.NestedField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// this field validations are marked declarative native
			defer func() {
				errs = errs.MarkDeclarativeNative()
			}()
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("nestedField"), &obj.NestedField, safe.Field(oldObj, func(oldObj *NestedStableType) *StableType { return &oldObj.NestedField }), oldObj != nil)...)

	// field NestedStableType.NestedFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("nestedFieldWithoutDV"), &obj.NestedFieldWithoutDV, safe.Field(oldObj, func(oldObj *NestedStableType) *StableType { return &oldObj.NestedFieldWithoutDV }), oldObj != nil)...)

	return errs
}

// Validate_StableType validates an instance of StableType according
// to declarative validation rules in the API schema.
func Validate_StableType(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *StableType) (errs field.ErrorList) {
	// field StableType.InnerField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string, oldValueCorrelated bool) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if oldValueCorrelated && op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.RequiredValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				errs = append(errs, e...)
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.MaxLength(ctx, op, fldPath, obj, oldObj, 10)...)
			return
		}(fldPath.Child("innerField"), &obj.InnerField, safe.Field(oldObj, func(oldObj *StableType) *string { return &oldObj.InnerField }), oldObj != nil)...)

	return errs
}

// Validate_UUIDString validates an instance of UUIDString according
// to declarative validation rules in the API schema.
func Validate_UUIDString(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *UUIDString) (errs field.ErrorList) {
	errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)

	return errs
}
