//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by validation-gen. DO NOT EDIT.

package native

import (
	context "context"
	fmt "fmt"

	equality "k8s.io/apimachinery/pkg/api/equality"
	operation "k8s.io/apimachinery/pkg/api/operation"
	safe "k8s.io/apimachinery/pkg/api/safe"
	validate "k8s.io/apimachinery/pkg/api/validate"
	field "k8s.io/apimachinery/pkg/util/validation/field"
	testscheme "k8s.io/code-generator/cmd/validation-gen/testscheme"
)

func init() { localSchemeBuilder.Register(RegisterValidations) }

// RegisterValidations adds validation functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterValidations(scheme *testscheme.Scheme) error {
	// type MyObject
	scheme.AddValidationFunc((*MyObject)(nil), func(ctx context.Context, op operation.Operation, obj, oldObj interface{}) field.ErrorList {
		switch op.Request.SubresourcePath() {
		case "/":
			return Validate_MyObject(ctx, op, nil /* fldPath */, obj.(*MyObject), safe.Cast[*MyObject](oldObj))
		}
		return field.ErrorList{field.InternalError(nil, fmt.Errorf("no validation found for %T, subresource: %v", obj, op.Request.SubresourcePath()))}
	})
	return nil
}

// Validate_MyObject validates an instance of MyObject according
// to declarative validation rules in the API schema.
func Validate_MyObject(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *MyObject) (errs field.ErrorList) {
	// field MyObject.TypeMeta has no validation

	// field MyObject.UUIDField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidField"), &obj.UUIDField, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.UUIDField }))...)

	// field MyObject.UUIDFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidFieldWithoutDV"), &obj.UUIDFieldWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.UUIDFieldWithoutDV }))...)

	// field MyObject.UUIDPtrField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalPointer(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidPtrField"), obj.UUIDPtrField, safe.Field(oldObj, func(oldObj *MyObject) *string { return oldObj.UUIDPtrField }))...)

	// field MyObject.UUIDPtrFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalPointer(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidPtrFieldWithoutDV"), obj.UUIDPtrFieldWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *string { return oldObj.UUIDPtrFieldWithoutDV }))...)

	// field MyObject.UUIDTypedefField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *UUIDString) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_UUIDString(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidTypedefField"), &obj.UUIDTypedefField, safe.Field(oldObj, func(oldObj *MyObject) *UUIDString { return &oldObj.UUIDTypedefField }))...)

	// field MyObject.UUIDTypedefFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *UUIDString) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_UUIDString(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("uuidTypedefFieldWithoutDV"), &obj.UUIDTypedefFieldWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *UUIDString { return &oldObj.UUIDTypedefFieldWithoutDV }))...)

	// field MyObject.FieldForLength
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.RequiredValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				errs = append(errs, e...)
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			return
		}(fldPath.Child("fieldForLength"), &obj.FieldForLength, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.FieldForLength }))...)

	// field MyObject.FieldForLengthWithoutDV has no validation

	// field MyObject.StableTypeField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("stableTypeField"), &obj.StableTypeField, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return &oldObj.StableTypeField }))...)

	// field MyObject.StableTypeFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("stableTypeFieldWithoutDV"), &obj.StableTypeFieldWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return &oldObj.StableTypeFieldWithoutDV }))...)

	// field MyObject.StableTypeFieldPointer
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("stableTypeFieldPointer"), obj.StableTypeFieldPointer, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return oldObj.StableTypeFieldPointer }))...)

	// field MyObject.StableTypeFieldPointerWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("stableTypeFieldPointerWithoutDV"), obj.StableTypeFieldPointerWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *StableType { return oldObj.StableTypeFieldPointerWithoutDV }))...)

	// field MyObject.StableTypeSlice
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []StableType) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.MaxItems(ctx, op, fldPath, obj, oldObj, 5); len(e) != 0 {
				errs = append(errs, e...)
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			// iterate the list and call the type's validation function
			errs = append(errs, validate.EachSliceVal(ctx, op, fldPath, obj, oldObj, nil, nil, Validate_StableType)...)
			return
		}(fldPath.Child("stableTypeSlice"), obj.StableTypeSlice, safe.Field(oldObj, func(oldObj *MyObject) []StableType { return oldObj.StableTypeSlice }))...)

	// field MyObject.StableTypeSliceWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []StableType) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.MaxItems(ctx, op, fldPath, obj, oldObj, 5); len(e) != 0 {
				errs = append(errs, e...)
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			// iterate the list and call the type's validation function
			errs = append(errs, validate.EachSliceVal(ctx, op, fldPath, obj, oldObj, nil, nil, Validate_StableType)...)
			return
		}(fldPath.Child("stableTypeSliceWithoutDV"), obj.StableTypeSliceWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) []StableType { return oldObj.StableTypeSliceWithoutDV }))...)

	// field MyObject.SetList
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []string) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			// lists with set semantics require unique values
			errs = append(errs, validate.Unique(ctx, op, fldPath, obj, oldObj, validate.DirectEqual)...)
			return
		}(fldPath.Child("setList"), obj.SetList, safe.Field(oldObj, func(oldObj *MyObject) []string { return oldObj.SetList }))...)

	// field MyObject.SetListWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []string) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil
			}
			// call field-attached validations
			// lists with set semantics require unique values
			errs = append(errs, validate.Unique(ctx, op, fldPath, obj, oldObj, validate.DirectEqual)...)
			return
		}(fldPath.Child("setListWithoutDV"), obj.SetListWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) []string { return oldObj.SetListWithoutDV }))...)

	// field MyObject.NestedStable
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *NestedStableType) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_NestedStableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("nestedStable"), &obj.NestedStable, safe.Field(oldObj, func(oldObj *MyObject) *NestedStableType { return &oldObj.NestedStable }))...)

	// field MyObject.NestedStableWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *NestedStableType) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_NestedStableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("nestedStableWithoutDV"), &obj.NestedStableWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *NestedStableType { return &oldObj.NestedStableWithoutDV }))...)

	// field MyObject.IPAddress
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.IPSloppy(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("ipAddress"), &obj.IPAddress, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.IPAddress }))...)

	// field MyObject.IPAddressWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.OptionalValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			errs = append(errs, validate.IPSloppy(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("ipAddressWithoutDV"), &obj.IPAddressWithoutDV, safe.Field(oldObj, func(oldObj *MyObject) *string { return &oldObj.IPAddressWithoutDV }))...)

	return errs
}

// Validate_NestedStableType validates an instance of NestedStableType according
// to declarative validation rules in the API schema.
func Validate_NestedStableType(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *NestedStableType) (errs field.ErrorList) {
	// field NestedStableType.NestedField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType) (errs field.ErrorList) {
			// this field validations are marked declarative only
			defer func() {
				errs = errs.MarkDeclarativeOnly()
			}()
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("nestedField"), &obj.NestedField, safe.Field(oldObj, func(oldObj *NestedStableType) *StableType { return &oldObj.NestedField }))...)

	// field NestedStableType.NestedFieldWithoutDV
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *StableType) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call the type's validation function
			errs = append(errs, Validate_StableType(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("nestedFieldWithoutDV"), &obj.NestedFieldWithoutDV, safe.Field(oldObj, func(oldObj *NestedStableType) *StableType { return &oldObj.NestedFieldWithoutDV }))...)

	return errs
}

// Validate_StableType validates an instance of StableType according
// to declarative validation rules in the API schema.
func Validate_StableType(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *StableType) (errs field.ErrorList) {
	// field StableType.InnerField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *string) (errs field.ErrorList) {
			// don't revalidate unchanged data
			if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
				return nil
			}
			// call field-attached validations
			earlyReturn := false
			if e := validate.RequiredValue(ctx, op, fldPath, obj, oldObj); len(e) != 0 {
				errs = append(errs, e...)
				earlyReturn = true
			}
			if earlyReturn {
				return // do not proceed
			}
			return
		}(fldPath.Child("innerField"), &obj.InnerField, safe.Field(oldObj, func(oldObj *StableType) *string { return &oldObj.InnerField }))...)

	return errs
}

// Validate_UUIDString validates an instance of UUIDString according
// to declarative validation rules in the API schema.
func Validate_UUIDString(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *UUIDString) (errs field.ErrorList) {
	errs = append(errs, validate.UUID(ctx, op, fldPath, obj, oldObj)...)

	return errs
}
