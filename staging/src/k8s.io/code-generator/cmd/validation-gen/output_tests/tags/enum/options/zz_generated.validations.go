//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by validation-gen. DO NOT EDIT.

package options

import (
	context "context"
	fmt "fmt"

	operation "k8s.io/apimachinery/pkg/api/operation"
	safe "k8s.io/apimachinery/pkg/api/safe"
	validate "k8s.io/apimachinery/pkg/api/validate"
	sets "k8s.io/apimachinery/pkg/util/sets"
	field "k8s.io/apimachinery/pkg/util/validation/field"
	testscheme "k8s.io/code-generator/cmd/validation-gen/testscheme"
)

func init() { localSchemeBuilder.Register(RegisterValidations) }

// RegisterValidations adds validation functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterValidations(scheme *testscheme.Scheme) error {
	scheme.AddValidationFunc((*ConditionalStruct)(nil), func(ctx context.Context, op operation.Operation, obj, oldObj interface{}) field.ErrorList {
		switch op.Request.SubresourcePath() {
		case "/":
			return Validate_ConditionalStruct(ctx, op, nil /* fldPath */, obj.(*ConditionalStruct), safe.Cast[*ConditionalStruct](oldObj))
		}
		return field.ErrorList{field.InternalError(nil, fmt.Errorf("no validation found for %T, subresource: %v", obj, op.Request.SubresourcePath()))}
	})
	scheme.AddValidationFunc((*Struct)(nil), func(ctx context.Context, op operation.Operation, obj, oldObj interface{}) field.ErrorList {
		switch op.Request.SubresourcePath() {
		case "/":
			return Validate_Struct(ctx, op, nil /* fldPath */, obj.(*Struct), safe.Cast[*Struct](oldObj))
		}
		return field.ErrorList{field.InternalError(nil, fmt.Errorf("no validation found for %T, subresource: %v", obj, op.Request.SubresourcePath()))}
	})
	return nil
}

var exclusionsForConditionalEnum = []validate.EnumExclusion[ConditionalEnum]{
	{
		Value: ConditionalA, Option: "FeatureA", ExcludeWhen: true},
	{
		Value: ConditionalB, Option: "FeatureB", ExcludeWhen: false},
	{
		Value: ConditionalD, Option: "FeatureA", ExcludeWhen: true},
	{
		Value: ConditionalD, Option: "FeatureB", ExcludeWhen: true},
	{
		Value: ConditionalE, Option: "FeatureC", ExcludeWhen: false},
	{
		Value: ConditionalE, Option: "FeatureD", ExcludeWhen: false},
	{
		Value: ConditionalF, Option: "FeatureC", ExcludeWhen: false},
	{
		Value: ConditionalF, Option: "FeatureD", ExcludeWhen: true},
}
var symbolsForConditionalEnum = sets.New(ConditionalA, ConditionalB, ConditionalC, ConditionalD, ConditionalE, ConditionalF)

func Validate_ConditionalEnum(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *ConditionalEnum) (errs field.ErrorList) {
	// type ConditionalEnum
	if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
		return nil // no changes
	}
	errs = append(errs, validate.Enum(ctx, op, fldPath, obj, oldObj, symbolsForConditionalEnum, exclusionsForConditionalEnum)...)

	return errs
}

func Validate_ConditionalStruct(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *ConditionalStruct) (errs field.ErrorList) {
	// field ConditionalStruct.TypeMeta has no validation

	// field ConditionalStruct.ConditionalEnumField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *ConditionalEnum) (errs field.ErrorList) {
			errs = append(errs, Validate_ConditionalEnum(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("conditionalEnumField"), &obj.ConditionalEnumField, safe.Field(oldObj, func(oldObj *ConditionalStruct) *ConditionalEnum { return &oldObj.ConditionalEnumField }))...)

	// field ConditionalStruct.ConditionalEnumPtrField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *ConditionalEnum) (errs field.ErrorList) {
			errs = append(errs, Validate_ConditionalEnum(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("conditionalEnumPtrField"), obj.ConditionalEnumPtrField, safe.Field(oldObj, func(oldObj *ConditionalStruct) *ConditionalEnum { return oldObj.ConditionalEnumPtrField }))...)

	return errs
}

var symbolsForEnum0 = sets.New[Enum0]()

func Validate_Enum0(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *Enum0) (errs field.ErrorList) {
	// type Enum0
	if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
		return nil // no changes
	}
	errs = append(errs, validate.Enum(ctx, op, fldPath, obj, oldObj, symbolsForEnum0, nil)...)

	return errs
}

var symbolsForEnum1 = sets.New(E1V1)

func Validate_Enum1(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *Enum1) (errs field.ErrorList) {
	// type Enum1
	if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
		return nil // no changes
	}
	errs = append(errs, validate.Enum(ctx, op, fldPath, obj, oldObj, symbolsForEnum1, nil)...)

	return errs
}

var symbolsForEnum2 = sets.New(E2V1, E2V2)

func Validate_Enum2(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *Enum2) (errs field.ErrorList) {
	// type Enum2
	if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
		return nil // no changes
	}
	errs = append(errs, validate.Enum(ctx, op, fldPath, obj, oldObj, symbolsForEnum2, nil)...)

	return errs
}

var symbolsForEnumWithExclude = sets.New(EnumWithExclude1)

func Validate_EnumWithExclude(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *EnumWithExclude) (errs field.ErrorList) {
	// type EnumWithExclude
	if op.Type == operation.Update && (obj == oldObj || (obj != nil && oldObj != nil && *obj == *oldObj)) {
		return nil // no changes
	}
	errs = append(errs, validate.Enum(ctx, op, fldPath, obj, oldObj, symbolsForEnumWithExclude, nil)...)

	return errs
}

func Validate_Struct(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *Struct) (errs field.ErrorList) {
	// field Struct.TypeMeta has no validation

	// field Struct.Enum0Field
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *Enum0) (errs field.ErrorList) {
			errs = append(errs, Validate_Enum0(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("enum0Field"), &obj.Enum0Field, safe.Field(oldObj, func(oldObj *Struct) *Enum0 { return &oldObj.Enum0Field }))...)

	// field Struct.Enum0PtrField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *Enum0) (errs field.ErrorList) {
			errs = append(errs, Validate_Enum0(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("enum0PtrField"), obj.Enum0PtrField, safe.Field(oldObj, func(oldObj *Struct) *Enum0 { return oldObj.Enum0PtrField }))...)

	// field Struct.Enum1Field
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *Enum1) (errs field.ErrorList) {
			errs = append(errs, Validate_Enum1(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("enum1Field"), &obj.Enum1Field, safe.Field(oldObj, func(oldObj *Struct) *Enum1 { return &oldObj.Enum1Field }))...)

	// field Struct.Enum1PtrField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *Enum1) (errs field.ErrorList) {
			errs = append(errs, Validate_Enum1(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("enum1PtrField"), obj.Enum1PtrField, safe.Field(oldObj, func(oldObj *Struct) *Enum1 { return oldObj.Enum1PtrField }))...)

	// field Struct.Enum2Field
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *Enum2) (errs field.ErrorList) {
			errs = append(errs, Validate_Enum2(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("enum2Field"), &obj.Enum2Field, safe.Field(oldObj, func(oldObj *Struct) *Enum2 { return &oldObj.Enum2Field }))...)

	// field Struct.Enum2PtrField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *Enum2) (errs field.ErrorList) {
			errs = append(errs, Validate_Enum2(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("enum2PtrField"), obj.Enum2PtrField, safe.Field(oldObj, func(oldObj *Struct) *Enum2 { return oldObj.Enum2PtrField }))...)

	// field Struct.NotEnumField has no validation
	// field Struct.NotEnumPtrField has no validation

	// field Struct.EnumWithExcludeField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *EnumWithExclude) (errs field.ErrorList) {
			errs = append(errs, Validate_EnumWithExclude(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("enumWithExcludeField"), &obj.EnumWithExcludeField, safe.Field(oldObj, func(oldObj *Struct) *EnumWithExclude { return &oldObj.EnumWithExcludeField }))...)

	// field Struct.EnumWithExcludePtrField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *EnumWithExclude) (errs field.ErrorList) {
			errs = append(errs, Validate_EnumWithExclude(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("enumWithExcludePtrField"), obj.EnumWithExcludePtrField, safe.Field(oldObj, func(oldObj *Struct) *EnumWithExclude { return oldObj.EnumWithExcludePtrField }))...)

	return errs
}
