// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: combos/unmarshaler/theproto3.proto

package theproto3

import (
	bytes "bytes"
	compress_gzip "compress/gzip"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_protoc_gen_gogo_descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	both "github.com/gogo/protobuf/test/combos/both"
	github_com_gogo_protobuf_test_custom "github.com/gogo/protobuf/test/custom"
	io "io"
	io_ioutil "io/ioutil"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MapEnum int32

const (
	MA MapEnum = 0
	MB MapEnum = 1
	MC MapEnum = 2
)

var MapEnum_name = map[int32]string{
	0: "MA",
	1: "MB",
	2: "MC",
}

var MapEnum_value = map[string]int32{
	"MA": 0,
	"MB": 1,
	"MC": 2,
}

func (MapEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{0}
}

type Message_Humour int32

const (
	UNKNOWN     Message_Humour = 0
	PUNS        Message_Humour = 1
	SLAPSTICK   Message_Humour = 2
	BILL_BAILEY Message_Humour = 3
)

var Message_Humour_name = map[int32]string{
	0: "UNKNOWN",
	1: "PUNS",
	2: "SLAPSTICK",
	3: "BILL_BAILEY",
}

var Message_Humour_value = map[string]int32{
	"UNKNOWN":     0,
	"PUNS":        1,
	"SLAPSTICK":   2,
	"BILL_BAILEY": 3,
}

func (Message_Humour) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{0, 0}
}

type Message struct {
	Name                 string                     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Hilarity             Message_Humour             `protobuf:"varint,2,opt,name=hilarity,proto3,enum=theproto3.Message_Humour" json:"hilarity,omitempty"`
	HeightInCm           uint32                     `protobuf:"varint,3,opt,name=height_in_cm,json=heightInCm,proto3" json:"height_in_cm,omitempty"`
	Data                 []byte                     `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	ResultCount          int64                      `protobuf:"varint,7,opt,name=result_count,json=resultCount,proto3" json:"result_count,omitempty"`
	TrueScotsman         bool                       `protobuf:"varint,8,opt,name=true_scotsman,json=trueScotsman,proto3" json:"true_scotsman,omitempty"`
	Score                float32                    `protobuf:"fixed32,9,opt,name=score,proto3" json:"score,omitempty"`
	Key                  []uint64                   `protobuf:"varint,5,rep,packed,name=key,proto3" json:"key,omitempty"`
	Nested               *Nested                    `protobuf:"bytes,6,opt,name=nested,proto3" json:"nested,omitempty"`
	Terrain              map[int64]*Nested          `protobuf:"bytes,10,rep,name=terrain,proto3" json:"terrain,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Proto2Field          *both.NinOptNative         `protobuf:"bytes,11,opt,name=proto2_field,json=proto2Field,proto3" json:"proto2_field,omitempty"`
	Proto2Value          map[int64]*both.NinOptEnum `protobuf:"bytes,13,rep,name=proto2_value,json=proto2Value,proto3" json:"proto2_value,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Message) Reset()      { *m = Message{} }
func (*Message) ProtoMessage() {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{0}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Message.Marshal(b, m, deterministic)
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return xxx_messageInfo_Message.Size(m)
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

type Nested struct {
	Bunny                string   `protobuf:"bytes,1,opt,name=bunny,proto3" json:"bunny,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Nested) Reset()      { *m = Nested{} }
func (*Nested) ProtoMessage() {}
func (*Nested) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{1}
}
func (m *Nested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Nested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Nested.Marshal(b, m, deterministic)
}
func (m *Nested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Nested.Merge(m, src)
}
func (m *Nested) XXX_Size() int {
	return xxx_messageInfo_Nested.Size(m)
}
func (m *Nested) XXX_DiscardUnknown() {
	xxx_messageInfo_Nested.DiscardUnknown(m)
}

var xxx_messageInfo_Nested proto.InternalMessageInfo

type AllMaps struct {
	StringToDoubleMap    map[string]float64        `protobuf:"bytes,1,rep,name=StringToDoubleMap,proto3" json:"StringToDoubleMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	StringToFloatMap     map[string]float32        `protobuf:"bytes,2,rep,name=StringToFloatMap,proto3" json:"StringToFloatMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Int32Map             map[int32]int32           `protobuf:"bytes,3,rep,name=Int32Map,proto3" json:"Int32Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Int64Map             map[int64]int64           `protobuf:"bytes,4,rep,name=Int64Map,proto3" json:"Int64Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Uint32Map            map[uint32]uint32         `protobuf:"bytes,5,rep,name=Uint32Map,proto3" json:"Uint32Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Uint64Map            map[uint64]uint64         `protobuf:"bytes,6,rep,name=Uint64Map,proto3" json:"Uint64Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Sint32Map            map[int32]int32           `protobuf:"bytes,7,rep,name=Sint32Map,proto3" json:"Sint32Map,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	Sint64Map            map[int64]int64           `protobuf:"bytes,8,rep,name=Sint64Map,proto3" json:"Sint64Map,omitempty" protobuf_key:"zigzag64,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	Fixed32Map           map[uint32]uint32         `protobuf:"bytes,9,rep,name=Fixed32Map,proto3" json:"Fixed32Map,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Sfixed32Map          map[int32]int32           `protobuf:"bytes,10,rep,name=Sfixed32Map,proto3" json:"Sfixed32Map,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Fixed64Map           map[uint64]uint64         `protobuf:"bytes,11,rep,name=Fixed64Map,proto3" json:"Fixed64Map,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	Sfixed64Map          map[int64]int64           `protobuf:"bytes,12,rep,name=Sfixed64Map,proto3" json:"Sfixed64Map,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	BoolMap              map[bool]bool             `protobuf:"bytes,13,rep,name=BoolMap,proto3" json:"BoolMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	StringMap            map[string]string         `protobuf:"bytes,14,rep,name=StringMap,proto3" json:"StringMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StringToBytesMap     map[string][]byte         `protobuf:"bytes,15,rep,name=StringToBytesMap,proto3" json:"StringToBytesMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StringToEnumMap      map[string]MapEnum        `protobuf:"bytes,16,rep,name=StringToEnumMap,proto3" json:"StringToEnumMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=theproto3.MapEnum"`
	StringToMsgMap       map[string]*FloatingPoint `protobuf:"bytes,17,rep,name=StringToMsgMap,proto3" json:"StringToMsgMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *AllMaps) Reset()      { *m = AllMaps{} }
func (*AllMaps) ProtoMessage() {}
func (*AllMaps) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{2}
}
func (m *AllMaps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllMaps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllMaps.Marshal(b, m, deterministic)
}
func (m *AllMaps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllMaps.Merge(m, src)
}
func (m *AllMaps) XXX_Size() int {
	return xxx_messageInfo_AllMaps.Size(m)
}
func (m *AllMaps) XXX_DiscardUnknown() {
	xxx_messageInfo_AllMaps.DiscardUnknown(m)
}

var xxx_messageInfo_AllMaps proto.InternalMessageInfo

type AllMapsOrdered struct {
	StringToDoubleMap    map[string]float64        `protobuf:"bytes,1,rep,name=StringToDoubleMap,proto3" json:"StringToDoubleMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	StringToFloatMap     map[string]float32        `protobuf:"bytes,2,rep,name=StringToFloatMap,proto3" json:"StringToFloatMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Int32Map             map[int32]int32           `protobuf:"bytes,3,rep,name=Int32Map,proto3" json:"Int32Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Int64Map             map[int64]int64           `protobuf:"bytes,4,rep,name=Int64Map,proto3" json:"Int64Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Uint32Map            map[uint32]uint32         `protobuf:"bytes,5,rep,name=Uint32Map,proto3" json:"Uint32Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Uint64Map            map[uint64]uint64         `protobuf:"bytes,6,rep,name=Uint64Map,proto3" json:"Uint64Map,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Sint32Map            map[int32]int32           `protobuf:"bytes,7,rep,name=Sint32Map,proto3" json:"Sint32Map,omitempty" protobuf_key:"zigzag32,1,opt,name=key,proto3" protobuf_val:"zigzag32,2,opt,name=value,proto3"`
	Sint64Map            map[int64]int64           `protobuf:"bytes,8,rep,name=Sint64Map,proto3" json:"Sint64Map,omitempty" protobuf_key:"zigzag64,1,opt,name=key,proto3" protobuf_val:"zigzag64,2,opt,name=value,proto3"`
	Fixed32Map           map[uint32]uint32         `protobuf:"bytes,9,rep,name=Fixed32Map,proto3" json:"Fixed32Map,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Sfixed32Map          map[int32]int32           `protobuf:"bytes,10,rep,name=Sfixed32Map,proto3" json:"Sfixed32Map,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Fixed64Map           map[uint64]uint64         `protobuf:"bytes,11,rep,name=Fixed64Map,proto3" json:"Fixed64Map,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	Sfixed64Map          map[int64]int64           `protobuf:"bytes,12,rep,name=Sfixed64Map,proto3" json:"Sfixed64Map,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	BoolMap              map[bool]bool             `protobuf:"bytes,13,rep,name=BoolMap,proto3" json:"BoolMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	StringMap            map[string]string         `protobuf:"bytes,14,rep,name=StringMap,proto3" json:"StringMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StringToBytesMap     map[string][]byte         `protobuf:"bytes,15,rep,name=StringToBytesMap,proto3" json:"StringToBytesMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StringToEnumMap      map[string]MapEnum        `protobuf:"bytes,16,rep,name=StringToEnumMap,proto3" json:"StringToEnumMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=theproto3.MapEnum"`
	StringToMsgMap       map[string]*FloatingPoint `protobuf:"bytes,17,rep,name=StringToMsgMap,proto3" json:"StringToMsgMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *AllMapsOrdered) Reset()      { *m = AllMapsOrdered{} }
func (*AllMapsOrdered) ProtoMessage() {}
func (*AllMapsOrdered) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{3}
}
func (m *AllMapsOrdered) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllMapsOrdered) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllMapsOrdered.Marshal(b, m, deterministic)
}
func (m *AllMapsOrdered) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllMapsOrdered.Merge(m, src)
}
func (m *AllMapsOrdered) XXX_Size() int {
	return xxx_messageInfo_AllMapsOrdered.Size(m)
}
func (m *AllMapsOrdered) XXX_DiscardUnknown() {
	xxx_messageInfo_AllMapsOrdered.DiscardUnknown(m)
}

var xxx_messageInfo_AllMapsOrdered proto.InternalMessageInfo

type MessageWithMap struct {
	NameMapping          map[int32]string         `protobuf:"bytes,1,rep,name=name_mapping,json=nameMapping,proto3" json:"name_mapping,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MsgMapping           map[int64]*FloatingPoint `protobuf:"bytes,2,rep,name=msg_mapping,json=msgMapping,proto3" json:"msg_mapping,omitempty" protobuf_key:"zigzag64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ByteMapping          map[bool][]byte          `protobuf:"bytes,3,rep,name=byte_mapping,json=byteMapping,proto3" json:"byte_mapping,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *MessageWithMap) Reset()      { *m = MessageWithMap{} }
func (*MessageWithMap) ProtoMessage() {}
func (*MessageWithMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{4}
}
func (m *MessageWithMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageWithMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MessageWithMap.Marshal(b, m, deterministic)
}
func (m *MessageWithMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageWithMap.Merge(m, src)
}
func (m *MessageWithMap) XXX_Size() int {
	return xxx_messageInfo_MessageWithMap.Size(m)
}
func (m *MessageWithMap) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageWithMap.DiscardUnknown(m)
}

var xxx_messageInfo_MessageWithMap proto.InternalMessageInfo

type FloatingPoint struct {
	F                    float64  `protobuf:"fixed64,1,opt,name=f,proto3" json:"f,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FloatingPoint) Reset()      { *m = FloatingPoint{} }
func (*FloatingPoint) ProtoMessage() {}
func (*FloatingPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{5}
}
func (m *FloatingPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatingPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FloatingPoint.Marshal(b, m, deterministic)
}
func (m *FloatingPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatingPoint.Merge(m, src)
}
func (m *FloatingPoint) XXX_Size() int {
	return xxx_messageInfo_FloatingPoint.Size(m)
}
func (m *FloatingPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatingPoint.DiscardUnknown(m)
}

var xxx_messageInfo_FloatingPoint proto.InternalMessageInfo

type Uint128Pair struct {
	Left                 github_com_gogo_protobuf_test_custom.Uint128  `protobuf:"bytes,1,opt,name=left,proto3,customtype=github.com/gogo/protobuf/test/custom.Uint128" json:"left"`
	Right                *github_com_gogo_protobuf_test_custom.Uint128 `protobuf:"bytes,2,opt,name=right,proto3,customtype=github.com/gogo/protobuf/test/custom.Uint128" json:"right,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *Uint128Pair) Reset()      { *m = Uint128Pair{} }
func (*Uint128Pair) ProtoMessage() {}
func (*Uint128Pair) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{6}
}
func (m *Uint128Pair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Uint128Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Uint128Pair.Marshal(b, m, deterministic)
}
func (m *Uint128Pair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Uint128Pair.Merge(m, src)
}
func (m *Uint128Pair) XXX_Size() int {
	return xxx_messageInfo_Uint128Pair.Size(m)
}
func (m *Uint128Pair) XXX_DiscardUnknown() {
	xxx_messageInfo_Uint128Pair.DiscardUnknown(m)
}

var xxx_messageInfo_Uint128Pair proto.InternalMessageInfo

type ContainsNestedMap struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainsNestedMap) Reset()      { *m = ContainsNestedMap{} }
func (*ContainsNestedMap) ProtoMessage() {}
func (*ContainsNestedMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{7}
}
func (m *ContainsNestedMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainsNestedMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContainsNestedMap.Marshal(b, m, deterministic)
}
func (m *ContainsNestedMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainsNestedMap.Merge(m, src)
}
func (m *ContainsNestedMap) XXX_Size() int {
	return xxx_messageInfo_ContainsNestedMap.Size(m)
}
func (m *ContainsNestedMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainsNestedMap.DiscardUnknown(m)
}

var xxx_messageInfo_ContainsNestedMap proto.InternalMessageInfo

type ContainsNestedMap_NestedMap struct {
	NestedMapField       map[string]float64 `protobuf:"bytes,1,rep,name=NestedMapField,proto3" json:"NestedMapField,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ContainsNestedMap_NestedMap) Reset()      { *m = ContainsNestedMap_NestedMap{} }
func (*ContainsNestedMap_NestedMap) ProtoMessage() {}
func (*ContainsNestedMap_NestedMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{7, 0}
}
func (m *ContainsNestedMap_NestedMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainsNestedMap_NestedMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContainsNestedMap_NestedMap.Marshal(b, m, deterministic)
}
func (m *ContainsNestedMap_NestedMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainsNestedMap_NestedMap.Merge(m, src)
}
func (m *ContainsNestedMap_NestedMap) XXX_Size() int {
	return xxx_messageInfo_ContainsNestedMap_NestedMap.Size(m)
}
func (m *ContainsNestedMap_NestedMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainsNestedMap_NestedMap.DiscardUnknown(m)
}

var xxx_messageInfo_ContainsNestedMap_NestedMap proto.InternalMessageInfo

type NotPacked struct {
	Key                  []uint64 `protobuf:"varint,5,rep,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NotPacked) Reset()      { *m = NotPacked{} }
func (*NotPacked) ProtoMessage() {}
func (*NotPacked) Descriptor() ([]byte, []int) {
	return fileDescriptor_e24bba79c1e35a1f, []int{8}
}
func (m *NotPacked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotPacked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NotPacked.Marshal(b, m, deterministic)
}
func (m *NotPacked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotPacked.Merge(m, src)
}
func (m *NotPacked) XXX_Size() int {
	return xxx_messageInfo_NotPacked.Size(m)
}
func (m *NotPacked) XXX_DiscardUnknown() {
	xxx_messageInfo_NotPacked.DiscardUnknown(m)
}

var xxx_messageInfo_NotPacked proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("theproto3.MapEnum", MapEnum_name, MapEnum_value)
	proto.RegisterEnum("theproto3.Message_Humour", Message_Humour_name, Message_Humour_value)
	proto.RegisterType((*Message)(nil), "theproto3.Message")
	proto.RegisterMapType((map[int64]*both.NinOptEnum)(nil), "theproto3.Message.Proto2ValueEntry")
	proto.RegisterMapType((map[int64]*Nested)(nil), "theproto3.Message.TerrainEntry")
	proto.RegisterType((*Nested)(nil), "theproto3.Nested")
	proto.RegisterType((*AllMaps)(nil), "theproto3.AllMaps")
	proto.RegisterMapType((map[bool]bool)(nil), "theproto3.AllMaps.BoolMapEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "theproto3.AllMaps.Fixed32MapEntry")
	proto.RegisterMapType((map[uint64]uint64)(nil), "theproto3.AllMaps.Fixed64MapEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "theproto3.AllMaps.Int32MapEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "theproto3.AllMaps.Int64MapEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "theproto3.AllMaps.Sfixed32MapEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "theproto3.AllMaps.Sfixed64MapEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "theproto3.AllMaps.Sint32MapEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "theproto3.AllMaps.Sint64MapEntry")
	proto.RegisterMapType((map[string]string)(nil), "theproto3.AllMaps.StringMapEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "theproto3.AllMaps.StringToBytesMapEntry")
	proto.RegisterMapType((map[string]float64)(nil), "theproto3.AllMaps.StringToDoubleMapEntry")
	proto.RegisterMapType((map[string]MapEnum)(nil), "theproto3.AllMaps.StringToEnumMapEntry")
	proto.RegisterMapType((map[string]float32)(nil), "theproto3.AllMaps.StringToFloatMapEntry")
	proto.RegisterMapType((map[string]*FloatingPoint)(nil), "theproto3.AllMaps.StringToMsgMapEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "theproto3.AllMaps.Uint32MapEntry")
	proto.RegisterMapType((map[uint64]uint64)(nil), "theproto3.AllMaps.Uint64MapEntry")
	proto.RegisterType((*AllMapsOrdered)(nil), "theproto3.AllMapsOrdered")
	proto.RegisterMapType((map[bool]bool)(nil), "theproto3.AllMapsOrdered.BoolMapEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "theproto3.AllMapsOrdered.Fixed32MapEntry")
	proto.RegisterMapType((map[uint64]uint64)(nil), "theproto3.AllMapsOrdered.Fixed64MapEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "theproto3.AllMapsOrdered.Int32MapEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "theproto3.AllMapsOrdered.Int64MapEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "theproto3.AllMapsOrdered.Sfixed32MapEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "theproto3.AllMapsOrdered.Sfixed64MapEntry")
	proto.RegisterMapType((map[int32]int32)(nil), "theproto3.AllMapsOrdered.Sint32MapEntry")
	proto.RegisterMapType((map[int64]int64)(nil), "theproto3.AllMapsOrdered.Sint64MapEntry")
	proto.RegisterMapType((map[string]string)(nil), "theproto3.AllMapsOrdered.StringMapEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "theproto3.AllMapsOrdered.StringToBytesMapEntry")
	proto.RegisterMapType((map[string]float64)(nil), "theproto3.AllMapsOrdered.StringToDoubleMapEntry")
	proto.RegisterMapType((map[string]MapEnum)(nil), "theproto3.AllMapsOrdered.StringToEnumMapEntry")
	proto.RegisterMapType((map[string]float32)(nil), "theproto3.AllMapsOrdered.StringToFloatMapEntry")
	proto.RegisterMapType((map[string]*FloatingPoint)(nil), "theproto3.AllMapsOrdered.StringToMsgMapEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "theproto3.AllMapsOrdered.Uint32MapEntry")
	proto.RegisterMapType((map[uint64]uint64)(nil), "theproto3.AllMapsOrdered.Uint64MapEntry")
	proto.RegisterType((*MessageWithMap)(nil), "theproto3.MessageWithMap")
	proto.RegisterMapType((map[bool][]byte)(nil), "theproto3.MessageWithMap.ByteMappingEntry")
	proto.RegisterMapType((map[int64]*FloatingPoint)(nil), "theproto3.MessageWithMap.MsgMappingEntry")
	proto.RegisterMapType((map[int32]string)(nil), "theproto3.MessageWithMap.NameMappingEntry")
	proto.RegisterType((*FloatingPoint)(nil), "theproto3.FloatingPoint")
	proto.RegisterType((*Uint128Pair)(nil), "theproto3.Uint128Pair")
	proto.RegisterType((*ContainsNestedMap)(nil), "theproto3.ContainsNestedMap")
	proto.RegisterType((*ContainsNestedMap_NestedMap)(nil), "theproto3.ContainsNestedMap.NestedMap")
	proto.RegisterMapType((map[string]float64)(nil), "theproto3.ContainsNestedMap.NestedMap.NestedMapFieldEntry")
	proto.RegisterType((*NotPacked)(nil), "theproto3.NotPacked")
}

func init() {
	proto.RegisterFile("combos/unmarshaler/theproto3.proto", fileDescriptor_e24bba79c1e35a1f)
}

var fileDescriptor_e24bba79c1e35a1f = []byte{
	// 1612 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x99, 0xcf, 0x6f, 0xdb, 0x46,
	0x16, 0xc7, 0x35, 0xfa, 0xad, 0xa7, 0x1f, 0xa6, 0x27, 0xd9, 0x85, 0xd6, 0xc0, 0xd2, 0xb2, 0x02,
	0x24, 0x4a, 0xb0, 0x91, 0xb3, 0x4e, 0xb2, 0x9b, 0xba, 0x69, 0x53, 0x4b, 0xb1, 0x10, 0x37, 0xb6,
	0xe2, 0x4a, 0x76, 0xdc, 0x22, 0x40, 0x0d, 0xca, 0xa6, 0x25, 0x22, 0x12, 0x69, 0x90, 0xa3, 0xa0,
	0xbe, 0xe5, 0xcf, 0xe8, 0xad, 0xe8, 0xad, 0xc7, 0x22, 0x87, 0xa2, 0xc7, 0xf6, 0xe6, 0x63, 0x80,
	0x5e, 0x8a, 0x1e, 0x82, 0x58, 0xbd, 0xe4, 0x98, 0x63, 0x8e, 0xc5, 0xcc, 0x50, 0xd2, 0x48, 0x1c,
	0x8a, 0x4d, 0x2f, 0xbd, 0xf8, 0x24, 0xce, 0xf3, 0xfb, 0x7e, 0xe6, 0x71, 0x38, 0xf3, 0xf8, 0x05,
	0x0d, 0xc5, 0x03, 0xab, 0xd7, 0xb2, 0x9c, 0xe5, 0xbe, 0xd9, 0xd3, 0x6c, 0xa7, 0xa3, 0x75, 0x75,
	0x7b, 0x99, 0x74, 0xf4, 0x63, 0xdb, 0x22, 0xd6, 0xcd, 0x32, 0xfb, 0xc1, 0xa9, 0x51, 0x60, 0xe1,
	0x7a, 0xdb, 0x20, 0x9d, 0x7e, 0xab, 0x7c, 0x60, 0xf5, 0x96, 0xdb, 0x56, 0xdb, 0x5a, 0x66, 0xf1,
	0x56, 0xff, 0x88, 0x8d, 0xd8, 0x80, 0x5d, 0x71, 0xe5, 0xc2, 0xff, 0x7d, 0xd3, 0x89, 0xee, 0x90,
	0x65, 0x77, 0xee, 0x96, 0x45, 0x3a, 0x74, 0x52, 0x1a, 0xe3, 0xc2, 0xe2, 0xcf, 0x31, 0x48, 0x6c,
	0xe9, 0x8e, 0xa3, 0xb5, 0x75, 0x8c, 0x21, 0x6a, 0x6a, 0x3d, 0x3d, 0x8f, 0x0a, 0xa8, 0x94, 0x6a,
	0xb0, 0x6b, 0x7c, 0x1b, 0x92, 0x1d, 0xa3, 0xab, 0xd9, 0x06, 0x39, 0xc9, 0x87, 0x0b, 0xa8, 0x94,
	0x5b, 0xf9, 0x57, 0x79, 0x5c, 0xb6, 0xab, 0x2c, 0x3f, 0xe8, 0xf7, 0xac, 0xbe, 0xdd, 0x18, 0xa5,
	0xe2, 0x02, 0x64, 0x3a, 0xba, 0xd1, 0xee, 0x90, 0x7d, 0xc3, 0xdc, 0x3f, 0xe8, 0xe5, 0x23, 0x05,
	0x54, 0xca, 0x36, 0x80, 0xc7, 0x36, 0xcc, 0x6a, 0x8f, 0x4e, 0x76, 0xa8, 0x11, 0x2d, 0x1f, 0x2d,
	0xa0, 0x52, 0xa6, 0xc1, 0xae, 0xf1, 0x12, 0x64, 0x6c, 0xdd, 0xe9, 0x77, 0xc9, 0xfe, 0x81, 0xd5,
	0x37, 0x49, 0x3e, 0x51, 0x40, 0xa5, 0x48, 0x23, 0xcd, 0x63, 0x55, 0x1a, 0xc2, 0x97, 0x20, 0x4b,
	0xec, 0xbe, 0xbe, 0xef, 0x1c, 0x58, 0xc4, 0xe9, 0x69, 0x66, 0x3e, 0x59, 0x40, 0xa5, 0x64, 0x23,
	0x43, 0x83, 0x4d, 0x37, 0x86, 0x2f, 0x42, 0xcc, 0x39, 0xb0, 0x6c, 0x3d, 0x9f, 0x2a, 0xa0, 0x52,
	0xb8, 0xc1, 0x07, 0x58, 0x81, 0xc8, 0x53, 0xfd, 0x24, 0x1f, 0x2b, 0x44, 0x4a, 0xd1, 0x06, 0xbd,
	0xc4, 0x57, 0x21, 0x6e, 0xea, 0x0e, 0xd1, 0x0f, 0xf3, 0xf1, 0x02, 0x2a, 0xa5, 0x57, 0xe6, 0x85,
	0x5b, 0xab, 0xb3, 0x3f, 0x34, 0xdc, 0x04, 0xfc, 0x01, 0x24, 0x88, 0x6e, 0xdb, 0x9a, 0x61, 0xe6,
	0xa1, 0x10, 0x29, 0xa5, 0x57, 0x16, 0x25, 0xcb, 0xb0, 0xc3, 0x33, 0xd6, 0x4d, 0x62, 0x9f, 0x34,
	0x86, 0xf9, 0xf8, 0x36, 0x64, 0x58, 0xde, 0xca, 0xfe, 0x91, 0xa1, 0x77, 0x0f, 0xf3, 0x69, 0x36,
	0x17, 0x2e, 0xb3, 0xa7, 0x50, 0x37, 0xcc, 0x47, 0xc7, 0xa4, 0xae, 0x11, 0xe3, 0x99, 0xde, 0x48,
	0xf3, 0xbc, 0x1a, 0x4d, 0xc3, 0xb5, 0x91, 0xec, 0x99, 0xd6, 0xed, 0xeb, 0xf9, 0x2c, 0x9b, 0xf6,
	0x92, 0x64, 0xda, 0x6d, 0x96, 0xf6, 0x98, 0x66, 0xf1, 0xa9, 0x5d, 0x0e, 0x8b, 0x2c, 0x6c, 0x41,
	0x46, 0xac, 0x6b, 0xb8, 0x0c, 0x88, 0xad, 0x2d, 0x5b, 0x86, 0x2b, 0x10, 0xe3, 0x53, 0x84, 0xfd,
	0x56, 0x81, 0xff, 0x7d, 0x35, 0x7c, 0x07, 0x2d, 0x6c, 0x83, 0x32, 0x3d, 0x9f, 0x04, 0x79, 0x79,
	0x12, 0xa9, 0x88, 0x37, 0xbb, 0x6e, 0xf6, 0x7b, 0x02, 0xb1, 0x78, 0x0f, 0xe2, 0x7c, 0xff, 0xe0,
	0x34, 0x24, 0x76, 0xeb, 0x0f, 0xeb, 0x8f, 0xf6, 0xea, 0x4a, 0x08, 0x27, 0x21, 0xba, 0xbd, 0x5b,
	0x6f, 0x2a, 0x08, 0x67, 0x21, 0xd5, 0xdc, 0x5c, 0xdb, 0x6e, 0xee, 0x6c, 0x54, 0x1f, 0x2a, 0x61,
	0x3c, 0x07, 0xe9, 0xca, 0xc6, 0xe6, 0xe6, 0x7e, 0x65, 0x6d, 0x63, 0x73, 0xfd, 0x0b, 0x25, 0x52,
	0x54, 0x21, 0xce, 0xeb, 0xa4, 0x0f, 0xbe, 0xd5, 0x37, 0xcd, 0x13, 0x77, 0x0b, 0xf3, 0x41, 0xf1,
	0x05, 0x86, 0xc4, 0x5a, 0xb7, 0xbb, 0xa5, 0x1d, 0x3b, 0x78, 0x0f, 0xe6, 0x9b, 0xc4, 0x36, 0xcc,
	0xf6, 0x8e, 0x75, 0xdf, 0xea, 0xb7, 0xba, 0xfa, 0x96, 0x76, 0x9c, 0x47, 0x6c, 0x69, 0xaf, 0x0a,
	0xf7, 0xed, 0xa6, 0x97, 0x3d, 0xb9, 0x7c, 0x81, 0xbd, 0x0c, 0xbc, 0x03, 0xca, 0x30, 0x58, 0xeb,
	0x5a, 0x1a, 0xa1, 0xdc, 0x30, 0xe3, 0x96, 0x66, 0x70, 0x87, 0xa9, 0x1c, 0xeb, 0x21, 0xe0, 0xbb,
	0x90, 0xdc, 0x30, 0xc9, 0xcd, 0x15, 0x4a, 0x8b, 0x30, 0x5a, 0x41, 0x42, 0x1b, 0xa6, 0x70, 0xca,
	0x48, 0xe1, 0xaa, 0xff, 0x77, 0x8b, 0xaa, 0xa3, 0xb3, 0xd4, 0x2c, 0x65, 0xac, 0x66, 0x43, 0x7c,
	0x0f, 0x52, 0xbb, 0xc6, 0x70, 0xf2, 0x18, 0x93, 0x2f, 0x49, 0xe4, 0xa3, 0x1c, 0xae, 0x1f, 0x6b,
	0x86, 0x00, 0x3e, 0x7f, 0x7c, 0x26, 0x40, 0x28, 0x60, 0xac, 0xa1, 0x80, 0xe6, 0xa8, 0x82, 0x84,
	0x2f, 0xa0, 0x39, 0x55, 0x41, 0x53, 0xac, 0xa0, 0x39, 0xaa, 0x20, 0x39, 0x13, 0x20, 0x56, 0x30,
	0x1a, 0xe3, 0x0a, 0x40, 0xcd, 0xf8, 0x4a, 0x3f, 0xe4, 0x25, 0xa4, 0x18, 0xa1, 0x28, 0x21, 0x8c,
	0x93, 0x38, 0x42, 0x50, 0xe1, 0x75, 0x48, 0x37, 0x8f, 0xc6, 0x10, 0xf0, 0x9c, 0xe3, 0x51, 0x19,
	0x47, 0x53, 0x14, 0x51, 0x37, 0x2a, 0x85, 0xdf, 0x4c, 0x7a, 0x76, 0x29, 0xc2, 0xdd, 0x08, 0xaa,
	0x71, 0x29, 0x1c, 0x92, 0x09, 0x28, 0x45, 0xa0, 0x88, 0x3a, 0xda, 0x0c, 0x2b, 0x96, 0x45, 0x33,
	0xdd, 0xae, 0xb4, 0x28, 0x41, 0xb8, 0x19, 0x6e, 0x33, 0x74, 0x47, 0xec, 0x89, 0xb0, 0x4d, 0x4e,
	0xc5, 0x39, 0xff, 0x27, 0x32, 0xcc, 0x19, 0x3e, 0x91, 0xe1, 0x58, 0x3c, 0x67, 0x95, 0x13, 0xa2,
	0x3b, 0x94, 0x33, 0x17, 0x78, 0xce, 0x86, 0xa9, 0x53, 0xe7, 0x6c, 0x18, 0xc6, 0x9f, 0xc1, 0xdc,
	0x30, 0x46, 0xdb, 0x13, 0x85, 0x2a, 0x0c, 0x7a, 0x65, 0x06, 0xd4, 0xcd, 0xe4, 0xcc, 0x69, 0x3d,
	0xae, 0x43, 0x6e, 0x18, 0xda, 0x72, 0xd8, 0xed, 0xce, 0x33, 0xe2, 0xe5, 0x19, 0x44, 0x9e, 0xc8,
	0x81, 0x53, 0xea, 0x85, 0xfb, 0xf0, 0x4f, 0x79, 0x37, 0x12, 0xdb, 0x6f, 0x8a, 0xb7, 0xdf, 0x8b,
	0x62, 0xfb, 0x45, 0x62, 0xfb, 0xae, 0xc2, 0x3f, 0xa4, 0xbd, 0x27, 0x08, 0x12, 0x16, 0x21, 0x1f,
	0x42, 0x76, 0xa2, 0xe5, 0x88, 0xe2, 0x98, 0x44, 0x1c, 0xf3, 0x8a, 0xc7, 0x5b, 0x4b, 0xf2, 0xf6,
	0x98, 0x10, 0x47, 0x44, 0xf1, 0x5d, 0xc8, 0x4d, 0xf6, 0x1b, 0x51, 0x9d, 0x95, 0xa8, 0xb3, 0x12,
	0xb5, 0x7c, 0xee, 0xa8, 0x44, 0x1d, 0x9d, 0x52, 0x37, 0x7d, 0xe7, 0x9e, 0x97, 0xa8, 0xe7, 0x25,
	0x6a, 0xf9, 0xdc, 0x58, 0xa2, 0xc6, 0xa2, 0xfa, 0x23, 0x98, 0x9b, 0x6a, 0x31, 0xa2, 0x3c, 0x21,
	0x91, 0x27, 0x44, 0xf9, 0xc7, 0xa0, 0x4c, 0x37, 0x17, 0x51, 0x3f, 0x27, 0xd1, 0xcf, 0xc9, 0xa6,
	0x97, 0x57, 0x1f, 0x97, 0xc8, 0xe3, 0xd2, 0xe9, 0xe5, 0x7a, 0x45, 0xa2, 0x57, 0x44, 0xfd, 0x2a,
	0x64, 0xc4, 0x6e, 0x22, 0x6a, 0x93, 0x12, 0x6d, 0x72, 0x7a, 0xdd, 0x27, 0x9a, 0x49, 0xd0, 0x4e,
	0x4f, 0xf9, 0x1c, 0x97, 0x89, 0x16, 0x12, 0x04, 0xc9, 0x88, 0x90, 0xc7, 0x70, 0x51, 0xd6, 0x32,
	0x24, 0x8c, 0x92, 0xc8, 0xc8, 0x51, 0x8f, 0x38, 0x36, 0x7b, 0x54, 0x35, 0x61, 0x9c, 0x16, 0x9e,
	0xc0, 0x05, 0x49, 0xe3, 0x90, 0x60, 0xcb, 0x93, 0x6e, 0x2c, 0x2f, 0x60, 0x59, 0x13, 0x30, 0xcc,
	0xf6, 0xb6, 0x65, 0x98, 0x44, 0x74, 0x65, 0x3f, 0x5c, 0x80, 0x9c, 0xdb, 0x9e, 0x1e, 0xd9, 0x87,
	0xba, 0xad, 0x1f, 0xe2, 0x2f, 0xfd, 0xbd, 0xd3, 0x0d, 0x6f, 0x53, 0x73, 0x55, 0xef, 0x61, 0xa1,
	0x9e, 0xf8, 0x5a, 0xa8, 0xe5, 0x60, 0x7c, 0x90, 0x93, 0xaa, 0x7a, 0x9c, 0xd4, 0x15, 0x7f, 0xa8,
	0x9f, 0xa1, 0xaa, 0x7a, 0x0c, 0xd5, 0x6c, 0x88, 0xd4, 0x57, 0xd5, 0xbc, 0xbe, 0xaa, 0xe4, 0x4f,
	0xf1, 0xb7, 0x57, 0x35, 0xaf, 0xbd, 0x0a, 0xe0, 0xc8, 0x5d, 0x56, 0xcd, 0xeb, 0xb2, 0x66, 0x70,
	0xfc, 0xcd, 0x56, 0xcd, 0x6b, 0xb6, 0x02, 0x38, 0x72, 0xcf, 0xb5, 0x21, 0xf1, 0x5c, 0x57, 0xfd,
	0x41, 0xb3, 0xac, 0xd7, 0xa6, 0xcc, 0x7a, 0x5d, 0x9b, 0x51, 0xd4, 0x4c, 0x07, 0xb6, 0x21, 0x71,
	0x60, 0x41, 0x85, 0xf9, 0x18, 0xb1, 0x4d, 0x99, 0x11, 0x0b, 0x2c, 0xcc, 0xcf, 0x8f, 0x7d, 0x32,
	0xed, 0xc7, 0x2e, 0xfb, 0x93, 0xe4, 0xb6, 0xac, 0xe6, 0xb5, 0x65, 0xa5, 0xa0, 0x33, 0x27, 0x73,
	0x67, 0x4f, 0x7c, 0xdd, 0xd9, 0x9f, 0x38, 0xc2, 0x41, 0x26, 0xed, 0x73, 0x3f, 0x93, 0x56, 0x0e,
	0x66, 0xcf, 0xf6, 0x6a, 0xbb, 0x3e, 0x5e, 0xed, 0x7a, 0x30, 0xf8, 0xdc, 0xb2, 0x9d, 0x5b, 0xb6,
	0x73, 0xcb, 0x76, 0x6e, 0xd9, 0xfe, 0x7e, 0xcb, 0xb6, 0x1a, 0xfd, 0xfa, 0xdb, 0x45, 0x54, 0xfc,
	0x25, 0x02, 0x39, 0xf7, 0xcb, 0xe0, 0x9e, 0x41, 0x3a, 0xb4, 0xbd, 0x6d, 0x41, 0xc6, 0xd4, 0x7a,
	0xfa, 0x7e, 0x4f, 0x3b, 0x3e, 0x36, 0xcc, 0xb6, 0xeb, 0xd9, 0xae, 0x79, 0x3f, 0x25, 0xba, 0x82,
	0x72, 0x5d, 0xeb, 0xd1, 0x5e, 0x45, 0x93, 0xdd, 0xd7, 0x8d, 0x39, 0x8e, 0xe0, 0x4f, 0x21, 0xdd,
	0x73, 0xda, 0x23, 0x5a, 0xd8, 0xf3, 0x22, 0x9c, 0xa2, 0xf1, 0x3b, 0x1d, 0xc3, 0xa0, 0x37, 0x0a,
	0xd0, 0xd2, 0x5a, 0x27, 0x64, 0x5c, 0x5a, 0x24, 0xa8, 0x34, 0xfa, 0x4c, 0x27, 0x4b, 0x6b, 0x8d,
	0x23, 0x74, 0xdb, 0x4e, 0xd7, 0x1e, 0xd4, 0xe9, 0x26, 0x36, 0xcf, 0x1e, 0xcc, 0x4d, 0x55, 0x2b,
	0x39, 0xf3, 0x7f, 0xe1, 0xd9, 0xd0, 0xc2, 0xa6, 0x2b, 0x0f, 0x3a, 0x13, 0xe2, 0x86, 0x2c, 0xfe,
	0x1b, 0xb2, 0x13, 0x6c, 0x9c, 0x01, 0x74, 0xc4, 0xa4, 0xa8, 0x81, 0x8e, 0x8a, 0xdf, 0x20, 0x48,
	0xd3, 0x3e, 0xf9, 0xdf, 0x95, 0x3b, 0xdb, 0x9a, 0x61, 0xe3, 0x07, 0x10, 0xed, 0xea, 0x47, 0x84,
	0x25, 0x64, 0x2a, 0xb7, 0x4e, 0x5f, 0x2d, 0x86, 0x7e, 0x7b, 0xb5, 0xf8, 0x9f, 0x80, 0xff, 0x12,
	0xf4, 0x1d, 0x62, 0xf5, 0xca, 0x2e, 0xa7, 0xc1, 0x08, 0xb8, 0x06, 0x31, 0xdb, 0x68, 0x77, 0x08,
	0x2f, 0xa9, 0x72, 0xe3, 0xbd, 0x31, 0x5c, 0x5e, 0x3c, 0x45, 0x30, 0x5f, 0xb5, 0x4c, 0xa2, 0x19,
	0xa6, 0xc3, 0xbf, 0xd6, 0xd2, 0x37, 0xe4, 0x0b, 0x04, 0xa9, 0xd1, 0x08, 0xb7, 0x20, 0x37, 0x1a,
	0xb0, 0x8f, 0xe0, 0xee, 0x4e, 0x5d, 0x15, 0x56, 0xd8, 0xc3, 0x28, 0x4b, 0xae, 0x98, 0xd8, 0x7d,
	0x27, 0x4f, 0x06, 0x17, 0xd6, 0xe0, 0x82, 0x24, 0xed, 0x7d, 0x5e, 0xc8, 0xc5, 0x25, 0x48, 0xd5,
	0x2d, 0xb2, 0xad, 0x1d, 0x3c, 0x65, 0x9f, 0x9c, 0xc7, 0xff, 0x55, 0xa8, 0x84, 0x95, 0x10, 0x13,
	0x5f, 0x5b, 0x82, 0x84, 0x7b, 0xfa, 0x71, 0x1c, 0xc2, 0x5b, 0x6b, 0x4a, 0x88, 0xfd, 0x56, 0x14,
	0xc4, 0x7e, 0xab, 0x4a, 0xb8, 0xb2, 0x79, 0x7a, 0xa6, 0x86, 0x5e, 0x9e, 0xa9, 0xa1, 0x5f, 0xcf,
	0xd4, 0xd0, 0xeb, 0x33, 0x15, 0xbd, 0x39, 0x53, 0xd1, 0xdb, 0x33, 0x15, 0xbd, 0x3b, 0x53, 0xd1,
	0xf3, 0x81, 0x8a, 0xbe, 0x1b, 0xa8, 0xe8, 0xfb, 0x81, 0x8a, 0x7e, 0x1c, 0xa8, 0xe8, 0xa7, 0x81,
	0x8a, 0x4e, 0x07, 0x6a, 0xe8, 0xe5, 0x40, 0x45, 0xaf, 0x07, 0x2a, 0x7a, 0x33, 0x50, 0x43, 0x6f,
	0x07, 0x2a, 0x7a, 0x37, 0x50, 0x43, 0xcf, 0x7f, 0x57, 0x43, 0xad, 0x38, 0x5f, 0x9e, 0x3f, 0x02,
	0x00, 0x00, 0xff, 0xff, 0xda, 0xba, 0x48, 0xa4, 0x67, 0x1a, 0x00, 0x00,
}

func (this *Message) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *Nested) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *AllMaps) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *AllMapsOrdered) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *MessageWithMap) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *FloatingPoint) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *Uint128Pair) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *ContainsNestedMap) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *ContainsNestedMap_NestedMap) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func (this *NotPacked) Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	return Theproto3Description()
}
func Theproto3Description() (desc *github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet) {
	d := &github_com_gogo_protobuf_protoc_gen_gogo_descriptor.FileDescriptorSet{}
	var gzipped = []byte{
		// 8097 bytes of a gzipped FileDescriptorSet
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x5b, 0x70, 0x23, 0xd7,
		0x99, 0x1e, 0x1b, 0x0d, 0x90, 0xc0, 0x0f, 0x90, 0x6c, 0x36, 0x67, 0x28, 0x88, 0x1a, 0x91, 0x33,
		0xd0, 0x68, 0x44, 0xd1, 0x12, 0x67, 0x86, 0xc3, 0xb9, 0x61, 0x2c, 0x69, 0x01, 0x10, 0x1c, 0x71,
		0x4c, 0x82, 0x74, 0x93, 0xb4, 0x34, 0x56, 0x12, 0x54, 0x13, 0x38, 0x24, 0x21, 0x01, 0xdd, 0x58,
		0x74, 0x43, 0x12, 0x55, 0xa9, 0x94, 0xb2, 0x4e, 0x36, 0xde, 0xdc, 0x93, 0x4d, 0x2a, 0x5e, 0xc7,
		0x17, 0x79, 0xb7, 0x76, 0xed, 0xdd, 0xdc, 0xbc, 0xce, 0xc6, 0xd9, 0x75, 0x52, 0x59, 0xe5, 0xc1,
		0xc9, 0xe4, 0x25, 0xe5, 0x4d, 0x5e, 0x52, 0xae, 0x94, 0xca, 0x1a, 0x3b, 0xb5, 0x4e, 0xe2, 0x24,
		0xce, 0x46, 0x55, 0x71, 0x95, 0xf7, 0x61, 0xeb, 0xdc, 0xba, 0x4f, 0x1f, 0x34, 0xd0, 0xe0, 0x48,
		0xb2, 0xf7, 0xc1, 0x2f, 0x33, 0xe8, 0x73, 0xfe, 0xef, 0xeb, 0xbf, 0xff, 0xcb, 0x39, 0x7f, 0x9f,
		0x73, 0x00, 0xc2, 0xbd, 0x3c, 0x9c, 0x3d, 0xb4, 0xed, 0xc3, 0x26, 0xba, 0xd8, 0xee, 0xd8, 0xae,
		0xbd, 0xdf, 0x3d, 0xb8, 0x58, 0x47, 0x4e, 0xad, 0xd3, 0x68, 0xbb, 0x76, 0x67, 0x89, 0xb4, 0xe9,
		0x93, 0x54, 0x62, 0x89, 0x4b, 0xe4, 0x36, 0x61, 0x6a, 0xad, 0xd1, 0x44, 0xab, 0x9e, 0xe0, 0x0e,
		0x72, 0xf5, 0x1b, 0x10, 0x3f, 0x68, 0x34, 0x51, 0x56, 0x39, 0xab, 0x2e, 0xa4, 0x97, 0xcf, 0x2f,
		0x49, 0xa0, 0xa5, 0x20, 0x62, 0x1b, 0x37, 0x1b, 0x04, 0x91, 0xfb, 0x5e, 0x1c, 0xa6, 0x43, 0x7a,
		0x75, 0x1d, 0xe2, 0x96, 0xd9, 0xc2, 0x8c, 0xca, 0x42, 0xca, 0x20, 0x9f, 0xf5, 0x2c, 0x8c, 0xb5,
		0xcd, 0xda, 0x2b, 0xe6, 0x21, 0xca, 0xc6, 0x48, 0x33, 0xbf, 0xd4, 0xe7, 0x00, 0xea, 0xa8, 0x8d,
		0xac, 0x3a, 0xb2, 0x6a, 0xc7, 0x59, 0xf5, 0xac, 0xba, 0x90, 0x32, 0x84, 0x16, 0xfd, 0x23, 0x30,
		0xd5, 0xee, 0xee, 0x37, 0x1b, 0xb5, 0xaa, 0x20, 0x06, 0x67, 0xd5, 0x85, 0x84, 0xa1, 0xd1, 0x8e,
		0x55, 0x5f, 0xf8, 0x09, 0x98, 0x7c, 0x0d, 0x99, 0xaf, 0x88, 0xa2, 0x69, 0x22, 0x3a, 0x81, 0x9b,
		0x05, 0xc1, 0x12, 0x64, 0x5a, 0xc8, 0x71, 0xcc, 0x43, 0x54, 0x75, 0x8f, 0xdb, 0x28, 0x1b, 0x27,
		0x4f, 0x7f, 0xb6, 0xe7, 0xe9, 0xe5, 0x27, 0x4f, 0x33, 0xd4, 0xee, 0x71, 0x1b, 0xe9, 0x05, 0x48,
		0x21, 0xab, 0xdb, 0xa2, 0x0c, 0x89, 0x3e, 0xf6, 0x2b, 0x5b, 0xdd, 0x96, 0xcc, 0x92, 0xc4, 0x30,
		0x46, 0x31, 0xe6, 0xa0, 0xce, 0xab, 0x8d, 0x1a, 0xca, 0x8e, 0x12, 0x82, 0x27, 0x7a, 0x08, 0x76,
		0x68, 0xbf, 0xcc, 0xc1, 0x71, 0x7a, 0x09, 0x52, 0xe8, 0x75, 0x17, 0x59, 0x4e, 0xc3, 0xb6, 0xb2,
		0x63, 0x84, 0xe4, 0xf1, 0x10, 0x2f, 0xa2, 0x66, 0x5d, 0xa6, 0xf0, 0x71, 0xfa, 0x35, 0x18, 0xb3,
		0xdb, 0x6e, 0xc3, 0xb6, 0x9c, 0x6c, 0xf2, 0xac, 0xb2, 0x90, 0x5e, 0x3e, 0x13, 0x1a, 0x08, 0x5b,
		0x54, 0xc6, 0xe0, 0xc2, 0xfa, 0x3a, 0x68, 0x8e, 0xdd, 0xed, 0xd4, 0x50, 0xb5, 0x66, 0xd7, 0x51,
		0xb5, 0x61, 0x1d, 0xd8, 0xd9, 0x14, 0x21, 0x98, 0xef, 0x7d, 0x10, 0x22, 0x58, 0xb2, 0xeb, 0x68,
		0xdd, 0x3a, 0xb0, 0x8d, 0x09, 0x27, 0x70, 0xad, 0xcf, 0xc0, 0xa8, 0x73, 0x6c, 0xb9, 0xe6, 0xeb,
		0xd9, 0x0c, 0x89, 0x10, 0x76, 0x95, 0xfb, 0xbd, 0x51, 0x98, 0x1c, 0x26, 0xc4, 0x6e, 0x41, 0xe2,
		0x00, 0x3f, 0x65, 0x36, 0x76, 0x12, 0x1b, 0x50, 0x4c, 0xd0, 0x88, 0xa3, 0x0f, 0x68, 0xc4, 0x02,
		0xa4, 0x2d, 0xe4, 0xb8, 0xa8, 0x4e, 0x23, 0x42, 0x1d, 0x32, 0xa6, 0x80, 0x82, 0x7a, 0x43, 0x2a,
		0xfe, 0x40, 0x21, 0xf5, 0x22, 0x4c, 0x7a, 0x2a, 0x55, 0x3b, 0xa6, 0x75, 0xc8, 0x63, 0xf3, 0x62,
		0x94, 0x26, 0x4b, 0x65, 0x8e, 0x33, 0x30, 0xcc, 0x98, 0x40, 0x81, 0x6b, 0x7d, 0x15, 0xc0, 0xb6,
		0x90, 0x7d, 0x50, 0xad, 0xa3, 0x5a, 0x33, 0x9b, 0xec, 0x63, 0xa5, 0x2d, 0x2c, 0xd2, 0x63, 0x25,
		0x9b, 0xb6, 0xd6, 0x9a, 0xfa, 0x4d, 0x3f, 0xd4, 0xc6, 0xfa, 0x44, 0xca, 0x26, 0x4d, 0xb2, 0x9e,
		0x68, 0xdb, 0x83, 0x89, 0x0e, 0xc2, 0x71, 0x8f, 0xea, 0xec, 0xc9, 0x52, 0x44, 0x89, 0xa5, 0xc8,
		0x27, 0x33, 0x18, 0x8c, 0x3e, 0xd8, 0x78, 0x47, 0xbc, 0xd4, 0x1f, 0x03, 0xaf, 0xa1, 0x4a, 0xc2,
		0x0a, 0xc8, 0x28, 0x94, 0xe1, 0x8d, 0x15, 0xb3, 0x85, 0x66, 0xdf, 0x80, 0x89, 0xa0, 0x79, 0xf4,
		0x53, 0x90, 0x70, 0x5c, 0xb3, 0xe3, 0x92, 0x28, 0x4c, 0x18, 0xf4, 0x42, 0xd7, 0x40, 0x45, 0x56,
		0x9d, 0x8c, 0x72, 0x09, 0x03, 0x7f, 0xd4, 0x7f, 0xce, 0x7f, 0x60, 0x95, 0x3c, 0xf0, 0x85, 0x5e,
		0x8f, 0x06, 0x98, 0xe5, 0xe7, 0x9e, 0xbd, 0x0e, 0xe3, 0x81, 0x07, 0x18, 0xf6, 0xd6, 0xb9, 0x3f,
		0x0f, 0xa7, 0x43, 0xa9, 0xf5, 0x17, 0xe1, 0x54, 0xd7, 0x6a, 0x58, 0x2e, 0xea, 0xb4, 0x3b, 0x08,
		0x47, 0x2c, 0xbd, 0x55, 0xf6, 0x0f, 0xc7, 0xfa, 0xc4, 0xdc, 0x9e, 0x28, 0x4d, 0x59, 0x8c, 0xe9,
		0x6e, 0x6f, 0xe3, 0x62, 0x2a, 0xf9, 0xfd, 0x31, 0xed, 0xcd, 0x37, 0xdf, 0x7c, 0x33, 0x96, 0xfb,
		0xcc, 0x28, 0x9c, 0x0a, 0xcb, 0x99, 0xd0, 0xf4, 0x9d, 0x81, 0x51, 0xab, 0xdb, 0xda, 0x47, 0x1d,
		0x62, 0xa4, 0x84, 0xc1, 0xae, 0xf4, 0x02, 0x24, 0x9a, 0xe6, 0x3e, 0x6a, 0x66, 0xe3, 0x67, 0x95,
		0x85, 0x89, 0xe5, 0x8f, 0x0c, 0x95, 0x95, 0x4b, 0x1b, 0x18, 0x62, 0x50, 0xa4, 0xfe, 0x2c, 0xc4,
		0xd9, 0x10, 0x8d, 0x19, 0x16, 0x87, 0x63, 0xc0, 0xb9, 0x64, 0x10, 0x9c, 0xfe, 0x08, 0xa4, 0xf0,
		0xff, 0x34, 0x36, 0x46, 0x89, 0xce, 0x49, 0xdc, 0x80, 0xe3, 0x42, 0x9f, 0x85, 0x24, 0x49, 0x93,
		0x3a, 0xe2, 0x53, 0x9b, 0x77, 0x8d, 0x03, 0xab, 0x8e, 0x0e, 0xcc, 0x6e, 0xd3, 0xad, 0xbe, 0x6a,
		0x36, 0xbb, 0x88, 0x04, 0x7c, 0xca, 0xc8, 0xb0, 0xc6, 0x4f, 0xe0, 0x36, 0x7d, 0x1e, 0xd2, 0x34,
		0xab, 0x1a, 0x56, 0x1d, 0xbd, 0x4e, 0x46, 0xcf, 0x84, 0x41, 0x13, 0x6d, 0x1d, 0xb7, 0xe0, 0xdb,
		0xbf, 0xec, 0xd8, 0x16, 0x0f, 0x4d, 0x72, 0x0b, 0xdc, 0x40, 0x6e, 0x7f, 0x5d, 0x1e, 0xb8, 0x1f,
		0x0d, 0x7f, 0x3c, 0x39, 0xa6, 0x72, 0x5f, 0x8f, 0x41, 0x9c, 0x8c, 0x17, 0x93, 0x90, 0xde, 0xbd,
		0xbb, 0x5d, 0xae, 0xae, 0x6e, 0xed, 0x15, 0x37, 0xca, 0x9a, 0xa2, 0x4f, 0x00, 0x90, 0x86, 0xb5,
		0x8d, 0xad, 0xc2, 0xae, 0x16, 0xf3, 0xae, 0xd7, 0x2b, 0xbb, 0xd7, 0x56, 0x34, 0xd5, 0x03, 0xec,
		0xd1, 0x86, 0xb8, 0x28, 0x70, 0x65, 0x59, 0x4b, 0xe8, 0x1a, 0x64, 0x28, 0xc1, 0xfa, 0x8b, 0xe5,
		0xd5, 0x6b, 0x2b, 0xda, 0x68, 0xb0, 0xe5, 0xca, 0xb2, 0x36, 0xa6, 0x8f, 0x43, 0x8a, 0xb4, 0x14,
		0xb7, 0xb6, 0x36, 0xb4, 0xa4, 0xc7, 0xb9, 0xb3, 0x6b, 0xac, 0x57, 0x6e, 0x6b, 0x29, 0x8f, 0xf3,
		0xb6, 0xb1, 0xb5, 0xb7, 0xad, 0x81, 0xc7, 0xb0, 0x59, 0xde, 0xd9, 0x29, 0xdc, 0x2e, 0x6b, 0x69,
		0x4f, 0xa2, 0x78, 0x77, 0xb7, 0xbc, 0xa3, 0x65, 0x02, 0x6a, 0x5d, 0x59, 0xd6, 0xc6, 0xbd, 0x5b,
		0x94, 0x2b, 0x7b, 0x9b, 0xda, 0x84, 0x3e, 0x05, 0xe3, 0xf4, 0x16, 0x5c, 0x89, 0x49, 0xa9, 0xe9,
		0xda, 0x8a, 0xa6, 0xf9, 0x8a, 0x50, 0x96, 0xa9, 0x40, 0xc3, 0xb5, 0x15, 0x4d, 0xcf, 0x95, 0x20,
		0x41, 0xa2, 0x4b, 0xd7, 0x61, 0x62, 0xa3, 0x50, 0x2c, 0x6f, 0x54, 0xb7, 0xb6, 0x77, 0xd7, 0xb7,
		0x2a, 0x85, 0x0d, 0x4d, 0xf1, 0xdb, 0x8c, 0xf2, 0xc7, 0xf7, 0xd6, 0x8d, 0xf2, 0xaa, 0x16, 0x13,
		0xdb, 0xb6, 0xcb, 0x85, 0xdd, 0xf2, 0xaa, 0xa6, 0xe6, 0x6a, 0x70, 0x2a, 0x6c, 0x9c, 0x0c, 0xcd,
		0x0c, 0xc1, 0xc5, 0xb1, 0x3e, 0x2e, 0x26, 0x5c, 0x3d, 0x2e, 0xfe, 0x6e, 0x0c, 0xa6, 0x43, 0xe6,
		0x8a, 0xd0, 0x9b, 0x3c, 0x07, 0x09, 0x1a, 0xa2, 0x74, 0xf6, 0x7c, 0x32, 0x74, 0xd2, 0x21, 0x01,
		0xdb, 0x33, 0x83, 0x12, 0x9c, 0x58, 0x41, 0xa8, 0x7d, 0x2a, 0x08, 0x4c, 0xd1, 0x33, 0xa6, 0xff,
		0xd9, 0x9e, 0x31, 0x9d, 0x4e, 0x7b, 0xd7, 0x86, 0x99, 0xf6, 0x48, 0xdb, 0xc9, 0xc6, 0xf6, 0x44,
		0xc8, 0xd8, 0x7e, 0x0b, 0xa6, 0x7a, 0x88, 0x86, 0x1e, 0x63, 0x3f, 0xa5, 0x40, 0xb6, 0x9f, 0x71,
		0x22, 0x46, 0xba, 0x58, 0x60, 0xa4, 0xbb, 0x25, 0x5b, 0xf0, 0x5c, 0x7f, 0x27, 0xf4, 0xf8, 0xfa,
		0xcb, 0x0a, 0xcc, 0x84, 0x57, 0x8a, 0xa1, 0x3a, 0x3c, 0x0b, 0xa3, 0x2d, 0xe4, 0x1e, 0xd9, 0xbc,
		0x5a, 0xba, 0x10, 0x32, 0x07, 0xe3, 0x6e, 0xd9, 0xd9, 0x0c, 0x25, 0x4e, 0xe2, 0x6a, 0xbf, 0x72,
		0x8f, 0x6a, 0xd3, 0xa3, 0xe9, 0x2f, 0xc5, 0xe0, 0x74, 0x28, 0x79, 0xa8, 0xa2, 0x8f, 0x02, 0x34,
		0xac, 0x76, 0xd7, 0xa5, 0x15, 0x11, 0x1d, 0x60, 0x53, 0xa4, 0x85, 0x0c, 0x5e, 0x78, 0xf0, 0xec,
		0xba, 0x5e, 0xbf, 0x4a, 0xfa, 0x81, 0x36, 0x11, 0x81, 0x1b, 0xbe, 0xa2, 0x71, 0xa2, 0xe8, 0x5c,
		0x9f, 0x27, 0xed, 0x09, 0xcc, 0x4b, 0xa0, 0xd5, 0x9a, 0x0d, 0x64, 0xb9, 0x55, 0xc7, 0xed, 0x20,
		0xb3, 0xd5, 0xb0, 0x0e, 0xc9, 0x0c, 0x92, 0xcc, 0x27, 0x0e, 0xcc, 0xa6, 0x83, 0x8c, 0x49, 0xda,
		0xbd, 0xc3, 0x7b, 0x31, 0x82, 0x04, 0x50, 0x47, 0x40, 0x8c, 0x06, 0x10, 0xb4, 0xdb, 0x43, 0xe4,
		0xfe, 0x7a, 0x0a, 0xd2, 0x42, 0x5d, 0xad, 0x9f, 0x83, 0xcc, 0xcb, 0xe6, 0xab, 0x66, 0x95, 0xbf,
		0x2b, 0x51, 0x4b, 0xa4, 0x71, 0xdb, 0x36, 0x7b, 0x5f, 0xba, 0x04, 0xa7, 0x88, 0x88, 0xdd, 0x75,
		0x51, 0xa7, 0x5a, 0x6b, 0x9a, 0x8e, 0x43, 0x8c, 0x96, 0x24, 0xa2, 0x3a, 0xee, 0xdb, 0xc2, 0x5d,
		0x25, 0xde, 0xa3, 0x5f, 0x85, 0x69, 0x82, 0x68, 0x75, 0x9b, 0x6e, 0xa3, 0xdd, 0x44, 0x55, 0xfc,
		0xf6, 0xe6, 0x90, 0x99, 0xc4, 0xd3, 0x6c, 0x0a, 0x4b, 0x6c, 0x32, 0x01, 0xac, 0x91, 0xa3, 0xaf,
		0xc2, 0xa3, 0x04, 0x76, 0x88, 0x2c, 0xd4, 0x31, 0x5d, 0x54, 0x45, 0x3f, 0xdf, 0x35, 0x9b, 0x4e,
		0xd5, 0xb4, 0xea, 0xd5, 0x23, 0xd3, 0x39, 0xca, 0x9e, 0xc2, 0x04, 0xc5, 0x58, 0x56, 0x31, 0x1e,
		0xc6, 0x82, 0xb7, 0x99, 0x5c, 0x99, 0x88, 0x15, 0xac, 0xfa, 0xf3, 0xa6, 0x73, 0xa4, 0xe7, 0x61,
		0x86, 0xb0, 0x38, 0x6e, 0xa7, 0x61, 0x1d, 0x56, 0x6b, 0x47, 0xa8, 0xf6, 0x4a, 0xb5, 0xeb, 0x1e,
		0xdc, 0xc8, 0x3e, 0x22, 0xde, 0x9f, 0x68, 0xb8, 0x43, 0x64, 0x4a, 0x58, 0x64, 0xcf, 0x3d, 0xb8,
		0xa1, 0xef, 0x40, 0x06, 0x3b, 0xa3, 0xd5, 0x78, 0x03, 0x55, 0x0f, 0xec, 0x0e, 0x99, 0x1a, 0x27,
		0x42, 0x86, 0x26, 0xc1, 0x82, 0x4b, 0x5b, 0x0c, 0xb0, 0x69, 0xd7, 0x51, 0x3e, 0xb1, 0xb3, 0x5d,
		0x2e, 0xaf, 0x1a, 0x69, 0xce, 0xb2, 0x66, 0x77, 0x70, 0x40, 0x1d, 0xda, 0x9e, 0x81, 0xd3, 0x34,
		0xa0, 0x0e, 0x6d, 0x6e, 0xde, 0xab, 0x30, 0x5d, 0xab, 0xd1, 0x67, 0x6e, 0xd4, 0xaa, 0xec, 0x1d,
		0xcb, 0xc9, 0x6a, 0x01, 0x63, 0xd5, 0x6a, 0xb7, 0xa9, 0x00, 0x8b, 0x71, 0x47, 0xbf, 0x09, 0xa7,
		0x7d, 0x63, 0x89, 0xc0, 0xa9, 0x9e, 0xa7, 0x94, 0xa1, 0x57, 0x61, 0xba, 0x7d, 0xdc, 0x0b, 0xd4,
		0x03, 0x77, 0x6c, 0x1f, 0xcb, 0xb0, 0xeb, 0x70, 0xaa, 0x7d, 0xd4, 0xee, 0xc5, 0x2d, 0x8a, 0x38,
		0xbd, 0x7d, 0xd4, 0x96, 0x81, 0x8f, 0x93, 0x17, 0xee, 0x0e, 0xaa, 0x99, 0x2e, 0xaa, 0x67, 0x1f,
		0x12, 0xc5, 0x85, 0x0e, 0xfd, 0x22, 0x68, 0xb5, 0x5a, 0x15, 0x59, 0xe6, 0x7e, 0x13, 0x55, 0xcd,
		0x0e, 0xb2, 0x4c, 0x27, 0x3b, 0x2f, 0x0a, 0x4f, 0xd4, 0x6a, 0x65, 0xd2, 0x5b, 0x20, 0x9d, 0xfa,
		0x22, 0x4c, 0xd9, 0xfb, 0x2f, 0xd7, 0x68, 0x48, 0x56, 0xdb, 0x1d, 0x74, 0xd0, 0x78, 0x3d, 0x7b,
		0x9e, 0xd8, 0x77, 0x12, 0x77, 0x90, 0x80, 0xdc, 0x26, 0xcd, 0xfa, 0x93, 0xa0, 0xd5, 0x9c, 0x23,
		0xb3, 0xd3, 0x26, 0x63, 0xb2, 0xd3, 0x36, 0x6b, 0x28, 0xfb, 0x38, 0x15, 0xa5, 0xed, 0x15, 0xde,
		0x8c, 0x53, 0xc2, 0x79, 0xad, 0x71, 0xe0, 0x72, 0xc6, 0x27, 0x68, 0x4a, 0x90, 0x36, 0xc6, 0xb6,
		0x00, 0x1a, 0x36, 0x45, 0xe0, 0xc6, 0x0b, 0x44, 0x6c, 0xa2, 0x7d, 0xd4, 0x16, 0xef, 0xfb, 0x18,
		0x8c, 0x63, 0x49, 0xff, 0xa6, 0x4f, 0xd2, 0x82, 0xac, 0x7d, 0x24, 0xdc, 0x71, 0x05, 0x66, 0xb0,
		0x50, 0x0b, 0xb9, 0x66, 0xdd, 0x74, 0x4d, 0x41, 0xfa, 0x29, 0x22, 0x8d, 0xed, 0xbe, 0xc9, 0x3a,
		0x03, 0x7a, 0x76, 0xba, 0xfb, 0xc7, 0x5e, 0x64, 0x3d, 0x4d, 0xf5, 0xc4, 0x6d, 0x3c, 0xb6, 0x3e,
		0xb4, 0xa2, 0x3b, 0x97, 0x87, 0x8c, 0x18, 0xf8, 0x7a, 0x0a, 0x68, 0xe8, 0x6b, 0x0a, 0xae, 0x82,
		0x4a, 0x5b, 0xab, 0xb8, 0x7e, 0xf9, 0x64, 0x59, 0x8b, 0xe1, 0x3a, 0x6a, 0x63, 0x7d, 0xb7, 0x5c,
		0x35, 0xf6, 0x2a, 0xbb, 0xeb, 0x9b, 0x65, 0x4d, 0x15, 0x0b, 0xf6, 0x6f, 0xc6, 0x60, 0x22, 0xf8,
		0xee, 0xa5, 0x7f, 0x14, 0x1e, 0xe2, 0x0b, 0x25, 0x0e, 0x72, 0xab, 0xaf, 0x35, 0x3a, 0x24, 0x17,
		0x5b, 0x26, 0x9d, 0x17, 0xbd, 0x68, 0x38, 0xc5, 0xa4, 0x76, 0x90, 0xfb, 0x42, 0xa3, 0x83, 0x33,
		0xad, 0x65, 0xba, 0xfa, 0x06, 0xcc, 0x5b, 0x76, 0xd5, 0x71, 0x4d, 0xab, 0x6e, 0x76, 0xea, 0x55,
		0x7f, 0x89, 0xaa, 0x6a, 0xd6, 0x6a, 0xc8, 0x71, 0x6c, 0x3a, 0x07, 0x7a, 0x2c, 0x67, 0x2c, 0x7b,
		0x87, 0x09, 0xfb, 0x93, 0x43, 0x81, 0x89, 0x4a, 0x91, 0xab, 0xf6, 0x8b, 0xdc, 0x47, 0x20, 0xd5,
		0x32, 0xdb, 0x55, 0x64, 0xb9, 0x9d, 0x63, 0x52, 0x71, 0x27, 0x8d, 0x64, 0xcb, 0x6c, 0x97, 0xf1,
		0xf5, 0x4f, 0xe6, 0xc5, 0xe7, 0xbf, 0xaa, 0x90, 0x11, 0xab, 0x6e, 0xfc, 0x12, 0x53, 0x23, 0x13,
		0x94, 0x42, 0x86, 0xb0, 0xc7, 0x06, 0xd6, 0xe8, 0x4b, 0x25, 0x3c, 0x73, 0xe5, 0x47, 0x69, 0x2d,
		0x6c, 0x50, 0x24, 0xae, 0x1a, 0x70, 0x68, 0x21, 0x5a, 0x7b, 0x24, 0x0d, 0x76, 0xa5, 0xdf, 0x86,
		0xd1, 0x97, 0x1d, 0xc2, 0x3d, 0x4a, 0xb8, 0xcf, 0x0f, 0xe6, 0xbe, 0xb3, 0x43, 0xc8, 0x53, 0x77,
		0x76, 0xaa, 0x95, 0x2d, 0x63, 0xb3, 0xb0, 0x61, 0x30, 0xb8, 0xfe, 0x30, 0xc4, 0x9b, 0xe6, 0x1b,
		0xc7, 0xc1, 0x39, 0x8e, 0x34, 0x0d, 0x6b, 0xf8, 0x87, 0x21, 0xfe, 0x1a, 0x32, 0x5f, 0x09, 0xce,
		0x2c, 0xa4, 0xe9, 0x43, 0x0c, 0xfd, 0x8b, 0x90, 0x20, 0xf6, 0xd2, 0x01, 0x98, 0xc5, 0xb4, 0x11,
		0x3d, 0x09, 0xf1, 0xd2, 0x96, 0x81, 0xc3, 0x5f, 0x83, 0x0c, 0x6d, 0xad, 0x6e, 0xaf, 0x97, 0x4b,
		0x65, 0x2d, 0x96, 0xbb, 0x0a, 0xa3, 0xd4, 0x08, 0x38, 0x35, 0x3c, 0x33, 0x68, 0x23, 0xec, 0x92,
		0x71, 0x28, 0xbc, 0x77, 0x6f, 0xb3, 0x58, 0x36, 0xb4, 0x98, 0xe8, 0x5e, 0x07, 0x32, 0x62, 0xc1,
		0xfd, 0x93, 0x89, 0xa9, 0x6f, 0x28, 0x90, 0x16, 0x0a, 0x68, 0x5c, 0xf9, 0x98, 0xcd, 0xa6, 0xfd,
		0x5a, 0xd5, 0x6c, 0x36, 0x4c, 0x87, 0x05, 0x05, 0x90, 0xa6, 0x02, 0x6e, 0x19, 0xd6, 0x69, 0x3f,
		0x11, 0xe5, 0xbf, 0xa0, 0x80, 0x26, 0xd7, 0xae, 0x92, 0x82, 0xca, 0x4f, 0x55, 0xc1, 0xcf, 0x29,
		0x30, 0x11, 0x2c, 0x58, 0x25, 0xf5, 0xce, 0xfd, 0x54, 0xd5, 0xfb, 0x4e, 0x0c, 0xc6, 0x03, 0x65,
		0xea, 0xb0, 0xda, 0xfd, 0x3c, 0x4c, 0x35, 0xea, 0xa8, 0xd5, 0xb6, 0x5d, 0x64, 0xd5, 0x8e, 0xab,
		0x4d, 0xf4, 0x2a, 0x6a, 0x66, 0x73, 0x64, 0xa0, 0xb8, 0x38, 0xb8, 0x10, 0x5e, 0x5a, 0xf7, 0x71,
		0x1b, 0x18, 0x96, 0x9f, 0x5e, 0x5f, 0x2d, 0x6f, 0x6e, 0x6f, 0xed, 0x96, 0x2b, 0xa5, 0xbb, 0xd5,
		0xbd, 0xca, 0xc7, 0x2a, 0x5b, 0x2f, 0x54, 0x0c, 0xad, 0x21, 0x89, 0x7d, 0x88, 0xa9, 0xbe, 0x0d,
		0x9a, 0xac, 0x94, 0xfe, 0x10, 0x84, 0xa9, 0xa5, 0x8d, 0xe8, 0xd3, 0x30, 0x59, 0xd9, 0xaa, 0xee,
		0xac, 0xaf, 0x96, 0xab, 0xe5, 0xb5, 0xb5, 0x72, 0x69, 0x77, 0x87, 0x2e, 0x6d, 0x78, 0xd2, 0xbb,
		0xc1, 0xa4, 0xfe, 0xac, 0x0a, 0xd3, 0x21, 0x9a, 0xe8, 0x05, 0xf6, 0x52, 0x42, 0xdf, 0x93, 0x9e,
		0x1e, 0x46, 0xfb, 0x25, 0x5c, 0x15, 0x6c, 0x9b, 0x1d, 0x97, 0xbd, 0xc3, 0x3c, 0x09, 0xd8, 0x4a,
		0x96, 0xdb, 0x38, 0x68, 0xa0, 0x0e, 0x5b, 0x09, 0xa2, 0x6f, 0x2a, 0x93, 0x7e, 0x3b, 0x5d, 0x0c,
		0x7a, 0x0a, 0xf4, 0xb6, 0xed, 0x34, 0xdc, 0xc6, 0xab, 0xa8, 0xda, 0xb0, 0xf8, 0xb2, 0x11, 0x7e,
		0x73, 0x89, 0x1b, 0x1a, 0xef, 0x59, 0xb7, 0x5c, 0x4f, 0xda, 0x42, 0x87, 0xa6, 0x24, 0x8d, 0x07,
		0x70, 0xd5, 0xd0, 0x78, 0x8f, 0x27, 0x7d, 0x0e, 0x32, 0x75, 0xbb, 0x8b, 0xcb, 0x39, 0x2a, 0x87,
		0xe7, 0x0b, 0xc5, 0x48, 0xd3, 0x36, 0x4f, 0x84, 0x15, 0xea, 0xfe, 0x7a, 0x55, 0xc6, 0x48, 0xd3,
		0x36, 0x2a, 0xf2, 0x04, 0x4c, 0x9a, 0x87, 0x87, 0x1d, 0x4c, 0xce, 0x89, 0xe8, 0xab, 0xc7, 0x84,
		0xd7, 0x4c, 0x04, 0x67, 0xef, 0x40, 0x92, 0xdb, 0x01, 0x4f, 0xc9, 0xd8, 0x12, 0xd5, 0x36, 0x7d,
		0x9f, 0x8e, 0x2d, 0xa4, 0x8c, 0xa4, 0xc5, 0x3b, 0xcf, 0x41, 0xa6, 0xe1, 0x54, 0xfd, 0xe5, 0xf7,
		0xd8, 0xd9, 0xd8, 0x42, 0xd2, 0x48, 0x37, 0x1c, 0x6f, 0xe9, 0x32, 0xf7, 0xe5, 0x18, 0x4c, 0x04,
		0xb7, 0x0f, 0xf4, 0x55, 0x48, 0x36, 0xed, 0x9a, 0x49, 0x42, 0x8b, 0xee, 0x5d, 0x2d, 0x44, 0xec,
		0x38, 0x2c, 0x6d, 0x30, 0x79, 0xc3, 0x43, 0xce, 0xfe, 0x47, 0x05, 0x92, 0xbc, 0x59, 0x9f, 0x81,
		0x78, 0xdb, 0x74, 0x8f, 0x08, 0x5d, 0xa2, 0x18, 0xd3, 0x14, 0x83, 0x5c, 0xe3, 0x76, 0xa7, 0x6d,
		0x5a, 0x24, 0x04, 0x58, 0x3b, 0xbe, 0xc6, 0x7e, 0x6d, 0x22, 0xb3, 0x4e, 0xde, 0x6b, 0xec, 0x56,
		0x0b, 0x59, 0xae, 0xc3, 0xfd, 0xca, 0xda, 0x4b, 0xac, 0x59, 0xff, 0x08, 0x4c, 0xb9, 0x1d, 0xb3,
		0xd1, 0x0c, 0xc8, 0xc6, 0x89, 0xac, 0xc6, 0x3b, 0x3c, 0xe1, 0x3c, 0x3c, 0xcc, 0x79, 0xeb, 0xc8,
		0x35, 0x6b, 0x47, 0xa8, 0xee, 0x83, 0x46, 0xc9, 0xfa, 0xc5, 0x43, 0x4c, 0x60, 0x95, 0xf5, 0x73,
		0x6c, 0xee, 0x0f, 0x14, 0x98, 0xe2, 0x6f, 0x62, 0x75, 0xcf, 0x58, 0x9b, 0x00, 0xa6, 0x65, 0xd9,
		0xae, 0x68, 0xae, 0xde, 0x50, 0xee, 0xc1, 0x2d, 0x15, 0x3c, 0x90, 0x21, 0x10, 0xcc, 0xb6, 0x00,
		0xfc, 0x9e, 0xbe, 0x66, 0x9b, 0x87, 0x34, 0xdb, 0x1b, 0x22, 0x1b, 0x8c, 0xf4, 0xdd, 0x1d, 0x68,
		0x13, 0x7e, 0x65, 0xd3, 0x4f, 0x41, 0x62, 0x1f, 0x1d, 0x36, 0x2c, 0xb6, 0xe2, 0x4b, 0x2f, 0xf8,
		0x0a, 0x4b, 0xdc, 0x5b, 0x61, 0x29, 0xbe, 0x04, 0xd3, 0x35, 0xbb, 0x25, 0xab, 0x5b, 0xd4, 0xa4,
		0xf5, 0x03, 0xe7, 0x79, 0xe5, 0x93, 0xe0, 0x97, 0x98, 0x3f, 0x52, 0x94, 0x5f, 0x8d, 0xa9, 0xb7,
		0xb7, 0x8b, 0xbf, 0x15, 0x9b, 0xbd, 0x4d, 0xa1, 0xdb, 0xfc, 0x49, 0x0d, 0x74, 0xd0, 0x44, 0x35,
		0xac, 0x3d, 0xfc, 0xc6, 0x47, 0xe0, 0xe9, 0xc3, 0x86, 0x7b, 0xd4, 0xdd, 0x5f, 0xaa, 0xd9, 0xad,
		0x8b, 0x87, 0xf6, 0xa1, 0xed, 0xef, 0xa9, 0xe2, 0x2b, 0x72, 0x41, 0x3e, 0xb1, 0x7d, 0xd5, 0x94,
		0xd7, 0x3a, 0x1b, 0xb9, 0x09, 0x9b, 0xaf, 0xc0, 0x34, 0x13, 0xae, 0x92, 0x8d, 0x1d, 0xfa, 0x7a,
		0xa2, 0x0f, 0x5c, 0x1c, 0xcb, 0xfe, 0xf6, 0xf7, 0xc8, 0x74, 0x6d, 0x4c, 0x31, 0x28, 0xee, 0xa3,
		0x6f, 0x30, 0x79, 0x03, 0x4e, 0x07, 0xf8, 0x68, 0x6a, 0xa2, 0x4e, 0x04, 0xe3, 0x37, 0x19, 0xe3,
		0xb4, 0xc0, 0xb8, 0xc3, 0xa0, 0xf9, 0x12, 0x8c, 0x9f, 0x84, 0xeb, 0xdf, 0x31, 0xae, 0x0c, 0x12,
		0x49, 0x6e, 0xc3, 0x24, 0x21, 0xa9, 0x75, 0x1d, 0xd7, 0x6e, 0x91, 0x71, 0x6f, 0x30, 0xcd, 0xbf,
		0xff, 0x1e, 0xcd, 0x95, 0x09, 0x0c, 0x2b, 0x79, 0xa8, 0x7c, 0x1e, 0xc8, 0x5e, 0x56, 0x1d, 0xd5,
		0x9a, 0x11, 0x0c, 0xf7, 0x98, 0x22, 0x9e, 0x7c, 0xfe, 0x13, 0x70, 0x0a, 0x7f, 0x26, 0xc3, 0x92,
		0xa8, 0x49, 0xf4, 0x4a, 0x5a, 0xf6, 0x0f, 0x3e, 0x45, 0xd3, 0x71, 0xda, 0x23, 0x10, 0x74, 0x12,
		0xbc, 0x78, 0x88, 0x5c, 0x17, 0x75, 0x9c, 0xaa, 0xd9, 0x0c, 0x53, 0x4f, 0x58, 0x8a, 0xc8, 0xfe,
		0xca, 0x0f, 0x82, 0x5e, 0xbc, 0x4d, 0x91, 0x85, 0x66, 0x33, 0xbf, 0x07, 0x0f, 0x85, 0x44, 0xc5,
		0x10, 0x9c, 0x9f, 0x65, 0x9c, 0xa7, 0x7a, 0x22, 0x03, 0xd3, 0x6e, 0x03, 0x6f, 0xf7, 0x7c, 0x39,
		0x04, 0xe7, 0x3f, 0x64, 0x9c, 0x3a, 0xc3, 0x72, 0x97, 0x62, 0xc6, 0x3b, 0x30, 0xf5, 0x2a, 0xea,
		0xec, 0xdb, 0x0e, 0x5b, 0xfe, 0x19, 0x82, 0xee, 0x73, 0x8c, 0x6e, 0x92, 0x01, 0xc9, 0x7a, 0x10,
		0xe6, 0xba, 0x09, 0xc9, 0x03, 0xb3, 0x86, 0x86, 0xa0, 0xf8, 0x3c, 0xa3, 0x18, 0xc3, 0xf2, 0x18,
		0x5a, 0x80, 0xcc, 0xa1, 0xcd, 0x66, 0xa6, 0x68, 0xf8, 0x17, 0x18, 0x3c, 0xcd, 0x31, 0x8c, 0xa2,
		0x6d, 0xb7, 0xbb, 0x4d, 0x3c, 0x6d, 0x45, 0x53, 0x7c, 0x91, 0x53, 0x70, 0x0c, 0xa3, 0x38, 0x81,
		0x59, 0xdf, 0xe2, 0x14, 0x8e, 0x60, 0xcf, 0xe7, 0x20, 0x6d, 0x5b, 0xcd, 0x63, 0xdb, 0x1a, 0x46,
		0x89, 0x2f, 0x31, 0x06, 0x60, 0x10, 0x4c, 0x70, 0x0b, 0x52, 0xc3, 0x3a, 0xe2, 0xd7, 0x7f, 0xc0,
		0xd3, 0x83, 0x7b, 0xe0, 0x36, 0x4c, 0xf2, 0x01, 0xaa, 0x61, 0x5b, 0x43, 0x50, 0xfc, 0x06, 0xa3,
		0x98, 0x10, 0x60, 0xec, 0x31, 0x5c, 0xe4, 0xb8, 0x87, 0x68, 0x18, 0x92, 0x2f, 0xf3, 0xc7, 0x60,
		0x10, 0x66, 0xca, 0x7d, 0x64, 0xd5, 0x8e, 0x86, 0x63, 0xf8, 0x0a, 0x37, 0x25, 0xc7, 0x60, 0x8a,
		0x12, 0x8c, 0xb7, 0xcc, 0x8e, 0x73, 0x64, 0x36, 0x87, 0x72, 0xc7, 0x6f, 0x32, 0x8e, 0x8c, 0x07,
		0x62, 0x16, 0xe9, 0x5a, 0x27, 0xa1, 0xf9, 0x2d, 0x6e, 0x11, 0x01, 0xc6, 0x52, 0xcf, 0x71, 0xc9,
		0x5a, 0xd9, 0x49, 0xd8, 0xfe, 0x11, 0x4f, 0x3d, 0x8a, 0xdd, 0x14, 0x19, 0x6f, 0x41, 0xca, 0x69,
		0xbc, 0x31, 0x14, 0xcd, 0x3f, 0xe6, 0x9e, 0x26, 0x00, 0x0c, 0xbe, 0x0b, 0x0f, 0x87, 0x4e, 0x13,
		0x43, 0x90, 0xfd, 0x13, 0x46, 0x36, 0x13, 0x32, 0x55, 0xb0, 0x21, 0xe1, 0xa4, 0x94, 0xff, 0x94,
		0x0f, 0x09, 0x48, 0xe2, 0xda, 0xc6, 0xef, 0x0a, 0x8e, 0x79, 0x70, 0x32, 0xab, 0xfd, 0x33, 0x6e,
		0x35, 0x8a, 0x0d, 0x58, 0x6d, 0x17, 0x66, 0x18, 0xe3, 0xc9, 0xfc, 0xfa, 0x55, 0x3e, 0xb0, 0x52,
		0xf4, 0x5e, 0xd0, 0xbb, 0x2f, 0xc1, 0xac, 0x67, 0x4e, 0x5e, 0x94, 0x3a, 0xd5, 0x96, 0xd9, 0x1e,
		0x82, 0xf9, 0xb7, 0x19, 0x33, 0x1f, 0xf1, 0xbd, 0xaa, 0xd6, 0xd9, 0x34, 0xdb, 0x98, 0xfc, 0x45,
		0xc8, 0x72, 0xf2, 0xae, 0xd5, 0x41, 0x35, 0xfb, 0xd0, 0x6a, 0xbc, 0x81, 0xea, 0x43, 0x50, 0x7f,
		0x4d, 0x72, 0xd5, 0x9e, 0x00, 0xc7, 0xcc, 0xeb, 0xa0, 0x79, 0xb5, 0x4a, 0xb5, 0xd1, 0x6a, 0xdb,
		0x1d, 0x37, 0x82, 0xf1, 0x9f, 0x73, 0x4f, 0x79, 0xb8, 0x75, 0x02, 0xcb, 0x97, 0x61, 0x82, 0x5c,
		0x0e, 0x1b, 0x92, 0xbf, 0xc3, 0x88, 0xc6, 0x7d, 0x14, 0x1b, 0x38, 0x6a, 0x76, 0xab, 0x6d, 0x76,
		0x86, 0x19, 0xff, 0xfe, 0x05, 0x1f, 0x38, 0x18, 0x84, 0x0d, 0x1c, 0xee, 0x71, 0x1b, 0xe1, 0xd9,
		0x7e, 0x08, 0x86, 0xaf, 0xf3, 0x81, 0x83, 0x63, 0x18, 0x05, 0x2f, 0x18, 0x86, 0xa0, 0xf8, 0x97,
		0x9c, 0x82, 0x63, 0x30, 0xc5, 0xc7, 0xfd, 0x89, 0xb6, 0x83, 0x0e, 0x1b, 0x8e, 0xdb, 0xa1, 0xa5,
		0xf0, 0x60, 0xaa, 0xdf, 0xfd, 0x41, 0xb0, 0x08, 0x33, 0x04, 0x28, 0x1e, 0x89, 0xd8, 0x12, 0x2a,
		0x79, 0x53, 0x8a, 0x56, 0xec, 0xf7, 0xf8, 0x48, 0x24, 0xc0, 0xb0, 0x6e, 0x42, 0x85, 0x88, 0xcd,
		0x5e, 0xc3, 0xef, 0x07, 0x43, 0xd0, 0x7d, 0x43, 0x52, 0x6e, 0x87, 0x63, 0x31, 0xa7, 0x50, 0xff,
		0x74, 0xad, 0x57, 0xd0, 0xf1, 0x50, 0xd1, 0xf9, 0xaf, 0xa4, 0xfa, 0x67, 0x8f, 0x22, 0xe9, 0x18,
		0x32, 0x29, 0xd5, 0x53, 0x7a, 0xd4, 0x29, 0xa0, 0xec, 0x5f, 0x7c, 0x8f, 0x3d, 0x6f, 0xb0, 0x9c,
		0xca, 0x6f, 0xe0, 0x20, 0x0f, 0x16, 0x3d, 0xd1, 0x64, 0x9f, 0x7a, 0xcf, 0x8b, 0xf3, 0x40, 0xcd,
		0x93, 0x5f, 0x83, 0xf1, 0x40, 0xc1, 0x13, 0x4d, 0xf5, 0x97, 0x18, 0x55, 0x46, 0xac, 0x77, 0xf2,
		0x57, 0x21, 0x8e, 0x8b, 0x97, 0x68, 0xf8, 0x5f, 0x66, 0x70, 0x22, 0x9e, 0x7f, 0x06, 0x92, 0xbc,
		0x68, 0x89, 0x86, 0xfe, 0x22, 0x83, 0x7a, 0x10, 0x0c, 0xe7, 0x05, 0x4b, 0x34, 0xfc, 0xaf, 0x70,
		0x38, 0x87, 0x60, 0xf8, 0xf0, 0x26, 0x7c, 0xfb, 0xaf, 0xc5, 0xd9, 0xa4, 0xc3, 0x6d, 0x77, 0x0b,
		0xc6, 0x58, 0xa5, 0x12, 0x8d, 0xfe, 0x25, 0x76, 0x73, 0x8e, 0xc8, 0x5f, 0x87, 0xc4, 0x90, 0x06,
		0xff, 0x1b, 0x0c, 0x4a, 0xe5, 0xf3, 0x25, 0x48, 0x0b, 0xd5, 0x49, 0x34, 0xfc, 0x6f, 0x32, 0xb8,
		0x88, 0xc2, 0xaa, 0xb3, 0xea, 0x24, 0x9a, 0xe0, 0x6f, 0x71, 0xd5, 0x19, 0x02, 0x9b, 0x8d, 0x17,
		0x26, 0xd1, 0xe8, 0xbf, 0xcd, 0xad, 0xce, 0x21, 0xf9, 0xe7, 0x20, 0xe5, 0x4d, 0x36, 0xd1, 0xf8,
		0xbf, 0xc3, 0xf0, 0x3e, 0x06, 0x5b, 0x40, 0x98, 0xec, 0xa2, 0x29, 0xfe, 0x2e, 0xb7, 0x80, 0x80,
		0xc2, 0x69, 0x24, 0x17, 0x30, 0xd1, 0x4c, 0xbf, 0xcc, 0xd3, 0x48, 0xaa, 0x5f, 0xb0, 0x37, 0xc9,
		0x98, 0x1f, 0x4d, 0xf1, 0xf7, 0xb8, 0x37, 0x89, 0x3c, 0x56, 0x43, 0xae, 0x08, 0xa2, 0x39, 0xfe,
		0x01, 0x57, 0x43, 0x2a, 0x08, 0xf2, 0xdb, 0xa0, 0xf7, 0x56, 0x03, 0xd1, 0x7c, 0x9f, 0x61, 0x7c,
		0x53, 0x3d, 0xc5, 0x40, 0xfe, 0x05, 0x98, 0x09, 0xaf, 0x04, 0xa2, 0x59, 0x7f, 0xe5, 0x3d, 0xe9,
		0xdd, 0x4d, 0x2c, 0x04, 0xf2, 0xbb, 0xfe, 0x94, 0x22, 0x56, 0x01, 0xd1, 0xb4, 0x9f, 0x7d, 0x2f,
		0x38, 0x70, 0x8b, 0x45, 0x40, 0xbe, 0x00, 0xe0, 0x4f, 0xc0, 0xd1, 0x5c, 0x9f, 0x63, 0x5c, 0x02,
		0x08, 0xa7, 0x06, 0x9b, 0x7f, 0xa3, 0xf1, 0x9f, 0xe7, 0xa9, 0xc1, 0x10, 0x38, 0x35, 0xf8, 0xd4,
		0x1b, 0x8d, 0xfe, 0x02, 0x4f, 0x0d, 0x0e, 0xc1, 0x91, 0x2d, 0xcc, 0x6e, 0xd1, 0x0c, 0x5f, 0xe2,
		0x91, 0x2d, 0xa0, 0xf2, 0x15, 0x98, 0xea, 0x99, 0x10, 0xa3, 0xa9, 0x7e, 0x95, 0x51, 0x69, 0xf2,
		0x7c, 0x28, 0x4e, 0x5e, 0x6c, 0x32, 0x8c, 0x66, 0xfb, 0x35, 0x69, 0xf2, 0x62, 0x73, 0x61, 0xfe,
		0x16, 0x24, 0xad, 0x6e, 0xb3, 0x89, 0x93, 0x47, 0x1f, 0x7c, 0x72, 0x2f, 0xfb, 0xdf, 0x7f, 0xcc,
		0xac, 0xc3, 0x01, 0xf9, 0xab, 0x90, 0x40, 0xad, 0x7d, 0x54, 0x8f, 0x42, 0xfe, 0x8f, 0x1f, 0xf3,
		0x01, 0x13, 0x4b, 0xe7, 0x9f, 0x03, 0xa0, 0x4b, 0x23, 0x64, 0xdb, 0x2f, 0x02, 0xfb, 0x3f, 0x7f,
		0xcc, 0xce, 0xd4, 0xf8, 0x10, 0x9f, 0x80, 0x9e, 0xd0, 0x19, 0x4c, 0xf0, 0x83, 0x20, 0x01, 0xf1,
		0xc8, 0x4d, 0x18, 0x7b, 0xd9, 0xb1, 0x2d, 0xd7, 0x3c, 0x8c, 0x42, 0xff, 0x2f, 0x86, 0xe6, 0xf2,
		0xd8, 0x60, 0x2d, 0xbb, 0x83, 0x5c, 0xf3, 0xd0, 0x89, 0xc2, 0xfe, 0x6f, 0x86, 0xf5, 0x00, 0x18,
		0x5c, 0x33, 0x1d, 0x77, 0x98, 0xe7, 0xfe, 0x3f, 0x1c, 0xcc, 0x01, 0x58, 0x69, 0xfc, 0xf9, 0x15,
		0x74, 0x1c, 0x85, 0xfd, 0x21, 0x57, 0x9a, 0xc9, 0xe7, 0x9f, 0x81, 0x14, 0xfe, 0x48, 0x0f, 0xca,
		0x45, 0x80, 0xff, 0x2f, 0x03, 0xfb, 0x08, 0x7c, 0x67, 0xc7, 0xad, 0xbb, 0x8d, 0x68, 0x63, 0xff,
		0x11, 0xf3, 0x34, 0x97, 0xcf, 0x17, 0x20, 0xed, 0xb8, 0xf5, 0x7a, 0x97, 0xd5, 0xa7, 0x11, 0xf0,
		0xff, 0xf7, 0x63, 0x6f, 0xc9, 0xc2, 0xc3, 0x60, 0x6f, 0xbf, 0xf6, 0x8a, 0xdb, 0xb6, 0xc9, 0x36,
		0x47, 0x14, 0xc3, 0x7b, 0x8c, 0x41, 0x80, 0x14, 0xcb, 0xe1, 0xcb, 0xb7, 0x70, 0xdb, 0xbe, 0x6d,
		0xd3, 0x85, 0xdb, 0x4f, 0xe6, 0xa2, 0x57, 0x60, 0xe1, 0xbf, 0x35, 0xe1, 0x7a, 0x5f, 0x31, 0x3c,
		0x15, 0x5f, 0xac, 0xd9, 0xad, 0x7d, 0xdb, 0xb9, 0xb8, 0x6f, 0xbb, 0x47, 0x17, 0xdd, 0x23, 0x84,
		0xdb, 0xd8, 0x92, 0x6d, 0x1c, 0x7f, 0x9e, 0x3d, 0xd9, 0x3a, 0x2f, 0xd9, 0xc5, 0xaf, 0x34, 0xf0,
		0xa3, 0x55, 0xc8, 0x46, 0x8a, 0x7e, 0x06, 0x46, 0xc9, 0xc3, 0x5e, 0x26, 0x9b, 0x95, 0x4a, 0x31,
		0x7e, 0xef, 0x9d, 0xf9, 0x11, 0x83, 0xb5, 0x79, 0xbd, 0xcb, 0x64, 0xa5, 0x3b, 0x16, 0xe8, 0x5d,
		0xf6, 0x7a, 0xaf, 0xd0, 0xc5, 0xee, 0x40, 0xef, 0x15, 0xaf, 0x77, 0x85, 0x2c, 0x7b, 0xab, 0x81,
		0xde, 0x15, 0xaf, 0xf7, 0x2a, 0xd9, 0xda, 0x19, 0x0f, 0xf4, 0x5e, 0xf5, 0x7a, 0xaf, 0x91, 0x0d,
		0x9d, 0x78, 0xa0, 0xf7, 0x9a, 0xd7, 0x7b, 0x9d, 0xec, 0xe5, 0x4c, 0x05, 0x7a, 0xaf, 0x7b, 0xbd,
		0x37, 0xc8, 0x1e, 0x8e, 0x1e, 0xe8, 0xbd, 0xe1, 0xf5, 0xde, 0x24, 0x27, 0xaf, 0xc6, 0x02, 0xbd,
		0x37, 0xf5, 0x39, 0x18, 0xa3, 0x4f, 0x7e, 0x89, 0x6c, 0xf8, 0x4f, 0xb2, 0x6e, 0xde, 0xe8, 0xf7,
		0x5f, 0x26, 0xa7, 0xac, 0x46, 0x83, 0xfd, 0x97, 0xfd, 0xfe, 0x65, 0xf2, 0x85, 0x0f, 0x2d, 0xd8,
		0xbf, 0xec, 0xf7, 0x5f, 0xc9, 0x8e, 0x93, 0x93, 0x66, 0x81, 0xfe, 0x2b, 0x7e, 0xff, 0x4a, 0x76,
		0x02, 0x67, 0x4c, 0xb0, 0x7f, 0xc5, 0xef, 0xbf, 0x9a, 0x9d, 0x3c, 0xab, 0x2c, 0x64, 0x82, 0xfd,
		0x57, 0x73, 0xbf, 0x40, 0xdc, 0x6b, 0xf9, 0xee, 0x9d, 0x09, 0xba, 0xd7, 0x73, 0xec, 0x4c, 0xd0,
		0xb1, 0x9e, 0x4b, 0x67, 0x82, 0x2e, 0xf5, 0x9c, 0x39, 0x13, 0x74, 0xa6, 0xe7, 0xc6, 0x99, 0xa0,
		0x1b, 0x3d, 0x07, 0xce, 0x04, 0x1d, 0xe8, 0xb9, 0x6e, 0x26, 0xe8, 0x3a, 0xcf, 0x69, 0x33, 0x41,
		0xa7, 0x79, 0xee, 0x9a, 0x09, 0xba, 0xcb, 0x73, 0x54, 0x56, 0x72, 0x94, 0xef, 0xa2, 0xac, 0xe4,
		0x22, 0xdf, 0x39, 0x59, 0xc9, 0x39, 0xbe, 0x5b, 0xb2, 0x92, 0x5b, 0x7c, 0x87, 0x64, 0x25, 0x87,
		0xf8, 0xae, 0xc8, 0x4a, 0xae, 0xf0, 0x9d, 0xc0, 0x72, 0xcc, 0x40, 0xed, 0x90, 0x1c, 0x53, 0x07,
		0xe6, 0x98, 0x3a, 0x30, 0xc7, 0xd4, 0x81, 0x39, 0xa6, 0x0e, 0xcc, 0x31, 0x75, 0x60, 0x8e, 0xa9,
		0x03, 0x73, 0x4c, 0x1d, 0x98, 0x63, 0xea, 0xc0, 0x1c, 0x53, 0x07, 0xe7, 0x98, 0x1a, 0x91, 0x63,
		0x6a, 0x44, 0x8e, 0xa9, 0x11, 0x39, 0xa6, 0x46, 0xe4, 0x98, 0x1a, 0x91, 0x63, 0x6a, 0xdf, 0x1c,
		0xf3, 0xdd, 0x3b, 0x13, 0x74, 0x6f, 0x68, 0x8e, 0xa9, 0x7d, 0x72, 0x4c, 0xed, 0x93, 0x63, 0x6a,
		0x9f, 0x1c, 0x53, 0xfb, 0xe4, 0x98, 0xda, 0x27, 0xc7, 0xd4, 0x3e, 0x39, 0xa6, 0xf6, 0xc9, 0x31,
		0xb5, 0x5f, 0x8e, 0xa9, 0x7d, 0x73, 0x4c, 0xed, 0x9b, 0x63, 0x6a, 0xdf, 0x1c, 0x53, 0xfb, 0xe6,
		0x98, 0xda, 0x37, 0xc7, 0x54, 0x31, 0xc7, 0xfe, 0xb5, 0x0a, 0x3a, 0xcd, 0xb1, 0x6d, 0x72, 0x64,
		0x8c, 0xb9, 0x62, 0x4e, 0xca, 0xb4, 0x51, 0xec, 0x3a, 0xcd, 0x77, 0xc9, 0x9c, 0x94, 0x6b, 0xc1,
		0xfe, 0x65, 0xaf, 0x9f, 0x67, 0x5b, 0xb0, 0xff, 0x8a, 0xd7, 0xcf, 0xf3, 0x2d, 0xd8, 0xbf, 0xe2,
		0xf5, 0xf3, 0x8c, 0x0b, 0xf6, 0x5f, 0xf5, 0xfa, 0x79, 0xce, 0x05, 0xfb, 0xaf, 0x79, 0xfd, 0x3c,
		0xeb, 0x82, 0xfd, 0xd7, 0xbd, 0x7e, 0x9e, 0x77, 0xc1, 0xfe, 0x1b, 0x5e, 0x3f, 0xcf, 0xbc, 0x60,
		0xff, 0x4d, 0xfd, 0xac, 0x9c, 0x7b, 0x5c, 0xc0, 0x73, 0xed, 0x59, 0x39, 0xfb, 0x24, 0x89, 0xcb,
		0xbe, 0x04, 0xcf, 0x3f, 0x49, 0x62, 0xd9, 0x97, 0xe0, 0x19, 0x28, 0x49, 0x5c, 0xc9, 0x7d, 0x9a,
		0xb8, 0xcf, 0x92, 0xdd, 0x37, 0x2b, 0xb9, 0x2f, 0x26, 0xb8, 0x6e, 0x56, 0x72, 0x5d, 0x4c, 0x70,
		0xdb, 0xac, 0xe4, 0xb6, 0x98, 0xe0, 0xb2, 0x59, 0xc9, 0x65, 0x31, 0xc1, 0x5d, 0xb3, 0x92, 0xbb,
		0x62, 0x82, 0xab, 0x66, 0x25, 0x57, 0xc5, 0x04, 0x37, 0xcd, 0x4a, 0x6e, 0x8a, 0x09, 0x2e, 0x9a,
		0x95, 0x5c, 0x14, 0x13, 0xdc, 0x33, 0x2b, 0xb9, 0x27, 0x26, 0xb8, 0xe6, 0x8c, 0xec, 0x9a, 0x98,
		0xe8, 0x96, 0x33, 0xb2, 0x5b, 0x62, 0xa2, 0x4b, 0xce, 0xc8, 0x2e, 0x89, 0x89, 0xee, 0x38, 0x23,
		0xbb, 0x23, 0x26, 0xba, 0xe2, 0x8f, 0x63, 0xbc, 0x22, 0xdc, 0x71, 0x3b, 0xdd, 0x9a, 0xfb, 0xbe,
		0x2a, 0xc2, 0x4b, 0x81, 0xf2, 0x21, 0xbd, 0xac, 0x2f, 0x91, 0x82, 0x55, 0xac, 0x38, 0xa5, 0x19,
		0xec, 0x52, 0xa0, 0xb0, 0x10, 0x10, 0x56, 0x38, 0x62, 0xe5, 0x7d, 0xd5, 0x86, 0x97, 0x02, 0x65,
		0x46, 0xb4, 0x7e, 0x37, 0x3e, 0xf4, 0x8a, 0xed, 0xed, 0x18, 0xaf, 0xd8, 0x98, 0xf9, 0x4f, 0x5a,
		0xb1, 0x2d, 0x46, 0x9b, 0xdc, 0x33, 0xf6, 0x62, 0xb4, 0xb1, 0x7b, 0x66, 0x9d, 0x61, 0x2b, 0xb8,
		0xc5, 0x68, 0xd3, 0x7a, 0x46, 0xfd, 0x60, 0xeb, 0x2d, 0x16, 0xc1, 0x06, 0x6a, 0x87, 0x44, 0xf0,
		0x49, 0xeb, 0xad, 0x4b, 0x81, 0xa1, 0xe4, 0xa4, 0x11, 0xac, 0x9e, 0x38, 0x82, 0x4f, 0x5a, 0x79,
		0x5d, 0x0a, 0x0c, 0x2f, 0x27, 0x8e, 0xe0, 0x0f, 0xa1, 0x1e, 0x62, 0x11, 0xec, 0x9b, 0xff, 0xa4,
		0xf5, 0xd0, 0x62, 0xb4, 0xc9, 0x43, 0x23, 0x58, 0x3d, 0x41, 0x04, 0x0f, 0x53, 0x1f, 0x2d, 0x46,
		0x9b, 0x36, 0x3c, 0x82, 0xdf, 0x77, 0x35, 0xf3, 0x45, 0x05, 0xa6, 0x2a, 0x8d, 0x7a, 0xb9, 0xb5,
		0x8f, 0xea, 0x75, 0x54, 0x67, 0x76, 0xbc, 0x14, 0x18, 0x09, 0xfa, 0xb8, 0xfa, 0x5b, 0xef, 0xcc,
		0xfb, 0x16, 0xbe, 0x0a, 0x49, 0x6a, 0xd3, 0x4b, 0x97, 0xb2, 0xf7, 0x94, 0x88, 0x11, 0xce, 0x13,
		0xd5, 0xcf, 0x71, 0xd8, 0xe5, 0x4b, 0xd9, 0xff, 0xa4, 0x08, 0xa3, 0x9c, 0xd7, 0x9c, 0xfb, 0x65,
		0xa2, 0xa1, 0xf5, 0xbe, 0x35, 0xbc, 0x38, 0x94, 0x86, 0x82, 0x6e, 0x8f, 0xf4, 0xe8, 0x26, 0x68,
		0xd5, 0x85, 0xc9, 0x4a, 0xa3, 0x5e, 0x21, 0x3f, 0x35, 0x30, 0x8c, 0x4a, 0x54, 0x46, 0x1a, 0x0f,
		0x2e, 0x05, 0xc2, 0x52, 0x44, 0x78, 0x21, 0x1d, 0x1c, 0x23, 0x72, 0x0d, 0x7c, 0x5b, 0x2b, 0x70,
		0xdb, 0xc5, 0x7e, 0xb7, 0xf5, 0x47, 0x76, 0xef, 0x86, 0x8b, 0xfd, 0x6e, 0xe8, 0xe7, 0x90, 0x77,
		0xab, 0xd7, 0xf9, 0xe4, 0x4c, 0x0f, 0x6e, 0xe9, 0x67, 0x20, 0xb6, 0x4e, 0xcf, 0x95, 0x67, 0x8a,
		0x19, 0xac, 0xd4, 0xb7, 0xdf, 0x99, 0x8f, 0xef, 0x75, 0x1b, 0x75, 0x23, 0xb6, 0x5e, 0xd7, 0xef,
		0x40, 0xe2, 0x13, 0xec, 0x0b, 0xaf, 0x58, 0x60, 0x85, 0x09, 0x3c, 0x15, 0xb1, 0xc4, 0x44, 0xa8,
		0x97, 0xf6, 0x1a, 0x96, 0x7b, 0x79, 0xf9, 0x86, 0x41, 0x29, 0x72, 0x7f, 0x06, 0x80, 0xde, 0x73,
		0xd5, 0x74, 0x8e, 0xf4, 0x0a, 0x67, 0xa6, 0xb7, 0xbe, 0xf1, 0xed, 0x77, 0xe6, 0x57, 0x86, 0x61,
		0x7d, 0xba, 0x6e, 0x3a, 0x47, 0x4f, 0xbb, 0xc7, 0x6d, 0xb4, 0x54, 0x3c, 0x76, 0x91, 0xc3, 0xd9,
		0xdb, 0x7c, 0xd6, 0x63, 0xcf, 0x95, 0x15, 0x9e, 0x2b, 0x19, 0x78, 0xa6, 0xb5, 0xe0, 0x33, 0x5d,
		0x7a, 0xd0, 0xe7, 0x79, 0x9d, 0x4f, 0x12, 0x92, 0x25, 0xd5, 0x28, 0x4b, 0xaa, 0xef, 0xd7, 0x92,
		0x6d, 0x3e, 0x3e, 0x4a, 0xcf, 0xaa, 0x0e, 0x7a, 0x56, 0xf5, 0xfd, 0x3c, 0xeb, 0xff, 0xa7, 0xd9,
		0xea, 0xe5, 0xd3, 0x9e, 0x45, 0xcf, 0xb4, 0xfe, 0xe9, 0x5a, 0x0b, 0xfa, 0x40, 0xab, 0x80, 0x7c,
		0xfc, 0xde, 0x5b, 0xf3, 0x4a, 0xee, 0x8b, 0x31, 0xfe, 0xe4, 0x34, 0x91, 0x1e, 0xec, 0xc9, 0xff,
		0xb4, 0xd4, 0x54, 0x1f, 0x86, 0x85, 0xbe, 0xa0, 0xc0, 0x4c, 0xcf, 0x48, 0x4e, 0xcd, 0xf4, 0xc1,
		0x0e, 0xe7, 0xd6, 0x49, 0x87, 0x73, 0xa6, 0xe0, 0xef, 0x28, 0x70, 0x4a, 0x1a, 0x5e, 0xa9, 0x7a,
		0x17, 0x25, 0xf5, 0x1e, 0xea, 0xbd, 0x13, 0x11, 0x14, 0xb4, 0x13, 0xdd, 0x2b, 0x01, 0x04, 0x66,
		0xcf, 0xef, 0x2b, 0x92, 0xdf, 0xcf, 0x78, 0x80, 0x10, 0x73, 0xf1, 0x08, 0x60, 0x6a, 0xdb, 0x10,
		0xdf, 0xed, 0x20, 0xa4, 0xcf, 0x41, 0x6c, 0xab, 0xc3, 0x34, 0x9c, 0xa0, 0xf8, 0xad, 0x4e, 0xb1,
		0x63, 0x5a, 0xb5, 0x23, 0x23, 0xb6, 0xd5, 0xd1, 0xcf, 0x81, 0x5a, 0x60, 0x5f, 0xb6, 0x4f, 0x2f,
		0x4f, 0x52, 0x81, 0x82, 0x55, 0x67, 0x12, 0xb8, 0x4f, 0x9f, 0x83, 0xf8, 0x06, 0x32, 0x0f, 0x98,
		0x12, 0x40, 0x65, 0x70, 0x8b, 0x41, 0xda, 0xd9, 0x0d, 0x5f, 0x84, 0x24, 0x27, 0xd6, 0xcf, 0x63,
		0xc4, 0x81, 0xcb, 0x6e, 0xcb, 0x10, 0x58, 0x1d, 0x36, 0x73, 0x91, 0x5e, 0xfd, 0x02, 0x24, 0x8c,
		0xc6, 0xe1, 0x91, 0xcb, 0x6e, 0xde, 0x2b, 0x46, 0xbb, 0x73, 0x77, 0x21, 0xe5, 0x69, 0xf4, 0x01,
		0x53, 0xaf, 0xd2, 0x47, 0xd3, 0x67, 0xc5, 0xf9, 0x84, 0xaf, 0x5b, 0xd2, 0x26, 0xfd, 0x2c, 0x24,
		0x77, 0xdc, 0x8e, 0x3f, 0xe8, 0xf3, 0x8a, 0xd4, 0x6b, 0xcd, 0xfd, 0x82, 0x02, 0xc9, 0x55, 0x84,
		0xda, 0xc4, 0xe0, 0x8f, 0x43, 0x7c, 0xd5, 0x7e, 0xcd, 0x62, 0x0a, 0x4e, 0x31, 0x8b, 0xe2, 0x6e,
		0x66, 0x53, 0xd2, 0xad, 0x3f, 0x2e, 0xda, 0x7d, 0xda, 0xb3, 0xbb, 0x20, 0x47, 0x6c, 0x9f, 0x0b,
		0xd8, 0x9e, 0x39, 0x10, 0x0b, 0xf5, 0xd8, 0xff, 0x3a, 0xa4, 0x85, 0xbb, 0xe8, 0x0b, 0x4c, 0x8d,
		0x98, 0x0c, 0x14, 0x6d, 0x85, 0x25, 0x72, 0x08, 0xc6, 0x03, 0x37, 0xc6, 0x50, 0xc1, 0xc4, 0x7d,
		0xa0, 0xc4, 0xcc, 0x8b, 0x41, 0x33, 0x87, 0x8b, 0x32, 0x53, 0x5f, 0xa2, 0x36, 0x22, 0xe6, 0x3e,
		0x4f, 0x83, 0xb3, 0xbf, 0x13, 0xf1, 0xe7, 0x5c, 0x02, 0xd4, 0x4a, 0xa3, 0x99, 0x7b, 0x06, 0x80,
		0xa6, 0x7c, 0xd9, 0xea, 0xb6, 0xa4, 0xac, 0x9b, 0xe0, 0x06, 0xde, 0x3d, 0x42, 0xbb, 0xc8, 0x21,
		0x22, 0xc1, 0x7a, 0x0a, 0x0f, 0x30, 0x40, 0x53, 0x8c, 0xe0, 0x9f, 0x8c, 0xc4, 0x87, 0x56, 0x62,
		0x58, 0x34, 0x4b, 0x45, 0xef, 0x22, 0xb7, 0x60, 0xd9, 0xee, 0x11, 0xea, 0x48, 0x88, 0x65, 0xfd,
		0x4a, 0x20, 0x61, 0x27, 0x96, 0x1f, 0xf1, 0x10, 0x7d, 0x41, 0x57, 0x72, 0x5f, 0x25, 0x0a, 0xe2,
		0x52, 0xa0, 0xe7, 0x01, 0xd5, 0x21, 0x1e, 0x50, 0xbf, 0x16, 0xa8, 0xdf, 0x06, 0xa8, 0x29, 0xbd,
		0x5a, 0xde, 0x0c, 0xbc, 0xe7, 0x0c, 0x56, 0x36, 0xf8, 0x8e, 0xc9, 0x6d, 0xca, 0x55, 0x7e, 0x32,
		0x52, 0xe5, 0x3e, 0xd5, 0xed, 0x49, 0x6d, 0xaa, 0x0e, 0x6b, 0xd3, 0x6f, 0x78, 0x15, 0x07, 0xfd,
		0x45, 0x13, 0xf2, 0x5b, 0x40, 0xfa, 0x53, 0x91, 0xbe, 0xcf, 0x2b, 0x25, 0x4f, 0xd5, 0x95, 0x61,
		0xdd, 0x9f, 0x8f, 0x15, 0x8b, 0x9e, 0xba, 0xd7, 0x4f, 0x10, 0x02, 0xf9, 0x58, 0xa9, 0xe4, 0x0d,
		0xdb, 0xc9, 0x4f, 0xbf, 0x35, 0xaf, 0x7c, 0xe5, 0xad, 0xf9, 0x91, 0xdc, 0x6f, 0x2a, 0x30, 0xc5,
		0x24, 0x85, 0xc0, 0x7d, 0x5a, 0x52, 0xfe, 0x34, 0x1f, 0x33, 0xc2, 0x2c, 0xf0, 0x13, 0x0b, 0xde,
		0x6f, 0x2a, 0x90, 0xed, 0xd1, 0x95, 0xdb, 0xfb, 0xd2, 0x50, 0x2a, 0xe7, 0x95, 0xf2, 0x4f, 0xdf,
		0xe6, 0x77, 0x21, 0xb1, 0xdb, 0x68, 0xa1, 0x0e, 0x9e, 0x09, 0xf0, 0x07, 0xaa, 0x32, 0xdf, 0xcc,
		0xa1, 0x4d, 0xbc, 0x8f, 0x2a, 0x17, 0xe8, 0x5b, 0xd6, 0xb3, 0x10, 0x5f, 0x35, 0x5d, 0x93, 0x68,
		0x90, 0xf1, 0xc6, 0x57, 0xd3, 0x35, 0x73, 0x57, 0x20, 0xb3, 0x79, 0x4c, 0x0e, 0x22, 0xd5, 0xc9,
		0x19, 0x94, 0x60, 0xf5, 0xc7, 0xeb, 0xd5, 0xcb, 0x8b, 0x89, 0x64, 0x5d, 0xbb, 0xa7, 0xe4, 0xe3,
		0x44, 0x9f, 0x57, 0x61, 0x62, 0x0b, 0xab, 0x4d, 0x70, 0x04, 0x76, 0x16, 0x94, 0xcd, 0x60, 0x21,
		0x24, 0xb2, 0x1a, 0xca, 0xa6, 0x54, 0x3e, 0xaa, 0x9e, 0x79, 0xa4, 0xb2, 0x4d, 0xf5, 0xca, 0xb6,
		0xc5, 0x78, 0x72, 0x42, 0x9b, 0x5a, 0x8c, 0x27, 0x41, 0x1b, 0x67, 0xf7, 0xfd, 0x0f, 0x2a, 0x68,
		0xb4, 0xd4, 0x59, 0x45, 0x07, 0x0d, 0xab, 0xe1, 0xf6, 0xd6, 0xab, 0x9e, 0xc6, 0xfa, 0x73, 0x90,
		0xc2, 0x26, 0x5d, 0x63, 0x3f, 0x09, 0x88, 0x4d, 0x7f, 0x8e, 0x95, 0x28, 0x12, 0x05, 0x6b, 0x20,
		0xa1, 0xe3, 0x63, 0xf4, 0x35, 0x50, 0x2b, 0x95, 0x4d, 0x36, 0xb9, 0xad, 0x0c, 0x84, 0xb2, 0xc3,
		0x3e, 0xec, 0x8a, 0xb5, 0x39, 0x87, 0x06, 0x26, 0xd0, 0x57, 0x20, 0x56, 0xd9, 0x64, 0x05, 0xef,
		0xf9, 0x61, 0x68, 0x8c, 0x58, 0x65, 0x73, 0xf6, 0xdf, 0x28, 0x30, 0x1e, 0x68, 0xd5, 0x73, 0x90,
		0xa1, 0x0d, 0xc2, 0xe3, 0x8e, 0x1a, 0x81, 0x36, 0xae, 0x73, 0xec, 0x7d, 0xea, 0x3c, 0x5b, 0x80,
		0x49, 0xa9, 0x5d, 0x5f, 0x02, 0x5d, 0x6c, 0x62, 0x4a, 0xd0, 0x9f, 0x23, 0x0b, 0xe9, 0xc9, 0x3d,
		0x0a, 0xe0, 0xdb, 0xd5, 0xfb, 0x15, 0xad, 0x4a, 0x79, 0x67, 0xb7, 0xbc, 0xaa, 0x29, 0xb9, 0xaf,
		0x2b, 0x90, 0x66, 0x65, 0x6b, 0xcd, 0x6e, 0x23, 0xbd, 0x08, 0x4a, 0x81, 0x45, 0xd0, 0x83, 0xe9,
		0xad, 0x14, 0xf4, 0x8b, 0xa0, 0x14, 0x87, 0x77, 0xb5, 0x52, 0xd4, 0x97, 0x41, 0x29, 0x31, 0x07,
		0x0f, 0xe7, 0x19, 0xa5, 0x94, 0xfb, 0x23, 0x15, 0xa6, 0xc5, 0x32, 0x9a, 0x8f, 0x27, 0xe7, 0x82,
		0xef, 0x4d, 0xf9, 0xd4, 0xe5, 0xe5, 0x2b, 0x2b, 0x4b, 0xf8, 0x1f, 0x2f, 0x24, 0x73, 0xc1, 0x57,
		0xa8, 0x3c, 0x78, 0x22, 0x97, 0xfb, 0x9d, 0x13, 0xc9, 0xc7, 0x05, 0x86, 0x9e, 0x73, 0x22, 0x81,
		0xde, 0x9e, 0x73, 0x22, 0x81, 0xde, 0x9e, 0x73, 0x22, 0x81, 0xde, 0x9e, 0xbd, 0x80, 0x40, 0x6f,
		0xcf, 0x39, 0x91, 0x40, 0x6f, 0xcf, 0x39, 0x91, 0x40, 0x6f, 0xef, 0x39, 0x11, 0xd6, 0xdd, 0xf7,
		0x9c, 0x48, 0xb0, 0xbf, 0xf7, 0x9c, 0x48, 0xb0, 0xbf, 0xf7, 0x9c, 0x48, 0x3e, 0xee, 0x76, 0xba,
		0xa8, 0xff, 0xae, 0x43, 0x10, 0x3f, 0xe8, 0x25, 0xd0, 0x1f, 0x81, 0xb7, 0x60, 0x92, 0x2e, 0x48,
		0x94, 0x6c, 0xcb, 0x35, 0x1b, 0x16, 0xea, 0xe8, 0x1f, 0x85, 0x0c, 0x6d, 0xa2, 0xaf, 0x39, 0x61,
		0xaf, 0x81, 0xb4, 0x9f, 0x8d, 0xb7, 0x01, 0xe9, 0xdc, 0x1f, 0xc7, 0x61, 0x86, 0x36, 0x54, 0xcc,
		0x16, 0x0a, 0x9c, 0x32, 0xba, 0x20, 0xed, 0x29, 0x4d, 0x60, 0xf8, 0xfd, 0x77, 0xe6, 0x69, 0x6b,
		0xc1, 0x8b, 0xa6, 0x0b, 0xd2, 0xee, 0x52, 0x50, 0xce, 0x9f, 0x80, 0x2e, 0x48, 0x27, 0x8f, 0x82,
		0x72, 0xde, 0x7c, 0xe3, 0xc9, 0xf1, 0x33, 0x48, 0x41, 0xb9, 0x55, 0x2f, 0xca, 0x2e, 0x48, 0xa7,
		0x91, 0x82, 0x72, 0x65, 0x2f, 0xde, 0x2e, 0x48, 0x7b, 0x4f, 0x41, 0xb9, 0x35, 0x2f, 0xf2, 0x2e,
		0x48, 0xbb, 0x50, 0x41, 0xb9, 0xdb, 0x5e, 0x0c, 0x5e, 0x90, 0xce, 0x2a, 0x05, 0xe5, 0x9e, 0xf7,
		0xa2, 0xf1, 0x82, 0x74, 0x6a, 0x29, 0x28, 0xb7, 0xee, 0xc5, 0xe5, 0x82, 0x7c, 0x7e, 0x29, 0x28,
		0x78, 0xc7, 0x8f, 0xd0, 0x05, 0xf9, 0x24, 0x53, 0x50, 0xf2, 0x63, 0x7e, 0xac, 0x2e, 0xc8, 0x67,
		0x9a, 0x82, 0x92, 0x1b, 0x7e, 0xd4, 0x2e, 0xc8, 0x7b, 0x65, 0x41, 0xc9, 0x4d, 0x3f, 0x7e, 0x17,
		0xe4, 0x5d, 0xb3, 0xa0, 0x64, 0xc5, 0x8f, 0xe4, 0x05, 0x79, 0xff, 0x2c, 0x28, 0xb9, 0xe5, 0x2f,
		0xa2, 0xff, 0xbe, 0x14, 0x7e, 0xc2, 0x29, 0xa8, 0x9c, 0x14, 0x7e, 0x10, 0x12, 0x7a, 0xd2, 0x40,
		0x26, 0xc8, 0xf8, 0x61, 0x97, 0x93, 0xc2, 0x0e, 0x42, 0x42, 0x2e, 0x27, 0x85, 0x1c, 0x84, 0x84,
		0x5b, 0x4e, 0x0a, 0x37, 0x08, 0x09, 0xb5, 0x9c, 0x14, 0x6a, 0x10, 0x12, 0x66, 0x39, 0x29, 0xcc,
		0x20, 0x24, 0xc4, 0x72, 0x52, 0x88, 0x41, 0x48, 0x78, 0xe5, 0xa4, 0xf0, 0x82, 0x90, 0xd0, 0x3a,
		0x2f, 0x87, 0x16, 0x84, 0x85, 0xd5, 0x79, 0x39, 0xac, 0x20, 0x2c, 0xa4, 0x1e, 0x93, 0x43, 0x2a,
		0x75, 0xff, 0x9d, 0xf9, 0x04, 0x6e, 0x12, 0xa2, 0xe9, 0xbc, 0x1c, 0x4d, 0x10, 0x16, 0x49, 0xe7,
		0xe5, 0x48, 0x82, 0xb0, 0x28, 0x3a, 0x2f, 0x47, 0x11, 0x84, 0x45, 0xd0, 0xdb, 0x72, 0x04, 0xf9,
		0x67, 0x7c, 0x72, 0xd2, 0x96, 0x62, 0x54, 0x04, 0xa9, 0x43, 0x44, 0x90, 0x3a, 0x44, 0x04, 0xa9,
		0x43, 0x44, 0x90, 0x3a, 0x44, 0x04, 0xa9, 0x43, 0x44, 0x90, 0x3a, 0x44, 0x04, 0xa9, 0x43, 0x44,
		0x90, 0x3a, 0x4c, 0x04, 0xa9, 0x43, 0x45, 0x90, 0xda, 0x2f, 0x82, 0xce, 0xcb, 0x27, 0x1e, 0x20,
		0x6c, 0x40, 0x3a, 0x2f, 0x6f, 0x7d, 0x46, 0x87, 0x90, 0x3a, 0x54, 0x08, 0xa9, 0xfd, 0x42, 0xe8,
		0xf7, 0x55, 0x98, 0x0e, 0x84, 0x10, 0xdb, 0x1f, 0xfa, 0xa0, 0x46, 0xa0, 0x6b, 0x43, 0x1c, 0xb0,
		0x08, 0x8b, 0xa9, 0x6b, 0x43, 0x6c, 0x52, 0x0f, 0x8a, 0xb3, 0xde, 0x51, 0xa8, 0x3c, 0xc4, 0x28,
		0xb4, 0xe6, 0xc5, 0xd0, 0xb5, 0x21, 0x0e, 0x5e, 0xf4, 0xc6, 0xde, 0x8d, 0x41, 0x83, 0xc0, 0xf3,
		0x43, 0x0d, 0x02, 0xeb, 0x43, 0x0d, 0x02, 0x77, 0x7c, 0x0f, 0xfe, 0x62, 0x0c, 0x4e, 0xf9, 0x1e,
		0xa4, 0x9f, 0xc8, 0x2f, 0x6b, 0xe5, 0x84, 0x2d, 0x2a, 0x9d, 0x6f, 0xdb, 0x08, 0x6e, 0x8c, 0xad,
		0xd7, 0xf5, 0xed, 0xe0, 0x66, 0x55, 0xfe, 0xa4, 0x1b, 0x38, 0x82, 0xc7, 0xd9, 0x62, 0xe8, 0x79,
		0x50, 0xd7, 0xeb, 0x0e, 0x19, 0x2d, 0xc2, 0x6e, 0x5b, 0x32, 0x70, 0xb7, 0x6e, 0xc0, 0x28, 0x11,
		0x77, 0x88, 0x7b, 0xdf, 0xcf, 0x8d, 0x57, 0x0d, 0xc6, 0x94, 0x7b, 0x5b, 0x81, 0xb3, 0x81, 0x50,
		0xfe, 0x60, 0xb6, 0x0c, 0x6e, 0x0d, 0xb5, 0x65, 0x10, 0x48, 0x10, 0x7f, 0xfb, 0xe0, 0x89, 0xde,
		0x9d, 0x6a, 0x31, 0x4b, 0xe4, 0xad, 0x84, 0xbf, 0x00, 0x13, 0xfe, 0x13, 0x90, 0x77, 0xb6, 0xab,
		0xd1, 0xab, 0x99, 0x61, 0xa9, 0x79, 0x55, 0x5a, 0x45, 0x1b, 0x08, 0xf3, 0xb2, 0x35, 0x97, 0x87,
		0xc9, 0x4a, 0xf0, 0x2b, 0x51, 0x51, 0x8b, 0x11, 0x49, 0x5c, 0x9a, 0xdf, 0xfb, 0xd2, 0xfc, 0x48,
		0xee, 0x29, 0xc8, 0x88, 0xdf, 0x7a, 0x92, 0x80, 0x29, 0x0e, 0xcc, 0xc7, 0xbf, 0x85, 0xa5, 0xff,
		0xbe, 0x02, 0xa7, 0x45, 0xf1, 0x17, 0x1a, 0xee, 0xd1, 0xba, 0x85, 0x6b, 0xfa, 0x67, 0x20, 0x89,
		0x98, 0xe3, 0xd8, 0x8f, 0xe4, 0xb0, 0xf7, 0xc8, 0x50, 0xf1, 0x25, 0xf2, 0xaf, 0xe1, 0x41, 0xa4,
		0x35, 0x0e, 0x7e, 0xdb, 0xe5, 0xd9, 0xc7, 0x21, 0x41, 0xf9, 0x83, 0x7a, 0x8d, 0x4b, 0x7a, 0xfd,
		0x7a, 0x88, 0x5e, 0x24, 0x8e, 0xf4, 0x3b, 0x01, 0xbd, 0x84, 0xd7, 0xd5, 0x50, 0xf1, 0x25, 0x1e,
		0x7c, 0xc5, 0x24, 0xae, 0xff, 0x48, 0x44, 0x45, 0x2b, 0xb9, 0x00, 0xc9, 0xb2, 0x2c, 0x13, 0xae,
		0xe7, 0x2a, 0xc4, 0x2b, 0x76, 0x9d, 0xfc, 0x7c, 0x0f, 0xf9, 0x21, 0x6c, 0x66, 0x64, 0xf6, 0xab,
		0xd8, 0x17, 0x20, 0x59, 0x3a, 0x6a, 0x34, 0xeb, 0x1d, 0x64, 0xb1, 0x3d, 0x7b, 0xb6, 0x84, 0x8e,
		0x31, 0x86, 0xd7, 0x97, 0x2b, 0xc1, 0x54, 0xc5, 0xb6, 0x8a, 0xc7, 0xae, 0x38, 0x6e, 0x2c, 0x49,
		0x29, 0xc2, 0xf6, 0x7c, 0xc8, 0xb7, 0x44, 0xb0, 0x40, 0x31, 0xf1, 0xed, 0x77, 0xe6, 0x95, 0x5d,
		0x6f, 0xfd, 0x7c, 0x13, 0x1e, 0x62, 0xe9, 0xd3, 0x43, 0xb5, 0x1c, 0x45, 0x95, 0x62, 0xfb, 0xd4,
		0x02, 0xdd, 0x3a, 0xa6, 0xb3, 0x42, 0xe9, 0x1e, 0x4c, 0x33, 0x5c, 0x14, 0x0d, 0xd4, 0x4c, 0x3d,
		0x91, 0x66, 0xa1, 0x74, 0x4b, 0x51, 0x74, 0x92, 0x66, 0x8f, 0x41, 0xca, 0xeb, 0x13, 0xa2, 0x41,
		0xcc, 0x94, 0xe5, 0xc5, 0x1c, 0xa4, 0x85, 0x84, 0xd5, 0x13, 0xa0, 0x14, 0xb4, 0x11, 0xfc, 0x5f,
		0x51, 0x53, 0xf0, 0x7f, 0x25, 0x2d, 0xb6, 0xf8, 0x38, 0x4c, 0x4a, 0xeb, 0x97, 0xb8, 0x67, 0x55,
		0x03, 0xfc, 0x5f, 0x59, 0x4b, 0xcf, 0xc6, 0x3f, 0xfd, 0x6b, 0x73, 0x23, 0x8b, 0xb7, 0x40, 0xef,
		0x5d, 0xe9, 0xd4, 0x47, 0x21, 0x56, 0xc0, 0x94, 0x0f, 0x41, 0xac, 0x58, 0xd4, 0x94, 0xd9, 0xc9,
		0xbf, 0xfa, 0xf9, 0xb3, 0xe9, 0x22, 0xf9, 0x4a, 0xf7, 0x5d, 0xe4, 0x16, 0x8b, 0x0c, 0xfc, 0x2c,
		0x9c, 0x0e, 0x5d, 0x29, 0xc5, 0xf8, 0x52, 0x89, 0xe2, 0x57, 0x57, 0x7b, 0xf0, 0xab, 0xab, 0x04,
		0xaf, 0xe4, 0xf9, 0x8e, 0x73, 0x41, 0x0f, 0x59, 0x97, 0xcc, 0xd6, 0x85, 0x1d, 0xee, 0x42, 0xfe,
		0x59, 0x26, 0x5b, 0x0c, 0x95, 0x45, 0x11, 0x3b, 0xd6, 0xc5, 0x7c, 0x89, 0xe1, 0x4b, 0xa1, 0xf8,
		0x03, 0x69, 0x5b, 0x35, 0x38, 0x43, 0x30, 0x92, 0x92, 0xa7, 0xf0, 0x6a, 0x28, 0xc9, 0x91, 0x70,
		0xd8, 0x7d, 0xd5, 0x53, 0xb8, 0x1c, 0x2a, 0xdb, 0x88, 0x38, 0xf4, 0x55, 0xce, 0x5f, 0x64, 0x93,
		0x7c, 0xe1, 0xb2, 0x7e, 0x9a, 0xe7, 0x68, 0x60, 0x04, 0x66, 0x06, 0xe2, 0x52, 0xf9, 0x12, 0x03,
		0x14, 0xfb, 0x02, 0xfa, 0x5b, 0x89, 0x23, 0xf3, 0xcf, 0x33, 0x92, 0x52, 0x5f, 0x92, 0x08, 0x53,
		0x71, 0x78, 0x71, 0xf7, 0xde, 0xbb, 0x73, 0x23, 0xdf, 0x7a, 0x77, 0x6e, 0xe4, 0xbf, 0xbc, 0x3b,
		0x37, 0xf2, 0x9d, 0x77, 0xe7, 0x94, 0xef, 0xbf, 0x3b, 0xa7, 0xfc, 0xf0, 0xdd, 0x39, 0xe5, 0x47,
		0xef, 0xce, 0x29, 0x6f, 0xde, 0x9f, 0x53, 0xbe, 0x72, 0x7f, 0x4e, 0xf9, 0xea, 0xfd, 0x39, 0xe5,
		0x77, 0xef, 0xcf, 0x29, 0x6f, 0xdf, 0x9f, 0x53, 0xee, 0xdd, 0x9f, 0x53, 0xbe, 0x75, 0x7f, 0x4e,
		0xf9, 0xce, 0xfd, 0x39, 0xe5, 0xfb, 0xf7, 0xe7, 0x46, 0x7e, 0x78, 0x7f, 0x4e, 0xf9, 0xd1, 0xfd,
		0xb9, 0x91, 0x37, 0xbf, 0x3b, 0x37, 0xf2, 0xd6, 0x77, 0xe7, 0x46, 0xbe, 0xf2, 0xdd, 0x39, 0x05,
		0xfe, 0x70, 0x05, 0x72, 0xec, 0x9b, 0x64, 0xc2, 0x97, 0x86, 0x2f, 0xba, 0x47, 0x88, 0x14, 0x05,
		0x57, 0xf8, 0xaf, 0x80, 0x79, 0x0d, 0x27, 0xfc, 0x5e, 0xd9, 0xec, 0x83, 0x7e, 0x8b, 0x2d, 0xf7,
		0x6f, 0x13, 0x30, 0xc6, 0x57, 0x83, 0xc3, 0x7e, 0x2b, 0xfd, 0x2a, 0x24, 0x8f, 0x1a, 0x4d, 0xb3,
		0xd3, 0x70, 0x8f, 0xd9, 0x32, 0xe8, 0xc3, 0x4b, 0xbe, 0xda, 0x7c, 0xe1, 0xf4, 0xf9, 0x6e, 0xcb,
		0xee, 0x76, 0x0c, 0x4f, 0x54, 0x3f, 0x0b, 0x99, 0x23, 0xd4, 0x38, 0x3c, 0x72, 0xab, 0x0d, 0xab,
		0x5a, 0x6b, 0x91, 0x6a, 0x79, 0xdc, 0x00, 0xda, 0xb6, 0x6e, 0x95, 0x5a, 0xf8, 0x66, 0x75, 0xd3,
		0x35, 0xc9, 0x5b, 0x7a, 0xc6, 0x20, 0x9f, 0xc9, 0xef, 0x1d, 0x23, 0xa7, 0xdb, 0x74, 0xab, 0x35,
		0xbb, 0x6b, 0xb9, 0xa4, 0x9e, 0x55, 0x8d, 0x34, 0x6d, 0x2b, 0xe1, 0x26, 0xfd, 0x31, 0x18, 0x77,
		0x3b, 0x5d, 0x54, 0x75, 0x6a, 0xb6, 0xeb, 0xb4, 0x4c, 0x8b, 0xd4, 0xb3, 0x49, 0x23, 0x83, 0x1b,
		0x77, 0x58, 0x1b, 0xf9, 0x99, 0xfd, 0x9a, 0xdd, 0x41, 0xe4, 0x75, 0x3a, 0x66, 0xd0, 0x0b, 0x5d,
		0x03, 0xf5, 0x15, 0x74, 0x4c, 0x5e, 0xd8, 0xe2, 0x06, 0xfe, 0xa8, 0x3f, 0x09, 0xa3, 0xf4, 0xef,
		0xe4, 0x90, 0xea, 0x9a, 0x6c, 0x5e, 0x7b, 0x8f, 0x46, 0x17, 0x69, 0x0d, 0x26, 0xa0, 0xdf, 0x84,
		0x31, 0x17, 0x75, 0x3a, 0x66, 0xc3, 0x22, 0x2f, 0x4f, 0xe9, 0xe5, 0xf9, 0x10, 0x33, 0xec, 0x52,
		0x09, 0xf2, 0xab, 0xc0, 0x06, 0x97, 0xd7, 0xaf, 0x42, 0x86, 0xc8, 0x2d, 0x57, 0xe9, 0xdf, 0x12,
		0x4a, 0xf7, 0x8d, 0xe7, 0x34, 0x95, 0xe3, 0x7b, 0x05, 0x1c, 0x46, 0x7f, 0x11, 0x71, 0x9c, 0xdc,
		0xf6, 0xb1, 0x90, 0xdb, 0x92, 0xa1, 0x77, 0x99, 0x94, 0x8d, 0xf4, 0xd6, 0x8c, 0x87, 0xfe, 0x66,
		0xe2, 0x26, 0x64, 0x44, 0xbd, 0xb8, 0x19, 0x68, 0xf9, 0x43, 0xcc, 0xf0, 0x84, 0xff, 0x77, 0x1a,
		0xfa, 0x58, 0x81, 0xf6, 0xe7, 0x63, 0x37, 0x94, 0xd9, 0x6d, 0xd0, 0xe4, 0xfb, 0x85, 0x50, 0x5e,
		0x08, 0x52, 0x6a, 0xe2, 0xc3, 0x92, 0x95, 0x72, 0x9f, 0x31, 0xf7, 0x1c, 0x8c, 0xd2, 0xf8, 0xd1,
		0xd3, 0x30, 0xe6, 0xff, 0xd8, 0x66, 0x12, 0xe2, 0xdb, 0x7b, 0x95, 0x1d, 0xfa, 0xab, 0xb9, 0x3b,
		0x1b, 0x85, 0xed, 0x9d, 0xdd, 0xf5, 0xd2, 0xc7, 0xb4, 0x98, 0x3e, 0x09, 0xe9, 0xe2, 0xfa, 0xc6,
		0x46, 0xb5, 0x58, 0x58, 0xdf, 0x28, 0xdf, 0xd5, 0xd4, 0xdc, 0x1c, 0x8c, 0x52, 0x3d, 0xc9, 0xaf,
		0xff, 0x75, 0x2d, 0xeb, 0x98, 0x97, 0x0f, 0xe4, 0x22, 0xf7, 0x35, 0x1d, 0xc6, 0x0a, 0xcd, 0xe6,
		0xa6, 0xd9, 0x76, 0xf4, 0x17, 0x60, 0x8a, 0xfe, 0x2e, 0xc7, 0xae, 0xbd, 0x4a, 0x7e, 0xa4, 0x12,
		0x0f, 0x0e, 0x0a, 0xfb, 0xfb, 0x14, 0xfe, 0x73, 0x33, 0xf1, 0xa5, 0x1e, 0x59, 0x6a, 0xe0, 0x5e,
		0x0e, 0x7d, 0x17, 0x34, 0xde, 0xb8, 0xd6, 0xb4, 0x4d, 0x17, 0xf3, 0xc6, 0xd8, 0x6f, 0x48, 0xf6,
		0xe7, 0xe5, 0xa2, 0x94, 0xb6, 0x87, 0x41, 0xff, 0x28, 0x24, 0xd7, 0x2d, 0xf7, 0xca, 0x32, 0x66,
		0xe3, 0x7f, 0xfb, 0xa9, 0x97, 0x8d, 0x8b, 0x50, 0x16, 0x0f, 0xc1, 0xd0, 0xd7, 0x56, 0x30, 0x3a,
		0x3e, 0x08, 0x4d, 0x44, 0x7c, 0x34, 0xb9, 0xd4, 0x9f, 0x83, 0x14, 0x7e, 0x3b, 0xa1, 0x37, 0x4f,
		0xf0, 0xd2, 0xb5, 0x07, 0xee, 0xc9, 0x50, 0xbc, 0x8f, 0xe1, 0x04, 0xf4, 0xfe, 0xa3, 0x03, 0x09,
		0x04, 0x05, 0x7c, 0x0c, 0x26, 0xd8, 0xf1, 0x34, 0x18, 0xeb, 0x4b, 0xb0, 0x23, 0x69, 0xb0, 0x23,
		0x6a, 0xb0, 0xe3, 0x69, 0x90, 0x1c, 0x48, 0x20, 0x6a, 0xe0, 0x5d, 0xeb, 0x45, 0x80, 0xb5, 0xc6,
		0xeb, 0xa8, 0x4e, 0x55, 0xa0, 0x7f, 0x19, 0x2a, 0x17, 0xc2, 0xe0, 0x0b, 0x51, 0x0a, 0x01, 0xa5,
		0x97, 0x21, 0xbd, 0x73, 0xe0, 0x93, 0x40, 0x4f, 0x1e, 0x7b, 0x6a, 0x1c, 0x48, 0x2c, 0x22, 0xce,
		0x53, 0x85, 0x3e, 0x4c, 0x7a, 0xb0, 0x2a, 0xc2, 0xd3, 0x08, 0x28, 0x5f, 0x15, 0x4a, 0x92, 0x89,
		0x50, 0x45, 0x60, 0x11, 0x71, 0x78, 0x30, 0x2c, 0xda, 0x36, 0x96, 0x64, 0xa3, 0xd2, 0x7c, 0x08,
		0x05, 0x93, 0x60, 0x83, 0x21, 0xbb, 0x22, 0x1e, 0x21, 0x41, 0x8e, 0xc1, 0x13, 0xfd, 0x3d, 0xc2,
		0x65, 0xb8, 0x47, 0xf8, 0xb5, 0x98, 0x67, 0xe4, 0x44, 0x2b, 0xe6, 0x99, 0x8c, 0xcc, 0x33, 0x2e,
		0x2a, 0xe5, 0x19, 0x6f, 0xd6, 0x3f, 0x0e, 0x93, 0xbc, 0x0d, 0x0f, 0x4f, 0x98, 0x54, 0x63, 0x7f,
		0x3b, 0xaf, 0x3f, 0x29, 0x93, 0xa4, 0x9c, 0x32, 0x5e, 0xaf, 0xc0, 0x04, 0x6f, 0xda, 0x74, 0xc8,
		0xe3, 0x4e, 0xb1, 0x3f, 0x8b, 0xd2, 0x9f, 0x91, 0x0a, 0x52, 0x42, 0x09, 0x3d, 0xbb, 0x0a, 0x33,
		0xe1, 0xa3, 0x91, 0x38, 0xfc, 0xa6, 0xe8, 0xf0, 0x7b, 0x4a, 0x1c, 0x7e, 0x15, 0x71, 0xf8, 0x2e,
		0xc1, 0xe9, 0xd0, 0xb1, 0x27, 0x8a, 0x24, 0x26, 0x92, 0xdc, 0x82, 0xf1, 0xc0, 0x90, 0x23, 0x82,
		0x13, 0x21, 0xe0, 0x44, 0x2f, 0xd8, 0x0f, 0xad, 0x90, 0xd9, 0x23, 0x00, 0x56, 0x45, 0xf0, 0x47,
		0x61, 0x22, 0x38, 0xde, 0x88, 0xe8, 0xf1, 0x10, 0xf4, 0x78, 0x08, 0x3a, 0xfc, 0xde, 0xf1, 0x10,
		0x74, 0x5c, 0x42, 0xef, 0xf4, 0xbd, 0xf7, 0x54, 0x08, 0x7a, 0x2a, 0x04, 0x1d, 0x7e, 0x6f, 0x3d,
		0x04, 0xad, 0x8b, 0xe8, 0x67, 0x60, 0x52, 0x1a, 0x62, 0x44, 0xf8, 0x58, 0x08, 0x7c, 0x4c, 0x84,
		0x3f, 0x0b, 0x9a, 0x3c, 0xb8, 0x88, 0xf8, 0xc9, 0x10, 0xfc, 0x64, 0xd8, 0xed, 0xc3, 0xb5, 0x1f,
		0x0d, 0x81, 0x8f, 0x86, 0xde, 0x3e, 0x1c, 0xaf, 0x85, 0xe0, 0x35, 0x11, 0x9f, 0x87, 0x8c, 0x38,
		0x9a, 0x88, 0xd8, 0x64, 0x08, 0x36, 0x29, 0xdb, 0x3d, 0x30, 0x98, 0x44, 0x45, 0x7a, 0xaa, 0x4f,
		0xba, 0x04, 0x86, 0x90, 0x28, 0x92, 0x8c, 0x48, 0xf2, 0x09, 0x38, 0x15, 0x36, 0x64, 0x84, 0x70,
		0x2c, 0x88, 0x1c, 0x13, 0xb8, 0x46, 0xf4, 0x8b, 0x3d, 0xb3, 0x2d, 0x15, 0x4e, 0xb3, 0x2f, 0xc1,
		0x74, 0xc8, 0xc0, 0x11, 0x42, 0xbb, 0x14, 0xac, 0xc6, 0xb2, 0x02, 0x2d, 0x19, 0x04, 0x1a, 0xd6,
		0xe1, 0xb6, 0xdd, 0xb0, 0x5c, 0xb1, 0x2a, 0xfb, 0xfa, 0x34, 0x4c, 0xb0, 0xe1, 0x69, 0xab, 0x53,
		0x47, 0x1d, 0x54, 0xd7, 0xff, 0x5c, 0xff, 0xda, 0xe9, 0x52, 0xef, 0xa0, 0xc6, 0x50, 0x27, 0x28,
		0xa1, 0x5e, 0xea, 0x5b, 0x42, 0x5d, 0x8c, 0xa6, 0x8f, 0xaa, 0xa4, 0x4a, 0x3d, 0x95, 0xd4, 0x13,
		0xfd, 0x49, 0xfb, 0x15, 0x54, 0xa5, 0x9e, 0x82, 0x6a, 0x30, 0x49, 0x68, 0x5d, 0xb5, 0xd6, 0x5b,
		0x57, 0x2d, 0xf4, 0x67, 0xe9, 0x5f, 0x5e, 0xad, 0xf5, 0x96, 0x57, 0x11, 0x3c, 0xe1, 0x55, 0xd6,
		0x5a, 0x6f, 0x95, 0x35, 0x80, 0xa7, 0x7f, 0xb1, 0xb5, 0xd6, 0x5b, 0x6c, 0x45, 0xf0, 0x84, 0xd7,
		0x5c, 0xeb, 0x21, 0x35, 0xd7, 0x93, 0xfd, 0x89, 0x06, 0x95, 0x5e, 0x1b, 0x61, 0xa5, 0xd7, 0xe2,
		0x00, 0xa5, 0x06, 0x56, 0x60, 0xeb, 0x21, 0x15, 0x58, 0x94, 0x62, 0x7d, 0x0a, 0xb1, 0x8d, 0xb0,
		0x42, 0x2c, 0x52, 0xb1, 0x7e, 0xf5, 0xd8, 0xcf, 0xc9, 0xf5, 0xd8, 0x85, 0xfe, 0x4c, 0xe1, 0x65,
		0xd9, 0x5a, 0x6f, 0x59, 0xb6, 0x10, 0x95, 0x73, 0x61, 0xd5, 0xd9, 0x4b, 0x7d, 0xab, 0xb3, 0x21,
		0x52, 0x38, 0xaa, 0x48, 0x7b, 0xb1, 0x5f, 0x91, 0xb6, 0x14, 0xcd, 0x3d, 0xb8, 0x56, 0xdb, 0xeb,
		0x53, 0xab, 0x3d, 0x1d, 0x4d, 0xfc, 0xb3, 0x92, 0xed, 0x67, 0x25, 0xdb, 0xcf, 0x4a, 0xb6, 0x9f,
		0x95, 0x6c, 0x3f, 0xfd, 0x92, 0x2d, 0x1f, 0xff, 0xcc, 0x97, 0xe6, 0x95, 0xdc, 0x7f, 0x56, 0xbd,
		0x3f, 0xb8, 0xf6, 0x42, 0xc3, 0x3d, 0xc2, 0xc3, 0xdb, 0x26, 0x64, 0xc8, 0x0f, 0x00, 0xb7, 0xcc,
		0x76, 0xbb, 0x61, 0x1d, 0xb2, 0x9a, 0x6d, 0xb1, 0x77, 0x29, 0x91, 0x01, 0xc8, 0x1f, 0x9b, 0xd9,
		0xa4, 0xc2, 0x6c, 0xba, 0xb1, 0xfc, 0x16, 0xfd, 0x0e, 0xa4, 0x5b, 0xce, 0xa1, 0xc7, 0x16, 0xeb,
		0x99, 0x08, 0x25, 0x36, 0xfa, 0xa4, 0x3e, 0x19, 0xb4, 0xbc, 0x06, 0xac, 0xda, 0xfe, 0xb1, 0xeb,
		0xab, 0xa6, 0x46, 0xa9, 0x86, 0x7d, 0x1a, 0x54, 0x6d, 0xdf, 0x6f, 0xc1, 0x61, 0x2b, 0xeb, 0x1e,
		0x35, 0xd2, 0x05, 0x82, 0xe7, 0x05, 0x98, 0x94, 0xb4, 0x0d, 0xc9, 0xf9, 0x07, 0xf0, 0x0d, 0x56,
		0x4c, 0xd6, 0x3c, 0x2a, 0x27, 0xc4, 0x80, 0xcc, 0x3d, 0x0a, 0xe3, 0x01, 0x6e, 0x3d, 0x03, 0xca,
		0x01, 0xfb, 0x3a, 0xa5, 0x72, 0x90, 0xfb, 0xa2, 0x02, 0x69, 0x76, 0x94, 0x60, 0xdb, 0x6c, 0x74,
		0xf4, 0xe7, 0x21, 0xde, 0xe4, 0x5f, 0x69, 0x7a, 0xd0, 0xaf, 0xcf, 0x12, 0x06, 0x7d, 0x0d, 0x12,
		0x1d, 0xef, 0x2b, 0x4f, 0x0f, 0xf4, 0x9d, 0x58, 0x02, 0xcf, 0xdd, 0x53, 0x60, 0x8a, 0x9d, 0x74,
		0x75, 0xd8, 0x01, 0x68, 0xb3, 0x3d, 0xfb, 0x35, 0x05, 0x52, 0xde, 0x95, 0xbe, 0x0f, 0x13, 0xde,
		0x05, 0x3d, 0x64, 0x4f, 0x23, 0x35, 0x2f, 0x58, 0xb8, 0x87, 0x63, 0x29, 0xe4, 0x13, 0xdd, 0x8c,
		0xa2, 0x73, 0x72, 0xb0, 0x71, 0xb6, 0x00, 0xd3, 0x21, 0x62, 0x27, 0x99, 0x90, 0x73, 0xe7, 0x20,
		0x55, 0xb1, 0x5d, 0xfa, 0xcb, 0x39, 0xfa, 0x29, 0x61, 0x57, 0xa1, 0x18, 0xd3, 0x46, 0x08, 0x78,
		0xf1, 0x1c, 0x8c, 0xb1, 0xec, 0xd7, 0x47, 0x21, 0xb6, 0x59, 0xd0, 0x46, 0xc8, 0xff, 0x45, 0x4d,
		0x21, 0xff, 0x97, 0xb4, 0x58, 0x71, 0xe3, 0x01, 0x76, 0x9a, 0x46, 0xfa, 0xed, 0x34, 0xed, 0x8f,
		0x52, 0xf3, 0xfc, 0x49, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3d, 0x79, 0x7c, 0xa8, 0xc6, 0x83, 0x00,
		0x00,
	}
	r := bytes.NewReader(gzipped)
	gzipr, err := compress_gzip.NewReader(r)
	if err != nil {
		panic(err)
	}
	ungzipped, err := io_ioutil.ReadAll(gzipr)
	if err != nil {
		panic(err)
	}
	if err := github_com_gogo_protobuf_proto.Unmarshal(ungzipped, d); err != nil {
		panic(err)
	}
	return d
}
func (x MapEnum) String() string {
	s, ok := MapEnum_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Message_Humour) String() string {
	s, ok := Message_Humour_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Message) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Message")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Message but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Message but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Hilarity != that1.Hilarity {
		return fmt.Errorf("Hilarity this(%v) Not Equal that(%v)", this.Hilarity, that1.Hilarity)
	}
	if this.HeightInCm != that1.HeightInCm {
		return fmt.Errorf("HeightInCm this(%v) Not Equal that(%v)", this.HeightInCm, that1.HeightInCm)
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if this.ResultCount != that1.ResultCount {
		return fmt.Errorf("ResultCount this(%v) Not Equal that(%v)", this.ResultCount, that1.ResultCount)
	}
	if this.TrueScotsman != that1.TrueScotsman {
		return fmt.Errorf("TrueScotsman this(%v) Not Equal that(%v)", this.TrueScotsman, that1.TrueScotsman)
	}
	if this.Score != that1.Score {
		return fmt.Errorf("Score this(%v) Not Equal that(%v)", this.Score, that1.Score)
	}
	if len(this.Key) != len(that1.Key) {
		return fmt.Errorf("Key this(%v) Not Equal that(%v)", len(this.Key), len(that1.Key))
	}
	for i := range this.Key {
		if this.Key[i] != that1.Key[i] {
			return fmt.Errorf("Key this[%v](%v) Not Equal that[%v](%v)", i, this.Key[i], i, that1.Key[i])
		}
	}
	if !this.Nested.Equal(that1.Nested) {
		return fmt.Errorf("Nested this(%v) Not Equal that(%v)", this.Nested, that1.Nested)
	}
	if len(this.Terrain) != len(that1.Terrain) {
		return fmt.Errorf("Terrain this(%v) Not Equal that(%v)", len(this.Terrain), len(that1.Terrain))
	}
	for i := range this.Terrain {
		if !this.Terrain[i].Equal(that1.Terrain[i]) {
			return fmt.Errorf("Terrain this[%v](%v) Not Equal that[%v](%v)", i, this.Terrain[i], i, that1.Terrain[i])
		}
	}
	if !this.Proto2Field.Equal(that1.Proto2Field) {
		return fmt.Errorf("Proto2Field this(%v) Not Equal that(%v)", this.Proto2Field, that1.Proto2Field)
	}
	if len(this.Proto2Value) != len(that1.Proto2Value) {
		return fmt.Errorf("Proto2Value this(%v) Not Equal that(%v)", len(this.Proto2Value), len(that1.Proto2Value))
	}
	for i := range this.Proto2Value {
		if !this.Proto2Value[i].Equal(that1.Proto2Value[i]) {
			return fmt.Errorf("Proto2Value this[%v](%v) Not Equal that[%v](%v)", i, this.Proto2Value[i], i, that1.Proto2Value[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Message) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Message)
	if !ok {
		that2, ok := that.(Message)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Hilarity != that1.Hilarity {
		return false
	}
	if this.HeightInCm != that1.HeightInCm {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if this.ResultCount != that1.ResultCount {
		return false
	}
	if this.TrueScotsman != that1.TrueScotsman {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if len(this.Key) != len(that1.Key) {
		return false
	}
	for i := range this.Key {
		if this.Key[i] != that1.Key[i] {
			return false
		}
	}
	if !this.Nested.Equal(that1.Nested) {
		return false
	}
	if len(this.Terrain) != len(that1.Terrain) {
		return false
	}
	for i := range this.Terrain {
		if !this.Terrain[i].Equal(that1.Terrain[i]) {
			return false
		}
	}
	if !this.Proto2Field.Equal(that1.Proto2Field) {
		return false
	}
	if len(this.Proto2Value) != len(that1.Proto2Value) {
		return false
	}
	for i := range this.Proto2Value {
		if !this.Proto2Value[i].Equal(that1.Proto2Value[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Nested) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Nested)
	if !ok {
		that2, ok := that.(Nested)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Nested")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Nested but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Nested but is not nil && this == nil")
	}
	if this.Bunny != that1.Bunny {
		return fmt.Errorf("Bunny this(%v) Not Equal that(%v)", this.Bunny, that1.Bunny)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Nested) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Nested)
	if !ok {
		that2, ok := that.(Nested)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bunny != that1.Bunny {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AllMaps) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AllMaps)
	if !ok {
		that2, ok := that.(AllMaps)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AllMaps")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AllMaps but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AllMaps but is not nil && this == nil")
	}
	if len(this.StringToDoubleMap) != len(that1.StringToDoubleMap) {
		return fmt.Errorf("StringToDoubleMap this(%v) Not Equal that(%v)", len(this.StringToDoubleMap), len(that1.StringToDoubleMap))
	}
	for i := range this.StringToDoubleMap {
		if this.StringToDoubleMap[i] != that1.StringToDoubleMap[i] {
			return fmt.Errorf("StringToDoubleMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToDoubleMap[i], i, that1.StringToDoubleMap[i])
		}
	}
	if len(this.StringToFloatMap) != len(that1.StringToFloatMap) {
		return fmt.Errorf("StringToFloatMap this(%v) Not Equal that(%v)", len(this.StringToFloatMap), len(that1.StringToFloatMap))
	}
	for i := range this.StringToFloatMap {
		if this.StringToFloatMap[i] != that1.StringToFloatMap[i] {
			return fmt.Errorf("StringToFloatMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToFloatMap[i], i, that1.StringToFloatMap[i])
		}
	}
	if len(this.Int32Map) != len(that1.Int32Map) {
		return fmt.Errorf("Int32Map this(%v) Not Equal that(%v)", len(this.Int32Map), len(that1.Int32Map))
	}
	for i := range this.Int32Map {
		if this.Int32Map[i] != that1.Int32Map[i] {
			return fmt.Errorf("Int32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Int32Map[i], i, that1.Int32Map[i])
		}
	}
	if len(this.Int64Map) != len(that1.Int64Map) {
		return fmt.Errorf("Int64Map this(%v) Not Equal that(%v)", len(this.Int64Map), len(that1.Int64Map))
	}
	for i := range this.Int64Map {
		if this.Int64Map[i] != that1.Int64Map[i] {
			return fmt.Errorf("Int64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Int64Map[i], i, that1.Int64Map[i])
		}
	}
	if len(this.Uint32Map) != len(that1.Uint32Map) {
		return fmt.Errorf("Uint32Map this(%v) Not Equal that(%v)", len(this.Uint32Map), len(that1.Uint32Map))
	}
	for i := range this.Uint32Map {
		if this.Uint32Map[i] != that1.Uint32Map[i] {
			return fmt.Errorf("Uint32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Uint32Map[i], i, that1.Uint32Map[i])
		}
	}
	if len(this.Uint64Map) != len(that1.Uint64Map) {
		return fmt.Errorf("Uint64Map this(%v) Not Equal that(%v)", len(this.Uint64Map), len(that1.Uint64Map))
	}
	for i := range this.Uint64Map {
		if this.Uint64Map[i] != that1.Uint64Map[i] {
			return fmt.Errorf("Uint64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Uint64Map[i], i, that1.Uint64Map[i])
		}
	}
	if len(this.Sint32Map) != len(that1.Sint32Map) {
		return fmt.Errorf("Sint32Map this(%v) Not Equal that(%v)", len(this.Sint32Map), len(that1.Sint32Map))
	}
	for i := range this.Sint32Map {
		if this.Sint32Map[i] != that1.Sint32Map[i] {
			return fmt.Errorf("Sint32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sint32Map[i], i, that1.Sint32Map[i])
		}
	}
	if len(this.Sint64Map) != len(that1.Sint64Map) {
		return fmt.Errorf("Sint64Map this(%v) Not Equal that(%v)", len(this.Sint64Map), len(that1.Sint64Map))
	}
	for i := range this.Sint64Map {
		if this.Sint64Map[i] != that1.Sint64Map[i] {
			return fmt.Errorf("Sint64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sint64Map[i], i, that1.Sint64Map[i])
		}
	}
	if len(this.Fixed32Map) != len(that1.Fixed32Map) {
		return fmt.Errorf("Fixed32Map this(%v) Not Equal that(%v)", len(this.Fixed32Map), len(that1.Fixed32Map))
	}
	for i := range this.Fixed32Map {
		if this.Fixed32Map[i] != that1.Fixed32Map[i] {
			return fmt.Errorf("Fixed32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Fixed32Map[i], i, that1.Fixed32Map[i])
		}
	}
	if len(this.Sfixed32Map) != len(that1.Sfixed32Map) {
		return fmt.Errorf("Sfixed32Map this(%v) Not Equal that(%v)", len(this.Sfixed32Map), len(that1.Sfixed32Map))
	}
	for i := range this.Sfixed32Map {
		if this.Sfixed32Map[i] != that1.Sfixed32Map[i] {
			return fmt.Errorf("Sfixed32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sfixed32Map[i], i, that1.Sfixed32Map[i])
		}
	}
	if len(this.Fixed64Map) != len(that1.Fixed64Map) {
		return fmt.Errorf("Fixed64Map this(%v) Not Equal that(%v)", len(this.Fixed64Map), len(that1.Fixed64Map))
	}
	for i := range this.Fixed64Map {
		if this.Fixed64Map[i] != that1.Fixed64Map[i] {
			return fmt.Errorf("Fixed64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Fixed64Map[i], i, that1.Fixed64Map[i])
		}
	}
	if len(this.Sfixed64Map) != len(that1.Sfixed64Map) {
		return fmt.Errorf("Sfixed64Map this(%v) Not Equal that(%v)", len(this.Sfixed64Map), len(that1.Sfixed64Map))
	}
	for i := range this.Sfixed64Map {
		if this.Sfixed64Map[i] != that1.Sfixed64Map[i] {
			return fmt.Errorf("Sfixed64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sfixed64Map[i], i, that1.Sfixed64Map[i])
		}
	}
	if len(this.BoolMap) != len(that1.BoolMap) {
		return fmt.Errorf("BoolMap this(%v) Not Equal that(%v)", len(this.BoolMap), len(that1.BoolMap))
	}
	for i := range this.BoolMap {
		if this.BoolMap[i] != that1.BoolMap[i] {
			return fmt.Errorf("BoolMap this[%v](%v) Not Equal that[%v](%v)", i, this.BoolMap[i], i, that1.BoolMap[i])
		}
	}
	if len(this.StringMap) != len(that1.StringMap) {
		return fmt.Errorf("StringMap this(%v) Not Equal that(%v)", len(this.StringMap), len(that1.StringMap))
	}
	for i := range this.StringMap {
		if this.StringMap[i] != that1.StringMap[i] {
			return fmt.Errorf("StringMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringMap[i], i, that1.StringMap[i])
		}
	}
	if len(this.StringToBytesMap) != len(that1.StringToBytesMap) {
		return fmt.Errorf("StringToBytesMap this(%v) Not Equal that(%v)", len(this.StringToBytesMap), len(that1.StringToBytesMap))
	}
	for i := range this.StringToBytesMap {
		if !bytes.Equal(this.StringToBytesMap[i], that1.StringToBytesMap[i]) {
			return fmt.Errorf("StringToBytesMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToBytesMap[i], i, that1.StringToBytesMap[i])
		}
	}
	if len(this.StringToEnumMap) != len(that1.StringToEnumMap) {
		return fmt.Errorf("StringToEnumMap this(%v) Not Equal that(%v)", len(this.StringToEnumMap), len(that1.StringToEnumMap))
	}
	for i := range this.StringToEnumMap {
		if this.StringToEnumMap[i] != that1.StringToEnumMap[i] {
			return fmt.Errorf("StringToEnumMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToEnumMap[i], i, that1.StringToEnumMap[i])
		}
	}
	if len(this.StringToMsgMap) != len(that1.StringToMsgMap) {
		return fmt.Errorf("StringToMsgMap this(%v) Not Equal that(%v)", len(this.StringToMsgMap), len(that1.StringToMsgMap))
	}
	for i := range this.StringToMsgMap {
		if !this.StringToMsgMap[i].Equal(that1.StringToMsgMap[i]) {
			return fmt.Errorf("StringToMsgMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToMsgMap[i], i, that1.StringToMsgMap[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *AllMaps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllMaps)
	if !ok {
		that2, ok := that.(AllMaps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StringToDoubleMap) != len(that1.StringToDoubleMap) {
		return false
	}
	for i := range this.StringToDoubleMap {
		if this.StringToDoubleMap[i] != that1.StringToDoubleMap[i] {
			return false
		}
	}
	if len(this.StringToFloatMap) != len(that1.StringToFloatMap) {
		return false
	}
	for i := range this.StringToFloatMap {
		if this.StringToFloatMap[i] != that1.StringToFloatMap[i] {
			return false
		}
	}
	if len(this.Int32Map) != len(that1.Int32Map) {
		return false
	}
	for i := range this.Int32Map {
		if this.Int32Map[i] != that1.Int32Map[i] {
			return false
		}
	}
	if len(this.Int64Map) != len(that1.Int64Map) {
		return false
	}
	for i := range this.Int64Map {
		if this.Int64Map[i] != that1.Int64Map[i] {
			return false
		}
	}
	if len(this.Uint32Map) != len(that1.Uint32Map) {
		return false
	}
	for i := range this.Uint32Map {
		if this.Uint32Map[i] != that1.Uint32Map[i] {
			return false
		}
	}
	if len(this.Uint64Map) != len(that1.Uint64Map) {
		return false
	}
	for i := range this.Uint64Map {
		if this.Uint64Map[i] != that1.Uint64Map[i] {
			return false
		}
	}
	if len(this.Sint32Map) != len(that1.Sint32Map) {
		return false
	}
	for i := range this.Sint32Map {
		if this.Sint32Map[i] != that1.Sint32Map[i] {
			return false
		}
	}
	if len(this.Sint64Map) != len(that1.Sint64Map) {
		return false
	}
	for i := range this.Sint64Map {
		if this.Sint64Map[i] != that1.Sint64Map[i] {
			return false
		}
	}
	if len(this.Fixed32Map) != len(that1.Fixed32Map) {
		return false
	}
	for i := range this.Fixed32Map {
		if this.Fixed32Map[i] != that1.Fixed32Map[i] {
			return false
		}
	}
	if len(this.Sfixed32Map) != len(that1.Sfixed32Map) {
		return false
	}
	for i := range this.Sfixed32Map {
		if this.Sfixed32Map[i] != that1.Sfixed32Map[i] {
			return false
		}
	}
	if len(this.Fixed64Map) != len(that1.Fixed64Map) {
		return false
	}
	for i := range this.Fixed64Map {
		if this.Fixed64Map[i] != that1.Fixed64Map[i] {
			return false
		}
	}
	if len(this.Sfixed64Map) != len(that1.Sfixed64Map) {
		return false
	}
	for i := range this.Sfixed64Map {
		if this.Sfixed64Map[i] != that1.Sfixed64Map[i] {
			return false
		}
	}
	if len(this.BoolMap) != len(that1.BoolMap) {
		return false
	}
	for i := range this.BoolMap {
		if this.BoolMap[i] != that1.BoolMap[i] {
			return false
		}
	}
	if len(this.StringMap) != len(that1.StringMap) {
		return false
	}
	for i := range this.StringMap {
		if this.StringMap[i] != that1.StringMap[i] {
			return false
		}
	}
	if len(this.StringToBytesMap) != len(that1.StringToBytesMap) {
		return false
	}
	for i := range this.StringToBytesMap {
		if !bytes.Equal(this.StringToBytesMap[i], that1.StringToBytesMap[i]) {
			return false
		}
	}
	if len(this.StringToEnumMap) != len(that1.StringToEnumMap) {
		return false
	}
	for i := range this.StringToEnumMap {
		if this.StringToEnumMap[i] != that1.StringToEnumMap[i] {
			return false
		}
	}
	if len(this.StringToMsgMap) != len(that1.StringToMsgMap) {
		return false
	}
	for i := range this.StringToMsgMap {
		if !this.StringToMsgMap[i].Equal(that1.StringToMsgMap[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AllMapsOrdered) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AllMapsOrdered)
	if !ok {
		that2, ok := that.(AllMapsOrdered)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AllMapsOrdered")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AllMapsOrdered but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AllMapsOrdered but is not nil && this == nil")
	}
	if len(this.StringToDoubleMap) != len(that1.StringToDoubleMap) {
		return fmt.Errorf("StringToDoubleMap this(%v) Not Equal that(%v)", len(this.StringToDoubleMap), len(that1.StringToDoubleMap))
	}
	for i := range this.StringToDoubleMap {
		if this.StringToDoubleMap[i] != that1.StringToDoubleMap[i] {
			return fmt.Errorf("StringToDoubleMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToDoubleMap[i], i, that1.StringToDoubleMap[i])
		}
	}
	if len(this.StringToFloatMap) != len(that1.StringToFloatMap) {
		return fmt.Errorf("StringToFloatMap this(%v) Not Equal that(%v)", len(this.StringToFloatMap), len(that1.StringToFloatMap))
	}
	for i := range this.StringToFloatMap {
		if this.StringToFloatMap[i] != that1.StringToFloatMap[i] {
			return fmt.Errorf("StringToFloatMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToFloatMap[i], i, that1.StringToFloatMap[i])
		}
	}
	if len(this.Int32Map) != len(that1.Int32Map) {
		return fmt.Errorf("Int32Map this(%v) Not Equal that(%v)", len(this.Int32Map), len(that1.Int32Map))
	}
	for i := range this.Int32Map {
		if this.Int32Map[i] != that1.Int32Map[i] {
			return fmt.Errorf("Int32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Int32Map[i], i, that1.Int32Map[i])
		}
	}
	if len(this.Int64Map) != len(that1.Int64Map) {
		return fmt.Errorf("Int64Map this(%v) Not Equal that(%v)", len(this.Int64Map), len(that1.Int64Map))
	}
	for i := range this.Int64Map {
		if this.Int64Map[i] != that1.Int64Map[i] {
			return fmt.Errorf("Int64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Int64Map[i], i, that1.Int64Map[i])
		}
	}
	if len(this.Uint32Map) != len(that1.Uint32Map) {
		return fmt.Errorf("Uint32Map this(%v) Not Equal that(%v)", len(this.Uint32Map), len(that1.Uint32Map))
	}
	for i := range this.Uint32Map {
		if this.Uint32Map[i] != that1.Uint32Map[i] {
			return fmt.Errorf("Uint32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Uint32Map[i], i, that1.Uint32Map[i])
		}
	}
	if len(this.Uint64Map) != len(that1.Uint64Map) {
		return fmt.Errorf("Uint64Map this(%v) Not Equal that(%v)", len(this.Uint64Map), len(that1.Uint64Map))
	}
	for i := range this.Uint64Map {
		if this.Uint64Map[i] != that1.Uint64Map[i] {
			return fmt.Errorf("Uint64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Uint64Map[i], i, that1.Uint64Map[i])
		}
	}
	if len(this.Sint32Map) != len(that1.Sint32Map) {
		return fmt.Errorf("Sint32Map this(%v) Not Equal that(%v)", len(this.Sint32Map), len(that1.Sint32Map))
	}
	for i := range this.Sint32Map {
		if this.Sint32Map[i] != that1.Sint32Map[i] {
			return fmt.Errorf("Sint32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sint32Map[i], i, that1.Sint32Map[i])
		}
	}
	if len(this.Sint64Map) != len(that1.Sint64Map) {
		return fmt.Errorf("Sint64Map this(%v) Not Equal that(%v)", len(this.Sint64Map), len(that1.Sint64Map))
	}
	for i := range this.Sint64Map {
		if this.Sint64Map[i] != that1.Sint64Map[i] {
			return fmt.Errorf("Sint64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sint64Map[i], i, that1.Sint64Map[i])
		}
	}
	if len(this.Fixed32Map) != len(that1.Fixed32Map) {
		return fmt.Errorf("Fixed32Map this(%v) Not Equal that(%v)", len(this.Fixed32Map), len(that1.Fixed32Map))
	}
	for i := range this.Fixed32Map {
		if this.Fixed32Map[i] != that1.Fixed32Map[i] {
			return fmt.Errorf("Fixed32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Fixed32Map[i], i, that1.Fixed32Map[i])
		}
	}
	if len(this.Sfixed32Map) != len(that1.Sfixed32Map) {
		return fmt.Errorf("Sfixed32Map this(%v) Not Equal that(%v)", len(this.Sfixed32Map), len(that1.Sfixed32Map))
	}
	for i := range this.Sfixed32Map {
		if this.Sfixed32Map[i] != that1.Sfixed32Map[i] {
			return fmt.Errorf("Sfixed32Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sfixed32Map[i], i, that1.Sfixed32Map[i])
		}
	}
	if len(this.Fixed64Map) != len(that1.Fixed64Map) {
		return fmt.Errorf("Fixed64Map this(%v) Not Equal that(%v)", len(this.Fixed64Map), len(that1.Fixed64Map))
	}
	for i := range this.Fixed64Map {
		if this.Fixed64Map[i] != that1.Fixed64Map[i] {
			return fmt.Errorf("Fixed64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Fixed64Map[i], i, that1.Fixed64Map[i])
		}
	}
	if len(this.Sfixed64Map) != len(that1.Sfixed64Map) {
		return fmt.Errorf("Sfixed64Map this(%v) Not Equal that(%v)", len(this.Sfixed64Map), len(that1.Sfixed64Map))
	}
	for i := range this.Sfixed64Map {
		if this.Sfixed64Map[i] != that1.Sfixed64Map[i] {
			return fmt.Errorf("Sfixed64Map this[%v](%v) Not Equal that[%v](%v)", i, this.Sfixed64Map[i], i, that1.Sfixed64Map[i])
		}
	}
	if len(this.BoolMap) != len(that1.BoolMap) {
		return fmt.Errorf("BoolMap this(%v) Not Equal that(%v)", len(this.BoolMap), len(that1.BoolMap))
	}
	for i := range this.BoolMap {
		if this.BoolMap[i] != that1.BoolMap[i] {
			return fmt.Errorf("BoolMap this[%v](%v) Not Equal that[%v](%v)", i, this.BoolMap[i], i, that1.BoolMap[i])
		}
	}
	if len(this.StringMap) != len(that1.StringMap) {
		return fmt.Errorf("StringMap this(%v) Not Equal that(%v)", len(this.StringMap), len(that1.StringMap))
	}
	for i := range this.StringMap {
		if this.StringMap[i] != that1.StringMap[i] {
			return fmt.Errorf("StringMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringMap[i], i, that1.StringMap[i])
		}
	}
	if len(this.StringToBytesMap) != len(that1.StringToBytesMap) {
		return fmt.Errorf("StringToBytesMap this(%v) Not Equal that(%v)", len(this.StringToBytesMap), len(that1.StringToBytesMap))
	}
	for i := range this.StringToBytesMap {
		if !bytes.Equal(this.StringToBytesMap[i], that1.StringToBytesMap[i]) {
			return fmt.Errorf("StringToBytesMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToBytesMap[i], i, that1.StringToBytesMap[i])
		}
	}
	if len(this.StringToEnumMap) != len(that1.StringToEnumMap) {
		return fmt.Errorf("StringToEnumMap this(%v) Not Equal that(%v)", len(this.StringToEnumMap), len(that1.StringToEnumMap))
	}
	for i := range this.StringToEnumMap {
		if this.StringToEnumMap[i] != that1.StringToEnumMap[i] {
			return fmt.Errorf("StringToEnumMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToEnumMap[i], i, that1.StringToEnumMap[i])
		}
	}
	if len(this.StringToMsgMap) != len(that1.StringToMsgMap) {
		return fmt.Errorf("StringToMsgMap this(%v) Not Equal that(%v)", len(this.StringToMsgMap), len(that1.StringToMsgMap))
	}
	for i := range this.StringToMsgMap {
		if !this.StringToMsgMap[i].Equal(that1.StringToMsgMap[i]) {
			return fmt.Errorf("StringToMsgMap this[%v](%v) Not Equal that[%v](%v)", i, this.StringToMsgMap[i], i, that1.StringToMsgMap[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *AllMapsOrdered) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllMapsOrdered)
	if !ok {
		that2, ok := that.(AllMapsOrdered)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StringToDoubleMap) != len(that1.StringToDoubleMap) {
		return false
	}
	for i := range this.StringToDoubleMap {
		if this.StringToDoubleMap[i] != that1.StringToDoubleMap[i] {
			return false
		}
	}
	if len(this.StringToFloatMap) != len(that1.StringToFloatMap) {
		return false
	}
	for i := range this.StringToFloatMap {
		if this.StringToFloatMap[i] != that1.StringToFloatMap[i] {
			return false
		}
	}
	if len(this.Int32Map) != len(that1.Int32Map) {
		return false
	}
	for i := range this.Int32Map {
		if this.Int32Map[i] != that1.Int32Map[i] {
			return false
		}
	}
	if len(this.Int64Map) != len(that1.Int64Map) {
		return false
	}
	for i := range this.Int64Map {
		if this.Int64Map[i] != that1.Int64Map[i] {
			return false
		}
	}
	if len(this.Uint32Map) != len(that1.Uint32Map) {
		return false
	}
	for i := range this.Uint32Map {
		if this.Uint32Map[i] != that1.Uint32Map[i] {
			return false
		}
	}
	if len(this.Uint64Map) != len(that1.Uint64Map) {
		return false
	}
	for i := range this.Uint64Map {
		if this.Uint64Map[i] != that1.Uint64Map[i] {
			return false
		}
	}
	if len(this.Sint32Map) != len(that1.Sint32Map) {
		return false
	}
	for i := range this.Sint32Map {
		if this.Sint32Map[i] != that1.Sint32Map[i] {
			return false
		}
	}
	if len(this.Sint64Map) != len(that1.Sint64Map) {
		return false
	}
	for i := range this.Sint64Map {
		if this.Sint64Map[i] != that1.Sint64Map[i] {
			return false
		}
	}
	if len(this.Fixed32Map) != len(that1.Fixed32Map) {
		return false
	}
	for i := range this.Fixed32Map {
		if this.Fixed32Map[i] != that1.Fixed32Map[i] {
			return false
		}
	}
	if len(this.Sfixed32Map) != len(that1.Sfixed32Map) {
		return false
	}
	for i := range this.Sfixed32Map {
		if this.Sfixed32Map[i] != that1.Sfixed32Map[i] {
			return false
		}
	}
	if len(this.Fixed64Map) != len(that1.Fixed64Map) {
		return false
	}
	for i := range this.Fixed64Map {
		if this.Fixed64Map[i] != that1.Fixed64Map[i] {
			return false
		}
	}
	if len(this.Sfixed64Map) != len(that1.Sfixed64Map) {
		return false
	}
	for i := range this.Sfixed64Map {
		if this.Sfixed64Map[i] != that1.Sfixed64Map[i] {
			return false
		}
	}
	if len(this.BoolMap) != len(that1.BoolMap) {
		return false
	}
	for i := range this.BoolMap {
		if this.BoolMap[i] != that1.BoolMap[i] {
			return false
		}
	}
	if len(this.StringMap) != len(that1.StringMap) {
		return false
	}
	for i := range this.StringMap {
		if this.StringMap[i] != that1.StringMap[i] {
			return false
		}
	}
	if len(this.StringToBytesMap) != len(that1.StringToBytesMap) {
		return false
	}
	for i := range this.StringToBytesMap {
		if !bytes.Equal(this.StringToBytesMap[i], that1.StringToBytesMap[i]) {
			return false
		}
	}
	if len(this.StringToEnumMap) != len(that1.StringToEnumMap) {
		return false
	}
	for i := range this.StringToEnumMap {
		if this.StringToEnumMap[i] != that1.StringToEnumMap[i] {
			return false
		}
	}
	if len(this.StringToMsgMap) != len(that1.StringToMsgMap) {
		return false
	}
	for i := range this.StringToMsgMap {
		if !this.StringToMsgMap[i].Equal(that1.StringToMsgMap[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MessageWithMap) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MessageWithMap)
	if !ok {
		that2, ok := that.(MessageWithMap)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MessageWithMap")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MessageWithMap but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MessageWithMap but is not nil && this == nil")
	}
	if len(this.NameMapping) != len(that1.NameMapping) {
		return fmt.Errorf("NameMapping this(%v) Not Equal that(%v)", len(this.NameMapping), len(that1.NameMapping))
	}
	for i := range this.NameMapping {
		if this.NameMapping[i] != that1.NameMapping[i] {
			return fmt.Errorf("NameMapping this[%v](%v) Not Equal that[%v](%v)", i, this.NameMapping[i], i, that1.NameMapping[i])
		}
	}
	if len(this.MsgMapping) != len(that1.MsgMapping) {
		return fmt.Errorf("MsgMapping this(%v) Not Equal that(%v)", len(this.MsgMapping), len(that1.MsgMapping))
	}
	for i := range this.MsgMapping {
		if !this.MsgMapping[i].Equal(that1.MsgMapping[i]) {
			return fmt.Errorf("MsgMapping this[%v](%v) Not Equal that[%v](%v)", i, this.MsgMapping[i], i, that1.MsgMapping[i])
		}
	}
	if len(this.ByteMapping) != len(that1.ByteMapping) {
		return fmt.Errorf("ByteMapping this(%v) Not Equal that(%v)", len(this.ByteMapping), len(that1.ByteMapping))
	}
	for i := range this.ByteMapping {
		if !bytes.Equal(this.ByteMapping[i], that1.ByteMapping[i]) {
			return fmt.Errorf("ByteMapping this[%v](%v) Not Equal that[%v](%v)", i, this.ByteMapping[i], i, that1.ByteMapping[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *MessageWithMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageWithMap)
	if !ok {
		that2, ok := that.(MessageWithMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.NameMapping) != len(that1.NameMapping) {
		return false
	}
	for i := range this.NameMapping {
		if this.NameMapping[i] != that1.NameMapping[i] {
			return false
		}
	}
	if len(this.MsgMapping) != len(that1.MsgMapping) {
		return false
	}
	for i := range this.MsgMapping {
		if !this.MsgMapping[i].Equal(that1.MsgMapping[i]) {
			return false
		}
	}
	if len(this.ByteMapping) != len(that1.ByteMapping) {
		return false
	}
	for i := range this.ByteMapping {
		if !bytes.Equal(this.ByteMapping[i], that1.ByteMapping[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FloatingPoint) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FloatingPoint)
	if !ok {
		that2, ok := that.(FloatingPoint)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FloatingPoint")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FloatingPoint but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FloatingPoint but is not nil && this == nil")
	}
	if this.F != that1.F {
		return fmt.Errorf("F this(%v) Not Equal that(%v)", this.F, that1.F)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *FloatingPoint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FloatingPoint)
	if !ok {
		that2, ok := that.(FloatingPoint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.F != that1.F {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Uint128Pair) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Uint128Pair)
	if !ok {
		that2, ok := that.(Uint128Pair)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Uint128Pair")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Uint128Pair but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Uint128Pair but is not nil && this == nil")
	}
	if !this.Left.Equal(that1.Left) {
		return fmt.Errorf("Left this(%v) Not Equal that(%v)", this.Left, that1.Left)
	}
	if that1.Right == nil {
		if this.Right != nil {
			return fmt.Errorf("this.Right != nil && that1.Right == nil")
		}
	} else if !this.Right.Equal(*that1.Right) {
		return fmt.Errorf("Right this(%v) Not Equal that(%v)", this.Right, that1.Right)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Uint128Pair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Uint128Pair)
	if !ok {
		that2, ok := that.(Uint128Pair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Left.Equal(that1.Left) {
		return false
	}
	if that1.Right == nil {
		if this.Right != nil {
			return false
		}
	} else if !this.Right.Equal(*that1.Right) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ContainsNestedMap) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainsNestedMap)
	if !ok {
		that2, ok := that.(ContainsNestedMap)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainsNestedMap")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainsNestedMap but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainsNestedMap but is not nil && this == nil")
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ContainsNestedMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainsNestedMap)
	if !ok {
		that2, ok := that.(ContainsNestedMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ContainsNestedMap_NestedMap) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ContainsNestedMap_NestedMap)
	if !ok {
		that2, ok := that.(ContainsNestedMap_NestedMap)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ContainsNestedMap_NestedMap")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ContainsNestedMap_NestedMap but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ContainsNestedMap_NestedMap but is not nil && this == nil")
	}
	if len(this.NestedMapField) != len(that1.NestedMapField) {
		return fmt.Errorf("NestedMapField this(%v) Not Equal that(%v)", len(this.NestedMapField), len(that1.NestedMapField))
	}
	for i := range this.NestedMapField {
		if this.NestedMapField[i] != that1.NestedMapField[i] {
			return fmt.Errorf("NestedMapField this[%v](%v) Not Equal that[%v](%v)", i, this.NestedMapField[i], i, that1.NestedMapField[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ContainsNestedMap_NestedMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainsNestedMap_NestedMap)
	if !ok {
		that2, ok := that.(ContainsNestedMap_NestedMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.NestedMapField) != len(that1.NestedMapField) {
		return false
	}
	for i := range this.NestedMapField {
		if this.NestedMapField[i] != that1.NestedMapField[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *NotPacked) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NotPacked)
	if !ok {
		that2, ok := that.(NotPacked)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *NotPacked")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NotPacked but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NotPacked but is not nil && this == nil")
	}
	if len(this.Key) != len(that1.Key) {
		return fmt.Errorf("Key this(%v) Not Equal that(%v)", len(this.Key), len(that1.Key))
	}
	for i := range this.Key {
		if this.Key[i] != that1.Key[i] {
			return fmt.Errorf("Key this[%v](%v) Not Equal that[%v](%v)", i, this.Key[i], i, that1.Key[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *NotPacked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NotPacked)
	if !ok {
		that2, ok := that.(NotPacked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Key) != len(that1.Key) {
		return false
	}
	for i := range this.Key {
		if this.Key[i] != that1.Key[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

type MessageFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetName() string
	GetHilarity() Message_Humour
	GetHeightInCm() uint32
	GetData() []byte
	GetResultCount() int64
	GetTrueScotsman() bool
	GetScore() float32
	GetKey() []uint64
	GetNested() *Nested
	GetTerrain() map[int64]*Nested
	GetProto2Field() *both.NinOptNative
	GetProto2Value() map[int64]*both.NinOptEnum
}

func (this *Message) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *Message) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewMessageFromFace(this)
}

func (this *Message) GetName() string {
	return this.Name
}

func (this *Message) GetHilarity() Message_Humour {
	return this.Hilarity
}

func (this *Message) GetHeightInCm() uint32 {
	return this.HeightInCm
}

func (this *Message) GetData() []byte {
	return this.Data
}

func (this *Message) GetResultCount() int64 {
	return this.ResultCount
}

func (this *Message) GetTrueScotsman() bool {
	return this.TrueScotsman
}

func (this *Message) GetScore() float32 {
	return this.Score
}

func (this *Message) GetKey() []uint64 {
	return this.Key
}

func (this *Message) GetNested() *Nested {
	return this.Nested
}

func (this *Message) GetTerrain() map[int64]*Nested {
	return this.Terrain
}

func (this *Message) GetProto2Field() *both.NinOptNative {
	return this.Proto2Field
}

func (this *Message) GetProto2Value() map[int64]*both.NinOptEnum {
	return this.Proto2Value
}

func NewMessageFromFace(that MessageFace) *Message {
	this := &Message{}
	this.Name = that.GetName()
	this.Hilarity = that.GetHilarity()
	this.HeightInCm = that.GetHeightInCm()
	this.Data = that.GetData()
	this.ResultCount = that.GetResultCount()
	this.TrueScotsman = that.GetTrueScotsman()
	this.Score = that.GetScore()
	this.Key = that.GetKey()
	this.Nested = that.GetNested()
	this.Terrain = that.GetTerrain()
	this.Proto2Field = that.GetProto2Field()
	this.Proto2Value = that.GetProto2Value()
	return this
}

type NestedFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetBunny() string
}

func (this *Nested) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *Nested) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewNestedFromFace(this)
}

func (this *Nested) GetBunny() string {
	return this.Bunny
}

func NewNestedFromFace(that NestedFace) *Nested {
	this := &Nested{}
	this.Bunny = that.GetBunny()
	return this
}

type AllMapsFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetStringToDoubleMap() map[string]float64
	GetStringToFloatMap() map[string]float32
	GetInt32Map() map[int32]int32
	GetInt64Map() map[int64]int64
	GetUint32Map() map[uint32]uint32
	GetUint64Map() map[uint64]uint64
	GetSint32Map() map[int32]int32
	GetSint64Map() map[int64]int64
	GetFixed32Map() map[uint32]uint32
	GetSfixed32Map() map[int32]int32
	GetFixed64Map() map[uint64]uint64
	GetSfixed64Map() map[int64]int64
	GetBoolMap() map[bool]bool
	GetStringMap() map[string]string
	GetStringToBytesMap() map[string][]byte
	GetStringToEnumMap() map[string]MapEnum
	GetStringToMsgMap() map[string]*FloatingPoint
}

func (this *AllMaps) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *AllMaps) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewAllMapsFromFace(this)
}

func (this *AllMaps) GetStringToDoubleMap() map[string]float64 {
	return this.StringToDoubleMap
}

func (this *AllMaps) GetStringToFloatMap() map[string]float32 {
	return this.StringToFloatMap
}

func (this *AllMaps) GetInt32Map() map[int32]int32 {
	return this.Int32Map
}

func (this *AllMaps) GetInt64Map() map[int64]int64 {
	return this.Int64Map
}

func (this *AllMaps) GetUint32Map() map[uint32]uint32 {
	return this.Uint32Map
}

func (this *AllMaps) GetUint64Map() map[uint64]uint64 {
	return this.Uint64Map
}

func (this *AllMaps) GetSint32Map() map[int32]int32 {
	return this.Sint32Map
}

func (this *AllMaps) GetSint64Map() map[int64]int64 {
	return this.Sint64Map
}

func (this *AllMaps) GetFixed32Map() map[uint32]uint32 {
	return this.Fixed32Map
}

func (this *AllMaps) GetSfixed32Map() map[int32]int32 {
	return this.Sfixed32Map
}

func (this *AllMaps) GetFixed64Map() map[uint64]uint64 {
	return this.Fixed64Map
}

func (this *AllMaps) GetSfixed64Map() map[int64]int64 {
	return this.Sfixed64Map
}

func (this *AllMaps) GetBoolMap() map[bool]bool {
	return this.BoolMap
}

func (this *AllMaps) GetStringMap() map[string]string {
	return this.StringMap
}

func (this *AllMaps) GetStringToBytesMap() map[string][]byte {
	return this.StringToBytesMap
}

func (this *AllMaps) GetStringToEnumMap() map[string]MapEnum {
	return this.StringToEnumMap
}

func (this *AllMaps) GetStringToMsgMap() map[string]*FloatingPoint {
	return this.StringToMsgMap
}

func NewAllMapsFromFace(that AllMapsFace) *AllMaps {
	this := &AllMaps{}
	this.StringToDoubleMap = that.GetStringToDoubleMap()
	this.StringToFloatMap = that.GetStringToFloatMap()
	this.Int32Map = that.GetInt32Map()
	this.Int64Map = that.GetInt64Map()
	this.Uint32Map = that.GetUint32Map()
	this.Uint64Map = that.GetUint64Map()
	this.Sint32Map = that.GetSint32Map()
	this.Sint64Map = that.GetSint64Map()
	this.Fixed32Map = that.GetFixed32Map()
	this.Sfixed32Map = that.GetSfixed32Map()
	this.Fixed64Map = that.GetFixed64Map()
	this.Sfixed64Map = that.GetSfixed64Map()
	this.BoolMap = that.GetBoolMap()
	this.StringMap = that.GetStringMap()
	this.StringToBytesMap = that.GetStringToBytesMap()
	this.StringToEnumMap = that.GetStringToEnumMap()
	this.StringToMsgMap = that.GetStringToMsgMap()
	return this
}

type AllMapsOrderedFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetStringToDoubleMap() map[string]float64
	GetStringToFloatMap() map[string]float32
	GetInt32Map() map[int32]int32
	GetInt64Map() map[int64]int64
	GetUint32Map() map[uint32]uint32
	GetUint64Map() map[uint64]uint64
	GetSint32Map() map[int32]int32
	GetSint64Map() map[int64]int64
	GetFixed32Map() map[uint32]uint32
	GetSfixed32Map() map[int32]int32
	GetFixed64Map() map[uint64]uint64
	GetSfixed64Map() map[int64]int64
	GetBoolMap() map[bool]bool
	GetStringMap() map[string]string
	GetStringToBytesMap() map[string][]byte
	GetStringToEnumMap() map[string]MapEnum
	GetStringToMsgMap() map[string]*FloatingPoint
}

func (this *AllMapsOrdered) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *AllMapsOrdered) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewAllMapsOrderedFromFace(this)
}

func (this *AllMapsOrdered) GetStringToDoubleMap() map[string]float64 {
	return this.StringToDoubleMap
}

func (this *AllMapsOrdered) GetStringToFloatMap() map[string]float32 {
	return this.StringToFloatMap
}

func (this *AllMapsOrdered) GetInt32Map() map[int32]int32 {
	return this.Int32Map
}

func (this *AllMapsOrdered) GetInt64Map() map[int64]int64 {
	return this.Int64Map
}

func (this *AllMapsOrdered) GetUint32Map() map[uint32]uint32 {
	return this.Uint32Map
}

func (this *AllMapsOrdered) GetUint64Map() map[uint64]uint64 {
	return this.Uint64Map
}

func (this *AllMapsOrdered) GetSint32Map() map[int32]int32 {
	return this.Sint32Map
}

func (this *AllMapsOrdered) GetSint64Map() map[int64]int64 {
	return this.Sint64Map
}

func (this *AllMapsOrdered) GetFixed32Map() map[uint32]uint32 {
	return this.Fixed32Map
}

func (this *AllMapsOrdered) GetSfixed32Map() map[int32]int32 {
	return this.Sfixed32Map
}

func (this *AllMapsOrdered) GetFixed64Map() map[uint64]uint64 {
	return this.Fixed64Map
}

func (this *AllMapsOrdered) GetSfixed64Map() map[int64]int64 {
	return this.Sfixed64Map
}

func (this *AllMapsOrdered) GetBoolMap() map[bool]bool {
	return this.BoolMap
}

func (this *AllMapsOrdered) GetStringMap() map[string]string {
	return this.StringMap
}

func (this *AllMapsOrdered) GetStringToBytesMap() map[string][]byte {
	return this.StringToBytesMap
}

func (this *AllMapsOrdered) GetStringToEnumMap() map[string]MapEnum {
	return this.StringToEnumMap
}

func (this *AllMapsOrdered) GetStringToMsgMap() map[string]*FloatingPoint {
	return this.StringToMsgMap
}

func NewAllMapsOrderedFromFace(that AllMapsOrderedFace) *AllMapsOrdered {
	this := &AllMapsOrdered{}
	this.StringToDoubleMap = that.GetStringToDoubleMap()
	this.StringToFloatMap = that.GetStringToFloatMap()
	this.Int32Map = that.GetInt32Map()
	this.Int64Map = that.GetInt64Map()
	this.Uint32Map = that.GetUint32Map()
	this.Uint64Map = that.GetUint64Map()
	this.Sint32Map = that.GetSint32Map()
	this.Sint64Map = that.GetSint64Map()
	this.Fixed32Map = that.GetFixed32Map()
	this.Sfixed32Map = that.GetSfixed32Map()
	this.Fixed64Map = that.GetFixed64Map()
	this.Sfixed64Map = that.GetSfixed64Map()
	this.BoolMap = that.GetBoolMap()
	this.StringMap = that.GetStringMap()
	this.StringToBytesMap = that.GetStringToBytesMap()
	this.StringToEnumMap = that.GetStringToEnumMap()
	this.StringToMsgMap = that.GetStringToMsgMap()
	return this
}

type MessageWithMapFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetNameMapping() map[int32]string
	GetMsgMapping() map[int64]*FloatingPoint
	GetByteMapping() map[bool][]byte
}

func (this *MessageWithMap) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *MessageWithMap) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewMessageWithMapFromFace(this)
}

func (this *MessageWithMap) GetNameMapping() map[int32]string {
	return this.NameMapping
}

func (this *MessageWithMap) GetMsgMapping() map[int64]*FloatingPoint {
	return this.MsgMapping
}

func (this *MessageWithMap) GetByteMapping() map[bool][]byte {
	return this.ByteMapping
}

func NewMessageWithMapFromFace(that MessageWithMapFace) *MessageWithMap {
	this := &MessageWithMap{}
	this.NameMapping = that.GetNameMapping()
	this.MsgMapping = that.GetMsgMapping()
	this.ByteMapping = that.GetByteMapping()
	return this
}

type FloatingPointFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetF() float64
}

func (this *FloatingPoint) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *FloatingPoint) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewFloatingPointFromFace(this)
}

func (this *FloatingPoint) GetF() float64 {
	return this.F
}

func NewFloatingPointFromFace(that FloatingPointFace) *FloatingPoint {
	this := &FloatingPoint{}
	this.F = that.GetF()
	return this
}

type Uint128PairFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetLeft() github_com_gogo_protobuf_test_custom.Uint128
	GetRight() *github_com_gogo_protobuf_test_custom.Uint128
}

func (this *Uint128Pair) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *Uint128Pair) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewUint128PairFromFace(this)
}

func (this *Uint128Pair) GetLeft() github_com_gogo_protobuf_test_custom.Uint128 {
	return this.Left
}

func (this *Uint128Pair) GetRight() *github_com_gogo_protobuf_test_custom.Uint128 {
	return this.Right
}

func NewUint128PairFromFace(that Uint128PairFace) *Uint128Pair {
	this := &Uint128Pair{}
	this.Left = that.GetLeft()
	this.Right = that.GetRight()
	return this
}

type ContainsNestedMapFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
}

func (this *ContainsNestedMap) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *ContainsNestedMap) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewContainsNestedMapFromFace(this)
}

func NewContainsNestedMapFromFace(that ContainsNestedMapFace) *ContainsNestedMap {
	this := &ContainsNestedMap{}
	return this
}

type ContainsNestedMap_NestedMapFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetNestedMapField() map[string]float64
}

func (this *ContainsNestedMap_NestedMap) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *ContainsNestedMap_NestedMap) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewContainsNestedMap_NestedMapFromFace(this)
}

func (this *ContainsNestedMap_NestedMap) GetNestedMapField() map[string]float64 {
	return this.NestedMapField
}

func NewContainsNestedMap_NestedMapFromFace(that ContainsNestedMap_NestedMapFace) *ContainsNestedMap_NestedMap {
	this := &ContainsNestedMap_NestedMap{}
	this.NestedMapField = that.GetNestedMapField()
	return this
}

type NotPackedFace interface {
	Proto() github_com_gogo_protobuf_proto.Message
	GetKey() []uint64
}

func (this *NotPacked) Proto() github_com_gogo_protobuf_proto.Message {
	return this
}

func (this *NotPacked) TestProto() github_com_gogo_protobuf_proto.Message {
	return NewNotPackedFromFace(this)
}

func (this *NotPacked) GetKey() []uint64 {
	return this.Key
}

func NewNotPackedFromFace(that NotPackedFace) *NotPacked {
	this := &NotPacked{}
	this.Key = that.GetKey()
	return this
}

func (this *Message) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&theproto3.Message{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Hilarity: "+fmt.Sprintf("%#v", this.Hilarity)+",\n")
	s = append(s, "HeightInCm: "+fmt.Sprintf("%#v", this.HeightInCm)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "ResultCount: "+fmt.Sprintf("%#v", this.ResultCount)+",\n")
	s = append(s, "TrueScotsman: "+fmt.Sprintf("%#v", this.TrueScotsman)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Nested != nil {
		s = append(s, "Nested: "+fmt.Sprintf("%#v", this.Nested)+",\n")
	}
	keysForTerrain := make([]int64, 0, len(this.Terrain))
	for k := range this.Terrain {
		keysForTerrain = append(keysForTerrain, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForTerrain)
	mapStringForTerrain := "map[int64]*Nested{"
	for _, k := range keysForTerrain {
		mapStringForTerrain += fmt.Sprintf("%#v: %#v,", k, this.Terrain[k])
	}
	mapStringForTerrain += "}"
	if this.Terrain != nil {
		s = append(s, "Terrain: "+mapStringForTerrain+",\n")
	}
	if this.Proto2Field != nil {
		s = append(s, "Proto2Field: "+fmt.Sprintf("%#v", this.Proto2Field)+",\n")
	}
	keysForProto2Value := make([]int64, 0, len(this.Proto2Value))
	for k := range this.Proto2Value {
		keysForProto2Value = append(keysForProto2Value, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForProto2Value)
	mapStringForProto2Value := "map[int64]*both.NinOptEnum{"
	for _, k := range keysForProto2Value {
		mapStringForProto2Value += fmt.Sprintf("%#v: %#v,", k, this.Proto2Value[k])
	}
	mapStringForProto2Value += "}"
	if this.Proto2Value != nil {
		s = append(s, "Proto2Value: "+mapStringForProto2Value+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Nested) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&theproto3.Nested{")
	s = append(s, "Bunny: "+fmt.Sprintf("%#v", this.Bunny)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllMaps) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&theproto3.AllMaps{")
	keysForStringToDoubleMap := make([]string, 0, len(this.StringToDoubleMap))
	for k := range this.StringToDoubleMap {
		keysForStringToDoubleMap = append(keysForStringToDoubleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToDoubleMap)
	mapStringForStringToDoubleMap := "map[string]float64{"
	for _, k := range keysForStringToDoubleMap {
		mapStringForStringToDoubleMap += fmt.Sprintf("%#v: %#v,", k, this.StringToDoubleMap[k])
	}
	mapStringForStringToDoubleMap += "}"
	if this.StringToDoubleMap != nil {
		s = append(s, "StringToDoubleMap: "+mapStringForStringToDoubleMap+",\n")
	}
	keysForStringToFloatMap := make([]string, 0, len(this.StringToFloatMap))
	for k := range this.StringToFloatMap {
		keysForStringToFloatMap = append(keysForStringToFloatMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToFloatMap)
	mapStringForStringToFloatMap := "map[string]float32{"
	for _, k := range keysForStringToFloatMap {
		mapStringForStringToFloatMap += fmt.Sprintf("%#v: %#v,", k, this.StringToFloatMap[k])
	}
	mapStringForStringToFloatMap += "}"
	if this.StringToFloatMap != nil {
		s = append(s, "StringToFloatMap: "+mapStringForStringToFloatMap+",\n")
	}
	keysForInt32Map := make([]int32, 0, len(this.Int32Map))
	for k := range this.Int32Map {
		keysForInt32Map = append(keysForInt32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInt32Map)
	mapStringForInt32Map := "map[int32]int32{"
	for _, k := range keysForInt32Map {
		mapStringForInt32Map += fmt.Sprintf("%#v: %#v,", k, this.Int32Map[k])
	}
	mapStringForInt32Map += "}"
	if this.Int32Map != nil {
		s = append(s, "Int32Map: "+mapStringForInt32Map+",\n")
	}
	keysForInt64Map := make([]int64, 0, len(this.Int64Map))
	for k := range this.Int64Map {
		keysForInt64Map = append(keysForInt64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForInt64Map)
	mapStringForInt64Map := "map[int64]int64{"
	for _, k := range keysForInt64Map {
		mapStringForInt64Map += fmt.Sprintf("%#v: %#v,", k, this.Int64Map[k])
	}
	mapStringForInt64Map += "}"
	if this.Int64Map != nil {
		s = append(s, "Int64Map: "+mapStringForInt64Map+",\n")
	}
	keysForUint32Map := make([]uint32, 0, len(this.Uint32Map))
	for k := range this.Uint32Map {
		keysForUint32Map = append(keysForUint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForUint32Map)
	mapStringForUint32Map := "map[uint32]uint32{"
	for _, k := range keysForUint32Map {
		mapStringForUint32Map += fmt.Sprintf("%#v: %#v,", k, this.Uint32Map[k])
	}
	mapStringForUint32Map += "}"
	if this.Uint32Map != nil {
		s = append(s, "Uint32Map: "+mapStringForUint32Map+",\n")
	}
	keysForUint64Map := make([]uint64, 0, len(this.Uint64Map))
	for k := range this.Uint64Map {
		keysForUint64Map = append(keysForUint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForUint64Map)
	mapStringForUint64Map := "map[uint64]uint64{"
	for _, k := range keysForUint64Map {
		mapStringForUint64Map += fmt.Sprintf("%#v: %#v,", k, this.Uint64Map[k])
	}
	mapStringForUint64Map += "}"
	if this.Uint64Map != nil {
		s = append(s, "Uint64Map: "+mapStringForUint64Map+",\n")
	}
	keysForSint32Map := make([]int32, 0, len(this.Sint32Map))
	for k := range this.Sint32Map {
		keysForSint32Map = append(keysForSint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSint32Map)
	mapStringForSint32Map := "map[int32]int32{"
	for _, k := range keysForSint32Map {
		mapStringForSint32Map += fmt.Sprintf("%#v: %#v,", k, this.Sint32Map[k])
	}
	mapStringForSint32Map += "}"
	if this.Sint32Map != nil {
		s = append(s, "Sint32Map: "+mapStringForSint32Map+",\n")
	}
	keysForSint64Map := make([]int64, 0, len(this.Sint64Map))
	for k := range this.Sint64Map {
		keysForSint64Map = append(keysForSint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSint64Map)
	mapStringForSint64Map := "map[int64]int64{"
	for _, k := range keysForSint64Map {
		mapStringForSint64Map += fmt.Sprintf("%#v: %#v,", k, this.Sint64Map[k])
	}
	mapStringForSint64Map += "}"
	if this.Sint64Map != nil {
		s = append(s, "Sint64Map: "+mapStringForSint64Map+",\n")
	}
	keysForFixed32Map := make([]uint32, 0, len(this.Fixed32Map))
	for k := range this.Fixed32Map {
		keysForFixed32Map = append(keysForFixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFixed32Map)
	mapStringForFixed32Map := "map[uint32]uint32{"
	for _, k := range keysForFixed32Map {
		mapStringForFixed32Map += fmt.Sprintf("%#v: %#v,", k, this.Fixed32Map[k])
	}
	mapStringForFixed32Map += "}"
	if this.Fixed32Map != nil {
		s = append(s, "Fixed32Map: "+mapStringForFixed32Map+",\n")
	}
	keysForSfixed32Map := make([]int32, 0, len(this.Sfixed32Map))
	for k := range this.Sfixed32Map {
		keysForSfixed32Map = append(keysForSfixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSfixed32Map)
	mapStringForSfixed32Map := "map[int32]int32{"
	for _, k := range keysForSfixed32Map {
		mapStringForSfixed32Map += fmt.Sprintf("%#v: %#v,", k, this.Sfixed32Map[k])
	}
	mapStringForSfixed32Map += "}"
	if this.Sfixed32Map != nil {
		s = append(s, "Sfixed32Map: "+mapStringForSfixed32Map+",\n")
	}
	keysForFixed64Map := make([]uint64, 0, len(this.Fixed64Map))
	for k := range this.Fixed64Map {
		keysForFixed64Map = append(keysForFixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForFixed64Map)
	mapStringForFixed64Map := "map[uint64]uint64{"
	for _, k := range keysForFixed64Map {
		mapStringForFixed64Map += fmt.Sprintf("%#v: %#v,", k, this.Fixed64Map[k])
	}
	mapStringForFixed64Map += "}"
	if this.Fixed64Map != nil {
		s = append(s, "Fixed64Map: "+mapStringForFixed64Map+",\n")
	}
	keysForSfixed64Map := make([]int64, 0, len(this.Sfixed64Map))
	for k := range this.Sfixed64Map {
		keysForSfixed64Map = append(keysForSfixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSfixed64Map)
	mapStringForSfixed64Map := "map[int64]int64{"
	for _, k := range keysForSfixed64Map {
		mapStringForSfixed64Map += fmt.Sprintf("%#v: %#v,", k, this.Sfixed64Map[k])
	}
	mapStringForSfixed64Map += "}"
	if this.Sfixed64Map != nil {
		s = append(s, "Sfixed64Map: "+mapStringForSfixed64Map+",\n")
	}
	keysForBoolMap := make([]bool, 0, len(this.BoolMap))
	for k := range this.BoolMap {
		keysForBoolMap = append(keysForBoolMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForBoolMap)
	mapStringForBoolMap := "map[bool]bool{"
	for _, k := range keysForBoolMap {
		mapStringForBoolMap += fmt.Sprintf("%#v: %#v,", k, this.BoolMap[k])
	}
	mapStringForBoolMap += "}"
	if this.BoolMap != nil {
		s = append(s, "BoolMap: "+mapStringForBoolMap+",\n")
	}
	keysForStringMap := make([]string, 0, len(this.StringMap))
	for k := range this.StringMap {
		keysForStringMap = append(keysForStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringMap)
	mapStringForStringMap := "map[string]string{"
	for _, k := range keysForStringMap {
		mapStringForStringMap += fmt.Sprintf("%#v: %#v,", k, this.StringMap[k])
	}
	mapStringForStringMap += "}"
	if this.StringMap != nil {
		s = append(s, "StringMap: "+mapStringForStringMap+",\n")
	}
	keysForStringToBytesMap := make([]string, 0, len(this.StringToBytesMap))
	for k := range this.StringToBytesMap {
		keysForStringToBytesMap = append(keysForStringToBytesMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToBytesMap)
	mapStringForStringToBytesMap := "map[string][]byte{"
	for _, k := range keysForStringToBytesMap {
		mapStringForStringToBytesMap += fmt.Sprintf("%#v: %#v,", k, this.StringToBytesMap[k])
	}
	mapStringForStringToBytesMap += "}"
	if this.StringToBytesMap != nil {
		s = append(s, "StringToBytesMap: "+mapStringForStringToBytesMap+",\n")
	}
	keysForStringToEnumMap := make([]string, 0, len(this.StringToEnumMap))
	for k := range this.StringToEnumMap {
		keysForStringToEnumMap = append(keysForStringToEnumMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToEnumMap)
	mapStringForStringToEnumMap := "map[string]MapEnum{"
	for _, k := range keysForStringToEnumMap {
		mapStringForStringToEnumMap += fmt.Sprintf("%#v: %#v,", k, this.StringToEnumMap[k])
	}
	mapStringForStringToEnumMap += "}"
	if this.StringToEnumMap != nil {
		s = append(s, "StringToEnumMap: "+mapStringForStringToEnumMap+",\n")
	}
	keysForStringToMsgMap := make([]string, 0, len(this.StringToMsgMap))
	for k := range this.StringToMsgMap {
		keysForStringToMsgMap = append(keysForStringToMsgMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToMsgMap)
	mapStringForStringToMsgMap := "map[string]*FloatingPoint{"
	for _, k := range keysForStringToMsgMap {
		mapStringForStringToMsgMap += fmt.Sprintf("%#v: %#v,", k, this.StringToMsgMap[k])
	}
	mapStringForStringToMsgMap += "}"
	if this.StringToMsgMap != nil {
		s = append(s, "StringToMsgMap: "+mapStringForStringToMsgMap+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllMapsOrdered) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&theproto3.AllMapsOrdered{")
	keysForStringToDoubleMap := make([]string, 0, len(this.StringToDoubleMap))
	for k := range this.StringToDoubleMap {
		keysForStringToDoubleMap = append(keysForStringToDoubleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToDoubleMap)
	mapStringForStringToDoubleMap := "map[string]float64{"
	for _, k := range keysForStringToDoubleMap {
		mapStringForStringToDoubleMap += fmt.Sprintf("%#v: %#v,", k, this.StringToDoubleMap[k])
	}
	mapStringForStringToDoubleMap += "}"
	if this.StringToDoubleMap != nil {
		s = append(s, "StringToDoubleMap: "+mapStringForStringToDoubleMap+",\n")
	}
	keysForStringToFloatMap := make([]string, 0, len(this.StringToFloatMap))
	for k := range this.StringToFloatMap {
		keysForStringToFloatMap = append(keysForStringToFloatMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToFloatMap)
	mapStringForStringToFloatMap := "map[string]float32{"
	for _, k := range keysForStringToFloatMap {
		mapStringForStringToFloatMap += fmt.Sprintf("%#v: %#v,", k, this.StringToFloatMap[k])
	}
	mapStringForStringToFloatMap += "}"
	if this.StringToFloatMap != nil {
		s = append(s, "StringToFloatMap: "+mapStringForStringToFloatMap+",\n")
	}
	keysForInt32Map := make([]int32, 0, len(this.Int32Map))
	for k := range this.Int32Map {
		keysForInt32Map = append(keysForInt32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInt32Map)
	mapStringForInt32Map := "map[int32]int32{"
	for _, k := range keysForInt32Map {
		mapStringForInt32Map += fmt.Sprintf("%#v: %#v,", k, this.Int32Map[k])
	}
	mapStringForInt32Map += "}"
	if this.Int32Map != nil {
		s = append(s, "Int32Map: "+mapStringForInt32Map+",\n")
	}
	keysForInt64Map := make([]int64, 0, len(this.Int64Map))
	for k := range this.Int64Map {
		keysForInt64Map = append(keysForInt64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForInt64Map)
	mapStringForInt64Map := "map[int64]int64{"
	for _, k := range keysForInt64Map {
		mapStringForInt64Map += fmt.Sprintf("%#v: %#v,", k, this.Int64Map[k])
	}
	mapStringForInt64Map += "}"
	if this.Int64Map != nil {
		s = append(s, "Int64Map: "+mapStringForInt64Map+",\n")
	}
	keysForUint32Map := make([]uint32, 0, len(this.Uint32Map))
	for k := range this.Uint32Map {
		keysForUint32Map = append(keysForUint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForUint32Map)
	mapStringForUint32Map := "map[uint32]uint32{"
	for _, k := range keysForUint32Map {
		mapStringForUint32Map += fmt.Sprintf("%#v: %#v,", k, this.Uint32Map[k])
	}
	mapStringForUint32Map += "}"
	if this.Uint32Map != nil {
		s = append(s, "Uint32Map: "+mapStringForUint32Map+",\n")
	}
	keysForUint64Map := make([]uint64, 0, len(this.Uint64Map))
	for k := range this.Uint64Map {
		keysForUint64Map = append(keysForUint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForUint64Map)
	mapStringForUint64Map := "map[uint64]uint64{"
	for _, k := range keysForUint64Map {
		mapStringForUint64Map += fmt.Sprintf("%#v: %#v,", k, this.Uint64Map[k])
	}
	mapStringForUint64Map += "}"
	if this.Uint64Map != nil {
		s = append(s, "Uint64Map: "+mapStringForUint64Map+",\n")
	}
	keysForSint32Map := make([]int32, 0, len(this.Sint32Map))
	for k := range this.Sint32Map {
		keysForSint32Map = append(keysForSint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSint32Map)
	mapStringForSint32Map := "map[int32]int32{"
	for _, k := range keysForSint32Map {
		mapStringForSint32Map += fmt.Sprintf("%#v: %#v,", k, this.Sint32Map[k])
	}
	mapStringForSint32Map += "}"
	if this.Sint32Map != nil {
		s = append(s, "Sint32Map: "+mapStringForSint32Map+",\n")
	}
	keysForSint64Map := make([]int64, 0, len(this.Sint64Map))
	for k := range this.Sint64Map {
		keysForSint64Map = append(keysForSint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSint64Map)
	mapStringForSint64Map := "map[int64]int64{"
	for _, k := range keysForSint64Map {
		mapStringForSint64Map += fmt.Sprintf("%#v: %#v,", k, this.Sint64Map[k])
	}
	mapStringForSint64Map += "}"
	if this.Sint64Map != nil {
		s = append(s, "Sint64Map: "+mapStringForSint64Map+",\n")
	}
	keysForFixed32Map := make([]uint32, 0, len(this.Fixed32Map))
	for k := range this.Fixed32Map {
		keysForFixed32Map = append(keysForFixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFixed32Map)
	mapStringForFixed32Map := "map[uint32]uint32{"
	for _, k := range keysForFixed32Map {
		mapStringForFixed32Map += fmt.Sprintf("%#v: %#v,", k, this.Fixed32Map[k])
	}
	mapStringForFixed32Map += "}"
	if this.Fixed32Map != nil {
		s = append(s, "Fixed32Map: "+mapStringForFixed32Map+",\n")
	}
	keysForSfixed32Map := make([]int32, 0, len(this.Sfixed32Map))
	for k := range this.Sfixed32Map {
		keysForSfixed32Map = append(keysForSfixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSfixed32Map)
	mapStringForSfixed32Map := "map[int32]int32{"
	for _, k := range keysForSfixed32Map {
		mapStringForSfixed32Map += fmt.Sprintf("%#v: %#v,", k, this.Sfixed32Map[k])
	}
	mapStringForSfixed32Map += "}"
	if this.Sfixed32Map != nil {
		s = append(s, "Sfixed32Map: "+mapStringForSfixed32Map+",\n")
	}
	keysForFixed64Map := make([]uint64, 0, len(this.Fixed64Map))
	for k := range this.Fixed64Map {
		keysForFixed64Map = append(keysForFixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForFixed64Map)
	mapStringForFixed64Map := "map[uint64]uint64{"
	for _, k := range keysForFixed64Map {
		mapStringForFixed64Map += fmt.Sprintf("%#v: %#v,", k, this.Fixed64Map[k])
	}
	mapStringForFixed64Map += "}"
	if this.Fixed64Map != nil {
		s = append(s, "Fixed64Map: "+mapStringForFixed64Map+",\n")
	}
	keysForSfixed64Map := make([]int64, 0, len(this.Sfixed64Map))
	for k := range this.Sfixed64Map {
		keysForSfixed64Map = append(keysForSfixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSfixed64Map)
	mapStringForSfixed64Map := "map[int64]int64{"
	for _, k := range keysForSfixed64Map {
		mapStringForSfixed64Map += fmt.Sprintf("%#v: %#v,", k, this.Sfixed64Map[k])
	}
	mapStringForSfixed64Map += "}"
	if this.Sfixed64Map != nil {
		s = append(s, "Sfixed64Map: "+mapStringForSfixed64Map+",\n")
	}
	keysForBoolMap := make([]bool, 0, len(this.BoolMap))
	for k := range this.BoolMap {
		keysForBoolMap = append(keysForBoolMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForBoolMap)
	mapStringForBoolMap := "map[bool]bool{"
	for _, k := range keysForBoolMap {
		mapStringForBoolMap += fmt.Sprintf("%#v: %#v,", k, this.BoolMap[k])
	}
	mapStringForBoolMap += "}"
	if this.BoolMap != nil {
		s = append(s, "BoolMap: "+mapStringForBoolMap+",\n")
	}
	keysForStringMap := make([]string, 0, len(this.StringMap))
	for k := range this.StringMap {
		keysForStringMap = append(keysForStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringMap)
	mapStringForStringMap := "map[string]string{"
	for _, k := range keysForStringMap {
		mapStringForStringMap += fmt.Sprintf("%#v: %#v,", k, this.StringMap[k])
	}
	mapStringForStringMap += "}"
	if this.StringMap != nil {
		s = append(s, "StringMap: "+mapStringForStringMap+",\n")
	}
	keysForStringToBytesMap := make([]string, 0, len(this.StringToBytesMap))
	for k := range this.StringToBytesMap {
		keysForStringToBytesMap = append(keysForStringToBytesMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToBytesMap)
	mapStringForStringToBytesMap := "map[string][]byte{"
	for _, k := range keysForStringToBytesMap {
		mapStringForStringToBytesMap += fmt.Sprintf("%#v: %#v,", k, this.StringToBytesMap[k])
	}
	mapStringForStringToBytesMap += "}"
	if this.StringToBytesMap != nil {
		s = append(s, "StringToBytesMap: "+mapStringForStringToBytesMap+",\n")
	}
	keysForStringToEnumMap := make([]string, 0, len(this.StringToEnumMap))
	for k := range this.StringToEnumMap {
		keysForStringToEnumMap = append(keysForStringToEnumMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToEnumMap)
	mapStringForStringToEnumMap := "map[string]MapEnum{"
	for _, k := range keysForStringToEnumMap {
		mapStringForStringToEnumMap += fmt.Sprintf("%#v: %#v,", k, this.StringToEnumMap[k])
	}
	mapStringForStringToEnumMap += "}"
	if this.StringToEnumMap != nil {
		s = append(s, "StringToEnumMap: "+mapStringForStringToEnumMap+",\n")
	}
	keysForStringToMsgMap := make([]string, 0, len(this.StringToMsgMap))
	for k := range this.StringToMsgMap {
		keysForStringToMsgMap = append(keysForStringToMsgMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToMsgMap)
	mapStringForStringToMsgMap := "map[string]*FloatingPoint{"
	for _, k := range keysForStringToMsgMap {
		mapStringForStringToMsgMap += fmt.Sprintf("%#v: %#v,", k, this.StringToMsgMap[k])
	}
	mapStringForStringToMsgMap += "}"
	if this.StringToMsgMap != nil {
		s = append(s, "StringToMsgMap: "+mapStringForStringToMsgMap+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageWithMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&theproto3.MessageWithMap{")
	keysForNameMapping := make([]int32, 0, len(this.NameMapping))
	for k := range this.NameMapping {
		keysForNameMapping = append(keysForNameMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNameMapping)
	mapStringForNameMapping := "map[int32]string{"
	for _, k := range keysForNameMapping {
		mapStringForNameMapping += fmt.Sprintf("%#v: %#v,", k, this.NameMapping[k])
	}
	mapStringForNameMapping += "}"
	if this.NameMapping != nil {
		s = append(s, "NameMapping: "+mapStringForNameMapping+",\n")
	}
	keysForMsgMapping := make([]int64, 0, len(this.MsgMapping))
	for k := range this.MsgMapping {
		keysForMsgMapping = append(keysForMsgMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForMsgMapping)
	mapStringForMsgMapping := "map[int64]*FloatingPoint{"
	for _, k := range keysForMsgMapping {
		mapStringForMsgMapping += fmt.Sprintf("%#v: %#v,", k, this.MsgMapping[k])
	}
	mapStringForMsgMapping += "}"
	if this.MsgMapping != nil {
		s = append(s, "MsgMapping: "+mapStringForMsgMapping+",\n")
	}
	keysForByteMapping := make([]bool, 0, len(this.ByteMapping))
	for k := range this.ByteMapping {
		keysForByteMapping = append(keysForByteMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForByteMapping)
	mapStringForByteMapping := "map[bool][]byte{"
	for _, k := range keysForByteMapping {
		mapStringForByteMapping += fmt.Sprintf("%#v: %#v,", k, this.ByteMapping[k])
	}
	mapStringForByteMapping += "}"
	if this.ByteMapping != nil {
		s = append(s, "ByteMapping: "+mapStringForByteMapping+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FloatingPoint) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&theproto3.FloatingPoint{")
	s = append(s, "F: "+fmt.Sprintf("%#v", this.F)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Uint128Pair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&theproto3.Uint128Pair{")
	s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainsNestedMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&theproto3.ContainsNestedMap{")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainsNestedMap_NestedMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&theproto3.ContainsNestedMap_NestedMap{")
	keysForNestedMapField := make([]string, 0, len(this.NestedMapField))
	for k := range this.NestedMapField {
		keysForNestedMapField = append(keysForNestedMapField, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForNestedMapField)
	mapStringForNestedMapField := "map[string]float64{"
	for _, k := range keysForNestedMapField {
		mapStringForNestedMapField += fmt.Sprintf("%#v: %#v,", k, this.NestedMapField[k])
	}
	mapStringForNestedMapField += "}"
	if this.NestedMapField != nil {
		s = append(s, "NestedMapField: "+mapStringForNestedMapField+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NotPacked) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&theproto3.NotPacked{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTheproto3(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func NewPopulatedMessage(r randyTheproto3, easy bool) *Message {
	this := &Message{}
	this.Name = string(randStringTheproto3(r))
	this.Hilarity = Message_Humour([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.HeightInCm = uint32(r.Uint32())
	v1 := r.Intn(100)
	this.Data = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Data[i] = byte(r.Intn(256))
	}
	this.ResultCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ResultCount *= -1
	}
	this.TrueScotsman = bool(bool(r.Intn(2) == 0))
	this.Score = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Score *= -1
	}
	v2 := r.Intn(10)
	this.Key = make([]uint64, v2)
	for i := 0; i < v2; i++ {
		this.Key[i] = uint64(uint64(r.Uint32()))
	}
	if r.Intn(5) != 0 {
		this.Nested = NewPopulatedNested(r, easy)
	}
	if r.Intn(5) != 0 {
		v3 := r.Intn(10)
		this.Terrain = make(map[int64]*Nested)
		for i := 0; i < v3; i++ {
			this.Terrain[int64(r.Int63())] = NewPopulatedNested(r, easy)
		}
	}
	if r.Intn(5) != 0 {
		this.Proto2Field = both.NewPopulatedNinOptNative(r, easy)
	}
	if r.Intn(5) != 0 {
		v4 := r.Intn(10)
		this.Proto2Value = make(map[int64]*both.NinOptEnum)
		for i := 0; i < v4; i++ {
			this.Proto2Value[int64(r.Int63())] = both.NewPopulatedNinOptEnum(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 14)
	}
	return this
}

func NewPopulatedNested(r randyTheproto3, easy bool) *Nested {
	this := &Nested{}
	this.Bunny = string(randStringTheproto3(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 2)
	}
	return this
}

func NewPopulatedAllMaps(r randyTheproto3, easy bool) *AllMaps {
	this := &AllMaps{}
	if r.Intn(5) != 0 {
		v5 := r.Intn(10)
		this.StringToDoubleMap = make(map[string]float64)
		for i := 0; i < v5; i++ {
			v6 := randStringTheproto3(r)
			this.StringToDoubleMap[v6] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.StringToDoubleMap[v6] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v7 := r.Intn(10)
		this.StringToFloatMap = make(map[string]float32)
		for i := 0; i < v7; i++ {
			v8 := randStringTheproto3(r)
			this.StringToFloatMap[v8] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.StringToFloatMap[v8] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v9 := r.Intn(10)
		this.Int32Map = make(map[int32]int32)
		for i := 0; i < v9; i++ {
			v10 := int32(r.Int31())
			this.Int32Map[v10] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Int32Map[v10] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v11 := r.Intn(10)
		this.Int64Map = make(map[int64]int64)
		for i := 0; i < v11; i++ {
			v12 := int64(r.Int63())
			this.Int64Map[v12] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Int64Map[v12] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v13 := r.Intn(10)
		this.Uint32Map = make(map[uint32]uint32)
		for i := 0; i < v13; i++ {
			v14 := uint32(r.Uint32())
			this.Uint32Map[v14] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v15 := r.Intn(10)
		this.Uint64Map = make(map[uint64]uint64)
		for i := 0; i < v15; i++ {
			v16 := uint64(uint64(r.Uint32()))
			this.Uint64Map[v16] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v17 := r.Intn(10)
		this.Sint32Map = make(map[int32]int32)
		for i := 0; i < v17; i++ {
			v18 := int32(r.Int31())
			this.Sint32Map[v18] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Sint32Map[v18] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v19 := r.Intn(10)
		this.Sint64Map = make(map[int64]int64)
		for i := 0; i < v19; i++ {
			v20 := int64(r.Int63())
			this.Sint64Map[v20] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Sint64Map[v20] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v21 := r.Intn(10)
		this.Fixed32Map = make(map[uint32]uint32)
		for i := 0; i < v21; i++ {
			v22 := uint32(r.Uint32())
			this.Fixed32Map[v22] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v23 := r.Intn(10)
		this.Sfixed32Map = make(map[int32]int32)
		for i := 0; i < v23; i++ {
			v24 := int32(r.Int31())
			this.Sfixed32Map[v24] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Sfixed32Map[v24] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v25 := r.Intn(10)
		this.Fixed64Map = make(map[uint64]uint64)
		for i := 0; i < v25; i++ {
			v26 := uint64(uint64(r.Uint32()))
			this.Fixed64Map[v26] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v27 := r.Intn(10)
		this.Sfixed64Map = make(map[int64]int64)
		for i := 0; i < v27; i++ {
			v28 := int64(r.Int63())
			this.Sfixed64Map[v28] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Sfixed64Map[v28] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v29 := r.Intn(10)
		this.BoolMap = make(map[bool]bool)
		for i := 0; i < v29; i++ {
			v30 := bool(bool(r.Intn(2) == 0))
			this.BoolMap[v30] = bool(bool(r.Intn(2) == 0))
		}
	}
	if r.Intn(5) != 0 {
		v31 := r.Intn(10)
		this.StringMap = make(map[string]string)
		for i := 0; i < v31; i++ {
			this.StringMap[randStringTheproto3(r)] = randStringTheproto3(r)
		}
	}
	if r.Intn(5) != 0 {
		v32 := r.Intn(10)
		this.StringToBytesMap = make(map[string][]byte)
		for i := 0; i < v32; i++ {
			v33 := r.Intn(100)
			v34 := randStringTheproto3(r)
			this.StringToBytesMap[v34] = make([]byte, v33)
			for i := 0; i < v33; i++ {
				this.StringToBytesMap[v34][i] = byte(r.Intn(256))
			}
		}
	}
	if r.Intn(5) != 0 {
		v35 := r.Intn(10)
		this.StringToEnumMap = make(map[string]MapEnum)
		for i := 0; i < v35; i++ {
			this.StringToEnumMap[randStringTheproto3(r)] = MapEnum([]int32{0, 1, 2}[r.Intn(3)])
		}
	}
	if r.Intn(5) != 0 {
		v36 := r.Intn(10)
		this.StringToMsgMap = make(map[string]*FloatingPoint)
		for i := 0; i < v36; i++ {
			this.StringToMsgMap[randStringTheproto3(r)] = NewPopulatedFloatingPoint(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 18)
	}
	return this
}

func NewPopulatedAllMapsOrdered(r randyTheproto3, easy bool) *AllMapsOrdered {
	this := &AllMapsOrdered{}
	if r.Intn(5) != 0 {
		v37 := r.Intn(10)
		this.StringToDoubleMap = make(map[string]float64)
		for i := 0; i < v37; i++ {
			v38 := randStringTheproto3(r)
			this.StringToDoubleMap[v38] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.StringToDoubleMap[v38] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v39 := r.Intn(10)
		this.StringToFloatMap = make(map[string]float32)
		for i := 0; i < v39; i++ {
			v40 := randStringTheproto3(r)
			this.StringToFloatMap[v40] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.StringToFloatMap[v40] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v41 := r.Intn(10)
		this.Int32Map = make(map[int32]int32)
		for i := 0; i < v41; i++ {
			v42 := int32(r.Int31())
			this.Int32Map[v42] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Int32Map[v42] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v43 := r.Intn(10)
		this.Int64Map = make(map[int64]int64)
		for i := 0; i < v43; i++ {
			v44 := int64(r.Int63())
			this.Int64Map[v44] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Int64Map[v44] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v45 := r.Intn(10)
		this.Uint32Map = make(map[uint32]uint32)
		for i := 0; i < v45; i++ {
			v46 := uint32(r.Uint32())
			this.Uint32Map[v46] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v47 := r.Intn(10)
		this.Uint64Map = make(map[uint64]uint64)
		for i := 0; i < v47; i++ {
			v48 := uint64(uint64(r.Uint32()))
			this.Uint64Map[v48] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v49 := r.Intn(10)
		this.Sint32Map = make(map[int32]int32)
		for i := 0; i < v49; i++ {
			v50 := int32(r.Int31())
			this.Sint32Map[v50] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Sint32Map[v50] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v51 := r.Intn(10)
		this.Sint64Map = make(map[int64]int64)
		for i := 0; i < v51; i++ {
			v52 := int64(r.Int63())
			this.Sint64Map[v52] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Sint64Map[v52] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v53 := r.Intn(10)
		this.Fixed32Map = make(map[uint32]uint32)
		for i := 0; i < v53; i++ {
			v54 := uint32(r.Uint32())
			this.Fixed32Map[v54] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v55 := r.Intn(10)
		this.Sfixed32Map = make(map[int32]int32)
		for i := 0; i < v55; i++ {
			v56 := int32(r.Int31())
			this.Sfixed32Map[v56] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Sfixed32Map[v56] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v57 := r.Intn(10)
		this.Fixed64Map = make(map[uint64]uint64)
		for i := 0; i < v57; i++ {
			v58 := uint64(uint64(r.Uint32()))
			this.Fixed64Map[v58] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v59 := r.Intn(10)
		this.Sfixed64Map = make(map[int64]int64)
		for i := 0; i < v59; i++ {
			v60 := int64(r.Int63())
			this.Sfixed64Map[v60] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Sfixed64Map[v60] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v61 := r.Intn(10)
		this.BoolMap = make(map[bool]bool)
		for i := 0; i < v61; i++ {
			v62 := bool(bool(r.Intn(2) == 0))
			this.BoolMap[v62] = bool(bool(r.Intn(2) == 0))
		}
	}
	if r.Intn(5) != 0 {
		v63 := r.Intn(10)
		this.StringMap = make(map[string]string)
		for i := 0; i < v63; i++ {
			this.StringMap[randStringTheproto3(r)] = randStringTheproto3(r)
		}
	}
	if r.Intn(5) != 0 {
		v64 := r.Intn(10)
		this.StringToBytesMap = make(map[string][]byte)
		for i := 0; i < v64; i++ {
			v65 := r.Intn(100)
			v66 := randStringTheproto3(r)
			this.StringToBytesMap[v66] = make([]byte, v65)
			for i := 0; i < v65; i++ {
				this.StringToBytesMap[v66][i] = byte(r.Intn(256))
			}
		}
	}
	if r.Intn(5) != 0 {
		v67 := r.Intn(10)
		this.StringToEnumMap = make(map[string]MapEnum)
		for i := 0; i < v67; i++ {
			this.StringToEnumMap[randStringTheproto3(r)] = MapEnum([]int32{0, 1, 2}[r.Intn(3)])
		}
	}
	if r.Intn(5) != 0 {
		v68 := r.Intn(10)
		this.StringToMsgMap = make(map[string]*FloatingPoint)
		for i := 0; i < v68; i++ {
			this.StringToMsgMap[randStringTheproto3(r)] = NewPopulatedFloatingPoint(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 18)
	}
	return this
}

func NewPopulatedMessageWithMap(r randyTheproto3, easy bool) *MessageWithMap {
	this := &MessageWithMap{}
	if r.Intn(5) != 0 {
		v69 := r.Intn(10)
		this.NameMapping = make(map[int32]string)
		for i := 0; i < v69; i++ {
			this.NameMapping[int32(r.Int31())] = randStringTheproto3(r)
		}
	}
	if r.Intn(5) != 0 {
		v70 := r.Intn(10)
		this.MsgMapping = make(map[int64]*FloatingPoint)
		for i := 0; i < v70; i++ {
			this.MsgMapping[int64(r.Int63())] = NewPopulatedFloatingPoint(r, easy)
		}
	}
	if r.Intn(5) != 0 {
		v71 := r.Intn(10)
		this.ByteMapping = make(map[bool][]byte)
		for i := 0; i < v71; i++ {
			v72 := r.Intn(100)
			v73 := bool(bool(r.Intn(2) == 0))
			this.ByteMapping[v73] = make([]byte, v72)
			for i := 0; i < v72; i++ {
				this.ByteMapping[v73][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 4)
	}
	return this
}

func NewPopulatedFloatingPoint(r randyTheproto3, easy bool) *FloatingPoint {
	this := &FloatingPoint{}
	this.F = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.F *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 2)
	}
	return this
}

func NewPopulatedUint128Pair(r randyTheproto3, easy bool) *Uint128Pair {
	this := &Uint128Pair{}
	v74 := github_com_gogo_protobuf_test_custom.NewPopulatedUint128(r)
	this.Left = *v74
	this.Right = github_com_gogo_protobuf_test_custom.NewPopulatedUint128(r)
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 3)
	}
	return this
}

func NewPopulatedContainsNestedMap(r randyTheproto3, easy bool) *ContainsNestedMap {
	this := &ContainsNestedMap{}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 1)
	}
	return this
}

func NewPopulatedContainsNestedMap_NestedMap(r randyTheproto3, easy bool) *ContainsNestedMap_NestedMap {
	this := &ContainsNestedMap_NestedMap{}
	if r.Intn(5) != 0 {
		v75 := r.Intn(10)
		this.NestedMapField = make(map[string]float64)
		for i := 0; i < v75; i++ {
			v76 := randStringTheproto3(r)
			this.NestedMapField[v76] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.NestedMapField[v76] *= -1
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 2)
	}
	return this
}

func NewPopulatedNotPacked(r randyTheproto3, easy bool) *NotPacked {
	this := &NotPacked{}
	v77 := r.Intn(10)
	this.Key = make([]uint64, v77)
	for i := 0; i < v77; i++ {
		this.Key[i] = uint64(uint64(r.Uint32()))
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedTheproto3(r, 6)
	}
	return this
}

type randyTheproto3 interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTheproto3(r randyTheproto3) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTheproto3(r randyTheproto3) string {
	v78 := r.Intn(100)
	tmps := make([]rune, v78)
	for i := 0; i < v78; i++ {
		tmps[i] = randUTF8RuneTheproto3(r)
	}
	return string(tmps)
}
func randUnrecognizedTheproto3(r randyTheproto3, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldTheproto3(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldTheproto3(dAtA []byte, r randyTheproto3, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateTheproto3(dAtA, uint64(key))
		v79 := r.Int63()
		if r.Intn(2) == 0 {
			v79 *= -1
		}
		dAtA = encodeVarintPopulateTheproto3(dAtA, uint64(v79))
	case 1:
		dAtA = encodeVarintPopulateTheproto3(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateTheproto3(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateTheproto3(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateTheproto3(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateTheproto3(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if m.Hilarity != 0 {
		n += 1 + sovTheproto3(uint64(m.Hilarity))
	}
	if m.HeightInCm != 0 {
		n += 1 + sovTheproto3(uint64(m.HeightInCm))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if m.ResultCount != 0 {
		n += 1 + sovTheproto3(uint64(m.ResultCount))
	}
	if m.TrueScotsman {
		n += 2
	}
	if m.Score != 0 {
		n += 5
	}
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovTheproto3(uint64(e))
		}
		n += 1 + sovTheproto3(uint64(l)) + l
	}
	if m.Nested != nil {
		l = m.Nested.Size()
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if len(m.Terrain) > 0 {
		for k, v := range m.Terrain {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTheproto3(uint64(l))
			}
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + l
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if m.Proto2Field != nil {
		l = m.Proto2Field.Size()
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if len(m.Proto2Value) > 0 {
		for k, v := range m.Proto2Value {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTheproto3(uint64(l))
			}
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + l
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Nested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bunny)
	if l > 0 {
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllMaps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StringToDoubleMap) > 0 {
		for k, v := range m.StringToDoubleMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToFloatMap) > 0 {
		for k, v := range m.StringToFloatMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Int32Map) > 0 {
		for k, v := range m.Int32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Int64Map) > 0 {
		for k, v := range m.Int64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Uint32Map) > 0 {
		for k, v := range m.Uint32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Uint64Map) > 0 {
		for k, v := range m.Uint64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sint32Map) > 0 {
		for k, v := range m.Sint32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + sozTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sint64Map) > 0 {
		for k, v := range m.Sint64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + sozTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Fixed32Map) > 0 {
		for k, v := range m.Fixed32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sfixed32Map) > 0 {
		for k, v := range m.Sfixed32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Fixed64Map) > 0 {
		for k, v := range m.Fixed64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sfixed64Map) > 0 {
		for k, v := range m.Sfixed64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.BoolMap) > 0 {
		for k, v := range m.BoolMap {
			_ = k
			_ = v
			mapEntrySize := 1 + 1 + 1 + 1
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringMap) > 0 {
		for k, v := range m.StringMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToBytesMap) > 0 {
		for k, v := range m.StringToBytesMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovTheproto3(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToEnumMap) > 0 {
		for k, v := range m.StringToEnumMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 2 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToMsgMap) > 0 {
		for k, v := range m.StringToMsgMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTheproto3(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllMapsOrdered) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StringToDoubleMap) > 0 {
		for k, v := range m.StringToDoubleMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToFloatMap) > 0 {
		for k, v := range m.StringToFloatMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Int32Map) > 0 {
		for k, v := range m.Int32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Int64Map) > 0 {
		for k, v := range m.Int64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Uint32Map) > 0 {
		for k, v := range m.Uint32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Uint64Map) > 0 {
		for k, v := range m.Uint64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sint32Map) > 0 {
		for k, v := range m.Sint32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + sozTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sint64Map) > 0 {
		for k, v := range m.Sint64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + 1 + sozTheproto3(uint64(v))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Fixed32Map) > 0 {
		for k, v := range m.Fixed32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sfixed32Map) > 0 {
		for k, v := range m.Sfixed32Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + 4
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Fixed64Map) > 0 {
		for k, v := range m.Fixed64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.Sfixed64Map) > 0 {
		for k, v := range m.Sfixed64Map {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.BoolMap) > 0 {
		for k, v := range m.BoolMap {
			_ = k
			_ = v
			mapEntrySize := 1 + 1 + 1 + 1
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringMap) > 0 {
		for k, v := range m.StringMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToBytesMap) > 0 {
		for k, v := range m.StringToBytesMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovTheproto3(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToEnumMap) > 0 {
		for k, v := range m.StringToEnumMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + sovTheproto3(uint64(v))
			n += mapEntrySize + 2 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.StringToMsgMap) > 0 {
		for k, v := range m.StringToMsgMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTheproto3(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageWithMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NameMapping) > 0 {
		for k, v := range m.NameMapping {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTheproto3(uint64(k)) + 1 + len(v) + sovTheproto3(uint64(len(v)))
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.MsgMapping) > 0 {
		for k, v := range m.MsgMapping {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTheproto3(uint64(l))
			}
			mapEntrySize := 1 + sozTheproto3(uint64(k)) + l
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if len(m.ByteMapping) > 0 {
		for k, v := range m.ByteMapping {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovTheproto3(uint64(len(v)))
			}
			mapEntrySize := 1 + 1 + l
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FloatingPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.F != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Uint128Pair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Left.Size()
	n += 1 + l + sovTheproto3(uint64(l))
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovTheproto3(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainsNestedMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainsNestedMap_NestedMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NestedMapField) > 0 {
		for k, v := range m.NestedMapField {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTheproto3(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovTheproto3(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotPacked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		for _, e := range m.Key {
			n += 1 + sovTheproto3(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTheproto3(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTheproto3(x uint64) (n int) {
	return sovTheproto3(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Message) String() string {
	if this == nil {
		return "nil"
	}
	keysForTerrain := make([]int64, 0, len(this.Terrain))
	for k := range this.Terrain {
		keysForTerrain = append(keysForTerrain, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForTerrain)
	mapStringForTerrain := "map[int64]*Nested{"
	for _, k := range keysForTerrain {
		mapStringForTerrain += fmt.Sprintf("%v: %v,", k, this.Terrain[k])
	}
	mapStringForTerrain += "}"
	keysForProto2Value := make([]int64, 0, len(this.Proto2Value))
	for k := range this.Proto2Value {
		keysForProto2Value = append(keysForProto2Value, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForProto2Value)
	mapStringForProto2Value := "map[int64]*both.NinOptEnum{"
	for _, k := range keysForProto2Value {
		mapStringForProto2Value += fmt.Sprintf("%v: %v,", k, this.Proto2Value[k])
	}
	mapStringForProto2Value += "}"
	s := strings.Join([]string{`&Message{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Hilarity:` + fmt.Sprintf("%v", this.Hilarity) + `,`,
		`HeightInCm:` + fmt.Sprintf("%v", this.HeightInCm) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`ResultCount:` + fmt.Sprintf("%v", this.ResultCount) + `,`,
		`TrueScotsman:` + fmt.Sprintf("%v", this.TrueScotsman) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Nested:` + strings.Replace(this.Nested.String(), "Nested", "Nested", 1) + `,`,
		`Terrain:` + mapStringForTerrain + `,`,
		`Proto2Field:` + strings.Replace(fmt.Sprintf("%v", this.Proto2Field), "NinOptNative", "both.NinOptNative", 1) + `,`,
		`Proto2Value:` + mapStringForProto2Value + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Nested) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Nested{`,
		`Bunny:` + fmt.Sprintf("%v", this.Bunny) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllMaps) String() string {
	if this == nil {
		return "nil"
	}
	keysForStringToDoubleMap := make([]string, 0, len(this.StringToDoubleMap))
	for k := range this.StringToDoubleMap {
		keysForStringToDoubleMap = append(keysForStringToDoubleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToDoubleMap)
	mapStringForStringToDoubleMap := "map[string]float64{"
	for _, k := range keysForStringToDoubleMap {
		mapStringForStringToDoubleMap += fmt.Sprintf("%v: %v,", k, this.StringToDoubleMap[k])
	}
	mapStringForStringToDoubleMap += "}"
	keysForStringToFloatMap := make([]string, 0, len(this.StringToFloatMap))
	for k := range this.StringToFloatMap {
		keysForStringToFloatMap = append(keysForStringToFloatMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToFloatMap)
	mapStringForStringToFloatMap := "map[string]float32{"
	for _, k := range keysForStringToFloatMap {
		mapStringForStringToFloatMap += fmt.Sprintf("%v: %v,", k, this.StringToFloatMap[k])
	}
	mapStringForStringToFloatMap += "}"
	keysForInt32Map := make([]int32, 0, len(this.Int32Map))
	for k := range this.Int32Map {
		keysForInt32Map = append(keysForInt32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInt32Map)
	mapStringForInt32Map := "map[int32]int32{"
	for _, k := range keysForInt32Map {
		mapStringForInt32Map += fmt.Sprintf("%v: %v,", k, this.Int32Map[k])
	}
	mapStringForInt32Map += "}"
	keysForInt64Map := make([]int64, 0, len(this.Int64Map))
	for k := range this.Int64Map {
		keysForInt64Map = append(keysForInt64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForInt64Map)
	mapStringForInt64Map := "map[int64]int64{"
	for _, k := range keysForInt64Map {
		mapStringForInt64Map += fmt.Sprintf("%v: %v,", k, this.Int64Map[k])
	}
	mapStringForInt64Map += "}"
	keysForUint32Map := make([]uint32, 0, len(this.Uint32Map))
	for k := range this.Uint32Map {
		keysForUint32Map = append(keysForUint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForUint32Map)
	mapStringForUint32Map := "map[uint32]uint32{"
	for _, k := range keysForUint32Map {
		mapStringForUint32Map += fmt.Sprintf("%v: %v,", k, this.Uint32Map[k])
	}
	mapStringForUint32Map += "}"
	keysForUint64Map := make([]uint64, 0, len(this.Uint64Map))
	for k := range this.Uint64Map {
		keysForUint64Map = append(keysForUint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForUint64Map)
	mapStringForUint64Map := "map[uint64]uint64{"
	for _, k := range keysForUint64Map {
		mapStringForUint64Map += fmt.Sprintf("%v: %v,", k, this.Uint64Map[k])
	}
	mapStringForUint64Map += "}"
	keysForSint32Map := make([]int32, 0, len(this.Sint32Map))
	for k := range this.Sint32Map {
		keysForSint32Map = append(keysForSint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSint32Map)
	mapStringForSint32Map := "map[int32]int32{"
	for _, k := range keysForSint32Map {
		mapStringForSint32Map += fmt.Sprintf("%v: %v,", k, this.Sint32Map[k])
	}
	mapStringForSint32Map += "}"
	keysForSint64Map := make([]int64, 0, len(this.Sint64Map))
	for k := range this.Sint64Map {
		keysForSint64Map = append(keysForSint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSint64Map)
	mapStringForSint64Map := "map[int64]int64{"
	for _, k := range keysForSint64Map {
		mapStringForSint64Map += fmt.Sprintf("%v: %v,", k, this.Sint64Map[k])
	}
	mapStringForSint64Map += "}"
	keysForFixed32Map := make([]uint32, 0, len(this.Fixed32Map))
	for k := range this.Fixed32Map {
		keysForFixed32Map = append(keysForFixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFixed32Map)
	mapStringForFixed32Map := "map[uint32]uint32{"
	for _, k := range keysForFixed32Map {
		mapStringForFixed32Map += fmt.Sprintf("%v: %v,", k, this.Fixed32Map[k])
	}
	mapStringForFixed32Map += "}"
	keysForSfixed32Map := make([]int32, 0, len(this.Sfixed32Map))
	for k := range this.Sfixed32Map {
		keysForSfixed32Map = append(keysForSfixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSfixed32Map)
	mapStringForSfixed32Map := "map[int32]int32{"
	for _, k := range keysForSfixed32Map {
		mapStringForSfixed32Map += fmt.Sprintf("%v: %v,", k, this.Sfixed32Map[k])
	}
	mapStringForSfixed32Map += "}"
	keysForFixed64Map := make([]uint64, 0, len(this.Fixed64Map))
	for k := range this.Fixed64Map {
		keysForFixed64Map = append(keysForFixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForFixed64Map)
	mapStringForFixed64Map := "map[uint64]uint64{"
	for _, k := range keysForFixed64Map {
		mapStringForFixed64Map += fmt.Sprintf("%v: %v,", k, this.Fixed64Map[k])
	}
	mapStringForFixed64Map += "}"
	keysForSfixed64Map := make([]int64, 0, len(this.Sfixed64Map))
	for k := range this.Sfixed64Map {
		keysForSfixed64Map = append(keysForSfixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSfixed64Map)
	mapStringForSfixed64Map := "map[int64]int64{"
	for _, k := range keysForSfixed64Map {
		mapStringForSfixed64Map += fmt.Sprintf("%v: %v,", k, this.Sfixed64Map[k])
	}
	mapStringForSfixed64Map += "}"
	keysForBoolMap := make([]bool, 0, len(this.BoolMap))
	for k := range this.BoolMap {
		keysForBoolMap = append(keysForBoolMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForBoolMap)
	mapStringForBoolMap := "map[bool]bool{"
	for _, k := range keysForBoolMap {
		mapStringForBoolMap += fmt.Sprintf("%v: %v,", k, this.BoolMap[k])
	}
	mapStringForBoolMap += "}"
	keysForStringMap := make([]string, 0, len(this.StringMap))
	for k := range this.StringMap {
		keysForStringMap = append(keysForStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringMap)
	mapStringForStringMap := "map[string]string{"
	for _, k := range keysForStringMap {
		mapStringForStringMap += fmt.Sprintf("%v: %v,", k, this.StringMap[k])
	}
	mapStringForStringMap += "}"
	keysForStringToBytesMap := make([]string, 0, len(this.StringToBytesMap))
	for k := range this.StringToBytesMap {
		keysForStringToBytesMap = append(keysForStringToBytesMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToBytesMap)
	mapStringForStringToBytesMap := "map[string][]byte{"
	for _, k := range keysForStringToBytesMap {
		mapStringForStringToBytesMap += fmt.Sprintf("%v: %v,", k, this.StringToBytesMap[k])
	}
	mapStringForStringToBytesMap += "}"
	keysForStringToEnumMap := make([]string, 0, len(this.StringToEnumMap))
	for k := range this.StringToEnumMap {
		keysForStringToEnumMap = append(keysForStringToEnumMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToEnumMap)
	mapStringForStringToEnumMap := "map[string]MapEnum{"
	for _, k := range keysForStringToEnumMap {
		mapStringForStringToEnumMap += fmt.Sprintf("%v: %v,", k, this.StringToEnumMap[k])
	}
	mapStringForStringToEnumMap += "}"
	keysForStringToMsgMap := make([]string, 0, len(this.StringToMsgMap))
	for k := range this.StringToMsgMap {
		keysForStringToMsgMap = append(keysForStringToMsgMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToMsgMap)
	mapStringForStringToMsgMap := "map[string]*FloatingPoint{"
	for _, k := range keysForStringToMsgMap {
		mapStringForStringToMsgMap += fmt.Sprintf("%v: %v,", k, this.StringToMsgMap[k])
	}
	mapStringForStringToMsgMap += "}"
	s := strings.Join([]string{`&AllMaps{`,
		`StringToDoubleMap:` + mapStringForStringToDoubleMap + `,`,
		`StringToFloatMap:` + mapStringForStringToFloatMap + `,`,
		`Int32Map:` + mapStringForInt32Map + `,`,
		`Int64Map:` + mapStringForInt64Map + `,`,
		`Uint32Map:` + mapStringForUint32Map + `,`,
		`Uint64Map:` + mapStringForUint64Map + `,`,
		`Sint32Map:` + mapStringForSint32Map + `,`,
		`Sint64Map:` + mapStringForSint64Map + `,`,
		`Fixed32Map:` + mapStringForFixed32Map + `,`,
		`Sfixed32Map:` + mapStringForSfixed32Map + `,`,
		`Fixed64Map:` + mapStringForFixed64Map + `,`,
		`Sfixed64Map:` + mapStringForSfixed64Map + `,`,
		`BoolMap:` + mapStringForBoolMap + `,`,
		`StringMap:` + mapStringForStringMap + `,`,
		`StringToBytesMap:` + mapStringForStringToBytesMap + `,`,
		`StringToEnumMap:` + mapStringForStringToEnumMap + `,`,
		`StringToMsgMap:` + mapStringForStringToMsgMap + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllMapsOrdered) String() string {
	if this == nil {
		return "nil"
	}
	keysForStringToDoubleMap := make([]string, 0, len(this.StringToDoubleMap))
	for k := range this.StringToDoubleMap {
		keysForStringToDoubleMap = append(keysForStringToDoubleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToDoubleMap)
	mapStringForStringToDoubleMap := "map[string]float64{"
	for _, k := range keysForStringToDoubleMap {
		mapStringForStringToDoubleMap += fmt.Sprintf("%v: %v,", k, this.StringToDoubleMap[k])
	}
	mapStringForStringToDoubleMap += "}"
	keysForStringToFloatMap := make([]string, 0, len(this.StringToFloatMap))
	for k := range this.StringToFloatMap {
		keysForStringToFloatMap = append(keysForStringToFloatMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToFloatMap)
	mapStringForStringToFloatMap := "map[string]float32{"
	for _, k := range keysForStringToFloatMap {
		mapStringForStringToFloatMap += fmt.Sprintf("%v: %v,", k, this.StringToFloatMap[k])
	}
	mapStringForStringToFloatMap += "}"
	keysForInt32Map := make([]int32, 0, len(this.Int32Map))
	for k := range this.Int32Map {
		keysForInt32Map = append(keysForInt32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForInt32Map)
	mapStringForInt32Map := "map[int32]int32{"
	for _, k := range keysForInt32Map {
		mapStringForInt32Map += fmt.Sprintf("%v: %v,", k, this.Int32Map[k])
	}
	mapStringForInt32Map += "}"
	keysForInt64Map := make([]int64, 0, len(this.Int64Map))
	for k := range this.Int64Map {
		keysForInt64Map = append(keysForInt64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForInt64Map)
	mapStringForInt64Map := "map[int64]int64{"
	for _, k := range keysForInt64Map {
		mapStringForInt64Map += fmt.Sprintf("%v: %v,", k, this.Int64Map[k])
	}
	mapStringForInt64Map += "}"
	keysForUint32Map := make([]uint32, 0, len(this.Uint32Map))
	for k := range this.Uint32Map {
		keysForUint32Map = append(keysForUint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForUint32Map)
	mapStringForUint32Map := "map[uint32]uint32{"
	for _, k := range keysForUint32Map {
		mapStringForUint32Map += fmt.Sprintf("%v: %v,", k, this.Uint32Map[k])
	}
	mapStringForUint32Map += "}"
	keysForUint64Map := make([]uint64, 0, len(this.Uint64Map))
	for k := range this.Uint64Map {
		keysForUint64Map = append(keysForUint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForUint64Map)
	mapStringForUint64Map := "map[uint64]uint64{"
	for _, k := range keysForUint64Map {
		mapStringForUint64Map += fmt.Sprintf("%v: %v,", k, this.Uint64Map[k])
	}
	mapStringForUint64Map += "}"
	keysForSint32Map := make([]int32, 0, len(this.Sint32Map))
	for k := range this.Sint32Map {
		keysForSint32Map = append(keysForSint32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSint32Map)
	mapStringForSint32Map := "map[int32]int32{"
	for _, k := range keysForSint32Map {
		mapStringForSint32Map += fmt.Sprintf("%v: %v,", k, this.Sint32Map[k])
	}
	mapStringForSint32Map += "}"
	keysForSint64Map := make([]int64, 0, len(this.Sint64Map))
	for k := range this.Sint64Map {
		keysForSint64Map = append(keysForSint64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSint64Map)
	mapStringForSint64Map := "map[int64]int64{"
	for _, k := range keysForSint64Map {
		mapStringForSint64Map += fmt.Sprintf("%v: %v,", k, this.Sint64Map[k])
	}
	mapStringForSint64Map += "}"
	keysForFixed32Map := make([]uint32, 0, len(this.Fixed32Map))
	for k := range this.Fixed32Map {
		keysForFixed32Map = append(keysForFixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint32s(keysForFixed32Map)
	mapStringForFixed32Map := "map[uint32]uint32{"
	for _, k := range keysForFixed32Map {
		mapStringForFixed32Map += fmt.Sprintf("%v: %v,", k, this.Fixed32Map[k])
	}
	mapStringForFixed32Map += "}"
	keysForSfixed32Map := make([]int32, 0, len(this.Sfixed32Map))
	for k := range this.Sfixed32Map {
		keysForSfixed32Map = append(keysForSfixed32Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForSfixed32Map)
	mapStringForSfixed32Map := "map[int32]int32{"
	for _, k := range keysForSfixed32Map {
		mapStringForSfixed32Map += fmt.Sprintf("%v: %v,", k, this.Sfixed32Map[k])
	}
	mapStringForSfixed32Map += "}"
	keysForFixed64Map := make([]uint64, 0, len(this.Fixed64Map))
	for k := range this.Fixed64Map {
		keysForFixed64Map = append(keysForFixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForFixed64Map)
	mapStringForFixed64Map := "map[uint64]uint64{"
	for _, k := range keysForFixed64Map {
		mapStringForFixed64Map += fmt.Sprintf("%v: %v,", k, this.Fixed64Map[k])
	}
	mapStringForFixed64Map += "}"
	keysForSfixed64Map := make([]int64, 0, len(this.Sfixed64Map))
	for k := range this.Sfixed64Map {
		keysForSfixed64Map = append(keysForSfixed64Map, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForSfixed64Map)
	mapStringForSfixed64Map := "map[int64]int64{"
	for _, k := range keysForSfixed64Map {
		mapStringForSfixed64Map += fmt.Sprintf("%v: %v,", k, this.Sfixed64Map[k])
	}
	mapStringForSfixed64Map += "}"
	keysForBoolMap := make([]bool, 0, len(this.BoolMap))
	for k := range this.BoolMap {
		keysForBoolMap = append(keysForBoolMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForBoolMap)
	mapStringForBoolMap := "map[bool]bool{"
	for _, k := range keysForBoolMap {
		mapStringForBoolMap += fmt.Sprintf("%v: %v,", k, this.BoolMap[k])
	}
	mapStringForBoolMap += "}"
	keysForStringMap := make([]string, 0, len(this.StringMap))
	for k := range this.StringMap {
		keysForStringMap = append(keysForStringMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringMap)
	mapStringForStringMap := "map[string]string{"
	for _, k := range keysForStringMap {
		mapStringForStringMap += fmt.Sprintf("%v: %v,", k, this.StringMap[k])
	}
	mapStringForStringMap += "}"
	keysForStringToBytesMap := make([]string, 0, len(this.StringToBytesMap))
	for k := range this.StringToBytesMap {
		keysForStringToBytesMap = append(keysForStringToBytesMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToBytesMap)
	mapStringForStringToBytesMap := "map[string][]byte{"
	for _, k := range keysForStringToBytesMap {
		mapStringForStringToBytesMap += fmt.Sprintf("%v: %v,", k, this.StringToBytesMap[k])
	}
	mapStringForStringToBytesMap += "}"
	keysForStringToEnumMap := make([]string, 0, len(this.StringToEnumMap))
	for k := range this.StringToEnumMap {
		keysForStringToEnumMap = append(keysForStringToEnumMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToEnumMap)
	mapStringForStringToEnumMap := "map[string]MapEnum{"
	for _, k := range keysForStringToEnumMap {
		mapStringForStringToEnumMap += fmt.Sprintf("%v: %v,", k, this.StringToEnumMap[k])
	}
	mapStringForStringToEnumMap += "}"
	keysForStringToMsgMap := make([]string, 0, len(this.StringToMsgMap))
	for k := range this.StringToMsgMap {
		keysForStringToMsgMap = append(keysForStringToMsgMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForStringToMsgMap)
	mapStringForStringToMsgMap := "map[string]*FloatingPoint{"
	for _, k := range keysForStringToMsgMap {
		mapStringForStringToMsgMap += fmt.Sprintf("%v: %v,", k, this.StringToMsgMap[k])
	}
	mapStringForStringToMsgMap += "}"
	s := strings.Join([]string{`&AllMapsOrdered{`,
		`StringToDoubleMap:` + mapStringForStringToDoubleMap + `,`,
		`StringToFloatMap:` + mapStringForStringToFloatMap + `,`,
		`Int32Map:` + mapStringForInt32Map + `,`,
		`Int64Map:` + mapStringForInt64Map + `,`,
		`Uint32Map:` + mapStringForUint32Map + `,`,
		`Uint64Map:` + mapStringForUint64Map + `,`,
		`Sint32Map:` + mapStringForSint32Map + `,`,
		`Sint64Map:` + mapStringForSint64Map + `,`,
		`Fixed32Map:` + mapStringForFixed32Map + `,`,
		`Sfixed32Map:` + mapStringForSfixed32Map + `,`,
		`Fixed64Map:` + mapStringForFixed64Map + `,`,
		`Sfixed64Map:` + mapStringForSfixed64Map + `,`,
		`BoolMap:` + mapStringForBoolMap + `,`,
		`StringMap:` + mapStringForStringMap + `,`,
		`StringToBytesMap:` + mapStringForStringToBytesMap + `,`,
		`StringToEnumMap:` + mapStringForStringToEnumMap + `,`,
		`StringToMsgMap:` + mapStringForStringToMsgMap + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageWithMap) String() string {
	if this == nil {
		return "nil"
	}
	keysForNameMapping := make([]int32, 0, len(this.NameMapping))
	for k := range this.NameMapping {
		keysForNameMapping = append(keysForNameMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNameMapping)
	mapStringForNameMapping := "map[int32]string{"
	for _, k := range keysForNameMapping {
		mapStringForNameMapping += fmt.Sprintf("%v: %v,", k, this.NameMapping[k])
	}
	mapStringForNameMapping += "}"
	keysForMsgMapping := make([]int64, 0, len(this.MsgMapping))
	for k := range this.MsgMapping {
		keysForMsgMapping = append(keysForMsgMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForMsgMapping)
	mapStringForMsgMapping := "map[int64]*FloatingPoint{"
	for _, k := range keysForMsgMapping {
		mapStringForMsgMapping += fmt.Sprintf("%v: %v,", k, this.MsgMapping[k])
	}
	mapStringForMsgMapping += "}"
	keysForByteMapping := make([]bool, 0, len(this.ByteMapping))
	for k := range this.ByteMapping {
		keysForByteMapping = append(keysForByteMapping, k)
	}
	github_com_gogo_protobuf_sortkeys.Bools(keysForByteMapping)
	mapStringForByteMapping := "map[bool][]byte{"
	for _, k := range keysForByteMapping {
		mapStringForByteMapping += fmt.Sprintf("%v: %v,", k, this.ByteMapping[k])
	}
	mapStringForByteMapping += "}"
	s := strings.Join([]string{`&MessageWithMap{`,
		`NameMapping:` + mapStringForNameMapping + `,`,
		`MsgMapping:` + mapStringForMsgMapping + `,`,
		`ByteMapping:` + mapStringForByteMapping + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FloatingPoint) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FloatingPoint{`,
		`F:` + fmt.Sprintf("%v", this.F) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Uint128Pair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Uint128Pair{`,
		`Left:` + fmt.Sprintf("%v", this.Left) + `,`,
		`Right:` + fmt.Sprintf("%v", this.Right) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainsNestedMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainsNestedMap{`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainsNestedMap_NestedMap) String() string {
	if this == nil {
		return "nil"
	}
	keysForNestedMapField := make([]string, 0, len(this.NestedMapField))
	for k := range this.NestedMapField {
		keysForNestedMapField = append(keysForNestedMapField, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForNestedMapField)
	mapStringForNestedMapField := "map[string]float64{"
	for _, k := range keysForNestedMapField {
		mapStringForNestedMapField += fmt.Sprintf("%v: %v,", k, this.NestedMapField[k])
	}
	mapStringForNestedMapField += "}"
	s := strings.Join([]string{`&ContainsNestedMap_NestedMap{`,
		`NestedMapField:` + mapStringForNestedMapField + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NotPacked) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NotPacked{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTheproto3(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hilarity", wireType)
			}
			m.Hilarity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hilarity |= Message_Humour(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeightInCm", wireType)
			}
			m.HeightInCm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeightInCm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultCount", wireType)
			}
			m.ResultCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrueScotsman", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrueScotsman = bool(v != 0)
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTheproto3
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTheproto3
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nested == nil {
				m.Nested = &Nested{}
			}
			if err := m.Nested.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terrain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Terrain == nil {
				m.Terrain = make(map[int64]*Nested)
			}
			var mapkey int64
			var mapvalue *Nested
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTheproto3
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Nested{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Terrain[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto2Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proto2Field == nil {
				m.Proto2Field = &both.NinOptNative{}
			}
			if err := m.Proto2Field.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto2Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proto2Value == nil {
				m.Proto2Value = make(map[int64]*both.NinOptEnum)
			}
			var mapkey int64
			var mapvalue *both.NinOptEnum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTheproto3
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &both.NinOptEnum{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Proto2Value[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bunny", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bunny = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllMaps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllMaps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllMaps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToDoubleMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToDoubleMap == nil {
				m.StringToDoubleMap = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToDoubleMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToFloatMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToFloatMap == nil {
				m.StringToFloatMap = make(map[string]float32)
			}
			var mapkey string
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToFloatMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Int32Map == nil {
				m.Int32Map = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Int32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Int64Map == nil {
				m.Int64Map = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Int64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uint32Map == nil {
				m.Uint32Map = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uint32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uint64Map == nil {
				m.Uint64Map = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uint64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sint32Map == nil {
				m.Sint32Map = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
					mapkey = int32(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sint32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sint64Map == nil {
				m.Sint64Map = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
					mapkey = int64(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sint64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fixed32Map == nil {
				m.Fixed32Map = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fixed32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sfixed32Map == nil {
				m.Sfixed32Map = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sfixed32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fixed64Map == nil {
				m.Fixed64Map = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fixed64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sfixed64Map == nil {
				m.Sfixed64Map = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sfixed64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoolMap == nil {
				m.BoolMap = make(map[bool]bool)
			}
			var mapkey bool
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkey = bool(mapkeytemp != 0)
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BoolMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringMap == nil {
				m.StringMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToBytesMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToBytesMap == nil {
				m.StringToBytesMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthTheproto3
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToBytesMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToEnumMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToEnumMap == nil {
				m.StringToEnumMap = make(map[string]MapEnum)
			}
			var mapkey string
			var mapvalue MapEnum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= MapEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToEnumMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToMsgMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToMsgMap == nil {
				m.StringToMsgMap = make(map[string]*FloatingPoint)
			}
			var mapkey string
			var mapvalue *FloatingPoint
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTheproto3
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FloatingPoint{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToMsgMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllMapsOrdered) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllMapsOrdered: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllMapsOrdered: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToDoubleMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToDoubleMap == nil {
				m.StringToDoubleMap = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToDoubleMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToFloatMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToFloatMap == nil {
				m.StringToFloatMap = make(map[string]float32)
			}
			var mapkey string
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToFloatMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Int32Map == nil {
				m.Int32Map = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Int32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Int64Map == nil {
				m.Int64Map = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Int64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uint32Map == nil {
				m.Uint32Map = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uint32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uint64Map == nil {
				m.Uint64Map = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Uint64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sint32Map == nil {
				m.Sint32Map = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = int32((uint32(mapkeytemp) >> 1) ^ uint32(((mapkeytemp&1)<<31)>>31))
					mapkey = int32(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = int32((uint32(mapvaluetemp) >> 1) ^ uint32(((mapvaluetemp&1)<<31)>>31))
					mapvalue = int32(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sint32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sint64Map == nil {
				m.Sint64Map = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
					mapkey = int64(mapkeytemp)
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvaluetemp = (mapvaluetemp >> 1) ^ uint64((int64(mapvaluetemp&1)<<63)>>63)
					mapvalue = int64(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sint64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fixed32Map == nil {
				m.Fixed32Map = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fixed32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed32Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sfixed32Map == nil {
				m.Sfixed32Map = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sfixed32Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fixed64Map == nil {
				m.Fixed64Map = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fixed64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed64Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sfixed64Map == nil {
				m.Sfixed64Map = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else if fieldNum == 2 {
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sfixed64Map[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BoolMap == nil {
				m.BoolMap = make(map[bool]bool)
			}
			var mapkey bool
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkey = bool(mapkeytemp != 0)
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BoolMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringMap == nil {
				m.StringMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToBytesMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToBytesMap == nil {
				m.StringToBytesMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthTheproto3
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToBytesMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToEnumMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToEnumMap == nil {
				m.StringToEnumMap = make(map[string]MapEnum)
			}
			var mapkey string
			var mapvalue MapEnum
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= MapEnum(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToEnumMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringToMsgMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StringToMsgMap == nil {
				m.StringToMsgMap = make(map[string]*FloatingPoint)
			}
			var mapkey string
			var mapvalue *FloatingPoint
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTheproto3
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FloatingPoint{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StringToMsgMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageWithMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageWithMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageWithMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NameMapping == nil {
				m.NameMapping = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NameMapping[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgMapping == nil {
				m.MsgMapping = make(map[int64]*FloatingPoint)
			}
			var mapkey int64
			var mapvalue *FloatingPoint
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkeytemp = (mapkeytemp >> 1) ^ uint64((int64(mapkeytemp&1)<<63)>>63)
					mapkey = int64(mapkeytemp)
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTheproto3
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FloatingPoint{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MsgMapping[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ByteMapping == nil {
				m.ByteMapping = make(map[bool][]byte)
			}
			var mapkey bool
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var mapkeytemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkeytemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapkey = bool(mapkeytemp != 0)
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthTheproto3
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ByteMapping[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatingPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatingPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatingPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.F = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Uint128Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Uint128Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Uint128Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_gogo_protobuf_test_custom.Uint128
			m.Right = &v
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainsNestedMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainsNestedMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainsNestedMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainsNestedMap_NestedMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NestedMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NestedMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NestedMapField", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheproto3
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheproto3
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NestedMapField == nil {
				m.NestedMapField = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTheproto3
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTheproto3(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTheproto3
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NestedMapField[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotPacked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotPacked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotPacked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheproto3
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTheproto3
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTheproto3
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTheproto3
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheproto3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheproto3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTheproto3(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTheproto3
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTheproto3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTheproto3
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTheproto3
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTheproto3
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTheproto3        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTheproto3          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTheproto3 = fmt.Errorf("proto: unexpected end of group")
)
