// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: unmarshalmerge.proto

package unmarshalmerge

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Big struct {
	Sub                  *Sub     `protobuf:"bytes,1,opt,name=Sub" json:"Sub,omitempty"`
	Number               *int64   `protobuf:"varint,2,opt,name=Number" json:"Number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Big) Reset()      { *m = Big{} }
func (*Big) ProtoMessage() {}
func (*Big) Descriptor() ([]byte, []int) {
	return fileDescriptor_701a7743bfe9c603, []int{0}
}
func (m *Big) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Big) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Big.Marshal(b, m, deterministic)
}
func (m *Big) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Big.Merge(m, src)
}
func (m *Big) XXX_Size() int {
	return xxx_messageInfo_Big.Size(m)
}
func (m *Big) XXX_DiscardUnknown() {
	xxx_messageInfo_Big.DiscardUnknown(m)
}

var xxx_messageInfo_Big proto.InternalMessageInfo

func (m *Big) GetSub() *Sub {
	if m != nil {
		return m.Sub
	}
	return nil
}

func (m *Big) GetNumber() int64 {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return 0
}

type BigUnsafe struct {
	Sub                  *Sub     `protobuf:"bytes,1,opt,name=Sub" json:"Sub,omitempty"`
	Number               *int64   `protobuf:"varint,2,opt,name=Number" json:"Number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BigUnsafe) Reset()      { *m = BigUnsafe{} }
func (*BigUnsafe) ProtoMessage() {}
func (*BigUnsafe) Descriptor() ([]byte, []int) {
	return fileDescriptor_701a7743bfe9c603, []int{1}
}
func (m *BigUnsafe) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BigUnsafe.Unmarshal(m, b)
}
func (m *BigUnsafe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BigUnsafe.Marshal(b, m, deterministic)
}
func (m *BigUnsafe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BigUnsafe.Merge(m, src)
}
func (m *BigUnsafe) XXX_Size() int {
	return xxx_messageInfo_BigUnsafe.Size(m)
}
func (m *BigUnsafe) XXX_DiscardUnknown() {
	xxx_messageInfo_BigUnsafe.DiscardUnknown(m)
}

var xxx_messageInfo_BigUnsafe proto.InternalMessageInfo

func (m *BigUnsafe) GetSub() *Sub {
	if m != nil {
		return m.Sub
	}
	return nil
}

func (m *BigUnsafe) GetNumber() int64 {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return 0
}

type Sub struct {
	SubNumber            *int64   `protobuf:"varint,1,opt,name=SubNumber" json:"SubNumber,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Sub) Reset()      { *m = Sub{} }
func (*Sub) ProtoMessage() {}
func (*Sub) Descriptor() ([]byte, []int) {
	return fileDescriptor_701a7743bfe9c603, []int{2}
}
func (m *Sub) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sub) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Sub.Marshal(b, m, deterministic)
}
func (m *Sub) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sub.Merge(m, src)
}
func (m *Sub) XXX_Size() int {
	return xxx_messageInfo_Sub.Size(m)
}
func (m *Sub) XXX_DiscardUnknown() {
	xxx_messageInfo_Sub.DiscardUnknown(m)
}

var xxx_messageInfo_Sub proto.InternalMessageInfo

func (m *Sub) GetSubNumber() int64 {
	if m != nil && m.SubNumber != nil {
		return *m.SubNumber
	}
	return 0
}

type IntMerge struct {
	Int64                int64    `protobuf:"varint,1,req,name=Int64" json:"Int64"`
	Int32                int32    `protobuf:"varint,2,opt,name=Int32" json:"Int32"`
	Sint32               int32    `protobuf:"zigzag32,3,req,name=Sint32" json:"Sint32"`
	Sint64               int64    `protobuf:"zigzag64,4,opt,name=Sint64" json:"Sint64"`
	Uint64               uint64   `protobuf:"varint,5,opt,name=Uint64" json:"Uint64"`
	Uint32               uint32   `protobuf:"varint,6,req,name=Uint32" json:"Uint32"`
	Fixed64              uint64   `protobuf:"fixed64,7,opt,name=Fixed64" json:"Fixed64"`
	Fixed32              uint32   `protobuf:"fixed32,8,opt,name=Fixed32" json:"Fixed32"`
	Sfixed32             int32    `protobuf:"fixed32,9,req,name=Sfixed32" json:"Sfixed32"`
	Sfixed64             int64    `protobuf:"fixed64,10,opt,name=Sfixed64" json:"Sfixed64"`
	Bool                 bool     `protobuf:"varint,11,opt,name=Bool" json:"Bool"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntMerge) Reset()      { *m = IntMerge{} }
func (*IntMerge) ProtoMessage() {}
func (*IntMerge) Descriptor() ([]byte, []int) {
	return fileDescriptor_701a7743bfe9c603, []int{3}
}
func (m *IntMerge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntMerge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IntMerge.Marshal(b, m, deterministic)
}
func (m *IntMerge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntMerge.Merge(m, src)
}
func (m *IntMerge) XXX_Size() int {
	return xxx_messageInfo_IntMerge.Size(m)
}
func (m *IntMerge) XXX_DiscardUnknown() {
	xxx_messageInfo_IntMerge.DiscardUnknown(m)
}

var xxx_messageInfo_IntMerge proto.InternalMessageInfo

func (m *IntMerge) GetInt64() int64 {
	if m != nil {
		return m.Int64
	}
	return 0
}

func (m *IntMerge) GetInt32() int32 {
	if m != nil {
		return m.Int32
	}
	return 0
}

func (m *IntMerge) GetSint32() int32 {
	if m != nil {
		return m.Sint32
	}
	return 0
}

func (m *IntMerge) GetSint64() int64 {
	if m != nil {
		return m.Sint64
	}
	return 0
}

func (m *IntMerge) GetUint64() uint64 {
	if m != nil {
		return m.Uint64
	}
	return 0
}

func (m *IntMerge) GetUint32() uint32 {
	if m != nil {
		return m.Uint32
	}
	return 0
}

func (m *IntMerge) GetFixed64() uint64 {
	if m != nil {
		return m.Fixed64
	}
	return 0
}

func (m *IntMerge) GetFixed32() uint32 {
	if m != nil {
		return m.Fixed32
	}
	return 0
}

func (m *IntMerge) GetSfixed32() int32 {
	if m != nil {
		return m.Sfixed32
	}
	return 0
}

func (m *IntMerge) GetSfixed64() int64 {
	if m != nil {
		return m.Sfixed64
	}
	return 0
}

func (m *IntMerge) GetBool() bool {
	if m != nil {
		return m.Bool
	}
	return false
}

func init() {
	proto.RegisterType((*Big)(nil), "unmarshalmerge.Big")
	proto.RegisterType((*BigUnsafe)(nil), "unmarshalmerge.BigUnsafe")
	proto.RegisterType((*Sub)(nil), "unmarshalmerge.Sub")
	proto.RegisterType((*IntMerge)(nil), "unmarshalmerge.IntMerge")
}

func init() { proto.RegisterFile("unmarshalmerge.proto", fileDescriptor_701a7743bfe9c603) }

var fileDescriptor_701a7743bfe9c603 = []byte{
	// 386 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0xd0, 0xcd, 0x8a, 0x9b, 0x50,
	0x14, 0x07, 0xf0, 0x1c, 0x35, 0xc6, 0xdc, 0xd0, 0xaf, 0xdb, 0x52, 0x2e, 0x21, 0xdc, 0x5c, 0x02,
	0x85, 0xdb, 0x45, 0x13, 0x50, 0x71, 0xd1, 0xa5, 0x8b, 0x42, 0x0a, 0x2d, 0x25, 0x92, 0x07, 0x88,
	0xad, 0x31, 0x42, 0xd4, 0x62, 0x14, 0xba, 0xec, 0x23, 0xf4, 0x15, 0xba, 0x9b, 0x47, 0x98, 0x65,
	0x96, 0xf3, 0x08, 0xb3, 0x0a, 0xa3, 0x4f, 0x30, 0xcb, 0x59, 0x0e, 0x5e, 0x6f, 0x3e, 0x9c, 0xed,
	0xec, 0x3c, 0xff, 0xdf, 0xdf, 0x73, 0xe0, 0xa2, 0x77, 0x45, 0x12, 0xaf, 0xb2, 0xdd, 0x66, 0xb5,
	0x8d, 0x83, 0x2c, 0x0c, 0xa6, 0xbf, 0xb3, 0x34, 0x4f, 0xf1, 0xcb, 0x76, 0x3a, 0xfc, 0x14, 0x46,
	0xf9, 0xa6, 0xf0, 0xa7, 0x3f, 0xd3, 0x78, 0x16, 0xa6, 0x61, 0x3a, 0x13, 0x35, 0xbf, 0x58, 0x8b,
	0x49, 0x0c, 0xe2, 0xab, 0xf9, 0x7d, 0xf2, 0x15, 0xa9, 0x6e, 0x14, 0xe2, 0x0f, 0x48, 0xf5, 0x0a,
	0x9f, 0x00, 0x03, 0x3e, 0x30, 0xdf, 0x4e, 0x9f, 0x5c, 0xf2, 0x0a, 0x7f, 0x51, 0x3b, 0x7e, 0x8f,
	0xf4, 0xef, 0x45, 0xec, 0x07, 0x19, 0x51, 0x18, 0x70, 0x75, 0x21, 0xa7, 0xcf, 0xda, 0xbf, 0xff,
	0x63, 0x98, 0xfc, 0x40, 0x7d, 0x37, 0x0a, 0x97, 0xc9, 0x6e, 0xb5, 0x0e, 0x9e, 0xbd, 0x71, 0x5f,
	0x6f, 0xfc, 0x28, 0x96, 0xe0, 0x11, 0xea, 0x7b, 0x85, 0x2f, 0x7b, 0x20, 0x7a, 0xe7, 0x40, 0x1e,
	0x3f, 0x28, 0xc8, 0x98, 0x27, 0xf9, 0xb7, 0x7a, 0x3d, 0x1e, 0xa2, 0xee, 0x3c, 0xc9, 0x1d, 0x9b,
	0x00, 0x53, 0xb8, 0xea, 0x6a, 0x37, 0x87, 0x71, 0x67, 0xd1, 0x44, 0xd2, 0x2c, 0x53, 0x1c, 0xec,
	0x5e, 0x98, 0x65, 0xe2, 0x11, 0xd2, 0xbd, 0x48, 0xa0, 0xca, 0x14, 0xfe, 0x46, 0xa2, 0xcc, 0x8e,
	0xea, 0xd8, 0x44, 0x63, 0xc0, 0xf1, 0xa5, 0x3a, 0x76, 0xad, 0xcb, 0x46, 0xbb, 0x0c, 0xb8, 0x76,
	0xd4, 0x65, 0x4b, 0x2d, 0x93, 0xe8, 0x4c, 0xe1, 0x2f, 0x2e, 0xd5, 0x32, 0x31, 0x45, 0xbd, 0x2f,
	0xd1, 0x9f, 0xe0, 0x97, 0x63, 0x93, 0x1e, 0x03, 0xae, 0x4b, 0x3e, 0x86, 0x27, 0xb7, 0x4c, 0x62,
	0x30, 0xe0, 0xbd, 0x96, 0x5b, 0x26, 0x66, 0xc8, 0xf0, 0xd6, 0xb2, 0xd0, 0x67, 0x0a, 0x7f, 0x25,
	0x0b, 0xa7, 0xf4, 0xdc, 0x70, 0x6c, 0x82, 0x18, 0xf0, 0xd7, 0xed, 0x86, 0x63, 0x63, 0x82, 0x34,
	0x37, 0x4d, 0xb7, 0x64, 0xc0, 0x80, 0x1b, 0x52, 0x45, 0xd2, 0x3c, 0xb0, 0xcb, 0x6e, 0x4b, 0xda,
	0xb9, 0x2b, 0x29, 0xdc, 0x97, 0x14, 0x1e, 0x4a, 0x0a, 0x7f, 0x2b, 0x0a, 0x57, 0x15, 0x85, 0xeb,
	0x8a, 0xc2, 0xbe, 0xa2, 0xf0, 0x18, 0x00, 0x00, 0xff, 0xff, 0xb2, 0x4e, 0xc7, 0x4e, 0xa1, 0x02,
	0x00, 0x00,
}

func (this *Big) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Big)
	if !ok {
		that2, ok := that.(Big)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Big")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Big but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Big but is not nil && this == nil")
	}
	if !this.Sub.Equal(that1.Sub) {
		return fmt.Errorf("Sub this(%v) Not Equal that(%v)", this.Sub, that1.Sub)
	}
	if this.Number != nil && that1.Number != nil {
		if *this.Number != *that1.Number {
			return fmt.Errorf("Number this(%v) Not Equal that(%v)", *this.Number, *that1.Number)
		}
	} else if this.Number != nil {
		return fmt.Errorf("this.Number == nil && that.Number != nil")
	} else if that1.Number != nil {
		return fmt.Errorf("Number this(%v) Not Equal that(%v)", this.Number, that1.Number)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Big) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Big)
	if !ok {
		that2, ok := that.(Big)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sub.Equal(that1.Sub) {
		return false
	}
	if this.Number != nil && that1.Number != nil {
		if *this.Number != *that1.Number {
			return false
		}
	} else if this.Number != nil {
		return false
	} else if that1.Number != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *BigUnsafe) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*BigUnsafe)
	if !ok {
		that2, ok := that.(BigUnsafe)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *BigUnsafe")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *BigUnsafe but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *BigUnsafe but is not nil && this == nil")
	}
	if !this.Sub.Equal(that1.Sub) {
		return fmt.Errorf("Sub this(%v) Not Equal that(%v)", this.Sub, that1.Sub)
	}
	if this.Number != nil && that1.Number != nil {
		if *this.Number != *that1.Number {
			return fmt.Errorf("Number this(%v) Not Equal that(%v)", *this.Number, *that1.Number)
		}
	} else if this.Number != nil {
		return fmt.Errorf("this.Number == nil && that.Number != nil")
	} else if that1.Number != nil {
		return fmt.Errorf("Number this(%v) Not Equal that(%v)", this.Number, that1.Number)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *BigUnsafe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BigUnsafe)
	if !ok {
		that2, ok := that.(BigUnsafe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sub.Equal(that1.Sub) {
		return false
	}
	if this.Number != nil && that1.Number != nil {
		if *this.Number != *that1.Number {
			return false
		}
	} else if this.Number != nil {
		return false
	} else if that1.Number != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Sub) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Sub)
	if !ok {
		that2, ok := that.(Sub)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Sub")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Sub but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Sub but is not nil && this == nil")
	}
	if this.SubNumber != nil && that1.SubNumber != nil {
		if *this.SubNumber != *that1.SubNumber {
			return fmt.Errorf("SubNumber this(%v) Not Equal that(%v)", *this.SubNumber, *that1.SubNumber)
		}
	} else if this.SubNumber != nil {
		return fmt.Errorf("this.SubNumber == nil && that.SubNumber != nil")
	} else if that1.SubNumber != nil {
		return fmt.Errorf("SubNumber this(%v) Not Equal that(%v)", this.SubNumber, that1.SubNumber)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Sub) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sub)
	if !ok {
		that2, ok := that.(Sub)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubNumber != nil && that1.SubNumber != nil {
		if *this.SubNumber != *that1.SubNumber {
			return false
		}
	} else if this.SubNumber != nil {
		return false
	} else if that1.SubNumber != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *IntMerge) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*IntMerge)
	if !ok {
		that2, ok := that.(IntMerge)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *IntMerge")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *IntMerge but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *IntMerge but is not nil && this == nil")
	}
	if this.Int64 != that1.Int64 {
		return fmt.Errorf("Int64 this(%v) Not Equal that(%v)", this.Int64, that1.Int64)
	}
	if this.Int32 != that1.Int32 {
		return fmt.Errorf("Int32 this(%v) Not Equal that(%v)", this.Int32, that1.Int32)
	}
	if this.Sint32 != that1.Sint32 {
		return fmt.Errorf("Sint32 this(%v) Not Equal that(%v)", this.Sint32, that1.Sint32)
	}
	if this.Sint64 != that1.Sint64 {
		return fmt.Errorf("Sint64 this(%v) Not Equal that(%v)", this.Sint64, that1.Sint64)
	}
	if this.Uint64 != that1.Uint64 {
		return fmt.Errorf("Uint64 this(%v) Not Equal that(%v)", this.Uint64, that1.Uint64)
	}
	if this.Uint32 != that1.Uint32 {
		return fmt.Errorf("Uint32 this(%v) Not Equal that(%v)", this.Uint32, that1.Uint32)
	}
	if this.Fixed64 != that1.Fixed64 {
		return fmt.Errorf("Fixed64 this(%v) Not Equal that(%v)", this.Fixed64, that1.Fixed64)
	}
	if this.Fixed32 != that1.Fixed32 {
		return fmt.Errorf("Fixed32 this(%v) Not Equal that(%v)", this.Fixed32, that1.Fixed32)
	}
	if this.Sfixed32 != that1.Sfixed32 {
		return fmt.Errorf("Sfixed32 this(%v) Not Equal that(%v)", this.Sfixed32, that1.Sfixed32)
	}
	if this.Sfixed64 != that1.Sfixed64 {
		return fmt.Errorf("Sfixed64 this(%v) Not Equal that(%v)", this.Sfixed64, that1.Sfixed64)
	}
	if this.Bool != that1.Bool {
		return fmt.Errorf("Bool this(%v) Not Equal that(%v)", this.Bool, that1.Bool)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *IntMerge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IntMerge)
	if !ok {
		that2, ok := that.(IntMerge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Int64 != that1.Int64 {
		return false
	}
	if this.Int32 != that1.Int32 {
		return false
	}
	if this.Sint32 != that1.Sint32 {
		return false
	}
	if this.Sint64 != that1.Sint64 {
		return false
	}
	if this.Uint64 != that1.Uint64 {
		return false
	}
	if this.Uint32 != that1.Uint32 {
		return false
	}
	if this.Fixed64 != that1.Fixed64 {
		return false
	}
	if this.Fixed32 != that1.Fixed32 {
		return false
	}
	if this.Sfixed32 != that1.Sfixed32 {
		return false
	}
	if this.Sfixed64 != that1.Sfixed64 {
		return false
	}
	if this.Bool != that1.Bool {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Big) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&unmarshalmerge.Big{")
	if this.Sub != nil {
		s = append(s, "Sub: "+fmt.Sprintf("%#v", this.Sub)+",\n")
	}
	if this.Number != nil {
		s = append(s, "Number: "+valueToGoStringUnmarshalmerge(this.Number, "int64")+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BigUnsafe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&unmarshalmerge.BigUnsafe{")
	if this.Sub != nil {
		s = append(s, "Sub: "+fmt.Sprintf("%#v", this.Sub)+",\n")
	}
	if this.Number != nil {
		s = append(s, "Number: "+valueToGoStringUnmarshalmerge(this.Number, "int64")+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sub) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&unmarshalmerge.Sub{")
	if this.SubNumber != nil {
		s = append(s, "SubNumber: "+valueToGoStringUnmarshalmerge(this.SubNumber, "int64")+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IntMerge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&unmarshalmerge.IntMerge{")
	s = append(s, "Int64: "+fmt.Sprintf("%#v", this.Int64)+",\n")
	s = append(s, "Int32: "+fmt.Sprintf("%#v", this.Int32)+",\n")
	s = append(s, "Sint32: "+fmt.Sprintf("%#v", this.Sint32)+",\n")
	s = append(s, "Sint64: "+fmt.Sprintf("%#v", this.Sint64)+",\n")
	s = append(s, "Uint64: "+fmt.Sprintf("%#v", this.Uint64)+",\n")
	s = append(s, "Uint32: "+fmt.Sprintf("%#v", this.Uint32)+",\n")
	s = append(s, "Fixed64: "+fmt.Sprintf("%#v", this.Fixed64)+",\n")
	s = append(s, "Fixed32: "+fmt.Sprintf("%#v", this.Fixed32)+",\n")
	s = append(s, "Sfixed32: "+fmt.Sprintf("%#v", this.Sfixed32)+",\n")
	s = append(s, "Sfixed64: "+fmt.Sprintf("%#v", this.Sfixed64)+",\n")
	s = append(s, "Bool: "+fmt.Sprintf("%#v", this.Bool)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringUnmarshalmerge(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func NewPopulatedBig(r randyUnmarshalmerge, easy bool) *Big {
	this := &Big{}
	if r.Intn(5) != 0 {
		this.Sub = NewPopulatedSub(r, easy)
	}
	if r.Intn(5) != 0 {
		v1 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v1 *= -1
		}
		this.Number = &v1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedUnmarshalmerge(r, 3)
	}
	return this
}

func NewPopulatedBigUnsafe(r randyUnmarshalmerge, easy bool) *BigUnsafe {
	this := &BigUnsafe{}
	if r.Intn(5) != 0 {
		this.Sub = NewPopulatedSub(r, easy)
	}
	if r.Intn(5) != 0 {
		v2 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v2 *= -1
		}
		this.Number = &v2
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedUnmarshalmerge(r, 3)
	}
	return this
}

func NewPopulatedSub(r randyUnmarshalmerge, easy bool) *Sub {
	this := &Sub{}
	if r.Intn(5) != 0 {
		v3 := int64(r.Int63())
		if r.Intn(2) == 0 {
			v3 *= -1
		}
		this.SubNumber = &v3
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedUnmarshalmerge(r, 2)
	}
	return this
}

func NewPopulatedIntMerge(r randyUnmarshalmerge, easy bool) *IntMerge {
	this := &IntMerge{}
	this.Int64 = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Int64 *= -1
	}
	this.Int32 = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Int32 *= -1
	}
	this.Sint32 = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Sint32 *= -1
	}
	this.Sint64 = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Sint64 *= -1
	}
	this.Uint64 = uint64(uint64(r.Uint32()))
	this.Uint32 = uint32(r.Uint32())
	this.Fixed64 = uint64(uint64(r.Uint32()))
	this.Fixed32 = uint32(r.Uint32())
	this.Sfixed32 = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Sfixed32 *= -1
	}
	this.Sfixed64 = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Sfixed64 *= -1
	}
	this.Bool = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedUnmarshalmerge(r, 12)
	}
	return this
}

type randyUnmarshalmerge interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneUnmarshalmerge(r randyUnmarshalmerge) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringUnmarshalmerge(r randyUnmarshalmerge) string {
	v4 := r.Intn(100)
	tmps := make([]rune, v4)
	for i := 0; i < v4; i++ {
		tmps[i] = randUTF8RuneUnmarshalmerge(r)
	}
	return string(tmps)
}
func randUnrecognizedUnmarshalmerge(r randyUnmarshalmerge, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldUnmarshalmerge(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldUnmarshalmerge(dAtA []byte, r randyUnmarshalmerge, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateUnmarshalmerge(dAtA, uint64(key))
		v5 := r.Int63()
		if r.Intn(2) == 0 {
			v5 *= -1
		}
		dAtA = encodeVarintPopulateUnmarshalmerge(dAtA, uint64(v5))
	case 1:
		dAtA = encodeVarintPopulateUnmarshalmerge(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateUnmarshalmerge(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateUnmarshalmerge(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateUnmarshalmerge(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateUnmarshalmerge(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (this *Big) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Big{`,
		`Sub:` + strings.Replace(this.Sub.String(), "Sub", "Sub", 1) + `,`,
		`Number:` + valueToStringUnmarshalmerge(this.Number) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BigUnsafe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BigUnsafe{`,
		`Sub:` + strings.Replace(this.Sub.String(), "Sub", "Sub", 1) + `,`,
		`Number:` + valueToStringUnmarshalmerge(this.Number) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sub) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sub{`,
		`SubNumber:` + valueToStringUnmarshalmerge(this.SubNumber) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IntMerge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IntMerge{`,
		`Int64:` + fmt.Sprintf("%v", this.Int64) + `,`,
		`Int32:` + fmt.Sprintf("%v", this.Int32) + `,`,
		`Sint32:` + fmt.Sprintf("%v", this.Sint32) + `,`,
		`Sint64:` + fmt.Sprintf("%v", this.Sint64) + `,`,
		`Uint64:` + fmt.Sprintf("%v", this.Uint64) + `,`,
		`Uint32:` + fmt.Sprintf("%v", this.Uint32) + `,`,
		`Fixed64:` + fmt.Sprintf("%v", this.Fixed64) + `,`,
		`Fixed32:` + fmt.Sprintf("%v", this.Fixed32) + `,`,
		`Sfixed32:` + fmt.Sprintf("%v", this.Sfixed32) + `,`,
		`Sfixed64:` + fmt.Sprintf("%v", this.Sfixed64) + `,`,
		`Bool:` + fmt.Sprintf("%v", this.Bool) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringUnmarshalmerge(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Big) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUnmarshalmerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Big: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Big: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUnmarshalmerge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUnmarshalmerge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sub == nil {
				m.Sub = &Sub{}
			}
			if err := m.Sub.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		default:
			iNdEx = preIndex
			skippy, err := skipUnmarshalmerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUnmarshalmerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BigUnsafe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUnmarshalmerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BigUnsafe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BigUnsafe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUnmarshalmerge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUnmarshalmerge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sub == nil {
				m.Sub = &Sub{}
			}
			if err := m.Sub.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		default:
			iNdEx = preIndex
			skippy, err := skipUnmarshalmerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUnmarshalmerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sub) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUnmarshalmerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sub: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sub: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubNumber", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SubNumber = &v
		default:
			iNdEx = preIndex
			skippy, err := skipUnmarshalmerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUnmarshalmerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntMerge) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUnmarshalmerge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntMerge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntMerge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			m.Int64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32", wireType)
			}
			m.Int32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int32 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint32", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Sint32 = v
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint64", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Sint64 = int64(v)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64", wireType)
			}
			m.Uint64 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uint64 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32", wireType)
			}
			m.Uint32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uint32 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64", wireType)
			}
			m.Fixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Fixed64 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32", wireType)
			}
			m.Fixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Fixed32 = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed32", wireType)
			}
			m.Sfixed32 = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.Sfixed32 = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			hasFields[0] |= uint64(0x00000008)
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed64", wireType)
			}
			m.Sfixed64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Sfixed64 = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bool = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipUnmarshalmerge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUnmarshalmerge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Int64")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Sint32")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Uint32")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Sfixed32")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUnmarshalmerge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUnmarshalmerge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUnmarshalmerge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUnmarshalmerge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUnmarshalmerge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUnmarshalmerge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUnmarshalmerge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUnmarshalmerge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUnmarshalmerge = fmt.Errorf("proto: unexpected end of group")
)
