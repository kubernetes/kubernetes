// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: packed.proto

package packed

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NinRepNative struct {
	Field1               []float64 `protobuf:"fixed64,1,rep,name=Field1" json:"Field1,omitempty"`
	Field2               []float32 `protobuf:"fixed32,2,rep,name=Field2" json:"Field2,omitempty"`
	Field3               []int32   `protobuf:"varint,3,rep,name=Field3" json:"Field3,omitempty"`
	Field4               []int64   `protobuf:"varint,4,rep,name=Field4" json:"Field4,omitempty"`
	Field5               []uint32  `protobuf:"varint,5,rep,name=Field5" json:"Field5,omitempty"`
	Field6               []uint64  `protobuf:"varint,6,rep,name=Field6" json:"Field6,omitempty"`
	Field7               []int32   `protobuf:"zigzag32,7,rep,name=Field7" json:"Field7,omitempty"`
	Field8               []int64   `protobuf:"zigzag64,8,rep,name=Field8" json:"Field8,omitempty"`
	Field9               []uint32  `protobuf:"fixed32,9,rep,name=Field9" json:"Field9,omitempty"`
	Field10              []int32   `protobuf:"fixed32,10,rep,name=Field10" json:"Field10,omitempty"`
	Field11              []uint64  `protobuf:"fixed64,11,rep,name=Field11" json:"Field11,omitempty"`
	Field12              []int64   `protobuf:"fixed64,12,rep,name=Field12" json:"Field12,omitempty"`
	Field13              []bool    `protobuf:"varint,13,rep,name=Field13" json:"Field13,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NinRepNative) Reset()         { *m = NinRepNative{} }
func (m *NinRepNative) String() string { return proto.CompactTextString(m) }
func (*NinRepNative) ProtoMessage()    {}
func (*NinRepNative) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c9922eb15f14bbb, []int{0}
}
func (m *NinRepNative) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NinRepNative) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NinRepNative.Marshal(b, m, deterministic)
}
func (m *NinRepNative) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NinRepNative.Merge(m, src)
}
func (m *NinRepNative) XXX_Size() int {
	return xxx_messageInfo_NinRepNative.Size(m)
}
func (m *NinRepNative) XXX_DiscardUnknown() {
	xxx_messageInfo_NinRepNative.DiscardUnknown(m)
}

var xxx_messageInfo_NinRepNative proto.InternalMessageInfo

func (m *NinRepNative) GetField1() []float64 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinRepNative) GetField2() []float32 {
	if m != nil {
		return m.Field2
	}
	return nil
}

func (m *NinRepNative) GetField3() []int32 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepNative) GetField4() []int64 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepNative) GetField5() []uint32 {
	if m != nil {
		return m.Field5
	}
	return nil
}

func (m *NinRepNative) GetField6() []uint64 {
	if m != nil {
		return m.Field6
	}
	return nil
}

func (m *NinRepNative) GetField7() []int32 {
	if m != nil {
		return m.Field7
	}
	return nil
}

func (m *NinRepNative) GetField8() []int64 {
	if m != nil {
		return m.Field8
	}
	return nil
}

func (m *NinRepNative) GetField9() []uint32 {
	if m != nil {
		return m.Field9
	}
	return nil
}

func (m *NinRepNative) GetField10() []int32 {
	if m != nil {
		return m.Field10
	}
	return nil
}

func (m *NinRepNative) GetField11() []uint64 {
	if m != nil {
		return m.Field11
	}
	return nil
}

func (m *NinRepNative) GetField12() []int64 {
	if m != nil {
		return m.Field12
	}
	return nil
}

func (m *NinRepNative) GetField13() []bool {
	if m != nil {
		return m.Field13
	}
	return nil
}

type NinRepPackedNative struct {
	Field1               []float64 `protobuf:"fixed64,1,rep,packed,name=Field1" json:"Field1,omitempty"`
	Field2               []float32 `protobuf:"fixed32,2,rep,packed,name=Field2" json:"Field2,omitempty"`
	Field3               []int32   `protobuf:"varint,3,rep,packed,name=Field3" json:"Field3,omitempty"`
	Field4               []int64   `protobuf:"varint,4,rep,packed,name=Field4" json:"Field4,omitempty"`
	Field5               []uint32  `protobuf:"varint,5,rep,packed,name=Field5" json:"Field5,omitempty"`
	Field6               []uint64  `protobuf:"varint,6,rep,packed,name=Field6" json:"Field6,omitempty"`
	Field7               []int32   `protobuf:"zigzag32,7,rep,packed,name=Field7" json:"Field7,omitempty"`
	Field8               []int64   `protobuf:"zigzag64,8,rep,packed,name=Field8" json:"Field8,omitempty"`
	Field9               []uint32  `protobuf:"fixed32,9,rep,packed,name=Field9" json:"Field9,omitempty"`
	Field10              []int32   `protobuf:"fixed32,10,rep,packed,name=Field10" json:"Field10,omitempty"`
	Field11              []uint64  `protobuf:"fixed64,11,rep,packed,name=Field11" json:"Field11,omitempty"`
	Field12              []int64   `protobuf:"fixed64,12,rep,packed,name=Field12" json:"Field12,omitempty"`
	Field13              []bool    `protobuf:"varint,13,rep,packed,name=Field13" json:"Field13,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NinRepPackedNative) Reset()         { *m = NinRepPackedNative{} }
func (m *NinRepPackedNative) String() string { return proto.CompactTextString(m) }
func (*NinRepPackedNative) ProtoMessage()    {}
func (*NinRepPackedNative) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c9922eb15f14bbb, []int{1}
}
func (m *NinRepPackedNative) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NinRepPackedNative) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NinRepPackedNative.Marshal(b, m, deterministic)
}
func (m *NinRepPackedNative) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NinRepPackedNative.Merge(m, src)
}
func (m *NinRepPackedNative) XXX_Size() int {
	return xxx_messageInfo_NinRepPackedNative.Size(m)
}
func (m *NinRepPackedNative) XXX_DiscardUnknown() {
	xxx_messageInfo_NinRepPackedNative.DiscardUnknown(m)
}

var xxx_messageInfo_NinRepPackedNative proto.InternalMessageInfo

func (m *NinRepPackedNative) GetField1() []float64 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinRepPackedNative) GetField2() []float32 {
	if m != nil {
		return m.Field2
	}
	return nil
}

func (m *NinRepPackedNative) GetField3() []int32 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepPackedNative) GetField4() []int64 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepPackedNative) GetField5() []uint32 {
	if m != nil {
		return m.Field5
	}
	return nil
}

func (m *NinRepPackedNative) GetField6() []uint64 {
	if m != nil {
		return m.Field6
	}
	return nil
}

func (m *NinRepPackedNative) GetField7() []int32 {
	if m != nil {
		return m.Field7
	}
	return nil
}

func (m *NinRepPackedNative) GetField8() []int64 {
	if m != nil {
		return m.Field8
	}
	return nil
}

func (m *NinRepPackedNative) GetField9() []uint32 {
	if m != nil {
		return m.Field9
	}
	return nil
}

func (m *NinRepPackedNative) GetField10() []int32 {
	if m != nil {
		return m.Field10
	}
	return nil
}

func (m *NinRepPackedNative) GetField11() []uint64 {
	if m != nil {
		return m.Field11
	}
	return nil
}

func (m *NinRepPackedNative) GetField12() []int64 {
	if m != nil {
		return m.Field12
	}
	return nil
}

func (m *NinRepPackedNative) GetField13() []bool {
	if m != nil {
		return m.Field13
	}
	return nil
}

type NinRepNativeUnsafe struct {
	Field1               []float64 `protobuf:"fixed64,1,rep,name=Field1" json:"Field1,omitempty"`
	Field2               []float32 `protobuf:"fixed32,2,rep,name=Field2" json:"Field2,omitempty"`
	Field3               []int32   `protobuf:"varint,3,rep,name=Field3" json:"Field3,omitempty"`
	Field4               []int64   `protobuf:"varint,4,rep,name=Field4" json:"Field4,omitempty"`
	Field5               []uint32  `protobuf:"varint,5,rep,name=Field5" json:"Field5,omitempty"`
	Field6               []uint64  `protobuf:"varint,6,rep,name=Field6" json:"Field6,omitempty"`
	Field7               []int32   `protobuf:"zigzag32,7,rep,name=Field7" json:"Field7,omitempty"`
	Field8               []int64   `protobuf:"zigzag64,8,rep,name=Field8" json:"Field8,omitempty"`
	Field9               []uint32  `protobuf:"fixed32,9,rep,name=Field9" json:"Field9,omitempty"`
	Field10              []int32   `protobuf:"fixed32,10,rep,name=Field10" json:"Field10,omitempty"`
	Field11              []uint64  `protobuf:"fixed64,11,rep,name=Field11" json:"Field11,omitempty"`
	Field12              []int64   `protobuf:"fixed64,12,rep,name=Field12" json:"Field12,omitempty"`
	Field13              []bool    `protobuf:"varint,13,rep,name=Field13" json:"Field13,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NinRepNativeUnsafe) Reset()         { *m = NinRepNativeUnsafe{} }
func (m *NinRepNativeUnsafe) String() string { return proto.CompactTextString(m) }
func (*NinRepNativeUnsafe) ProtoMessage()    {}
func (*NinRepNativeUnsafe) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c9922eb15f14bbb, []int{2}
}
func (m *NinRepNativeUnsafe) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NinRepNativeUnsafe.Unmarshal(m, b)
}
func (m *NinRepNativeUnsafe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NinRepNativeUnsafe.Marshal(b, m, deterministic)
}
func (m *NinRepNativeUnsafe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NinRepNativeUnsafe.Merge(m, src)
}
func (m *NinRepNativeUnsafe) XXX_Size() int {
	return xxx_messageInfo_NinRepNativeUnsafe.Size(m)
}
func (m *NinRepNativeUnsafe) XXX_DiscardUnknown() {
	xxx_messageInfo_NinRepNativeUnsafe.DiscardUnknown(m)
}

var xxx_messageInfo_NinRepNativeUnsafe proto.InternalMessageInfo

func (m *NinRepNativeUnsafe) GetField1() []float64 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField2() []float32 {
	if m != nil {
		return m.Field2
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField3() []int32 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField4() []int64 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField5() []uint32 {
	if m != nil {
		return m.Field5
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField6() []uint64 {
	if m != nil {
		return m.Field6
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField7() []int32 {
	if m != nil {
		return m.Field7
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField8() []int64 {
	if m != nil {
		return m.Field8
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField9() []uint32 {
	if m != nil {
		return m.Field9
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField10() []int32 {
	if m != nil {
		return m.Field10
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField11() []uint64 {
	if m != nil {
		return m.Field11
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField12() []int64 {
	if m != nil {
		return m.Field12
	}
	return nil
}

func (m *NinRepNativeUnsafe) GetField13() []bool {
	if m != nil {
		return m.Field13
	}
	return nil
}

type NinRepPackedNativeUnsafe struct {
	Field1               []float64 `protobuf:"fixed64,1,rep,packed,name=Field1" json:"Field1,omitempty"`
	Field2               []float32 `protobuf:"fixed32,2,rep,packed,name=Field2" json:"Field2,omitempty"`
	Field3               []int32   `protobuf:"varint,3,rep,packed,name=Field3" json:"Field3,omitempty"`
	Field4               []int64   `protobuf:"varint,4,rep,packed,name=Field4" json:"Field4,omitempty"`
	Field5               []uint32  `protobuf:"varint,5,rep,packed,name=Field5" json:"Field5,omitempty"`
	Field6               []uint64  `protobuf:"varint,6,rep,packed,name=Field6" json:"Field6,omitempty"`
	Field7               []int32   `protobuf:"zigzag32,7,rep,packed,name=Field7" json:"Field7,omitempty"`
	Field8               []int64   `protobuf:"zigzag64,8,rep,packed,name=Field8" json:"Field8,omitempty"`
	Field9               []uint32  `protobuf:"fixed32,9,rep,packed,name=Field9" json:"Field9,omitempty"`
	Field10              []int32   `protobuf:"fixed32,10,rep,packed,name=Field10" json:"Field10,omitempty"`
	Field11              []uint64  `protobuf:"fixed64,11,rep,packed,name=Field11" json:"Field11,omitempty"`
	Field12              []int64   `protobuf:"fixed64,12,rep,packed,name=Field12" json:"Field12,omitempty"`
	Field13              []bool    `protobuf:"varint,13,rep,packed,name=Field13" json:"Field13,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NinRepPackedNativeUnsafe) Reset()         { *m = NinRepPackedNativeUnsafe{} }
func (m *NinRepPackedNativeUnsafe) String() string { return proto.CompactTextString(m) }
func (*NinRepPackedNativeUnsafe) ProtoMessage()    {}
func (*NinRepPackedNativeUnsafe) Descriptor() ([]byte, []int) {
	return fileDescriptor_2c9922eb15f14bbb, []int{3}
}
func (m *NinRepPackedNativeUnsafe) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NinRepPackedNativeUnsafe.Unmarshal(m, b)
}
func (m *NinRepPackedNativeUnsafe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NinRepPackedNativeUnsafe.Marshal(b, m, deterministic)
}
func (m *NinRepPackedNativeUnsafe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NinRepPackedNativeUnsafe.Merge(m, src)
}
func (m *NinRepPackedNativeUnsafe) XXX_Size() int {
	return xxx_messageInfo_NinRepPackedNativeUnsafe.Size(m)
}
func (m *NinRepPackedNativeUnsafe) XXX_DiscardUnknown() {
	xxx_messageInfo_NinRepPackedNativeUnsafe.DiscardUnknown(m)
}

var xxx_messageInfo_NinRepPackedNativeUnsafe proto.InternalMessageInfo

func (m *NinRepPackedNativeUnsafe) GetField1() []float64 {
	if m != nil {
		return m.Field1
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField2() []float32 {
	if m != nil {
		return m.Field2
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField3() []int32 {
	if m != nil {
		return m.Field3
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField4() []int64 {
	if m != nil {
		return m.Field4
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField5() []uint32 {
	if m != nil {
		return m.Field5
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField6() []uint64 {
	if m != nil {
		return m.Field6
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField7() []int32 {
	if m != nil {
		return m.Field7
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField8() []int64 {
	if m != nil {
		return m.Field8
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField9() []uint32 {
	if m != nil {
		return m.Field9
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField10() []int32 {
	if m != nil {
		return m.Field10
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField11() []uint64 {
	if m != nil {
		return m.Field11
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField12() []int64 {
	if m != nil {
		return m.Field12
	}
	return nil
}

func (m *NinRepPackedNativeUnsafe) GetField13() []bool {
	if m != nil {
		return m.Field13
	}
	return nil
}

func init() {
	proto.RegisterType((*NinRepNative)(nil), "packed.NinRepNative")
	proto.RegisterType((*NinRepPackedNative)(nil), "packed.NinRepPackedNative")
	proto.RegisterType((*NinRepNativeUnsafe)(nil), "packed.NinRepNativeUnsafe")
	proto.RegisterType((*NinRepPackedNativeUnsafe)(nil), "packed.NinRepPackedNativeUnsafe")
}

func init() { proto.RegisterFile("packed.proto", fileDescriptor_2c9922eb15f14bbb) }

var fileDescriptor_2c9922eb15f14bbb = []byte{
	// 388 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x92, 0xbf, 0x4e, 0xfa, 0x50,
	0x14, 0xc7, 0xd3, 0x9e, 0x52, 0xf8, 0xdd, 0x1f, 0x44, 0xec, 0x60, 0x4e, 0x08, 0xd1, 0x1b, 0xa6,
	0xbb, 0x08, 0xb6, 0xe5, 0xaf, 0x23, 0x83, 0x23, 0x31, 0x24, 0x3e, 0x00, 0x7f, 0x0a, 0x36, 0x2a,
	0x25, 0x0a, 0x3e, 0x86, 0x71, 0xf0, 0x05, 0x7c, 0x13, 0x1f, 0xc2, 0xc9, 0xcd, 0xb7, 0x70, 0x34,
	0xb4, 0xa7, 0xa7, 0x17, 0x1c, 0x1d, 0x5c, 0xd8, 0xb8, 0x9f, 0x4f, 0x18, 0xfa, 0xf9, 0x1e, 0x51,
	0x5c, 0x8e, 0x26, 0x37, 0xc1, 0xb4, 0xbe, 0xbc, 0x8f, 0x56, 0x91, 0x63, 0x27, 0xaf, 0xca, 0xe9,
	0x3c, 0x5c, 0x5d, 0xaf, 0xc7, 0xf5, 0x49, 0x74, 0xd7, 0x98, 0x47, 0xf3, 0xa8, 0x11, 0xeb, 0xf1,
	0x7a, 0x16, 0xbf, 0xe2, 0x47, 0xfc, 0x2b, 0xf9, 0x5b, 0xed, 0xdd, 0x14, 0xc5, 0x41, 0xb8, 0x18,
	0x06, 0xcb, 0xc1, 0x68, 0x15, 0x3e, 0x06, 0xce, 0x91, 0xb0, 0x2f, 0xc2, 0xe0, 0x76, 0xea, 0xa2,
	0x21, 0x41, 0x19, 0x43, 0x7a, 0x31, 0xf7, 0xd0, 0x94, 0xa0, 0x4c, 0xe2, 0x1e, 0x73, 0x1f, 0x41,
	0x82, 0xca, 0x11, 0xf7, 0x99, 0x37, 0xd1, 0x92, 0xa0, 0x80, 0x78, 0x93, 0x79, 0x0b, 0x73, 0x12,
	0x54, 0x89, 0x78, 0x8b, 0x79, 0x1b, 0x6d, 0x09, 0xca, 0x22, 0xde, 0x66, 0xde, 0xc1, 0xbc, 0x04,
	0x75, 0x48, 0xbc, 0xc3, 0xbc, 0x8b, 0x05, 0x09, 0xca, 0x21, 0xde, 0x65, 0xde, 0xc3, 0x7f, 0x12,
	0x54, 0x9e, 0x78, 0xcf, 0x41, 0x91, 0x4f, 0xbe, 0xe4, 0x0c, 0x85, 0x04, 0x75, 0x30, 0x4c, 0x9f,
	0x99, 0x71, 0xf1, 0xbf, 0x04, 0x65, 0xa7, 0xc6, 0xcd, 0x8c, 0x87, 0x45, 0x09, 0xaa, 0x9c, 0x1a,
	0x2f, 0x33, 0x3e, 0x96, 0x24, 0xa8, 0x42, 0x6a, 0xfc, 0x73, 0xeb, 0xf9, 0xf5, 0xc4, 0xa8, 0x3d,
	0x81, 0x70, 0x92, 0xac, 0x97, 0xf1, 0x2c, 0x14, 0xb7, 0xb2, 0x1d, 0xb7, 0x6f, 0x96, 0xb3, 0xc0,
	0x95, 0xed, 0xc0, 0x9a, 0xf3, 0xd8, 0x51, 0x64, 0xcd, 0xf9, 0xec, 0x28, 0xb4, 0xe6, 0x9a, 0xec,
	0x28, 0xb6, 0xe6, 0x5a, 0xec, 0x28, 0xb8, 0xe6, 0xda, 0xec, 0x28, 0xba, 0xe6, 0x3a, 0xec, 0x28,
	0xbc, 0xe6, 0xba, 0xec, 0x28, 0xbe, 0xe6, 0x7a, 0x4e, 0x75, 0x67, 0x80, 0x58, 0xf2, 0x08, 0xd5,
	0x9d, 0x11, 0x74, 0xeb, 0x66, 0x96, 0x86, 0xd0, 0xad, 0x97, 0x59, 0x1a, 0x43, 0xb7, 0xe9, 0x20,
	0x1f, 0x66, 0x3a, 0x48, 0x32, 0xc5, 0xd5, 0xe2, 0x61, 0x34, 0xdb, 0x5f, 0xfb, 0xaf, 0xaf, 0xfd,
	0x6d, 0x13, 0xf7, 0x05, 0x04, 0xfe, 0xbc, 0x76, 0x4a, 0xbc, 0xbf, 0xf9, 0x3f, 0xb8, 0xf9, 0xcd,
	0x2c, 0x7d, 0xeb, 0xeb, 0xf3, 0xd8, 0xf8, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x13, 0x20, 0xf1, 0x6c,
	0x27, 0x06, 0x00, 0x00,
}

func NewPopulatedNinRepNative(r randyPacked, easy bool) *NinRepNative {
	this := &NinRepNative{}
	if r.Intn(5) != 0 {
		v1 := r.Intn(10)
		this.Field1 = make([]float64, v1)
		for i := 0; i < v1; i++ {
			this.Field1[i] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Field1[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v2 := r.Intn(10)
		this.Field2 = make([]float32, v2)
		for i := 0; i < v2; i++ {
			this.Field2[i] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.Field2[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v3 := r.Intn(10)
		this.Field3 = make([]int32, v3)
		for i := 0; i < v3; i++ {
			this.Field3[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field3[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v4 := r.Intn(10)
		this.Field4 = make([]int64, v4)
		for i := 0; i < v4; i++ {
			this.Field4[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field4[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v5 := r.Intn(10)
		this.Field5 = make([]uint32, v5)
		for i := 0; i < v5; i++ {
			this.Field5[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v6 := r.Intn(10)
		this.Field6 = make([]uint64, v6)
		for i := 0; i < v6; i++ {
			this.Field6[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v7 := r.Intn(10)
		this.Field7 = make([]int32, v7)
		for i := 0; i < v7; i++ {
			this.Field7[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field7[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v8 := r.Intn(10)
		this.Field8 = make([]int64, v8)
		for i := 0; i < v8; i++ {
			this.Field8[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field8[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v9 := r.Intn(10)
		this.Field9 = make([]uint32, v9)
		for i := 0; i < v9; i++ {
			this.Field9[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v10 := r.Intn(10)
		this.Field10 = make([]int32, v10)
		for i := 0; i < v10; i++ {
			this.Field10[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field10[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v11 := r.Intn(10)
		this.Field11 = make([]uint64, v11)
		for i := 0; i < v11; i++ {
			this.Field11[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v12 := r.Intn(10)
		this.Field12 = make([]int64, v12)
		for i := 0; i < v12; i++ {
			this.Field12[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field12[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v13 := r.Intn(10)
		this.Field13 = make([]bool, v13)
		for i := 0; i < v13; i++ {
			this.Field13[i] = bool(bool(r.Intn(2) == 0))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPacked(r, 14)
	}
	return this
}

func NewPopulatedNinRepPackedNative(r randyPacked, easy bool) *NinRepPackedNative {
	this := &NinRepPackedNative{}
	if r.Intn(5) != 0 {
		v14 := r.Intn(10)
		this.Field1 = make([]float64, v14)
		for i := 0; i < v14; i++ {
			this.Field1[i] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Field1[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v15 := r.Intn(10)
		this.Field2 = make([]float32, v15)
		for i := 0; i < v15; i++ {
			this.Field2[i] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.Field2[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v16 := r.Intn(10)
		this.Field3 = make([]int32, v16)
		for i := 0; i < v16; i++ {
			this.Field3[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field3[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v17 := r.Intn(10)
		this.Field4 = make([]int64, v17)
		for i := 0; i < v17; i++ {
			this.Field4[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field4[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v18 := r.Intn(10)
		this.Field5 = make([]uint32, v18)
		for i := 0; i < v18; i++ {
			this.Field5[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v19 := r.Intn(10)
		this.Field6 = make([]uint64, v19)
		for i := 0; i < v19; i++ {
			this.Field6[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v20 := r.Intn(10)
		this.Field7 = make([]int32, v20)
		for i := 0; i < v20; i++ {
			this.Field7[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field7[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v21 := r.Intn(10)
		this.Field8 = make([]int64, v21)
		for i := 0; i < v21; i++ {
			this.Field8[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field8[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v22 := r.Intn(10)
		this.Field9 = make([]uint32, v22)
		for i := 0; i < v22; i++ {
			this.Field9[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v23 := r.Intn(10)
		this.Field10 = make([]int32, v23)
		for i := 0; i < v23; i++ {
			this.Field10[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field10[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v24 := r.Intn(10)
		this.Field11 = make([]uint64, v24)
		for i := 0; i < v24; i++ {
			this.Field11[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v25 := r.Intn(10)
		this.Field12 = make([]int64, v25)
		for i := 0; i < v25; i++ {
			this.Field12[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field12[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v26 := r.Intn(10)
		this.Field13 = make([]bool, v26)
		for i := 0; i < v26; i++ {
			this.Field13[i] = bool(bool(r.Intn(2) == 0))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPacked(r, 14)
	}
	return this
}

func NewPopulatedNinRepNativeUnsafe(r randyPacked, easy bool) *NinRepNativeUnsafe {
	this := &NinRepNativeUnsafe{}
	if r.Intn(5) != 0 {
		v27 := r.Intn(10)
		this.Field1 = make([]float64, v27)
		for i := 0; i < v27; i++ {
			this.Field1[i] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Field1[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v28 := r.Intn(10)
		this.Field2 = make([]float32, v28)
		for i := 0; i < v28; i++ {
			this.Field2[i] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.Field2[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v29 := r.Intn(10)
		this.Field3 = make([]int32, v29)
		for i := 0; i < v29; i++ {
			this.Field3[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field3[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v30 := r.Intn(10)
		this.Field4 = make([]int64, v30)
		for i := 0; i < v30; i++ {
			this.Field4[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field4[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v31 := r.Intn(10)
		this.Field5 = make([]uint32, v31)
		for i := 0; i < v31; i++ {
			this.Field5[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v32 := r.Intn(10)
		this.Field6 = make([]uint64, v32)
		for i := 0; i < v32; i++ {
			this.Field6[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v33 := r.Intn(10)
		this.Field7 = make([]int32, v33)
		for i := 0; i < v33; i++ {
			this.Field7[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field7[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v34 := r.Intn(10)
		this.Field8 = make([]int64, v34)
		for i := 0; i < v34; i++ {
			this.Field8[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field8[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v35 := r.Intn(10)
		this.Field9 = make([]uint32, v35)
		for i := 0; i < v35; i++ {
			this.Field9[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v36 := r.Intn(10)
		this.Field10 = make([]int32, v36)
		for i := 0; i < v36; i++ {
			this.Field10[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field10[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v37 := r.Intn(10)
		this.Field11 = make([]uint64, v37)
		for i := 0; i < v37; i++ {
			this.Field11[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v38 := r.Intn(10)
		this.Field12 = make([]int64, v38)
		for i := 0; i < v38; i++ {
			this.Field12[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field12[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v39 := r.Intn(10)
		this.Field13 = make([]bool, v39)
		for i := 0; i < v39; i++ {
			this.Field13[i] = bool(bool(r.Intn(2) == 0))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPacked(r, 14)
	}
	return this
}

func NewPopulatedNinRepPackedNativeUnsafe(r randyPacked, easy bool) *NinRepPackedNativeUnsafe {
	this := &NinRepPackedNativeUnsafe{}
	if r.Intn(5) != 0 {
		v40 := r.Intn(10)
		this.Field1 = make([]float64, v40)
		for i := 0; i < v40; i++ {
			this.Field1[i] = float64(r.Float64())
			if r.Intn(2) == 0 {
				this.Field1[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v41 := r.Intn(10)
		this.Field2 = make([]float32, v41)
		for i := 0; i < v41; i++ {
			this.Field2[i] = float32(r.Float32())
			if r.Intn(2) == 0 {
				this.Field2[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v42 := r.Intn(10)
		this.Field3 = make([]int32, v42)
		for i := 0; i < v42; i++ {
			this.Field3[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field3[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v43 := r.Intn(10)
		this.Field4 = make([]int64, v43)
		for i := 0; i < v43; i++ {
			this.Field4[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field4[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v44 := r.Intn(10)
		this.Field5 = make([]uint32, v44)
		for i := 0; i < v44; i++ {
			this.Field5[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v45 := r.Intn(10)
		this.Field6 = make([]uint64, v45)
		for i := 0; i < v45; i++ {
			this.Field6[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v46 := r.Intn(10)
		this.Field7 = make([]int32, v46)
		for i := 0; i < v46; i++ {
			this.Field7[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field7[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v47 := r.Intn(10)
		this.Field8 = make([]int64, v47)
		for i := 0; i < v47; i++ {
			this.Field8[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field8[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v48 := r.Intn(10)
		this.Field9 = make([]uint32, v48)
		for i := 0; i < v48; i++ {
			this.Field9[i] = uint32(r.Uint32())
		}
	}
	if r.Intn(5) != 0 {
		v49 := r.Intn(10)
		this.Field10 = make([]int32, v49)
		for i := 0; i < v49; i++ {
			this.Field10[i] = int32(r.Int31())
			if r.Intn(2) == 0 {
				this.Field10[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v50 := r.Intn(10)
		this.Field11 = make([]uint64, v50)
		for i := 0; i < v50; i++ {
			this.Field11[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(5) != 0 {
		v51 := r.Intn(10)
		this.Field12 = make([]int64, v51)
		for i := 0; i < v51; i++ {
			this.Field12[i] = int64(r.Int63())
			if r.Intn(2) == 0 {
				this.Field12[i] *= -1
			}
		}
	}
	if r.Intn(5) != 0 {
		v52 := r.Intn(10)
		this.Field13 = make([]bool, v52)
		for i := 0; i < v52; i++ {
			this.Field13[i] = bool(bool(r.Intn(2) == 0))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPacked(r, 14)
	}
	return this
}

type randyPacked interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RunePacked(r randyPacked) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringPacked(r randyPacked) string {
	v53 := r.Intn(100)
	tmps := make([]rune, v53)
	for i := 0; i < v53; i++ {
		tmps[i] = randUTF8RunePacked(r)
	}
	return string(tmps)
}
func randUnrecognizedPacked(r randyPacked, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldPacked(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldPacked(dAtA []byte, r randyPacked, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulatePacked(dAtA, uint64(key))
		v54 := r.Int63()
		if r.Intn(2) == 0 {
			v54 *= -1
		}
		dAtA = encodeVarintPopulatePacked(dAtA, uint64(v54))
	case 1:
		dAtA = encodeVarintPopulatePacked(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulatePacked(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulatePacked(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulatePacked(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulatePacked(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *NinRepNative) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacked
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NinRepNative: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NinRepNative: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Field1 = append(m.Field1, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field1) == 0 {
					m.Field1 = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Field1 = append(m.Field1, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Field2 = append(m.Field2, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field2) == 0 {
					m.Field2 = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Field2 = append(m.Field2, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field3 = append(m.Field3, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field3) == 0 {
					m.Field3 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field3 = append(m.Field3, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field4 = append(m.Field4, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field4) == 0 {
					m.Field4 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field4 = append(m.Field4, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field5 = append(m.Field5, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field5) == 0 {
					m.Field5 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field5 = append(m.Field5, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field6 = append(m.Field6, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field6) == 0 {
					m.Field6 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field6 = append(m.Field6, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Field7 = append(m.Field7, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field7) == 0 {
					m.Field7 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Field7 = append(m.Field7, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Field8 = append(m.Field8, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field8) == 0 {
					m.Field8 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Field8 = append(m.Field8, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Field9 = append(m.Field9, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field9) == 0 {
					m.Field9 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Field9 = append(m.Field9, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
		case 10:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Field10 = append(m.Field10, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field10) == 0 {
					m.Field10 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Field10 = append(m.Field10, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
		case 11:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Field11 = append(m.Field11, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field11) == 0 {
					m.Field11 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Field11 = append(m.Field11, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
		case 12:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Field12 = append(m.Field12, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field12) == 0 {
					m.Field12 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Field12 = append(m.Field12, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field13 = append(m.Field13, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Field13) == 0 {
					m.Field13 = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field13 = append(m.Field13, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacked(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacked
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NinRepPackedNative) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacked
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NinRepPackedNative: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NinRepPackedNative: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Field1 = append(m.Field1, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field1) == 0 {
					m.Field1 = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Field1 = append(m.Field1, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Field2 = append(m.Field2, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field2) == 0 {
					m.Field2 = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Field2 = append(m.Field2, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field3 = append(m.Field3, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field3) == 0 {
					m.Field3 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field3 = append(m.Field3, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field4 = append(m.Field4, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field4) == 0 {
					m.Field4 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field4 = append(m.Field4, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field5 = append(m.Field5, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field5) == 0 {
					m.Field5 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field5 = append(m.Field5, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field6 = append(m.Field6, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field6) == 0 {
					m.Field6 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field6 = append(m.Field6, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Field7 = append(m.Field7, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field7) == 0 {
					m.Field7 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Field7 = append(m.Field7, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Field8 = append(m.Field8, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field8) == 0 {
					m.Field8 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Field8 = append(m.Field8, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Field9 = append(m.Field9, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field9) == 0 {
					m.Field9 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Field9 = append(m.Field9, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
		case 10:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Field10 = append(m.Field10, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field10) == 0 {
					m.Field10 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Field10 = append(m.Field10, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
		case 11:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Field11 = append(m.Field11, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field11) == 0 {
					m.Field11 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Field11 = append(m.Field11, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
		case 12:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Field12 = append(m.Field12, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field12) == 0 {
					m.Field12 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Field12 = append(m.Field12, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field13 = append(m.Field13, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Field13) == 0 {
					m.Field13 = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field13 = append(m.Field13, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacked(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacked
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NinRepNativeUnsafe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacked
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NinRepNativeUnsafe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NinRepNativeUnsafe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Field1 = append(m.Field1, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field1) == 0 {
					m.Field1 = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Field1 = append(m.Field1, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Field2 = append(m.Field2, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field2) == 0 {
					m.Field2 = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Field2 = append(m.Field2, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field3 = append(m.Field3, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field3) == 0 {
					m.Field3 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field3 = append(m.Field3, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field4 = append(m.Field4, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field4) == 0 {
					m.Field4 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field4 = append(m.Field4, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field5 = append(m.Field5, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field5) == 0 {
					m.Field5 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field5 = append(m.Field5, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field6 = append(m.Field6, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field6) == 0 {
					m.Field6 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field6 = append(m.Field6, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Field7 = append(m.Field7, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field7) == 0 {
					m.Field7 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Field7 = append(m.Field7, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Field8 = append(m.Field8, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field8) == 0 {
					m.Field8 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Field8 = append(m.Field8, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Field9 = append(m.Field9, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field9) == 0 {
					m.Field9 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Field9 = append(m.Field9, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
		case 10:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Field10 = append(m.Field10, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field10) == 0 {
					m.Field10 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Field10 = append(m.Field10, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
		case 11:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Field11 = append(m.Field11, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field11) == 0 {
					m.Field11 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Field11 = append(m.Field11, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
		case 12:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Field12 = append(m.Field12, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field12) == 0 {
					m.Field12 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Field12 = append(m.Field12, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field13 = append(m.Field13, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Field13) == 0 {
					m.Field13 = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field13 = append(m.Field13, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacked(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacked
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NinRepPackedNativeUnsafe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacked
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NinRepPackedNativeUnsafe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NinRepPackedNativeUnsafe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Field1 = append(m.Field1, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field1) == 0 {
					m.Field1 = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Field1 = append(m.Field1, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field1", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Field2 = append(m.Field2, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field2) == 0 {
					m.Field2 = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Field2 = append(m.Field2, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field2", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field3 = append(m.Field3, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field3) == 0 {
					m.Field3 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field3 = append(m.Field3, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field3", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field4 = append(m.Field4, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field4) == 0 {
					m.Field4 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field4 = append(m.Field4, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field4", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field5 = append(m.Field5, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field5) == 0 {
					m.Field5 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field5 = append(m.Field5, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field5", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field6 = append(m.Field6, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field6) == 0 {
					m.Field6 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field6 = append(m.Field6, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field6", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Field7 = append(m.Field7, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field7) == 0 {
					m.Field7 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Field7 = append(m.Field7, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field7", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.Field8 = append(m.Field8, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Field8) == 0 {
					m.Field8 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.Field8 = append(m.Field8, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field8", wireType)
			}
		case 9:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Field9 = append(m.Field9, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field9) == 0 {
					m.Field9 = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Field9 = append(m.Field9, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field9", wireType)
			}
		case 10:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.Field10 = append(m.Field10, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Field10) == 0 {
					m.Field10 = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.Field10 = append(m.Field10, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field10", wireType)
			}
		case 11:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Field11 = append(m.Field11, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field11) == 0 {
					m.Field11 = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Field11 = append(m.Field11, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field11", wireType)
			}
		case 12:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.Field12 = append(m.Field12, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Field12) == 0 {
					m.Field12 = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.Field12 = append(m.Field12, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field12", wireType)
			}
		case 13:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Field13 = append(m.Field13, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacked
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacked
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacked
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Field13) == 0 {
					m.Field13 = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacked
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Field13 = append(m.Field13, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Field13", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacked(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacked
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPacked(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPacked
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacked
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPacked
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPacked
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPacked
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPacked        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPacked          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPacked = fmt.Errorf("proto: unexpected end of group")
)
