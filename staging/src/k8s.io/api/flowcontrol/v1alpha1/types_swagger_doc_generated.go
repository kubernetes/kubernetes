/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

// This file contains a collection of methods that can be used from go-restful to
// generate Swagger API documentation for its models. Please read this PR for more
// information on the implementation: https://github.com/emicklei/go-restful/pull/215
//
// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
// they are on one line! For multiple line or blocks that you want to ignore use ---.
// Any context after a --- is ignored.
//
// Those methods can be generated by using hack/update-generated-swagger-docs.sh

// AUTO-GENERATED FUNCTIONS START HERE. DO NOT EDIT.
var map_FlowDistinguisherMethod = map[string]string{
	"":     "FlowDistinguisherMethod specifies the method of a flow distinguisher.",
	"type": "`type` is the type of flow distinguisher method",
}

func (FlowDistinguisherMethod) SwaggerDoc() map[string]string {
	return map_FlowDistinguisherMethod
}

var map_FlowSchema = map[string]string{
	"":         "FlowSchema defines the schema of a group of flows. Note that a flow is made up of a set of inbound API requests with similar attributes and is identified by a pair of strings: the name of the FlowSchema and a \"flow distinguisher\".",
	"metadata": "`metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
	"spec":     "`spec` is the specification of the desired behavior of a flow-schema. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
	"status":   "`status` is the current status of a flow-schema. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
}

func (FlowSchema) SwaggerDoc() map[string]string {
	return map_FlowSchema
}

var map_FlowSchemaCondition = map[string]string{
	"":                   "FlowSchemaCondition describes conditions for a flow-schema.",
	"type":               "`type` is the type of the condition.",
	"status":             "`status` is the status of the condition. Can be True, False, Unknown.",
	"lastTransitionTime": "`lastTransitionTime` is the last time the condition transitioned from one status to another.",
	"reason":             "`reason` is a unique, one-word, CamelCase reason for the condition's last transition.",
	"message":            "`message` is a human-readable message indicating details about last transition.",
}

func (FlowSchemaCondition) SwaggerDoc() map[string]string {
	return map_FlowSchemaCondition
}

var map_FlowSchemaList = map[string]string{
	"":         "FlowSchemaList is a list of FlowSchema objects.",
	"metadata": "`metadata` is the standard list metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
	"items":    "`items` is a list of flow-schemas.",
}

func (FlowSchemaList) SwaggerDoc() map[string]string {
	return map_FlowSchemaList
}

var map_FlowSchemaSpec = map[string]string{
	"":                           "FlowSchemaSpec describes how the flow-schema's specification looks like.",
	"priorityLevelConfiguration": "`priorityLevelConfiguration` should reference a PriorityLevelConfiguration in the cluster. If the reference cannot be resolved, the flow-schema will be ignored and marked as invalid in its status. Required.",
	"matchingPrecedence":         "`matchingPrecedence` is used to choose among the FlowSchemas that match a given request.  The chosen FlowSchema is among those with the numerically lowest (which we take to be logically highest) MatchingPrecedence.  Each MatchingPrecedence value must be non-negative.",
	"distinguisherMethod":        "`distinguisherMethod` defines how to compute the flow distinguisher for requests that match this schema. `nil` specifies that the distinguisher is disabled and thus will always be the empty string.",
	"rules":                      "`rules` describes which requests will match this flow schema. The flow-schema applies if any rule matches.",
}

func (FlowSchemaSpec) SwaggerDoc() map[string]string {
	return map_FlowSchemaSpec
}

var map_FlowSchemaStatus = map[string]string{
	"":           "FlowSchemaStatus represents the current state of a flow-schema.",
	"conditions": "Current state of flow-schema.",
}

func (FlowSchemaStatus) SwaggerDoc() map[string]string {
	return map_FlowSchemaStatus
}

var map_PolicyRule = map[string]string{
	"":                "PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.",
	"verbs":           "`verbs` is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions contained in this rule. VerbAll represents all verbs.",
	"apiGroups":       "`apiGroups` is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed. '*' represents all api groups.",
	"resources":       "`resources` is a list of resources this rule applies to.  ResourceAll represents all resources.",
	"nonResourceURLs": "`nonResourceURLs` is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either apply to API resources (such as \"pods\" or \"secrets\") or non-resource URL paths (such as \"/api\"),  but not both. NonResourceAll represents all non-resource urls.",
}

func (PolicyRule) SwaggerDoc() map[string]string {
	return map_PolicyRule
}

var map_PolicyRuleWithSubjects = map[string]string{
	"":         "PolicyRuleWithSubjects prescribes a test that applies to a request to an apiserver. The test considers the subject making the request, the verb being requested, and the resource to be acted upon.",
	"subjects": "`subjects` is the list of normal user, serviceaccount, or group that this rule cares about.",
	"rule":     "`rule` is the target verb, resource or the subresource the rule cares about. APIGroups, Resources, etc. Required.",
}

func (PolicyRuleWithSubjects) SwaggerDoc() map[string]string {
	return map_PolicyRuleWithSubjects
}

var map_PriorityLevelConfiguration = map[string]string{
	"":         "PriorityLevelConfiguration represents the configuration of a priority level.",
	"metadata": "`metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
	"spec":     "`spec` is the specification of the desired behavior of a \"request-priority\". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
	"status":   "`status` is the current status of a \"request-priority\". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
}

func (PriorityLevelConfiguration) SwaggerDoc() map[string]string {
	return map_PriorityLevelConfiguration
}

var map_PriorityLevelConfigurationCondition = map[string]string{
	"":                   "PriorityLevelConfigurationCondition defines the condition of priority level.",
	"type":               "`type` is the type of the condition.",
	"status":             "`status` is the status of the condition. Can be True, False, Unknown.",
	"lastTransitionTime": "`lastTransitionTime` is the last time the condition transitioned from one status to another.",
	"reason":             "`reason` is a unique, one-word, CamelCase reason for the condition's last transition.",
	"message":            "`message` is a human-readable message indicating details about last transition.",
}

func (PriorityLevelConfigurationCondition) SwaggerDoc() map[string]string {
	return map_PriorityLevelConfigurationCondition
}

var map_PriorityLevelConfigurationList = map[string]string{
	"":         "PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.",
	"metadata": "`metadata` is the standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
	"items":    "`items` is a list of request-priorities.",
}

func (PriorityLevelConfigurationList) SwaggerDoc() map[string]string {
	return map_PriorityLevelConfigurationList
}

var map_PriorityLevelConfigurationReference = map[string]string{
	"":     "PriorityLevelConfigurationReference contains information that points to the \"request-priority\" being used.",
	"name": "`name` is the name of resource being referenced",
}

func (PriorityLevelConfigurationReference) SwaggerDoc() map[string]string {
	return map_PriorityLevelConfigurationReference
}

var map_PriorityLevelConfigurationSpec = map[string]string{
	"":                         "PriorityLevelConfigurationSpec is specification of a priority level",
	"assuredConcurrencyShares": "`assuredConcurrencyShares` is a positive number for a non-exempt priority level. The concurrency limit of an apiserver is divided among the non-exempt priority levels in proportion to their assured concurrency shares. Basically this produces the assured concurrency value (ACV) for each priority level:\n\n            ACV(l) = ceil( SCL * ACS(l) / ( sum[priority levels k] ACS(k) ) )",
	"queues":                   "`queues` is a number of queues that belong to a non-exempt PriorityLevelConfiguration object. The queues exist independently at each apiserver. The value must be positive for a non-exempt priority level and setting it to 1 disables shufflesharding and makes the distinguisher method irrelevant.",
	"handSize":                 "`handSize` is a small positive number for applying shuffle sharding. When a request arrives at an apiserver the request flow identifierâ€™s string pair is hashed and the hash value is used to shuffle the queue indices and deal a hand of the size specified here. If empty, the hand size will the be set to 1. NOTE: To figure out a better value for your cluster, please refer to (#76846)[https://github.com/kubernetes/kubernetes/issues/76846#issuecomment-523700960]",
	"queueLengthLimit":         "`queueLengthLimit` is a length limit applied to each queue belongs to the priority.  The value must be positive for a non-exempt priority level.",
	"exempt":                   "`exempt` defines whether the priority level is exempted or not.  There should be at most one exempt priority level. Being exempt means that requests of that priority are not subject to concurrency limits (and thus are never queued) and do not detract from the concurrency available for non-exempt requests. The field is default to false and only those system preset priority level can be exempt.",
	"globalDefault":            "`globalDefault` specifies whether this priority level can be used for non-exempt requests that do not match any FlowSchema. If multiple PriorityLevelConfiguration objects have this field `true` then the implementation freely chooses among them.  If none have this field `true` then the implementation pretends that a default one exists.",
}

func (PriorityLevelConfigurationSpec) SwaggerDoc() map[string]string {
	return map_PriorityLevelConfigurationSpec
}

var map_PriorityLevelConfigurationStatus = map[string]string{
	"":           "PriorityLevelConfigurationStatus represents the current state of a \"request-priority\".",
	"conditions": "`conditions` is the current state of \"request-priority\".",
}

func (PriorityLevelConfigurationStatus) SwaggerDoc() map[string]string {
	return map_PriorityLevelConfigurationStatus
}

var map_Subject = map[string]string{
	"":          "Subject matches a set of users. Syntactically, Subject is a general API object reference. Authorization produces a username and a set of groups, and we imagine special kinds of non-namespaced objects, User and Group in API group \"flowcontrol.apiserver.k8s.io\", to represent such a username or group. The only kind of true object reference that currently will match any users is ServiceAccount.",
	"kind":      "`kind` of object being referenced. Values defined by this API group are \"User\", \"Group\", and \"ServiceAccount\". If the kind value is not recognized, the flow-control layer in api-server should report an error.",
	"apiGroup":  "`apiGroup` holds the API group of the referenced subject. Defaults to \"\" for ServiceAccount subjects. Defaults to \"flowcontrol.apiserver.k8s.io\" for User and Group subjects.",
	"name":      "`name` of the object being referenced.  To match regardless of name, use NameAll. Required.",
	"namespace": "`namespace` of the referenced object.  If the object kind is non-namespace, such as \"User\" or \"Group\", and this value is not empty the Authorizer should report an error.",
}

func (Subject) SwaggerDoc() map[string]string {
	return map_Subject
}

// AUTO-GENERATED FUNCTIONS END HERE
