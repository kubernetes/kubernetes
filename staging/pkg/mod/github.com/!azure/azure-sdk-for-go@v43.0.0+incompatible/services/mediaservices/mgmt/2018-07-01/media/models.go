package media

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/satori/go.uuid"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/mediaservices/mgmt/2018-07-01/media"

// AacAudioProfile enumerates the values for aac audio profile.
type AacAudioProfile string

const (
	// AacLc Specifies that the output audio is to be encoded into AAC Low Complexity profile (AAC-LC).
	AacLc AacAudioProfile = "AacLc"
	// HeAacV1 Specifies that the output audio is to be encoded into HE-AAC v1 profile.
	HeAacV1 AacAudioProfile = "HeAacV1"
	// HeAacV2 Specifies that the output audio is to be encoded into HE-AAC v2 profile.
	HeAacV2 AacAudioProfile = "HeAacV2"
)

// PossibleAacAudioProfileValues returns an array of possible values for the AacAudioProfile const type.
func PossibleAacAudioProfileValues() []AacAudioProfile {
	return []AacAudioProfile{AacLc, HeAacV1, HeAacV2}
}

// AnalysisResolution enumerates the values for analysis resolution.
type AnalysisResolution string

const (
	// SourceResolution ...
	SourceResolution AnalysisResolution = "SourceResolution"
	// StandardDefinition ...
	StandardDefinition AnalysisResolution = "StandardDefinition"
)

// PossibleAnalysisResolutionValues returns an array of possible values for the AnalysisResolution const type.
func PossibleAnalysisResolutionValues() []AnalysisResolution {
	return []AnalysisResolution{SourceResolution, StandardDefinition}
}

// AssetContainerPermission enumerates the values for asset container permission.
type AssetContainerPermission string

const (
	// Read The SAS URL will allow read access to the container.
	Read AssetContainerPermission = "Read"
	// ReadWrite The SAS URL will allow read and write access to the container.
	ReadWrite AssetContainerPermission = "ReadWrite"
	// ReadWriteDelete The SAS URL will allow read, write and delete access to the container.
	ReadWriteDelete AssetContainerPermission = "ReadWriteDelete"
)

// PossibleAssetContainerPermissionValues returns an array of possible values for the AssetContainerPermission const type.
func PossibleAssetContainerPermissionValues() []AssetContainerPermission {
	return []AssetContainerPermission{Read, ReadWrite, ReadWriteDelete}
}

// AssetStorageEncryptionFormat enumerates the values for asset storage encryption format.
type AssetStorageEncryptionFormat string

const (
	// MediaStorageClientEncryption The Asset is encrypted with Media Services client-side encryption.
	MediaStorageClientEncryption AssetStorageEncryptionFormat = "MediaStorageClientEncryption"
	// None The Asset does not use client-side storage encryption (this is the only allowed value for new
	// Assets).
	None AssetStorageEncryptionFormat = "None"
)

// PossibleAssetStorageEncryptionFormatValues returns an array of possible values for the AssetStorageEncryptionFormat const type.
func PossibleAssetStorageEncryptionFormatValues() []AssetStorageEncryptionFormat {
	return []AssetStorageEncryptionFormat{MediaStorageClientEncryption, None}
}

// ContentKeyPolicyFairPlayRentalAndLeaseKeyType enumerates the values for content key policy fair play rental
// and lease key type.
type ContentKeyPolicyFairPlayRentalAndLeaseKeyType string

const (
	// DualExpiry Dual expiry for offline rental.
	DualExpiry ContentKeyPolicyFairPlayRentalAndLeaseKeyType = "DualExpiry"
	// PersistentLimited Content key can be persisted and the valid duration is limited by the Rental Duration
	// value
	PersistentLimited ContentKeyPolicyFairPlayRentalAndLeaseKeyType = "PersistentLimited"
	// PersistentUnlimited Content key can be persisted with an unlimited duration
	PersistentUnlimited ContentKeyPolicyFairPlayRentalAndLeaseKeyType = "PersistentUnlimited"
	// Undefined Key duration is not specified.
	Undefined ContentKeyPolicyFairPlayRentalAndLeaseKeyType = "Undefined"
	// Unknown Represents a ContentKeyPolicyFairPlayRentalAndLeaseKeyType that is unavailable in current API
	// version.
	Unknown ContentKeyPolicyFairPlayRentalAndLeaseKeyType = "Unknown"
)

// PossibleContentKeyPolicyFairPlayRentalAndLeaseKeyTypeValues returns an array of possible values for the ContentKeyPolicyFairPlayRentalAndLeaseKeyType const type.
func PossibleContentKeyPolicyFairPlayRentalAndLeaseKeyTypeValues() []ContentKeyPolicyFairPlayRentalAndLeaseKeyType {
	return []ContentKeyPolicyFairPlayRentalAndLeaseKeyType{DualExpiry, PersistentLimited, PersistentUnlimited, Undefined, Unknown}
}

// ContentKeyPolicyPlayReadyContentType enumerates the values for content key policy play ready content type.
type ContentKeyPolicyPlayReadyContentType string

const (
	// ContentKeyPolicyPlayReadyContentTypeUltraVioletDownload Ultraviolet download content type.
	ContentKeyPolicyPlayReadyContentTypeUltraVioletDownload ContentKeyPolicyPlayReadyContentType = "UltraVioletDownload"
	// ContentKeyPolicyPlayReadyContentTypeUltraVioletStreaming Ultraviolet streaming content type.
	ContentKeyPolicyPlayReadyContentTypeUltraVioletStreaming ContentKeyPolicyPlayReadyContentType = "UltraVioletStreaming"
	// ContentKeyPolicyPlayReadyContentTypeUnknown Represents a ContentKeyPolicyPlayReadyContentType that is
	// unavailable in current API version.
	ContentKeyPolicyPlayReadyContentTypeUnknown ContentKeyPolicyPlayReadyContentType = "Unknown"
	// ContentKeyPolicyPlayReadyContentTypeUnspecified Unspecified content type.
	ContentKeyPolicyPlayReadyContentTypeUnspecified ContentKeyPolicyPlayReadyContentType = "Unspecified"
)

// PossibleContentKeyPolicyPlayReadyContentTypeValues returns an array of possible values for the ContentKeyPolicyPlayReadyContentType const type.
func PossibleContentKeyPolicyPlayReadyContentTypeValues() []ContentKeyPolicyPlayReadyContentType {
	return []ContentKeyPolicyPlayReadyContentType{ContentKeyPolicyPlayReadyContentTypeUltraVioletDownload, ContentKeyPolicyPlayReadyContentTypeUltraVioletStreaming, ContentKeyPolicyPlayReadyContentTypeUnknown, ContentKeyPolicyPlayReadyContentTypeUnspecified}
}

// ContentKeyPolicyPlayReadyLicenseType enumerates the values for content key policy play ready license type.
type ContentKeyPolicyPlayReadyLicenseType string

const (
	// ContentKeyPolicyPlayReadyLicenseTypeNonPersistent Non persistent license.
	ContentKeyPolicyPlayReadyLicenseTypeNonPersistent ContentKeyPolicyPlayReadyLicenseType = "NonPersistent"
	// ContentKeyPolicyPlayReadyLicenseTypePersistent Persistent license. Allows offline playback.
	ContentKeyPolicyPlayReadyLicenseTypePersistent ContentKeyPolicyPlayReadyLicenseType = "Persistent"
	// ContentKeyPolicyPlayReadyLicenseTypeUnknown Represents a ContentKeyPolicyPlayReadyLicenseType that is
	// unavailable in current API version.
	ContentKeyPolicyPlayReadyLicenseTypeUnknown ContentKeyPolicyPlayReadyLicenseType = "Unknown"
)

// PossibleContentKeyPolicyPlayReadyLicenseTypeValues returns an array of possible values for the ContentKeyPolicyPlayReadyLicenseType const type.
func PossibleContentKeyPolicyPlayReadyLicenseTypeValues() []ContentKeyPolicyPlayReadyLicenseType {
	return []ContentKeyPolicyPlayReadyLicenseType{ContentKeyPolicyPlayReadyLicenseTypeNonPersistent, ContentKeyPolicyPlayReadyLicenseTypePersistent, ContentKeyPolicyPlayReadyLicenseTypeUnknown}
}

// ContentKeyPolicyPlayReadyUnknownOutputPassingOption enumerates the values for content key policy play ready
// unknown output passing option.
type ContentKeyPolicyPlayReadyUnknownOutputPassingOption string

const (
	// ContentKeyPolicyPlayReadyUnknownOutputPassingOptionAllowed Passing the video portion of protected
	// content to an Unknown Output is allowed.
	ContentKeyPolicyPlayReadyUnknownOutputPassingOptionAllowed ContentKeyPolicyPlayReadyUnknownOutputPassingOption = "Allowed"
	// ContentKeyPolicyPlayReadyUnknownOutputPassingOptionAllowedWithVideoConstriction Passing the video
	// portion of protected content to an Unknown Output is allowed but with constrained resolution.
	ContentKeyPolicyPlayReadyUnknownOutputPassingOptionAllowedWithVideoConstriction ContentKeyPolicyPlayReadyUnknownOutputPassingOption = "AllowedWithVideoConstriction"
	// ContentKeyPolicyPlayReadyUnknownOutputPassingOptionNotAllowed Passing the video portion of protected
	// content to an Unknown Output is not allowed.
	ContentKeyPolicyPlayReadyUnknownOutputPassingOptionNotAllowed ContentKeyPolicyPlayReadyUnknownOutputPassingOption = "NotAllowed"
	// ContentKeyPolicyPlayReadyUnknownOutputPassingOptionUnknown Represents a
	// ContentKeyPolicyPlayReadyUnknownOutputPassingOption that is unavailable in current API version.
	ContentKeyPolicyPlayReadyUnknownOutputPassingOptionUnknown ContentKeyPolicyPlayReadyUnknownOutputPassingOption = "Unknown"
)

// PossibleContentKeyPolicyPlayReadyUnknownOutputPassingOptionValues returns an array of possible values for the ContentKeyPolicyPlayReadyUnknownOutputPassingOption const type.
func PossibleContentKeyPolicyPlayReadyUnknownOutputPassingOptionValues() []ContentKeyPolicyPlayReadyUnknownOutputPassingOption {
	return []ContentKeyPolicyPlayReadyUnknownOutputPassingOption{ContentKeyPolicyPlayReadyUnknownOutputPassingOptionAllowed, ContentKeyPolicyPlayReadyUnknownOutputPassingOptionAllowedWithVideoConstriction, ContentKeyPolicyPlayReadyUnknownOutputPassingOptionNotAllowed, ContentKeyPolicyPlayReadyUnknownOutputPassingOptionUnknown}
}

// ContentKeyPolicyRestrictionTokenType enumerates the values for content key policy restriction token type.
type ContentKeyPolicyRestrictionTokenType string

const (
	// ContentKeyPolicyRestrictionTokenTypeJwt JSON Web Token.
	ContentKeyPolicyRestrictionTokenTypeJwt ContentKeyPolicyRestrictionTokenType = "Jwt"
	// ContentKeyPolicyRestrictionTokenTypeSwt Simple Web Token.
	ContentKeyPolicyRestrictionTokenTypeSwt ContentKeyPolicyRestrictionTokenType = "Swt"
	// ContentKeyPolicyRestrictionTokenTypeUnknown Represents a ContentKeyPolicyRestrictionTokenType that is
	// unavailable in current API version.
	ContentKeyPolicyRestrictionTokenTypeUnknown ContentKeyPolicyRestrictionTokenType = "Unknown"
)

// PossibleContentKeyPolicyRestrictionTokenTypeValues returns an array of possible values for the ContentKeyPolicyRestrictionTokenType const type.
func PossibleContentKeyPolicyRestrictionTokenTypeValues() []ContentKeyPolicyRestrictionTokenType {
	return []ContentKeyPolicyRestrictionTokenType{ContentKeyPolicyRestrictionTokenTypeJwt, ContentKeyPolicyRestrictionTokenTypeSwt, ContentKeyPolicyRestrictionTokenTypeUnknown}
}

// DeinterlaceMode enumerates the values for deinterlace mode.
type DeinterlaceMode string

const (
	// AutoPixelAdaptive Apply automatic pixel adaptive de-interlacing on each frame in the input video.
	AutoPixelAdaptive DeinterlaceMode = "AutoPixelAdaptive"
	// Off Disables de-interlacing of the source video.
	Off DeinterlaceMode = "Off"
)

// PossibleDeinterlaceModeValues returns an array of possible values for the DeinterlaceMode const type.
func PossibleDeinterlaceModeValues() []DeinterlaceMode {
	return []DeinterlaceMode{AutoPixelAdaptive, Off}
}

// DeinterlaceParity enumerates the values for deinterlace parity.
type DeinterlaceParity string

const (
	// Auto Automatically detect the order of fields
	Auto DeinterlaceParity = "Auto"
	// BottomFieldFirst Apply bottom field first processing of input video.
	BottomFieldFirst DeinterlaceParity = "BottomFieldFirst"
	// TopFieldFirst Apply top field first processing of input video.
	TopFieldFirst DeinterlaceParity = "TopFieldFirst"
)

// PossibleDeinterlaceParityValues returns an array of possible values for the DeinterlaceParity const type.
func PossibleDeinterlaceParityValues() []DeinterlaceParity {
	return []DeinterlaceParity{Auto, BottomFieldFirst, TopFieldFirst}
}

// EncoderNamedPreset enumerates the values for encoder named preset.
type EncoderNamedPreset string

const (
	// AACGoodQualityAudio Produces a single MP4 file containing only stereo audio encoded at 192 kbps.
	AACGoodQualityAudio EncoderNamedPreset = "AACGoodQualityAudio"
	// AdaptiveStreaming Produces a set of GOP aligned MP4 files with H.264 video and stereo AAC audio.
	// Auto-generates a bitrate ladder based on the input resolution and bitrate. The auto-generated preset
	// will never exceed the input resolution and bitrate. For example, if the input is 720p at 3 Mbps, output
	// will remain 720p at best, and will start at rates lower than 3 Mbps. The output will have video and
	// audio in separate MP4 files, which is optimal for adaptive streaming.
	AdaptiveStreaming EncoderNamedPreset = "AdaptiveStreaming"
	// ContentAwareEncoding Produces a set of GOP-aligned MP4s by using content-aware encoding. Given any input
	// content, the service performs an initial lightweight analysis of the input content, and uses the results
	// to determine the optimal number of layers, appropriate bitrate and resolution settings for delivery by
	// adaptive streaming. This preset is particularly effective for low and medium complexity videos, where
	// the output files will be at lower bitrates but at a quality that still delivers a good experience to
	// viewers. The output will contain MP4 files with video and audio interleaved.
	ContentAwareEncoding EncoderNamedPreset = "ContentAwareEncoding"
	// ContentAwareEncodingExperimental Exposes an experimental preset for content-aware encoding. Given any
	// input content, the service attempts to automatically determine the optimal number of layers, appropriate
	// bitrate and resolution settings for delivery by adaptive streaming. The underlying algorithms will
	// continue to evolve over time. The output will contain MP4 files with video and audio interleaved.
	ContentAwareEncodingExperimental EncoderNamedPreset = "ContentAwareEncodingExperimental"
	// H264MultipleBitrate1080p Produces a set of 8 GOP-aligned MP4 files, ranging from 6000 kbps to 400 kbps,
	// and stereo AAC audio. Resolution starts at 1080p and goes down to 360p.
	H264MultipleBitrate1080p EncoderNamedPreset = "H264MultipleBitrate1080p"
	// H264MultipleBitrate720p Produces a set of 6 GOP-aligned MP4 files, ranging from 3400 kbps to 400 kbps,
	// and stereo AAC audio. Resolution starts at 720p and goes down to 360p.
	H264MultipleBitrate720p EncoderNamedPreset = "H264MultipleBitrate720p"
	// H264MultipleBitrateSD Produces a set of 5 GOP-aligned MP4 files, ranging from 1600kbps to 400 kbps, and
	// stereo AAC audio. Resolution starts at 480p and goes down to 360p.
	H264MultipleBitrateSD EncoderNamedPreset = "H264MultipleBitrateSD"
	// H264SingleBitrate1080p Produces an MP4 file where the video is encoded with H.264 codec at 6750 kbps and
	// a picture height of 1080 pixels, and the stereo audio is encoded with AAC-LC codec at 64 kbps.
	H264SingleBitrate1080p EncoderNamedPreset = "H264SingleBitrate1080p"
	// H264SingleBitrate720p Produces an MP4 file where the video is encoded with H.264 codec at 4500 kbps and
	// a picture height of 720 pixels, and the stereo audio is encoded with AAC-LC codec at 64 kbps.
	H264SingleBitrate720p EncoderNamedPreset = "H264SingleBitrate720p"
	// H264SingleBitrateSD Produces an MP4 file where the video is encoded with H.264 codec at 2200 kbps and a
	// picture height of 480 pixels, and the stereo audio is encoded with AAC-LC codec at 64 kbps.
	H264SingleBitrateSD EncoderNamedPreset = "H264SingleBitrateSD"
)

// PossibleEncoderNamedPresetValues returns an array of possible values for the EncoderNamedPreset const type.
func PossibleEncoderNamedPresetValues() []EncoderNamedPreset {
	return []EncoderNamedPreset{AACGoodQualityAudio, AdaptiveStreaming, ContentAwareEncoding, ContentAwareEncodingExperimental, H264MultipleBitrate1080p, H264MultipleBitrate720p, H264MultipleBitrateSD, H264SingleBitrate1080p, H264SingleBitrate720p, H264SingleBitrateSD}
}

// EncryptionScheme enumerates the values for encryption scheme.
type EncryptionScheme string

const (
	// EncryptionSchemeCommonEncryptionCbcs CommonEncryptionCbcs scheme
	EncryptionSchemeCommonEncryptionCbcs EncryptionScheme = "CommonEncryptionCbcs"
	// EncryptionSchemeCommonEncryptionCenc CommonEncryptionCenc scheme
	EncryptionSchemeCommonEncryptionCenc EncryptionScheme = "CommonEncryptionCenc"
	// EncryptionSchemeEnvelopeEncryption EnvelopeEncryption scheme
	EncryptionSchemeEnvelopeEncryption EncryptionScheme = "EnvelopeEncryption"
	// EncryptionSchemeNoEncryption NoEncryption scheme
	EncryptionSchemeNoEncryption EncryptionScheme = "NoEncryption"
)

// PossibleEncryptionSchemeValues returns an array of possible values for the EncryptionScheme const type.
func PossibleEncryptionSchemeValues() []EncryptionScheme {
	return []EncryptionScheme{EncryptionSchemeCommonEncryptionCbcs, EncryptionSchemeCommonEncryptionCenc, EncryptionSchemeEnvelopeEncryption, EncryptionSchemeNoEncryption}
}

// EntropyMode enumerates the values for entropy mode.
type EntropyMode string

const (
	// Cabac Context Adaptive Binary Arithmetic Coder (CABAC) entropy encoding.
	Cabac EntropyMode = "Cabac"
	// Cavlc Context Adaptive Variable Length Coder (CAVLC) entropy encoding.
	Cavlc EntropyMode = "Cavlc"
)

// PossibleEntropyModeValues returns an array of possible values for the EntropyMode const type.
func PossibleEntropyModeValues() []EntropyMode {
	return []EntropyMode{Cabac, Cavlc}
}

// FilterTrackPropertyCompareOperation enumerates the values for filter track property compare operation.
type FilterTrackPropertyCompareOperation string

const (
	// Equal The equal operation.
	Equal FilterTrackPropertyCompareOperation = "Equal"
	// NotEqual The not equal operation.
	NotEqual FilterTrackPropertyCompareOperation = "NotEqual"
)

// PossibleFilterTrackPropertyCompareOperationValues returns an array of possible values for the FilterTrackPropertyCompareOperation const type.
func PossibleFilterTrackPropertyCompareOperationValues() []FilterTrackPropertyCompareOperation {
	return []FilterTrackPropertyCompareOperation{Equal, NotEqual}
}

// FilterTrackPropertyType enumerates the values for filter track property type.
type FilterTrackPropertyType string

const (
	// FilterTrackPropertyTypeBitrate The bitrate.
	FilterTrackPropertyTypeBitrate FilterTrackPropertyType = "Bitrate"
	// FilterTrackPropertyTypeFourCC The fourCC.
	FilterTrackPropertyTypeFourCC FilterTrackPropertyType = "FourCC"
	// FilterTrackPropertyTypeLanguage The language.
	FilterTrackPropertyTypeLanguage FilterTrackPropertyType = "Language"
	// FilterTrackPropertyTypeName The name.
	FilterTrackPropertyTypeName FilterTrackPropertyType = "Name"
	// FilterTrackPropertyTypeType The type.
	FilterTrackPropertyTypeType FilterTrackPropertyType = "Type"
	// FilterTrackPropertyTypeUnknown The unknown track property type.
	FilterTrackPropertyTypeUnknown FilterTrackPropertyType = "Unknown"
)

// PossibleFilterTrackPropertyTypeValues returns an array of possible values for the FilterTrackPropertyType const type.
func PossibleFilterTrackPropertyTypeValues() []FilterTrackPropertyType {
	return []FilterTrackPropertyType{FilterTrackPropertyTypeBitrate, FilterTrackPropertyTypeFourCC, FilterTrackPropertyTypeLanguage, FilterTrackPropertyTypeName, FilterTrackPropertyTypeType, FilterTrackPropertyTypeUnknown}
}

// H264Complexity enumerates the values for h264 complexity.
type H264Complexity string

const (
	// Balanced Tells the encoder to use settings that achieve a balance between speed and quality.
	Balanced H264Complexity = "Balanced"
	// Quality Tells the encoder to use settings that are optimized to produce higher quality output at the
	// expense of slower overall encode time.
	Quality H264Complexity = "Quality"
	// Speed Tells the encoder to use settings that are optimized for faster encoding. Quality is sacrificed to
	// decrease encoding time.
	Speed H264Complexity = "Speed"
)

// PossibleH264ComplexityValues returns an array of possible values for the H264Complexity const type.
func PossibleH264ComplexityValues() []H264Complexity {
	return []H264Complexity{Balanced, Quality, Speed}
}

// H264VideoProfile enumerates the values for h264 video profile.
type H264VideoProfile string

const (
	// H264VideoProfileAuto Tells the encoder to automatically determine the appropriate H.264 profile.
	H264VideoProfileAuto H264VideoProfile = "Auto"
	// H264VideoProfileBaseline Baseline profile
	H264VideoProfileBaseline H264VideoProfile = "Baseline"
	// H264VideoProfileHigh High profile.
	H264VideoProfileHigh H264VideoProfile = "High"
	// H264VideoProfileHigh422 High 4:2:2 profile.
	H264VideoProfileHigh422 H264VideoProfile = "High422"
	// H264VideoProfileHigh444 High 4:4:4 predictive profile.
	H264VideoProfileHigh444 H264VideoProfile = "High444"
	// H264VideoProfileMain Main profile
	H264VideoProfileMain H264VideoProfile = "Main"
)

// PossibleH264VideoProfileValues returns an array of possible values for the H264VideoProfile const type.
func PossibleH264VideoProfileValues() []H264VideoProfile {
	return []H264VideoProfile{H264VideoProfileAuto, H264VideoProfileBaseline, H264VideoProfileHigh, H264VideoProfileHigh422, H264VideoProfileHigh444, H264VideoProfileMain}
}

// InsightsType enumerates the values for insights type.
type InsightsType string

const (
	// AllInsights Generate both audio and video insights. Fails if either audio or video Insights fail.
	AllInsights InsightsType = "AllInsights"
	// AudioInsightsOnly Generate audio only insights. Ignore video even if present. Fails if no audio is
	// present.
	AudioInsightsOnly InsightsType = "AudioInsightsOnly"
	// VideoInsightsOnly Generate video only insights. Ignore audio if present. Fails if no video is present.
	VideoInsightsOnly InsightsType = "VideoInsightsOnly"
)

// PossibleInsightsTypeValues returns an array of possible values for the InsightsType const type.
func PossibleInsightsTypeValues() []InsightsType {
	return []InsightsType{AllInsights, AudioInsightsOnly, VideoInsightsOnly}
}

// JobErrorCategory enumerates the values for job error category.
type JobErrorCategory string

const (
	// JobErrorCategoryConfiguration The error is configuration related.
	JobErrorCategoryConfiguration JobErrorCategory = "Configuration"
	// JobErrorCategoryContent The error is related to data in the input files.
	JobErrorCategoryContent JobErrorCategory = "Content"
	// JobErrorCategoryDownload The error is download related.
	JobErrorCategoryDownload JobErrorCategory = "Download"
	// JobErrorCategoryService The error is service related.
	JobErrorCategoryService JobErrorCategory = "Service"
	// JobErrorCategoryUpload The error is upload related.
	JobErrorCategoryUpload JobErrorCategory = "Upload"
)

// PossibleJobErrorCategoryValues returns an array of possible values for the JobErrorCategory const type.
func PossibleJobErrorCategoryValues() []JobErrorCategory {
	return []JobErrorCategory{JobErrorCategoryConfiguration, JobErrorCategoryContent, JobErrorCategoryDownload, JobErrorCategoryService, JobErrorCategoryUpload}
}

// JobErrorCode enumerates the values for job error code.
type JobErrorCode string

const (
	// ConfigurationUnsupported There was a problem with the combination of input files and the configuration
	// settings applied, fix the configuration settings and retry with the same input, or change input to match
	// the configuration.
	ConfigurationUnsupported JobErrorCode = "ConfigurationUnsupported"
	// ContentMalformed There was a problem with the input content (for example: zero byte files, or
	// corrupt/non-decodable files), check the input files.
	ContentMalformed JobErrorCode = "ContentMalformed"
	// ContentUnsupported There was a problem with the format of the input (not valid media file, or an
	// unsupported file/codec), check the validity of the input files.
	ContentUnsupported JobErrorCode = "ContentUnsupported"
	// DownloadNotAccessible While trying to download the input files, the files were not accessible, please
	// check the availability of the source.
	DownloadNotAccessible JobErrorCode = "DownloadNotAccessible"
	// DownloadTransientError While trying to download the input files, there was an issue during transfer
	// (storage service, network errors), see details and check your source.
	DownloadTransientError JobErrorCode = "DownloadTransientError"
	// ServiceError Fatal service error, please contact support.
	ServiceError JobErrorCode = "ServiceError"
	// ServiceTransientError Transient error, please retry, if retry is unsuccessful, please contact support.
	ServiceTransientError JobErrorCode = "ServiceTransientError"
	// UploadNotAccessible While trying to upload the output files, the destination was not reachable, please
	// check the availability of the destination.
	UploadNotAccessible JobErrorCode = "UploadNotAccessible"
	// UploadTransientError While trying to upload the output files, there was an issue during transfer
	// (storage service, network errors), see details and check your destination.
	UploadTransientError JobErrorCode = "UploadTransientError"
)

// PossibleJobErrorCodeValues returns an array of possible values for the JobErrorCode const type.
func PossibleJobErrorCodeValues() []JobErrorCode {
	return []JobErrorCode{ConfigurationUnsupported, ContentMalformed, ContentUnsupported, DownloadNotAccessible, DownloadTransientError, ServiceError, ServiceTransientError, UploadNotAccessible, UploadTransientError}
}

// JobRetry enumerates the values for job retry.
type JobRetry string

const (
	// DoNotRetry Issue needs to be investigated and then the job resubmitted with corrections or retried once
	// the underlying issue has been corrected.
	DoNotRetry JobRetry = "DoNotRetry"
	// MayRetry Issue may be resolved after waiting for a period of time and resubmitting the same Job.
	MayRetry JobRetry = "MayRetry"
)

// PossibleJobRetryValues returns an array of possible values for the JobRetry const type.
func PossibleJobRetryValues() []JobRetry {
	return []JobRetry{DoNotRetry, MayRetry}
}

// JobState enumerates the values for job state.
type JobState string

const (
	// Canceled The job was canceled. This is a final state for the job.
	Canceled JobState = "Canceled"
	// Canceling The job is in the process of being canceled. This is a transient state for the job.
	Canceling JobState = "Canceling"
	// Error The job has encountered an error. This is a final state for the job.
	Error JobState = "Error"
	// Finished The job is finished. This is a final state for the job.
	Finished JobState = "Finished"
	// Processing The job is processing. This is a transient state for the job.
	Processing JobState = "Processing"
	// Queued The job is in a queued state, waiting for resources to become available. This is a transient
	// state.
	Queued JobState = "Queued"
	// Scheduled The job is being scheduled to run on an available resource. This is a transient state, between
	// queued and processing states.
	Scheduled JobState = "Scheduled"
)

// PossibleJobStateValues returns an array of possible values for the JobState const type.
func PossibleJobStateValues() []JobState {
	return []JobState{Canceled, Canceling, Error, Finished, Processing, Queued, Scheduled}
}

// LiveEventEncodingType enumerates the values for live event encoding type.
type LiveEventEncodingType string

const (
	// LiveEventEncodingTypeBasic ...
	LiveEventEncodingTypeBasic LiveEventEncodingType = "Basic"
	// LiveEventEncodingTypeNone ...
	LiveEventEncodingTypeNone LiveEventEncodingType = "None"
	// LiveEventEncodingTypePremium1080p ...
	LiveEventEncodingTypePremium1080p LiveEventEncodingType = "Premium1080p"
	// LiveEventEncodingTypeStandard ...
	LiveEventEncodingTypeStandard LiveEventEncodingType = "Standard"
)

// PossibleLiveEventEncodingTypeValues returns an array of possible values for the LiveEventEncodingType const type.
func PossibleLiveEventEncodingTypeValues() []LiveEventEncodingType {
	return []LiveEventEncodingType{LiveEventEncodingTypeBasic, LiveEventEncodingTypeNone, LiveEventEncodingTypePremium1080p, LiveEventEncodingTypeStandard}
}

// LiveEventInputProtocol enumerates the values for live event input protocol.
type LiveEventInputProtocol string

const (
	// FragmentedMP4 ...
	FragmentedMP4 LiveEventInputProtocol = "FragmentedMP4"
	// RTMP ...
	RTMP LiveEventInputProtocol = "RTMP"
)

// PossibleLiveEventInputProtocolValues returns an array of possible values for the LiveEventInputProtocol const type.
func PossibleLiveEventInputProtocolValues() []LiveEventInputProtocol {
	return []LiveEventInputProtocol{FragmentedMP4, RTMP}
}

// LiveEventResourceState enumerates the values for live event resource state.
type LiveEventResourceState string

const (
	// Deleting ...
	Deleting LiveEventResourceState = "Deleting"
	// Running ...
	Running LiveEventResourceState = "Running"
	// Starting ...
	Starting LiveEventResourceState = "Starting"
	// Stopped ...
	Stopped LiveEventResourceState = "Stopped"
	// Stopping ...
	Stopping LiveEventResourceState = "Stopping"
)

// PossibleLiveEventResourceStateValues returns an array of possible values for the LiveEventResourceState const type.
func PossibleLiveEventResourceStateValues() []LiveEventResourceState {
	return []LiveEventResourceState{Deleting, Running, Starting, Stopped, Stopping}
}

// LiveOutputResourceState enumerates the values for live output resource state.
type LiveOutputResourceState string

const (
	// LiveOutputResourceStateCreating ...
	LiveOutputResourceStateCreating LiveOutputResourceState = "Creating"
	// LiveOutputResourceStateDeleting ...
	LiveOutputResourceStateDeleting LiveOutputResourceState = "Deleting"
	// LiveOutputResourceStateRunning ...
	LiveOutputResourceStateRunning LiveOutputResourceState = "Running"
)

// PossibleLiveOutputResourceStateValues returns an array of possible values for the LiveOutputResourceState const type.
func PossibleLiveOutputResourceStateValues() []LiveOutputResourceState {
	return []LiveOutputResourceState{LiveOutputResourceStateCreating, LiveOutputResourceStateDeleting, LiveOutputResourceStateRunning}
}

// MetricAggregationType enumerates the values for metric aggregation type.
type MetricAggregationType string

const (
	// Average The average.
	Average MetricAggregationType = "Average"
	// Count The count of a number of items, usually requests.
	Count MetricAggregationType = "Count"
	// Total The sum.
	Total MetricAggregationType = "Total"
)

// PossibleMetricAggregationTypeValues returns an array of possible values for the MetricAggregationType const type.
func PossibleMetricAggregationTypeValues() []MetricAggregationType {
	return []MetricAggregationType{Average, Count, Total}
}

// MetricUnit enumerates the values for metric unit.
type MetricUnit string

const (
	// MetricUnitBytes The number of bytes.
	MetricUnitBytes MetricUnit = "Bytes"
	// MetricUnitCount The count.
	MetricUnitCount MetricUnit = "Count"
	// MetricUnitMilliseconds The number of milliseconds.
	MetricUnitMilliseconds MetricUnit = "Milliseconds"
)

// PossibleMetricUnitValues returns an array of possible values for the MetricUnit const type.
func PossibleMetricUnitValues() []MetricUnit {
	return []MetricUnit{MetricUnitBytes, MetricUnitCount, MetricUnitMilliseconds}
}

// OdataType enumerates the values for odata type.
type OdataType string

const (
	// OdataTypeContentKeyPolicyPlayReadyContentKeyLocation ...
	OdataTypeContentKeyPolicyPlayReadyContentKeyLocation OdataType = "ContentKeyPolicyPlayReadyContentKeyLocation"
	// OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader ...
	OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader OdataType = "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader"
	// OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier ...
	OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier OdataType = "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier"
)

// PossibleOdataTypeValues returns an array of possible values for the OdataType const type.
func PossibleOdataTypeValues() []OdataType {
	return []OdataType{OdataTypeContentKeyPolicyPlayReadyContentKeyLocation, OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier}
}

// OdataTypeBasicClipTime enumerates the values for odata type basic clip time.
type OdataTypeBasicClipTime string

const (
	// OdataTypeClipTime ...
	OdataTypeClipTime OdataTypeBasicClipTime = "ClipTime"
	// OdataTypeMicrosoftMediaAbsoluteClipTime ...
	OdataTypeMicrosoftMediaAbsoluteClipTime OdataTypeBasicClipTime = "#Microsoft.Media.AbsoluteClipTime"
)

// PossibleOdataTypeBasicClipTimeValues returns an array of possible values for the OdataTypeBasicClipTime const type.
func PossibleOdataTypeBasicClipTimeValues() []OdataTypeBasicClipTime {
	return []OdataTypeBasicClipTime{OdataTypeClipTime, OdataTypeMicrosoftMediaAbsoluteClipTime}
}

// OdataTypeBasicCodec enumerates the values for odata type basic codec.
type OdataTypeBasicCodec string

const (
	// OdataTypeCodec ...
	OdataTypeCodec OdataTypeBasicCodec = "Codec"
	// OdataTypeMicrosoftMediaAacAudio ...
	OdataTypeMicrosoftMediaAacAudio OdataTypeBasicCodec = "#Microsoft.Media.AacAudio"
	// OdataTypeMicrosoftMediaAudio ...
	OdataTypeMicrosoftMediaAudio OdataTypeBasicCodec = "#Microsoft.Media.Audio"
	// OdataTypeMicrosoftMediaCopyAudio ...
	OdataTypeMicrosoftMediaCopyAudio OdataTypeBasicCodec = "#Microsoft.Media.CopyAudio"
	// OdataTypeMicrosoftMediaCopyVideo ...
	OdataTypeMicrosoftMediaCopyVideo OdataTypeBasicCodec = "#Microsoft.Media.CopyVideo"
	// OdataTypeMicrosoftMediaH264Video ...
	OdataTypeMicrosoftMediaH264Video OdataTypeBasicCodec = "#Microsoft.Media.H264Video"
	// OdataTypeMicrosoftMediaImage ...
	OdataTypeMicrosoftMediaImage OdataTypeBasicCodec = "#Microsoft.Media.Image"
	// OdataTypeMicrosoftMediaJpgImage ...
	OdataTypeMicrosoftMediaJpgImage OdataTypeBasicCodec = "#Microsoft.Media.JpgImage"
	// OdataTypeMicrosoftMediaPngImage ...
	OdataTypeMicrosoftMediaPngImage OdataTypeBasicCodec = "#Microsoft.Media.PngImage"
	// OdataTypeMicrosoftMediaVideo ...
	OdataTypeMicrosoftMediaVideo OdataTypeBasicCodec = "#Microsoft.Media.Video"
)

// PossibleOdataTypeBasicCodecValues returns an array of possible values for the OdataTypeBasicCodec const type.
func PossibleOdataTypeBasicCodecValues() []OdataTypeBasicCodec {
	return []OdataTypeBasicCodec{OdataTypeCodec, OdataTypeMicrosoftMediaAacAudio, OdataTypeMicrosoftMediaAudio, OdataTypeMicrosoftMediaCopyAudio, OdataTypeMicrosoftMediaCopyVideo, OdataTypeMicrosoftMediaH264Video, OdataTypeMicrosoftMediaImage, OdataTypeMicrosoftMediaJpgImage, OdataTypeMicrosoftMediaPngImage, OdataTypeMicrosoftMediaVideo}
}

// OdataTypeBasicContentKeyPolicyConfiguration enumerates the values for odata type basic content key policy
// configuration.
type OdataTypeBasicContentKeyPolicyConfiguration string

const (
	// OdataTypeContentKeyPolicyConfiguration ...
	OdataTypeContentKeyPolicyConfiguration OdataTypeBasicContentKeyPolicyConfiguration = "ContentKeyPolicyConfiguration"
	// OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration ...
	OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration OdataTypeBasicContentKeyPolicyConfiguration = "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration"
	// OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration ...
	OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration OdataTypeBasicContentKeyPolicyConfiguration = "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration"
	// OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration ...
	OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration OdataTypeBasicContentKeyPolicyConfiguration = "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration"
	// OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration ...
	OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration OdataTypeBasicContentKeyPolicyConfiguration = "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration"
	// OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration ...
	OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration OdataTypeBasicContentKeyPolicyConfiguration = "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration"
)

// PossibleOdataTypeBasicContentKeyPolicyConfigurationValues returns an array of possible values for the OdataTypeBasicContentKeyPolicyConfiguration const type.
func PossibleOdataTypeBasicContentKeyPolicyConfigurationValues() []OdataTypeBasicContentKeyPolicyConfiguration {
	return []OdataTypeBasicContentKeyPolicyConfiguration{OdataTypeContentKeyPolicyConfiguration, OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration, OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration, OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration, OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration, OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration}
}

// OdataTypeBasicContentKeyPolicyRestriction enumerates the values for odata type basic content key policy
// restriction.
type OdataTypeBasicContentKeyPolicyRestriction string

const (
	// OdataTypeContentKeyPolicyRestriction ...
	OdataTypeContentKeyPolicyRestriction OdataTypeBasicContentKeyPolicyRestriction = "ContentKeyPolicyRestriction"
	// OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction ...
	OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction OdataTypeBasicContentKeyPolicyRestriction = "#Microsoft.Media.ContentKeyPolicyOpenRestriction"
	// OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction ...
	OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction OdataTypeBasicContentKeyPolicyRestriction = "#Microsoft.Media.ContentKeyPolicyTokenRestriction"
	// OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction ...
	OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction OdataTypeBasicContentKeyPolicyRestriction = "#Microsoft.Media.ContentKeyPolicyUnknownRestriction"
)

// PossibleOdataTypeBasicContentKeyPolicyRestrictionValues returns an array of possible values for the OdataTypeBasicContentKeyPolicyRestriction const type.
func PossibleOdataTypeBasicContentKeyPolicyRestrictionValues() []OdataTypeBasicContentKeyPolicyRestriction {
	return []OdataTypeBasicContentKeyPolicyRestriction{OdataTypeContentKeyPolicyRestriction, OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction, OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction, OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction}
}

// OdataTypeBasicContentKeyPolicyRestrictionTokenKey enumerates the values for odata type basic content key
// policy restriction token key.
type OdataTypeBasicContentKeyPolicyRestrictionTokenKey string

const (
	// OdataTypeContentKeyPolicyRestrictionTokenKey ...
	OdataTypeContentKeyPolicyRestrictionTokenKey OdataTypeBasicContentKeyPolicyRestrictionTokenKey = "ContentKeyPolicyRestrictionTokenKey"
	// OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey ...
	OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey OdataTypeBasicContentKeyPolicyRestrictionTokenKey = "#Microsoft.Media.ContentKeyPolicyRsaTokenKey"
	// OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey ...
	OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey OdataTypeBasicContentKeyPolicyRestrictionTokenKey = "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey"
	// OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey ...
	OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey OdataTypeBasicContentKeyPolicyRestrictionTokenKey = "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey"
)

// PossibleOdataTypeBasicContentKeyPolicyRestrictionTokenKeyValues returns an array of possible values for the OdataTypeBasicContentKeyPolicyRestrictionTokenKey const type.
func PossibleOdataTypeBasicContentKeyPolicyRestrictionTokenKeyValues() []OdataTypeBasicContentKeyPolicyRestrictionTokenKey {
	return []OdataTypeBasicContentKeyPolicyRestrictionTokenKey{OdataTypeContentKeyPolicyRestrictionTokenKey, OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey, OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey, OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey}
}

// OdataTypeBasicFormat enumerates the values for odata type basic format.
type OdataTypeBasicFormat string

const (
	// OdataTypeFormat ...
	OdataTypeFormat OdataTypeBasicFormat = "Format"
	// OdataTypeMicrosoftMediaImageFormat ...
	OdataTypeMicrosoftMediaImageFormat OdataTypeBasicFormat = "#Microsoft.Media.ImageFormat"
	// OdataTypeMicrosoftMediaJpgFormat ...
	OdataTypeMicrosoftMediaJpgFormat OdataTypeBasicFormat = "#Microsoft.Media.JpgFormat"
	// OdataTypeMicrosoftMediaMp4Format ...
	OdataTypeMicrosoftMediaMp4Format OdataTypeBasicFormat = "#Microsoft.Media.Mp4Format"
	// OdataTypeMicrosoftMediaMultiBitrateFormat ...
	OdataTypeMicrosoftMediaMultiBitrateFormat OdataTypeBasicFormat = "#Microsoft.Media.MultiBitrateFormat"
	// OdataTypeMicrosoftMediaPngFormat ...
	OdataTypeMicrosoftMediaPngFormat OdataTypeBasicFormat = "#Microsoft.Media.PngFormat"
	// OdataTypeMicrosoftMediaTransportStreamFormat ...
	OdataTypeMicrosoftMediaTransportStreamFormat OdataTypeBasicFormat = "#Microsoft.Media.TransportStreamFormat"
)

// PossibleOdataTypeBasicFormatValues returns an array of possible values for the OdataTypeBasicFormat const type.
func PossibleOdataTypeBasicFormatValues() []OdataTypeBasicFormat {
	return []OdataTypeBasicFormat{OdataTypeFormat, OdataTypeMicrosoftMediaImageFormat, OdataTypeMicrosoftMediaJpgFormat, OdataTypeMicrosoftMediaMp4Format, OdataTypeMicrosoftMediaMultiBitrateFormat, OdataTypeMicrosoftMediaPngFormat, OdataTypeMicrosoftMediaTransportStreamFormat}
}

// OdataTypeBasicJobInput enumerates the values for odata type basic job input.
type OdataTypeBasicJobInput string

const (
	// OdataTypeJobInput ...
	OdataTypeJobInput OdataTypeBasicJobInput = "JobInput"
	// OdataTypeMicrosoftMediaJobInputAsset ...
	OdataTypeMicrosoftMediaJobInputAsset OdataTypeBasicJobInput = "#Microsoft.Media.JobInputAsset"
	// OdataTypeMicrosoftMediaJobInputClip ...
	OdataTypeMicrosoftMediaJobInputClip OdataTypeBasicJobInput = "#Microsoft.Media.JobInputClip"
	// OdataTypeMicrosoftMediaJobInputHTTP ...
	OdataTypeMicrosoftMediaJobInputHTTP OdataTypeBasicJobInput = "#Microsoft.Media.JobInputHttp"
	// OdataTypeMicrosoftMediaJobInputs ...
	OdataTypeMicrosoftMediaJobInputs OdataTypeBasicJobInput = "#Microsoft.Media.JobInputs"
)

// PossibleOdataTypeBasicJobInputValues returns an array of possible values for the OdataTypeBasicJobInput const type.
func PossibleOdataTypeBasicJobInputValues() []OdataTypeBasicJobInput {
	return []OdataTypeBasicJobInput{OdataTypeJobInput, OdataTypeMicrosoftMediaJobInputAsset, OdataTypeMicrosoftMediaJobInputClip, OdataTypeMicrosoftMediaJobInputHTTP, OdataTypeMicrosoftMediaJobInputs}
}

// OdataTypeBasicJobOutput enumerates the values for odata type basic job output.
type OdataTypeBasicJobOutput string

const (
	// OdataTypeJobOutput ...
	OdataTypeJobOutput OdataTypeBasicJobOutput = "JobOutput"
	// OdataTypeMicrosoftMediaJobOutputAsset ...
	OdataTypeMicrosoftMediaJobOutputAsset OdataTypeBasicJobOutput = "#Microsoft.Media.JobOutputAsset"
)

// PossibleOdataTypeBasicJobOutputValues returns an array of possible values for the OdataTypeBasicJobOutput const type.
func PossibleOdataTypeBasicJobOutputValues() []OdataTypeBasicJobOutput {
	return []OdataTypeBasicJobOutput{OdataTypeJobOutput, OdataTypeMicrosoftMediaJobOutputAsset}
}

// OdataTypeBasicLayer enumerates the values for odata type basic layer.
type OdataTypeBasicLayer string

const (
	// OdataTypeLayer ...
	OdataTypeLayer OdataTypeBasicLayer = "Layer"
	// OdataTypeMicrosoftMediaH264Layer ...
	OdataTypeMicrosoftMediaH264Layer OdataTypeBasicLayer = "#Microsoft.Media.H264Layer"
	// OdataTypeMicrosoftMediaJpgLayer ...
	OdataTypeMicrosoftMediaJpgLayer OdataTypeBasicLayer = "#Microsoft.Media.JpgLayer"
	// OdataTypeMicrosoftMediaPngLayer ...
	OdataTypeMicrosoftMediaPngLayer OdataTypeBasicLayer = "#Microsoft.Media.PngLayer"
	// OdataTypeMicrosoftMediaVideoLayer ...
	OdataTypeMicrosoftMediaVideoLayer OdataTypeBasicLayer = "#Microsoft.Media.VideoLayer"
)

// PossibleOdataTypeBasicLayerValues returns an array of possible values for the OdataTypeBasicLayer const type.
func PossibleOdataTypeBasicLayerValues() []OdataTypeBasicLayer {
	return []OdataTypeBasicLayer{OdataTypeLayer, OdataTypeMicrosoftMediaH264Layer, OdataTypeMicrosoftMediaJpgLayer, OdataTypeMicrosoftMediaPngLayer, OdataTypeMicrosoftMediaVideoLayer}
}

// OdataTypeBasicOverlay enumerates the values for odata type basic overlay.
type OdataTypeBasicOverlay string

const (
	// OdataTypeMicrosoftMediaAudioOverlay ...
	OdataTypeMicrosoftMediaAudioOverlay OdataTypeBasicOverlay = "#Microsoft.Media.AudioOverlay"
	// OdataTypeMicrosoftMediaVideoOverlay ...
	OdataTypeMicrosoftMediaVideoOverlay OdataTypeBasicOverlay = "#Microsoft.Media.VideoOverlay"
	// OdataTypeOverlay ...
	OdataTypeOverlay OdataTypeBasicOverlay = "Overlay"
)

// PossibleOdataTypeBasicOverlayValues returns an array of possible values for the OdataTypeBasicOverlay const type.
func PossibleOdataTypeBasicOverlayValues() []OdataTypeBasicOverlay {
	return []OdataTypeBasicOverlay{OdataTypeMicrosoftMediaAudioOverlay, OdataTypeMicrosoftMediaVideoOverlay, OdataTypeOverlay}
}

// OdataTypeBasicPreset enumerates the values for odata type basic preset.
type OdataTypeBasicPreset string

const (
	// OdataTypeMicrosoftMediaAudioAnalyzerPreset ...
	OdataTypeMicrosoftMediaAudioAnalyzerPreset OdataTypeBasicPreset = "#Microsoft.Media.AudioAnalyzerPreset"
	// OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset ...
	OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset OdataTypeBasicPreset = "#Microsoft.Media.BuiltInStandardEncoderPreset"
	// OdataTypeMicrosoftMediaFaceDetectorPreset ...
	OdataTypeMicrosoftMediaFaceDetectorPreset OdataTypeBasicPreset = "#Microsoft.Media.FaceDetectorPreset"
	// OdataTypeMicrosoftMediaStandardEncoderPreset ...
	OdataTypeMicrosoftMediaStandardEncoderPreset OdataTypeBasicPreset = "#Microsoft.Media.StandardEncoderPreset"
	// OdataTypeMicrosoftMediaVideoAnalyzerPreset ...
	OdataTypeMicrosoftMediaVideoAnalyzerPreset OdataTypeBasicPreset = "#Microsoft.Media.VideoAnalyzerPreset"
	// OdataTypePreset ...
	OdataTypePreset OdataTypeBasicPreset = "Preset"
)

// PossibleOdataTypeBasicPresetValues returns an array of possible values for the OdataTypeBasicPreset const type.
func PossibleOdataTypeBasicPresetValues() []OdataTypeBasicPreset {
	return []OdataTypeBasicPreset{OdataTypeMicrosoftMediaAudioAnalyzerPreset, OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset, OdataTypeMicrosoftMediaFaceDetectorPreset, OdataTypeMicrosoftMediaStandardEncoderPreset, OdataTypeMicrosoftMediaVideoAnalyzerPreset, OdataTypePreset}
}

// OnErrorType enumerates the values for on error type.
type OnErrorType string

const (
	// ContinueJob Tells the service that if this TransformOutput fails, then allow any other TransformOutput
	// to continue.
	ContinueJob OnErrorType = "ContinueJob"
	// StopProcessingJob Tells the service that if this TransformOutput fails, then any other incomplete
	// TransformOutputs can be stopped.
	StopProcessingJob OnErrorType = "StopProcessingJob"
)

// PossibleOnErrorTypeValues returns an array of possible values for the OnErrorType const type.
func PossibleOnErrorTypeValues() []OnErrorType {
	return []OnErrorType{ContinueJob, StopProcessingJob}
}

// Priority enumerates the values for priority.
type Priority string

const (
	// High Used for TransformOutputs that should take precedence over others.
	High Priority = "High"
	// Low Used for TransformOutputs that can be generated after Normal and High priority TransformOutputs.
	Low Priority = "Low"
	// Normal Used for TransformOutputs that can be generated at Normal priority.
	Normal Priority = "Normal"
)

// PossiblePriorityValues returns an array of possible values for the Priority const type.
func PossiblePriorityValues() []Priority {
	return []Priority{High, Low, Normal}
}

// Rotation enumerates the values for rotation.
type Rotation string

const (
	// RotationAuto Automatically detect and rotate as needed.
	RotationAuto Rotation = "Auto"
	// RotationNone Do not rotate the video.  If the output format supports it, any metadata about rotation is
	// kept intact.
	RotationNone Rotation = "None"
	// RotationRotate0 Do not rotate the video but remove any metadata about the rotation.
	RotationRotate0 Rotation = "Rotate0"
	// RotationRotate180 Rotate 180 degrees clockwise.
	RotationRotate180 Rotation = "Rotate180"
	// RotationRotate270 Rotate 270 degrees clockwise.
	RotationRotate270 Rotation = "Rotate270"
	// RotationRotate90 Rotate 90 degrees clockwise.
	RotationRotate90 Rotation = "Rotate90"
)

// PossibleRotationValues returns an array of possible values for the Rotation const type.
func PossibleRotationValues() []Rotation {
	return []Rotation{RotationAuto, RotationNone, RotationRotate0, RotationRotate180, RotationRotate270, RotationRotate90}
}

// StorageAccountType enumerates the values for storage account type.
type StorageAccountType string

const (
	// Primary The primary storage account for the Media Services account.
	Primary StorageAccountType = "Primary"
	// Secondary A secondary storage account for the Media Services account.
	Secondary StorageAccountType = "Secondary"
)

// PossibleStorageAccountTypeValues returns an array of possible values for the StorageAccountType const type.
func PossibleStorageAccountTypeValues() []StorageAccountType {
	return []StorageAccountType{Primary, Secondary}
}

// StreamingEndpointResourceState enumerates the values for streaming endpoint resource state.
type StreamingEndpointResourceState string

const (
	// StreamingEndpointResourceStateDeleting ...
	StreamingEndpointResourceStateDeleting StreamingEndpointResourceState = "Deleting"
	// StreamingEndpointResourceStateRunning ...
	StreamingEndpointResourceStateRunning StreamingEndpointResourceState = "Running"
	// StreamingEndpointResourceStateScaling ...
	StreamingEndpointResourceStateScaling StreamingEndpointResourceState = "Scaling"
	// StreamingEndpointResourceStateStarting ...
	StreamingEndpointResourceStateStarting StreamingEndpointResourceState = "Starting"
	// StreamingEndpointResourceStateStopped ...
	StreamingEndpointResourceStateStopped StreamingEndpointResourceState = "Stopped"
	// StreamingEndpointResourceStateStopping ...
	StreamingEndpointResourceStateStopping StreamingEndpointResourceState = "Stopping"
)

// PossibleStreamingEndpointResourceStateValues returns an array of possible values for the StreamingEndpointResourceState const type.
func PossibleStreamingEndpointResourceStateValues() []StreamingEndpointResourceState {
	return []StreamingEndpointResourceState{StreamingEndpointResourceStateDeleting, StreamingEndpointResourceStateRunning, StreamingEndpointResourceStateScaling, StreamingEndpointResourceStateStarting, StreamingEndpointResourceStateStopped, StreamingEndpointResourceStateStopping}
}

// StreamingLocatorContentKeyType enumerates the values for streaming locator content key type.
type StreamingLocatorContentKeyType string

const (
	// StreamingLocatorContentKeyTypeCommonEncryptionCbcs Common Encryption using CBCS
	StreamingLocatorContentKeyTypeCommonEncryptionCbcs StreamingLocatorContentKeyType = "CommonEncryptionCbcs"
	// StreamingLocatorContentKeyTypeCommonEncryptionCenc Common Encryption using CENC
	StreamingLocatorContentKeyTypeCommonEncryptionCenc StreamingLocatorContentKeyType = "CommonEncryptionCenc"
	// StreamingLocatorContentKeyTypeEnvelopeEncryption Envelope Encryption
	StreamingLocatorContentKeyTypeEnvelopeEncryption StreamingLocatorContentKeyType = "EnvelopeEncryption"
)

// PossibleStreamingLocatorContentKeyTypeValues returns an array of possible values for the StreamingLocatorContentKeyType const type.
func PossibleStreamingLocatorContentKeyTypeValues() []StreamingLocatorContentKeyType {
	return []StreamingLocatorContentKeyType{StreamingLocatorContentKeyTypeCommonEncryptionCbcs, StreamingLocatorContentKeyTypeCommonEncryptionCenc, StreamingLocatorContentKeyTypeEnvelopeEncryption}
}

// StreamingPolicyStreamingProtocol enumerates the values for streaming policy streaming protocol.
type StreamingPolicyStreamingProtocol string

const (
	// StreamingPolicyStreamingProtocolDash DASH protocol
	StreamingPolicyStreamingProtocolDash StreamingPolicyStreamingProtocol = "Dash"
	// StreamingPolicyStreamingProtocolDownload Download protocol
	StreamingPolicyStreamingProtocolDownload StreamingPolicyStreamingProtocol = "Download"
	// StreamingPolicyStreamingProtocolHls HLS protocol
	StreamingPolicyStreamingProtocolHls StreamingPolicyStreamingProtocol = "Hls"
	// StreamingPolicyStreamingProtocolSmoothStreaming SmoothStreaming protocol
	StreamingPolicyStreamingProtocolSmoothStreaming StreamingPolicyStreamingProtocol = "SmoothStreaming"
)

// PossibleStreamingPolicyStreamingProtocolValues returns an array of possible values for the StreamingPolicyStreamingProtocol const type.
func PossibleStreamingPolicyStreamingProtocolValues() []StreamingPolicyStreamingProtocol {
	return []StreamingPolicyStreamingProtocol{StreamingPolicyStreamingProtocolDash, StreamingPolicyStreamingProtocolDownload, StreamingPolicyStreamingProtocolHls, StreamingPolicyStreamingProtocolSmoothStreaming}
}

// StreamOptionsFlag enumerates the values for stream options flag.
type StreamOptionsFlag string

const (
	// Default ...
	Default StreamOptionsFlag = "Default"
	// LowLatency ...
	LowLatency StreamOptionsFlag = "LowLatency"
)

// PossibleStreamOptionsFlagValues returns an array of possible values for the StreamOptionsFlag const type.
func PossibleStreamOptionsFlagValues() []StreamOptionsFlag {
	return []StreamOptionsFlag{Default, LowLatency}
}

// StretchMode enumerates the values for stretch mode.
type StretchMode string

const (
	// StretchModeAutoFit Pad the output (with either letterbox or pillar box) to honor the output resolution,
	// while ensuring that the active video region in the output has the same aspect ratio as the input. For
	// example, if the input is 1920x1080 and the encoding preset asks for 1280x1280, then the output will be
	// at 1280x1280, which contains an inner rectangle of 1280x720 at aspect ratio of 16:9, and pillar box
	// regions 280 pixels wide at the left and right.
	StretchModeAutoFit StretchMode = "AutoFit"
	// StretchModeAutoSize Override the output resolution, and change it to match the display aspect ratio of
	// the input, without padding. For example, if the input is 1920x1080 and the encoding preset asks for
	// 1280x1280, then the value in the preset is overridden, and the output will be at 1280x720, which
	// maintains the input aspect ratio of 16:9.
	StretchModeAutoSize StretchMode = "AutoSize"
	// StretchModeNone Strictly respect the output resolution without considering the pixel aspect ratio or
	// display aspect ratio of the input video.
	StretchModeNone StretchMode = "None"
)

// PossibleStretchModeValues returns an array of possible values for the StretchMode const type.
func PossibleStretchModeValues() []StretchMode {
	return []StretchMode{StretchModeAutoFit, StretchModeAutoSize, StretchModeNone}
}

// TrackPropertyCompareOperation enumerates the values for track property compare operation.
type TrackPropertyCompareOperation string

const (
	// TrackPropertyCompareOperationEqual Equal operation
	TrackPropertyCompareOperationEqual TrackPropertyCompareOperation = "Equal"
	// TrackPropertyCompareOperationUnknown Unknown track property compare operation
	TrackPropertyCompareOperationUnknown TrackPropertyCompareOperation = "Unknown"
)

// PossibleTrackPropertyCompareOperationValues returns an array of possible values for the TrackPropertyCompareOperation const type.
func PossibleTrackPropertyCompareOperationValues() []TrackPropertyCompareOperation {
	return []TrackPropertyCompareOperation{TrackPropertyCompareOperationEqual, TrackPropertyCompareOperationUnknown}
}

// TrackPropertyType enumerates the values for track property type.
type TrackPropertyType string

const (
	// TrackPropertyTypeFourCC Track FourCC
	TrackPropertyTypeFourCC TrackPropertyType = "FourCC"
	// TrackPropertyTypeUnknown Unknown track property
	TrackPropertyTypeUnknown TrackPropertyType = "Unknown"
)

// PossibleTrackPropertyTypeValues returns an array of possible values for the TrackPropertyType const type.
func PossibleTrackPropertyTypeValues() []TrackPropertyType {
	return []TrackPropertyType{TrackPropertyTypeFourCC, TrackPropertyTypeUnknown}
}

// AacAudio describes Advanced Audio Codec (AAC) audio encoding settings.
type AacAudio struct {
	// Profile - The encoding profile to be used when encoding audio with AAC. Possible values include: 'AacLc', 'HeAacV1', 'HeAacV2'
	Profile AacAudioProfile `json:"profile,omitempty"`
	// Channels - The number of channels in the audio.
	Channels *int32 `json:"channels,omitempty"`
	// SamplingRate - The sampling rate to use for encoding in hertz.
	SamplingRate *int32 `json:"samplingRate,omitempty"`
	// Bitrate - The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int32 `json:"bitrate,omitempty"`
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for AacAudio.
func (aa AacAudio) MarshalJSON() ([]byte, error) {
	aa.OdataType = OdataTypeMicrosoftMediaAacAudio
	objectMap := make(map[string]interface{})
	if aa.Profile != "" {
		objectMap["profile"] = aa.Profile
	}
	if aa.Channels != nil {
		objectMap["channels"] = aa.Channels
	}
	if aa.SamplingRate != nil {
		objectMap["samplingRate"] = aa.SamplingRate
	}
	if aa.Bitrate != nil {
		objectMap["bitrate"] = aa.Bitrate
	}
	if aa.Label != nil {
		objectMap["label"] = aa.Label
	}
	if aa.OdataType != "" {
		objectMap["@odata.type"] = aa.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsBasicAudio() (BasicAudio, bool) {
	return &aa, true
}

// AsAacAudio is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsAacAudio() (*AacAudio, bool) {
	return &aa, true
}

// AsCopyVideo is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsBasicVideo() (BasicVideo, bool) {
	return nil, false
}

// AsImage is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsBasicImage() (BasicImage, bool) {
	return nil, false
}

// AsCopyAudio is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for AacAudio.
func (aa AacAudio) AsBasicCodec() (BasicCodec, bool) {
	return &aa, true
}

// AbsoluteClipTime specifies the clip time as an absolute time position in the media file.  The absolute
// time can point to a different position depending on whether the media file starts from a timestamp of
// zero or not.
type AbsoluteClipTime struct {
	// Time - The time position on the timeline of the input media. It is usually specified as an ISO8601 period. e.g PT30S for 30 seconds.
	Time *string `json:"time,omitempty"`
	// OdataType - Possible values include: 'OdataTypeClipTime', 'OdataTypeMicrosoftMediaAbsoluteClipTime'
	OdataType OdataTypeBasicClipTime `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for AbsoluteClipTime.
func (act AbsoluteClipTime) MarshalJSON() ([]byte, error) {
	act.OdataType = OdataTypeMicrosoftMediaAbsoluteClipTime
	objectMap := make(map[string]interface{})
	if act.Time != nil {
		objectMap["time"] = act.Time
	}
	if act.OdataType != "" {
		objectMap["@odata.type"] = act.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAbsoluteClipTime is the BasicClipTime implementation for AbsoluteClipTime.
func (act AbsoluteClipTime) AsAbsoluteClipTime() (*AbsoluteClipTime, bool) {
	return &act, true
}

// AsClipTime is the BasicClipTime implementation for AbsoluteClipTime.
func (act AbsoluteClipTime) AsClipTime() (*ClipTime, bool) {
	return nil, false
}

// AsBasicClipTime is the BasicClipTime implementation for AbsoluteClipTime.
func (act AbsoluteClipTime) AsBasicClipTime() (BasicClipTime, bool) {
	return &act, true
}

// AccountFilter an Account Filter.
type AccountFilter struct {
	autorest.Response `json:"-"`
	*FilterProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountFilter.
func (af AccountFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if af.FilterProperties != nil {
		objectMap["properties"] = af.FilterProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccountFilter struct.
func (af *AccountFilter) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var filterProperties FilterProperties
				err = json.Unmarshal(*v, &filterProperties)
				if err != nil {
					return err
				}
				af.FilterProperties = &filterProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				af.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				af.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				af.Type = &typeVar
			}
		}
	}

	return nil
}

// AccountFilterCollection a collection of AccountFilter items.
type AccountFilterCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of AccountFilter items.
	Value *[]AccountFilter `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// AccountFilterCollectionIterator provides access to a complete listing of AccountFilter values.
type AccountFilterCollectionIterator struct {
	i    int
	page AccountFilterCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccountFilterCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountFilterCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccountFilterCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccountFilterCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccountFilterCollectionIterator) Response() AccountFilterCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccountFilterCollectionIterator) Value() AccountFilter {
	if !iter.page.NotDone() {
		return AccountFilter{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccountFilterCollectionIterator type.
func NewAccountFilterCollectionIterator(page AccountFilterCollectionPage) AccountFilterCollectionIterator {
	return AccountFilterCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (afc AccountFilterCollection) IsEmpty() bool {
	return afc.Value == nil || len(*afc.Value) == 0
}

// accountFilterCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (afc AccountFilterCollection) accountFilterCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if afc.OdataNextLink == nil || len(to.String(afc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(afc.OdataNextLink)))
}

// AccountFilterCollectionPage contains a page of AccountFilter values.
type AccountFilterCollectionPage struct {
	fn  func(context.Context, AccountFilterCollection) (AccountFilterCollection, error)
	afc AccountFilterCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccountFilterCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountFilterCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.afc)
	if err != nil {
		return err
	}
	page.afc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccountFilterCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccountFilterCollectionPage) NotDone() bool {
	return !page.afc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccountFilterCollectionPage) Response() AccountFilterCollection {
	return page.afc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccountFilterCollectionPage) Values() []AccountFilter {
	if page.afc.IsEmpty() {
		return nil
	}
	return *page.afc.Value
}

// Creates a new instance of the AccountFilterCollectionPage type.
func NewAccountFilterCollectionPage(getNextPage func(context.Context, AccountFilterCollection) (AccountFilterCollection, error)) AccountFilterCollectionPage {
	return AccountFilterCollectionPage{fn: getNextPage}
}

// AkamaiAccessControl akamai access control
type AkamaiAccessControl struct {
	// AkamaiSignatureHeaderAuthenticationKeyList - authentication key list
	AkamaiSignatureHeaderAuthenticationKeyList *[]AkamaiSignatureHeaderAuthenticationKey `json:"akamaiSignatureHeaderAuthenticationKeyList,omitempty"`
}

// AkamaiSignatureHeaderAuthenticationKey akamai Signature Header authentication key.
type AkamaiSignatureHeaderAuthenticationKey struct {
	// Identifier - identifier of the key
	Identifier *string `json:"identifier,omitempty"`
	// Base64Key - authentication key
	Base64Key *string `json:"base64Key,omitempty"`
	// Expiration - The expiration time of the authentication key.
	Expiration *date.Time `json:"expiration,omitempty"`
}

// APIError the API error.
type APIError struct {
	// Error - The error properties.
	Error *ODataError `json:"error,omitempty"`
}

// Asset an Asset.
type Asset struct {
	autorest.Response `json:"-"`
	// AssetProperties - The resource properties.
	*AssetProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Asset.
func (a Asset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.AssetProperties != nil {
		objectMap["properties"] = a.AssetProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Asset struct.
func (a *Asset) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var assetProperties AssetProperties
				err = json.Unmarshal(*v, &assetProperties)
				if err != nil {
					return err
				}
				a.AssetProperties = &assetProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				a.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				a.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				a.Type = &typeVar
			}
		}
	}

	return nil
}

// AssetCollection a collection of Asset items.
type AssetCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of Asset items.
	Value *[]Asset `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// AssetCollectionIterator provides access to a complete listing of Asset values.
type AssetCollectionIterator struct {
	i    int
	page AssetCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AssetCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AssetCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AssetCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AssetCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AssetCollectionIterator) Response() AssetCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AssetCollectionIterator) Value() Asset {
	if !iter.page.NotDone() {
		return Asset{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AssetCollectionIterator type.
func NewAssetCollectionIterator(page AssetCollectionPage) AssetCollectionIterator {
	return AssetCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ac AssetCollection) IsEmpty() bool {
	return ac.Value == nil || len(*ac.Value) == 0
}

// assetCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ac AssetCollection) assetCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if ac.OdataNextLink == nil || len(to.String(ac.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ac.OdataNextLink)))
}

// AssetCollectionPage contains a page of Asset values.
type AssetCollectionPage struct {
	fn func(context.Context, AssetCollection) (AssetCollection, error)
	ac AssetCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AssetCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AssetCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.ac)
	if err != nil {
		return err
	}
	page.ac = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AssetCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AssetCollectionPage) NotDone() bool {
	return !page.ac.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AssetCollectionPage) Response() AssetCollection {
	return page.ac
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AssetCollectionPage) Values() []Asset {
	if page.ac.IsEmpty() {
		return nil
	}
	return *page.ac.Value
}

// Creates a new instance of the AssetCollectionPage type.
func NewAssetCollectionPage(getNextPage func(context.Context, AssetCollection) (AssetCollection, error)) AssetCollectionPage {
	return AssetCollectionPage{fn: getNextPage}
}

// AssetContainerSas the Asset Storage container SAS URLs.
type AssetContainerSas struct {
	autorest.Response `json:"-"`
	// AssetContainerSasUrls - The list of Asset container SAS URLs.
	AssetContainerSasUrls *[]string `json:"assetContainerSasUrls,omitempty"`
}

// AssetFileEncryptionMetadata the Asset File Storage encryption metadata.
type AssetFileEncryptionMetadata struct {
	// InitializationVector - The Asset File initialization vector.
	InitializationVector *string `json:"initializationVector,omitempty"`
	// AssetFileName - The Asset File name.
	AssetFileName *string `json:"assetFileName,omitempty"`
	// AssetFileID - The Asset File Id.
	AssetFileID *uuid.UUID `json:"assetFileId,omitempty"`
}

// AssetFilter an Asset Filter.
type AssetFilter struct {
	autorest.Response `json:"-"`
	*FilterProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AssetFilter.
func (af AssetFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if af.FilterProperties != nil {
		objectMap["properties"] = af.FilterProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AssetFilter struct.
func (af *AssetFilter) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var filterProperties FilterProperties
				err = json.Unmarshal(*v, &filterProperties)
				if err != nil {
					return err
				}
				af.FilterProperties = &filterProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				af.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				af.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				af.Type = &typeVar
			}
		}
	}

	return nil
}

// AssetFilterCollection a collection of AssetFilter items.
type AssetFilterCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of AssetFilter items.
	Value *[]AssetFilter `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// AssetFilterCollectionIterator provides access to a complete listing of AssetFilter values.
type AssetFilterCollectionIterator struct {
	i    int
	page AssetFilterCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AssetFilterCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AssetFilterCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AssetFilterCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AssetFilterCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AssetFilterCollectionIterator) Response() AssetFilterCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AssetFilterCollectionIterator) Value() AssetFilter {
	if !iter.page.NotDone() {
		return AssetFilter{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AssetFilterCollectionIterator type.
func NewAssetFilterCollectionIterator(page AssetFilterCollectionPage) AssetFilterCollectionIterator {
	return AssetFilterCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (afc AssetFilterCollection) IsEmpty() bool {
	return afc.Value == nil || len(*afc.Value) == 0
}

// assetFilterCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (afc AssetFilterCollection) assetFilterCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if afc.OdataNextLink == nil || len(to.String(afc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(afc.OdataNextLink)))
}

// AssetFilterCollectionPage contains a page of AssetFilter values.
type AssetFilterCollectionPage struct {
	fn  func(context.Context, AssetFilterCollection) (AssetFilterCollection, error)
	afc AssetFilterCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AssetFilterCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AssetFilterCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.afc)
	if err != nil {
		return err
	}
	page.afc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AssetFilterCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AssetFilterCollectionPage) NotDone() bool {
	return !page.afc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AssetFilterCollectionPage) Response() AssetFilterCollection {
	return page.afc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AssetFilterCollectionPage) Values() []AssetFilter {
	if page.afc.IsEmpty() {
		return nil
	}
	return *page.afc.Value
}

// Creates a new instance of the AssetFilterCollectionPage type.
func NewAssetFilterCollectionPage(getNextPage func(context.Context, AssetFilterCollection) (AssetFilterCollection, error)) AssetFilterCollectionPage {
	return AssetFilterCollectionPage{fn: getNextPage}
}

// AssetProperties the Asset properties.
type AssetProperties struct {
	// AssetID - READ-ONLY; The Asset ID.
	AssetID *uuid.UUID `json:"assetId,omitempty"`
	// Created - READ-ONLY; The creation date of the Asset.
	Created *date.Time `json:"created,omitempty"`
	// LastModified - READ-ONLY; The last modified date of the Asset.
	LastModified *date.Time `json:"lastModified,omitempty"`
	// AlternateID - The alternate ID of the Asset.
	AlternateID *string `json:"alternateId,omitempty"`
	// Description - The Asset description.
	Description *string `json:"description,omitempty"`
	// Container - The name of the asset blob container.
	Container *string `json:"container,omitempty"`
	// StorageAccountName - The name of the storage account.
	StorageAccountName *string `json:"storageAccountName,omitempty"`
	// StorageEncryptionFormat - READ-ONLY; The Asset encryption format. One of None or MediaStorageEncryption. Possible values include: 'None', 'MediaStorageClientEncryption'
	StorageEncryptionFormat AssetStorageEncryptionFormat `json:"storageEncryptionFormat,omitempty"`
}

// AssetStreamingLocator properties of the Streaming Locator.
type AssetStreamingLocator struct {
	// Name - READ-ONLY; Streaming Locator name.
	Name *string `json:"name,omitempty"`
	// AssetName - READ-ONLY; Asset Name.
	AssetName *string `json:"assetName,omitempty"`
	// Created - READ-ONLY; The creation time of the Streaming Locator.
	Created *date.Time `json:"created,omitempty"`
	// StartTime - READ-ONLY; The start time of the Streaming Locator.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; The end time of the Streaming Locator.
	EndTime *date.Time `json:"endTime,omitempty"`
	// StreamingLocatorID - READ-ONLY; StreamingLocatorId of the Streaming Locator.
	StreamingLocatorID *uuid.UUID `json:"streamingLocatorId,omitempty"`
	// StreamingPolicyName - READ-ONLY; Name of the Streaming Policy used by this Streaming Locator.
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty"`
	// DefaultContentKeyPolicyName - READ-ONLY; Name of the default ContentKeyPolicy used by this Streaming Locator.
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty"`
}

// BasicAudio defines the common properties for all audio codecs.
type BasicAudio interface {
	AsAacAudio() (*AacAudio, bool)
	AsAudio() (*Audio, bool)
}

// Audio defines the common properties for all audio codecs.
type Audio struct {
	// Channels - The number of channels in the audio.
	Channels *int32 `json:"channels,omitempty"`
	// SamplingRate - The sampling rate to use for encoding in hertz.
	SamplingRate *int32 `json:"samplingRate,omitempty"`
	// Bitrate - The bitrate, in bits per second, of the output encoded audio.
	Bitrate *int32 `json:"bitrate,omitempty"`
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

func unmarshalBasicAudio(body []byte) (BasicAudio, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaAacAudio):
		var aa AacAudio
		err := json.Unmarshal(body, &aa)
		return aa, err
	default:
		var a Audio
		err := json.Unmarshal(body, &a)
		return a, err
	}
}
func unmarshalBasicAudioArray(body []byte) ([]BasicAudio, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	aArray := make([]BasicAudio, len(rawMessages))

	for index, rawMessage := range rawMessages {
		a, err := unmarshalBasicAudio(*rawMessage)
		if err != nil {
			return nil, err
		}
		aArray[index] = a
	}
	return aArray, nil
}

// MarshalJSON is the custom marshaler for Audio.
func (a Audio) MarshalJSON() ([]byte, error) {
	a.OdataType = OdataTypeMicrosoftMediaAudio
	objectMap := make(map[string]interface{})
	if a.Channels != nil {
		objectMap["channels"] = a.Channels
	}
	if a.SamplingRate != nil {
		objectMap["samplingRate"] = a.SamplingRate
	}
	if a.Bitrate != nil {
		objectMap["bitrate"] = a.Bitrate
	}
	if a.Label != nil {
		objectMap["label"] = a.Label
	}
	if a.OdataType != "" {
		objectMap["@odata.type"] = a.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for Audio.
func (a Audio) AsAudio() (*Audio, bool) {
	return &a, true
}

// AsBasicAudio is the BasicCodec implementation for Audio.
func (a Audio) AsBasicAudio() (BasicAudio, bool) {
	return &a, true
}

// AsAacAudio is the BasicCodec implementation for Audio.
func (a Audio) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for Audio.
func (a Audio) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for Audio.
func (a Audio) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for Audio.
func (a Audio) AsBasicVideo() (BasicVideo, bool) {
	return nil, false
}

// AsImage is the BasicCodec implementation for Audio.
func (a Audio) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for Audio.
func (a Audio) AsBasicImage() (BasicImage, bool) {
	return nil, false
}

// AsCopyAudio is the BasicCodec implementation for Audio.
func (a Audio) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for Audio.
func (a Audio) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for Audio.
func (a Audio) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for Audio.
func (a Audio) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for Audio.
func (a Audio) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for Audio.
func (a Audio) AsBasicCodec() (BasicCodec, bool) {
	return &a, true
}

// BasicAudioAnalyzerPreset the Audio Analyzer preset applies a pre-defined set of AI-based analysis operations,
// including speech transcription. Currently, the preset supports processing of content with a single audio track.
type BasicAudioAnalyzerPreset interface {
	AsVideoAnalyzerPreset() (*VideoAnalyzerPreset, bool)
	AsAudioAnalyzerPreset() (*AudioAnalyzerPreset, bool)
}

// AudioAnalyzerPreset the Audio Analyzer preset applies a pre-defined set of AI-based analysis operations,
// including speech transcription. Currently, the preset supports processing of content with a single audio
// track.
type AudioAnalyzerPreset struct {
	// AudioLanguage - The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `json:"audioLanguage,omitempty"`
	// ExperimentalOptions - Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]*string `json:"experimentalOptions"`
	// OdataType - Possible values include: 'OdataTypePreset', 'OdataTypeMicrosoftMediaFaceDetectorPreset', 'OdataTypeMicrosoftMediaAudioAnalyzerPreset', 'OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset', 'OdataTypeMicrosoftMediaStandardEncoderPreset', 'OdataTypeMicrosoftMediaVideoAnalyzerPreset'
	OdataType OdataTypeBasicPreset `json:"@odata.type,omitempty"`
}

func unmarshalBasicAudioAnalyzerPreset(body []byte) (BasicAudioAnalyzerPreset, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaVideoAnalyzerPreset):
		var vap VideoAnalyzerPreset
		err := json.Unmarshal(body, &vap)
		return vap, err
	default:
		var aap AudioAnalyzerPreset
		err := json.Unmarshal(body, &aap)
		return aap, err
	}
}
func unmarshalBasicAudioAnalyzerPresetArray(body []byte) ([]BasicAudioAnalyzerPreset, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	aapArray := make([]BasicAudioAnalyzerPreset, len(rawMessages))

	for index, rawMessage := range rawMessages {
		aap, err := unmarshalBasicAudioAnalyzerPreset(*rawMessage)
		if err != nil {
			return nil, err
		}
		aapArray[index] = aap
	}
	return aapArray, nil
}

// MarshalJSON is the custom marshaler for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) MarshalJSON() ([]byte, error) {
	aap.OdataType = OdataTypeMicrosoftMediaAudioAnalyzerPreset
	objectMap := make(map[string]interface{})
	if aap.AudioLanguage != nil {
		objectMap["audioLanguage"] = aap.AudioLanguage
	}
	if aap.ExperimentalOptions != nil {
		objectMap["experimentalOptions"] = aap.ExperimentalOptions
	}
	if aap.OdataType != "" {
		objectMap["@odata.type"] = aap.OdataType
	}
	return json.Marshal(objectMap)
}

// AsFaceDetectorPreset is the BasicPreset implementation for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) AsFaceDetectorPreset() (*FaceDetectorPreset, bool) {
	return nil, false
}

// AsAudioAnalyzerPreset is the BasicPreset implementation for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) AsAudioAnalyzerPreset() (*AudioAnalyzerPreset, bool) {
	return &aap, true
}

// AsBasicAudioAnalyzerPreset is the BasicPreset implementation for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) AsBasicAudioAnalyzerPreset() (BasicAudioAnalyzerPreset, bool) {
	return &aap, true
}

// AsBuiltInStandardEncoderPreset is the BasicPreset implementation for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) AsBuiltInStandardEncoderPreset() (*BuiltInStandardEncoderPreset, bool) {
	return nil, false
}

// AsStandardEncoderPreset is the BasicPreset implementation for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) AsStandardEncoderPreset() (*StandardEncoderPreset, bool) {
	return nil, false
}

// AsVideoAnalyzerPreset is the BasicPreset implementation for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) AsVideoAnalyzerPreset() (*VideoAnalyzerPreset, bool) {
	return nil, false
}

// AsPreset is the BasicPreset implementation for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) AsPreset() (*Preset, bool) {
	return nil, false
}

// AsBasicPreset is the BasicPreset implementation for AudioAnalyzerPreset.
func (aap AudioAnalyzerPreset) AsBasicPreset() (BasicPreset, bool) {
	return &aap, true
}

// AudioOverlay describes the properties of an audio overlay.
type AudioOverlay struct {
	// InputLabel - The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG or PNG formats, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel *string `json:"inputLabel,omitempty"`
	// Start - The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds in to the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `json:"start,omitempty"`
	// End - The position in the input video at which the overlay ends. The value should be in ISO 8601 duration format. For example, PT30S to end the overlay at 30 seconds in to the input video. If not specified the overlay will be applied until the end of the input video if inputLoop is true. Else, if inputLoop is false, then overlay will last as long as the duration of the overlay media.
	End *string `json:"end,omitempty"`
	// FadeInDuration - The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `json:"fadeInDuration,omitempty"`
	// FadeOutDuration - The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `json:"fadeOutDuration,omitempty"`
	// AudioGainLevel - The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `json:"audioGainLevel,omitempty"`
	// OdataType - Possible values include: 'OdataTypeOverlay', 'OdataTypeMicrosoftMediaAudioOverlay', 'OdataTypeMicrosoftMediaVideoOverlay'
	OdataType OdataTypeBasicOverlay `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for AudioOverlay.
func (ao AudioOverlay) MarshalJSON() ([]byte, error) {
	ao.OdataType = OdataTypeMicrosoftMediaAudioOverlay
	objectMap := make(map[string]interface{})
	if ao.InputLabel != nil {
		objectMap["inputLabel"] = ao.InputLabel
	}
	if ao.Start != nil {
		objectMap["start"] = ao.Start
	}
	if ao.End != nil {
		objectMap["end"] = ao.End
	}
	if ao.FadeInDuration != nil {
		objectMap["fadeInDuration"] = ao.FadeInDuration
	}
	if ao.FadeOutDuration != nil {
		objectMap["fadeOutDuration"] = ao.FadeOutDuration
	}
	if ao.AudioGainLevel != nil {
		objectMap["audioGainLevel"] = ao.AudioGainLevel
	}
	if ao.OdataType != "" {
		objectMap["@odata.type"] = ao.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudioOverlay is the BasicOverlay implementation for AudioOverlay.
func (ao AudioOverlay) AsAudioOverlay() (*AudioOverlay, bool) {
	return &ao, true
}

// AsVideoOverlay is the BasicOverlay implementation for AudioOverlay.
func (ao AudioOverlay) AsVideoOverlay() (*VideoOverlay, bool) {
	return nil, false
}

// AsOverlay is the BasicOverlay implementation for AudioOverlay.
func (ao AudioOverlay) AsOverlay() (*Overlay, bool) {
	return nil, false
}

// AsBasicOverlay is the BasicOverlay implementation for AudioOverlay.
func (ao AudioOverlay) AsBasicOverlay() (BasicOverlay, bool) {
	return &ao, true
}

// BuiltInStandardEncoderPreset describes a built-in preset for encoding the input video with the Standard
// Encoder.
type BuiltInStandardEncoderPreset struct {
	// PresetName - The built-in preset to be used for encoding videos. Possible values include: 'H264SingleBitrateSD', 'H264SingleBitrate720p', 'H264SingleBitrate1080p', 'AdaptiveStreaming', 'AACGoodQualityAudio', 'ContentAwareEncodingExperimental', 'ContentAwareEncoding', 'H264MultipleBitrate1080p', 'H264MultipleBitrate720p', 'H264MultipleBitrateSD'
	PresetName EncoderNamedPreset `json:"presetName,omitempty"`
	// OdataType - Possible values include: 'OdataTypePreset', 'OdataTypeMicrosoftMediaFaceDetectorPreset', 'OdataTypeMicrosoftMediaAudioAnalyzerPreset', 'OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset', 'OdataTypeMicrosoftMediaStandardEncoderPreset', 'OdataTypeMicrosoftMediaVideoAnalyzerPreset'
	OdataType OdataTypeBasicPreset `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) MarshalJSON() ([]byte, error) {
	bisep.OdataType = OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset
	objectMap := make(map[string]interface{})
	if bisep.PresetName != "" {
		objectMap["presetName"] = bisep.PresetName
	}
	if bisep.OdataType != "" {
		objectMap["@odata.type"] = bisep.OdataType
	}
	return json.Marshal(objectMap)
}

// AsFaceDetectorPreset is the BasicPreset implementation for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) AsFaceDetectorPreset() (*FaceDetectorPreset, bool) {
	return nil, false
}

// AsAudioAnalyzerPreset is the BasicPreset implementation for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) AsAudioAnalyzerPreset() (*AudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBasicAudioAnalyzerPreset is the BasicPreset implementation for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) AsBasicAudioAnalyzerPreset() (BasicAudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBuiltInStandardEncoderPreset is the BasicPreset implementation for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) AsBuiltInStandardEncoderPreset() (*BuiltInStandardEncoderPreset, bool) {
	return &bisep, true
}

// AsStandardEncoderPreset is the BasicPreset implementation for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) AsStandardEncoderPreset() (*StandardEncoderPreset, bool) {
	return nil, false
}

// AsVideoAnalyzerPreset is the BasicPreset implementation for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) AsVideoAnalyzerPreset() (*VideoAnalyzerPreset, bool) {
	return nil, false
}

// AsPreset is the BasicPreset implementation for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) AsPreset() (*Preset, bool) {
	return nil, false
}

// AsBasicPreset is the BasicPreset implementation for BuiltInStandardEncoderPreset.
func (bisep BuiltInStandardEncoderPreset) AsBasicPreset() (BasicPreset, bool) {
	return &bisep, true
}

// CbcsDrmConfiguration class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming
// Policy
type CbcsDrmConfiguration struct {
	// FairPlay - FairPlay configurations
	FairPlay *StreamingPolicyFairPlayConfiguration `json:"fairPlay,omitempty"`
	// PlayReady - PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `json:"playReady,omitempty"`
	// Widevine - Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `json:"widevine,omitempty"`
}

// CencDrmConfiguration class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming
// Policy
type CencDrmConfiguration struct {
	// PlayReady - PlayReady configurations
	PlayReady *StreamingPolicyPlayReadyConfiguration `json:"playReady,omitempty"`
	// Widevine - Widevine configurations
	Widevine *StreamingPolicyWidevineConfiguration `json:"widevine,omitempty"`
}

// CheckNameAvailabilityInput the input to the check name availability request.
type CheckNameAvailabilityInput struct {
	// Name - The account name.
	Name *string `json:"name,omitempty"`
	// Type - The account type. For a Media Services account, this should be 'MediaServices'.
	Type *string `json:"type,omitempty"`
}

// BasicClipTime base class for specifying a clip time. Use sub classes of this class to specify the time position in
// the media.
type BasicClipTime interface {
	AsAbsoluteClipTime() (*AbsoluteClipTime, bool)
	AsClipTime() (*ClipTime, bool)
}

// ClipTime base class for specifying a clip time. Use sub classes of this class to specify the time position
// in the media.
type ClipTime struct {
	// OdataType - Possible values include: 'OdataTypeClipTime', 'OdataTypeMicrosoftMediaAbsoluteClipTime'
	OdataType OdataTypeBasicClipTime `json:"@odata.type,omitempty"`
}

func unmarshalBasicClipTime(body []byte) (BasicClipTime, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaAbsoluteClipTime):
		var act AbsoluteClipTime
		err := json.Unmarshal(body, &act)
		return act, err
	default:
		var ct ClipTime
		err := json.Unmarshal(body, &ct)
		return ct, err
	}
}
func unmarshalBasicClipTimeArray(body []byte) ([]BasicClipTime, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ctArray := make([]BasicClipTime, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ct, err := unmarshalBasicClipTime(*rawMessage)
		if err != nil {
			return nil, err
		}
		ctArray[index] = ct
	}
	return ctArray, nil
}

// MarshalJSON is the custom marshaler for ClipTime.
func (ct ClipTime) MarshalJSON() ([]byte, error) {
	ct.OdataType = OdataTypeClipTime
	objectMap := make(map[string]interface{})
	if ct.OdataType != "" {
		objectMap["@odata.type"] = ct.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAbsoluteClipTime is the BasicClipTime implementation for ClipTime.
func (ct ClipTime) AsAbsoluteClipTime() (*AbsoluteClipTime, bool) {
	return nil, false
}

// AsClipTime is the BasicClipTime implementation for ClipTime.
func (ct ClipTime) AsClipTime() (*ClipTime, bool) {
	return &ct, true
}

// AsBasicClipTime is the BasicClipTime implementation for ClipTime.
func (ct ClipTime) AsBasicClipTime() (BasicClipTime, bool) {
	return &ct, true
}

// BasicCodec describes the basic properties of all codecs.
type BasicCodec interface {
	AsAudio() (*Audio, bool)
	AsBasicAudio() (BasicAudio, bool)
	AsAacAudio() (*AacAudio, bool)
	AsCopyVideo() (*CopyVideo, bool)
	AsVideo() (*Video, bool)
	AsBasicVideo() (BasicVideo, bool)
	AsImage() (*Image, bool)
	AsBasicImage() (BasicImage, bool)
	AsCopyAudio() (*CopyAudio, bool)
	AsH264Video() (*H264Video, bool)
	AsJpgImage() (*JpgImage, bool)
	AsPngImage() (*PngImage, bool)
	AsCodec() (*Codec, bool)
}

// Codec describes the basic properties of all codecs.
type Codec struct {
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

func unmarshalBasicCodec(body []byte) (BasicCodec, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaAudio):
		var a Audio
		err := json.Unmarshal(body, &a)
		return a, err
	case string(OdataTypeMicrosoftMediaAacAudio):
		var aa AacAudio
		err := json.Unmarshal(body, &aa)
		return aa, err
	case string(OdataTypeMicrosoftMediaCopyVideo):
		var cv CopyVideo
		err := json.Unmarshal(body, &cv)
		return cv, err
	case string(OdataTypeMicrosoftMediaVideo):
		var vVar Video
		err := json.Unmarshal(body, &vVar)
		return vVar, err
	case string(OdataTypeMicrosoftMediaImage):
		var i Image
		err := json.Unmarshal(body, &i)
		return i, err
	case string(OdataTypeMicrosoftMediaCopyAudio):
		var ca CopyAudio
		err := json.Unmarshal(body, &ca)
		return ca, err
	case string(OdataTypeMicrosoftMediaH264Video):
		var hv H264Video
		err := json.Unmarshal(body, &hv)
		return hv, err
	case string(OdataTypeMicrosoftMediaJpgImage):
		var ji JpgImage
		err := json.Unmarshal(body, &ji)
		return ji, err
	case string(OdataTypeMicrosoftMediaPngImage):
		var pi PngImage
		err := json.Unmarshal(body, &pi)
		return pi, err
	default:
		var c Codec
		err := json.Unmarshal(body, &c)
		return c, err
	}
}
func unmarshalBasicCodecArray(body []byte) ([]BasicCodec, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	cArray := make([]BasicCodec, len(rawMessages))

	for index, rawMessage := range rawMessages {
		c, err := unmarshalBasicCodec(*rawMessage)
		if err != nil {
			return nil, err
		}
		cArray[index] = c
	}
	return cArray, nil
}

// MarshalJSON is the custom marshaler for Codec.
func (c Codec) MarshalJSON() ([]byte, error) {
	c.OdataType = OdataTypeCodec
	objectMap := make(map[string]interface{})
	if c.Label != nil {
		objectMap["label"] = c.Label
	}
	if c.OdataType != "" {
		objectMap["@odata.type"] = c.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for Codec.
func (c Codec) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for Codec.
func (c Codec) AsBasicAudio() (BasicAudio, bool) {
	return nil, false
}

// AsAacAudio is the BasicCodec implementation for Codec.
func (c Codec) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for Codec.
func (c Codec) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for Codec.
func (c Codec) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for Codec.
func (c Codec) AsBasicVideo() (BasicVideo, bool) {
	return nil, false
}

// AsImage is the BasicCodec implementation for Codec.
func (c Codec) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for Codec.
func (c Codec) AsBasicImage() (BasicImage, bool) {
	return nil, false
}

// AsCopyAudio is the BasicCodec implementation for Codec.
func (c Codec) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for Codec.
func (c Codec) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for Codec.
func (c Codec) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for Codec.
func (c Codec) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for Codec.
func (c Codec) AsCodec() (*Codec, bool) {
	return &c, true
}

// AsBasicCodec is the BasicCodec implementation for Codec.
func (c Codec) AsBasicCodec() (BasicCodec, bool) {
	return &c, true
}

// CommonEncryptionCbcs class for CommonEncryptionCbcs encryption scheme
type CommonEncryptionCbcs struct {
	// EnabledProtocols - Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
	// ClearTracks - Representing which tracks should not be encrypted
	ClearTracks *[]TrackSelection `json:"clearTracks,omitempty"`
	// ContentKeys - Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`
	// Drm - Configuration of DRMs for current encryption scheme
	Drm *CbcsDrmConfiguration `json:"drm,omitempty"`
}

// CommonEncryptionCenc class for envelope encryption scheme
type CommonEncryptionCenc struct {
	// EnabledProtocols - Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
	// ClearTracks - Representing which tracks should not be encrypted
	ClearTracks *[]TrackSelection `json:"clearTracks,omitempty"`
	// ContentKeys - Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`
	// Drm - Configuration of DRMs for CommonEncryptionCenc encryption scheme
	Drm *CencDrmConfiguration `json:"drm,omitempty"`
}

// ContentKeyPolicy a Content Key Policy resource.
type ContentKeyPolicy struct {
	autorest.Response           `json:"-"`
	*ContentKeyPolicyProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicy.
func (ckp ContentKeyPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ckp.ContentKeyPolicyProperties != nil {
		objectMap["properties"] = ckp.ContentKeyPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ContentKeyPolicy struct.
func (ckp *ContentKeyPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var contentKeyPolicyProperties ContentKeyPolicyProperties
				err = json.Unmarshal(*v, &contentKeyPolicyProperties)
				if err != nil {
					return err
				}
				ckp.ContentKeyPolicyProperties = &contentKeyPolicyProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ckp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ckp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ckp.Type = &typeVar
			}
		}
	}

	return nil
}

// ContentKeyPolicyClearKeyConfiguration represents a configuration for non-DRM keys.
type ContentKeyPolicyClearKeyConfiguration struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration'
	OdataType OdataTypeBasicContentKeyPolicyConfiguration `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyClearKeyConfiguration.
func (ckpckc ContentKeyPolicyClearKeyConfiguration) MarshalJSON() ([]byte, error) {
	ckpckc.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration
	objectMap := make(map[string]interface{})
	if ckpckc.OdataType != "" {
		objectMap["@odata.type"] = ckpckc.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyClearKeyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyClearKeyConfiguration.
func (ckpckc ContentKeyPolicyClearKeyConfiguration) AsContentKeyPolicyClearKeyConfiguration() (*ContentKeyPolicyClearKeyConfiguration, bool) {
	return &ckpckc, true
}

// AsContentKeyPolicyUnknownConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyClearKeyConfiguration.
func (ckpckc ContentKeyPolicyClearKeyConfiguration) AsContentKeyPolicyUnknownConfiguration() (*ContentKeyPolicyUnknownConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyWidevineConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyClearKeyConfiguration.
func (ckpckc ContentKeyPolicyClearKeyConfiguration) AsContentKeyPolicyWidevineConfiguration() (*ContentKeyPolicyWidevineConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyClearKeyConfiguration.
func (ckpckc ContentKeyPolicyClearKeyConfiguration) AsContentKeyPolicyPlayReadyConfiguration() (*ContentKeyPolicyPlayReadyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyFairPlayConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyClearKeyConfiguration.
func (ckpckc ContentKeyPolicyClearKeyConfiguration) AsContentKeyPolicyFairPlayConfiguration() (*ContentKeyPolicyFairPlayConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyClearKeyConfiguration.
func (ckpckc ContentKeyPolicyClearKeyConfiguration) AsContentKeyPolicyConfiguration() (*ContentKeyPolicyConfiguration, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyClearKeyConfiguration.
func (ckpckc ContentKeyPolicyClearKeyConfiguration) AsBasicContentKeyPolicyConfiguration() (BasicContentKeyPolicyConfiguration, bool) {
	return &ckpckc, true
}

// ContentKeyPolicyCollection a collection of ContentKeyPolicy items.
type ContentKeyPolicyCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of ContentKeyPolicy items.
	Value *[]ContentKeyPolicy `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// ContentKeyPolicyCollectionIterator provides access to a complete listing of ContentKeyPolicy values.
type ContentKeyPolicyCollectionIterator struct {
	i    int
	page ContentKeyPolicyCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ContentKeyPolicyCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ContentKeyPolicyCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ContentKeyPolicyCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ContentKeyPolicyCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ContentKeyPolicyCollectionIterator) Response() ContentKeyPolicyCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ContentKeyPolicyCollectionIterator) Value() ContentKeyPolicy {
	if !iter.page.NotDone() {
		return ContentKeyPolicy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ContentKeyPolicyCollectionIterator type.
func NewContentKeyPolicyCollectionIterator(page ContentKeyPolicyCollectionPage) ContentKeyPolicyCollectionIterator {
	return ContentKeyPolicyCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ckpc ContentKeyPolicyCollection) IsEmpty() bool {
	return ckpc.Value == nil || len(*ckpc.Value) == 0
}

// contentKeyPolicyCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ckpc ContentKeyPolicyCollection) contentKeyPolicyCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if ckpc.OdataNextLink == nil || len(to.String(ckpc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ckpc.OdataNextLink)))
}

// ContentKeyPolicyCollectionPage contains a page of ContentKeyPolicy values.
type ContentKeyPolicyCollectionPage struct {
	fn   func(context.Context, ContentKeyPolicyCollection) (ContentKeyPolicyCollection, error)
	ckpc ContentKeyPolicyCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ContentKeyPolicyCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ContentKeyPolicyCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.ckpc)
	if err != nil {
		return err
	}
	page.ckpc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ContentKeyPolicyCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ContentKeyPolicyCollectionPage) NotDone() bool {
	return !page.ckpc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ContentKeyPolicyCollectionPage) Response() ContentKeyPolicyCollection {
	return page.ckpc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ContentKeyPolicyCollectionPage) Values() []ContentKeyPolicy {
	if page.ckpc.IsEmpty() {
		return nil
	}
	return *page.ckpc.Value
}

// Creates a new instance of the ContentKeyPolicyCollectionPage type.
func NewContentKeyPolicyCollectionPage(getNextPage func(context.Context, ContentKeyPolicyCollection) (ContentKeyPolicyCollection, error)) ContentKeyPolicyCollectionPage {
	return ContentKeyPolicyCollectionPage{fn: getNextPage}
}

// BasicContentKeyPolicyConfiguration base class for Content Key Policy configuration. A derived class must be used to
// create a configuration.
type BasicContentKeyPolicyConfiguration interface {
	AsContentKeyPolicyClearKeyConfiguration() (*ContentKeyPolicyClearKeyConfiguration, bool)
	AsContentKeyPolicyUnknownConfiguration() (*ContentKeyPolicyUnknownConfiguration, bool)
	AsContentKeyPolicyWidevineConfiguration() (*ContentKeyPolicyWidevineConfiguration, bool)
	AsContentKeyPolicyPlayReadyConfiguration() (*ContentKeyPolicyPlayReadyConfiguration, bool)
	AsContentKeyPolicyFairPlayConfiguration() (*ContentKeyPolicyFairPlayConfiguration, bool)
	AsContentKeyPolicyConfiguration() (*ContentKeyPolicyConfiguration, bool)
}

// ContentKeyPolicyConfiguration base class for Content Key Policy configuration. A derived class must be used
// to create a configuration.
type ContentKeyPolicyConfiguration struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration'
	OdataType OdataTypeBasicContentKeyPolicyConfiguration `json:"@odata.type,omitempty"`
}

func unmarshalBasicContentKeyPolicyConfiguration(body []byte) (BasicContentKeyPolicyConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration):
		var ckpckc ContentKeyPolicyClearKeyConfiguration
		err := json.Unmarshal(body, &ckpckc)
		return ckpckc, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration):
		var ckpuc ContentKeyPolicyUnknownConfiguration
		err := json.Unmarshal(body, &ckpuc)
		return ckpuc, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration):
		var ckpwc ContentKeyPolicyWidevineConfiguration
		err := json.Unmarshal(body, &ckpwc)
		return ckpwc, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration):
		var ckpprc ContentKeyPolicyPlayReadyConfiguration
		err := json.Unmarshal(body, &ckpprc)
		return ckpprc, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration):
		var ckpfpc ContentKeyPolicyFairPlayConfiguration
		err := json.Unmarshal(body, &ckpfpc)
		return ckpfpc, err
	default:
		var ckpc ContentKeyPolicyConfiguration
		err := json.Unmarshal(body, &ckpc)
		return ckpc, err
	}
}
func unmarshalBasicContentKeyPolicyConfigurationArray(body []byte) ([]BasicContentKeyPolicyConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ckpcArray := make([]BasicContentKeyPolicyConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ckpc, err := unmarshalBasicContentKeyPolicyConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		ckpcArray[index] = ckpc
	}
	return ckpcArray, nil
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyConfiguration.
func (ckpc ContentKeyPolicyConfiguration) MarshalJSON() ([]byte, error) {
	ckpc.OdataType = OdataTypeContentKeyPolicyConfiguration
	objectMap := make(map[string]interface{})
	if ckpc.OdataType != "" {
		objectMap["@odata.type"] = ckpc.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyClearKeyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyConfiguration.
func (ckpc ContentKeyPolicyConfiguration) AsContentKeyPolicyClearKeyConfiguration() (*ContentKeyPolicyClearKeyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyUnknownConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyConfiguration.
func (ckpc ContentKeyPolicyConfiguration) AsContentKeyPolicyUnknownConfiguration() (*ContentKeyPolicyUnknownConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyWidevineConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyConfiguration.
func (ckpc ContentKeyPolicyConfiguration) AsContentKeyPolicyWidevineConfiguration() (*ContentKeyPolicyWidevineConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyConfiguration.
func (ckpc ContentKeyPolicyConfiguration) AsContentKeyPolicyPlayReadyConfiguration() (*ContentKeyPolicyPlayReadyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyFairPlayConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyConfiguration.
func (ckpc ContentKeyPolicyConfiguration) AsContentKeyPolicyFairPlayConfiguration() (*ContentKeyPolicyFairPlayConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyConfiguration.
func (ckpc ContentKeyPolicyConfiguration) AsContentKeyPolicyConfiguration() (*ContentKeyPolicyConfiguration, bool) {
	return &ckpc, true
}

// AsBasicContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyConfiguration.
func (ckpc ContentKeyPolicyConfiguration) AsBasicContentKeyPolicyConfiguration() (BasicContentKeyPolicyConfiguration, bool) {
	return &ckpc, true
}

// ContentKeyPolicyFairPlayConfiguration specifies a configuration for FairPlay licenses.
type ContentKeyPolicyFairPlayConfiguration struct {
	// Ask - The key that must be used as FairPlay Application Secret key.
	Ask *[]byte `json:"ask,omitempty"`
	// FairPlayPfxPassword - The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
	FairPlayPfxPassword *string `json:"fairPlayPfxPassword,omitempty"`
	// FairPlayPfx - The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
	FairPlayPfx *string `json:"fairPlayPfx,omitempty"`
	// RentalAndLeaseKeyType - The rental and lease key type. Possible values include: 'Unknown', 'Undefined', 'DualExpiry', 'PersistentUnlimited', 'PersistentLimited'
	RentalAndLeaseKeyType ContentKeyPolicyFairPlayRentalAndLeaseKeyType `json:"rentalAndLeaseKeyType,omitempty"`
	// RentalDuration - The rental duration. Must be greater than or equal to 0.
	RentalDuration *int64 `json:"rentalDuration,omitempty"`
	// OfflineRentalConfiguration - Offline rental policy
	OfflineRentalConfiguration *ContentKeyPolicyFairPlayOfflineRentalConfiguration `json:"offlineRentalConfiguration,omitempty"`
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration'
	OdataType OdataTypeBasicContentKeyPolicyConfiguration `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyFairPlayConfiguration.
func (ckpfpc ContentKeyPolicyFairPlayConfiguration) MarshalJSON() ([]byte, error) {
	ckpfpc.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration
	objectMap := make(map[string]interface{})
	if ckpfpc.Ask != nil {
		objectMap["ask"] = ckpfpc.Ask
	}
	if ckpfpc.FairPlayPfxPassword != nil {
		objectMap["fairPlayPfxPassword"] = ckpfpc.FairPlayPfxPassword
	}
	if ckpfpc.FairPlayPfx != nil {
		objectMap["fairPlayPfx"] = ckpfpc.FairPlayPfx
	}
	if ckpfpc.RentalAndLeaseKeyType != "" {
		objectMap["rentalAndLeaseKeyType"] = ckpfpc.RentalAndLeaseKeyType
	}
	if ckpfpc.RentalDuration != nil {
		objectMap["rentalDuration"] = ckpfpc.RentalDuration
	}
	if ckpfpc.OfflineRentalConfiguration != nil {
		objectMap["offlineRentalConfiguration"] = ckpfpc.OfflineRentalConfiguration
	}
	if ckpfpc.OdataType != "" {
		objectMap["@odata.type"] = ckpfpc.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyClearKeyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyFairPlayConfiguration.
func (ckpfpc ContentKeyPolicyFairPlayConfiguration) AsContentKeyPolicyClearKeyConfiguration() (*ContentKeyPolicyClearKeyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyUnknownConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyFairPlayConfiguration.
func (ckpfpc ContentKeyPolicyFairPlayConfiguration) AsContentKeyPolicyUnknownConfiguration() (*ContentKeyPolicyUnknownConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyWidevineConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyFairPlayConfiguration.
func (ckpfpc ContentKeyPolicyFairPlayConfiguration) AsContentKeyPolicyWidevineConfiguration() (*ContentKeyPolicyWidevineConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyFairPlayConfiguration.
func (ckpfpc ContentKeyPolicyFairPlayConfiguration) AsContentKeyPolicyPlayReadyConfiguration() (*ContentKeyPolicyPlayReadyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyFairPlayConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyFairPlayConfiguration.
func (ckpfpc ContentKeyPolicyFairPlayConfiguration) AsContentKeyPolicyFairPlayConfiguration() (*ContentKeyPolicyFairPlayConfiguration, bool) {
	return &ckpfpc, true
}

// AsContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyFairPlayConfiguration.
func (ckpfpc ContentKeyPolicyFairPlayConfiguration) AsContentKeyPolicyConfiguration() (*ContentKeyPolicyConfiguration, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyFairPlayConfiguration.
func (ckpfpc ContentKeyPolicyFairPlayConfiguration) AsBasicContentKeyPolicyConfiguration() (BasicContentKeyPolicyConfiguration, bool) {
	return &ckpfpc, true
}

// ContentKeyPolicyFairPlayOfflineRentalConfiguration ...
type ContentKeyPolicyFairPlayOfflineRentalConfiguration struct {
	// PlaybackDurationSeconds - Playback duration
	PlaybackDurationSeconds *int64 `json:"playbackDurationSeconds,omitempty"`
	// StorageDurationSeconds - Storage duration
	StorageDurationSeconds *int64 `json:"storageDurationSeconds,omitempty"`
}

// ContentKeyPolicyOpenRestriction represents an open restriction. License or key will be delivered on
// every request.
type ContentKeyPolicyOpenRestriction struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction'
	OdataType OdataTypeBasicContentKeyPolicyRestriction `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyOpenRestriction.
func (ckpor ContentKeyPolicyOpenRestriction) MarshalJSON() ([]byte, error) {
	ckpor.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction
	objectMap := make(map[string]interface{})
	if ckpor.OdataType != "" {
		objectMap["@odata.type"] = ckpor.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyOpenRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyOpenRestriction.
func (ckpor ContentKeyPolicyOpenRestriction) AsContentKeyPolicyOpenRestriction() (*ContentKeyPolicyOpenRestriction, bool) {
	return &ckpor, true
}

// AsContentKeyPolicyUnknownRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyOpenRestriction.
func (ckpor ContentKeyPolicyOpenRestriction) AsContentKeyPolicyUnknownRestriction() (*ContentKeyPolicyUnknownRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyTokenRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyOpenRestriction.
func (ckpor ContentKeyPolicyOpenRestriction) AsContentKeyPolicyTokenRestriction() (*ContentKeyPolicyTokenRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyOpenRestriction.
func (ckpor ContentKeyPolicyOpenRestriction) AsContentKeyPolicyRestriction() (*ContentKeyPolicyRestriction, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyOpenRestriction.
func (ckpor ContentKeyPolicyOpenRestriction) AsBasicContentKeyPolicyRestriction() (BasicContentKeyPolicyRestriction, bool) {
	return &ckpor, true
}

// ContentKeyPolicyOption represents a policy option.
type ContentKeyPolicyOption struct {
	// PolicyOptionID - READ-ONLY; The legacy Policy Option ID.
	PolicyOptionID *uuid.UUID `json:"policyOptionId,omitempty"`
	// Name - The Policy Option description.
	Name *string `json:"name,omitempty"`
	// Configuration - The key delivery configuration.
	Configuration BasicContentKeyPolicyConfiguration `json:"configuration,omitempty"`
	// Restriction - The requirements that must be met to deliver keys with this configuration
	Restriction BasicContentKeyPolicyRestriction `json:"restriction,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ContentKeyPolicyOption struct.
func (ckpo *ContentKeyPolicyOption) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "policyOptionId":
			if v != nil {
				var policyOptionID uuid.UUID
				err = json.Unmarshal(*v, &policyOptionID)
				if err != nil {
					return err
				}
				ckpo.PolicyOptionID = &policyOptionID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ckpo.Name = &name
			}
		case "configuration":
			if v != nil {
				configuration, err := unmarshalBasicContentKeyPolicyConfiguration(*v)
				if err != nil {
					return err
				}
				ckpo.Configuration = configuration
			}
		case "restriction":
			if v != nil {
				restriction, err := unmarshalBasicContentKeyPolicyRestriction(*v)
				if err != nil {
					return err
				}
				ckpo.Restriction = restriction
			}
		}
	}

	return nil
}

// ContentKeyPolicyPlayReadyConfiguration specifies a configuration for PlayReady licenses.
type ContentKeyPolicyPlayReadyConfiguration struct {
	// Licenses - The PlayReady licenses.
	Licenses *[]ContentKeyPolicyPlayReadyLicense `json:"licenses,omitempty"`
	// ResponseCustomData - The custom response data.
	ResponseCustomData *string `json:"responseCustomData,omitempty"`
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration'
	OdataType OdataTypeBasicContentKeyPolicyConfiguration `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyPlayReadyConfiguration.
func (ckpprc ContentKeyPolicyPlayReadyConfiguration) MarshalJSON() ([]byte, error) {
	ckpprc.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration
	objectMap := make(map[string]interface{})
	if ckpprc.Licenses != nil {
		objectMap["licenses"] = ckpprc.Licenses
	}
	if ckpprc.ResponseCustomData != nil {
		objectMap["responseCustomData"] = ckpprc.ResponseCustomData
	}
	if ckpprc.OdataType != "" {
		objectMap["@odata.type"] = ckpprc.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyClearKeyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyPlayReadyConfiguration.
func (ckpprc ContentKeyPolicyPlayReadyConfiguration) AsContentKeyPolicyClearKeyConfiguration() (*ContentKeyPolicyClearKeyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyUnknownConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyPlayReadyConfiguration.
func (ckpprc ContentKeyPolicyPlayReadyConfiguration) AsContentKeyPolicyUnknownConfiguration() (*ContentKeyPolicyUnknownConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyWidevineConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyPlayReadyConfiguration.
func (ckpprc ContentKeyPolicyPlayReadyConfiguration) AsContentKeyPolicyWidevineConfiguration() (*ContentKeyPolicyWidevineConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyPlayReadyConfiguration.
func (ckpprc ContentKeyPolicyPlayReadyConfiguration) AsContentKeyPolicyPlayReadyConfiguration() (*ContentKeyPolicyPlayReadyConfiguration, bool) {
	return &ckpprc, true
}

// AsContentKeyPolicyFairPlayConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyPlayReadyConfiguration.
func (ckpprc ContentKeyPolicyPlayReadyConfiguration) AsContentKeyPolicyFairPlayConfiguration() (*ContentKeyPolicyFairPlayConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyPlayReadyConfiguration.
func (ckpprc ContentKeyPolicyPlayReadyConfiguration) AsContentKeyPolicyConfiguration() (*ContentKeyPolicyConfiguration, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyPlayReadyConfiguration.
func (ckpprc ContentKeyPolicyPlayReadyConfiguration) AsBasicContentKeyPolicyConfiguration() (BasicContentKeyPolicyConfiguration, bool) {
	return &ckpprc, true
}

// ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader specifies that the content key ID is in the
// PlayReady header.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyPlayReadyContentKeyLocation', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'
	OdataType OdataType `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (ckpprcekfh ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) MarshalJSON() ([]byte, error) {
	ckpprcekfh.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader
	objectMap := make(map[string]interface{})
	if ckpprcekfh.OdataType != "" {
		objectMap["@odata.type"] = ckpprcekfh.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (ckpprcekfh ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) AsContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader() (*ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, bool) {
	return &ckpprcekfh, true
}

// AsContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (ckpprcekfh ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) AsContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier() (*ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyContentKeyLocation is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (ckpprcekfh ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) AsContentKeyPolicyPlayReadyContentKeyLocation() (*ContentKeyPolicyPlayReadyContentKeyLocation, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyPlayReadyContentKeyLocation is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
func (ckpprcekfh ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader) AsBasicContentKeyPolicyPlayReadyContentKeyLocation() (BasicContentKeyPolicyPlayReadyContentKeyLocation, bool) {
	return &ckpprcekfh, true
}

// ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier specifies that the content key ID is
// specified in the PlayReady configuration.
type ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier struct {
	// KeyID - The content key ID.
	KeyID *uuid.UUID `json:"keyId,omitempty"`
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyPlayReadyContentKeyLocation', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'
	OdataType OdataType `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (ckpprcekfki ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) MarshalJSON() ([]byte, error) {
	ckpprcekfki.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier
	objectMap := make(map[string]interface{})
	if ckpprcekfki.KeyID != nil {
		objectMap["keyId"] = ckpprcekfki.KeyID
	}
	if ckpprcekfki.OdataType != "" {
		objectMap["@odata.type"] = ckpprcekfki.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (ckpprcekfki ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) AsContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader() (*ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (ckpprcekfki ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) AsContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier() (*ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier, bool) {
	return &ckpprcekfki, true
}

// AsContentKeyPolicyPlayReadyContentKeyLocation is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (ckpprcekfki ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) AsContentKeyPolicyPlayReadyContentKeyLocation() (*ContentKeyPolicyPlayReadyContentKeyLocation, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyPlayReadyContentKeyLocation is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
func (ckpprcekfki ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier) AsBasicContentKeyPolicyPlayReadyContentKeyLocation() (BasicContentKeyPolicyPlayReadyContentKeyLocation, bool) {
	return &ckpprcekfki, true
}

// BasicContentKeyPolicyPlayReadyContentKeyLocation base class for content key ID location. A derived class must be
// used to represent the location.
type BasicContentKeyPolicyPlayReadyContentKeyLocation interface {
	AsContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader() (*ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, bool)
	AsContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier() (*ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier, bool)
	AsContentKeyPolicyPlayReadyContentKeyLocation() (*ContentKeyPolicyPlayReadyContentKeyLocation, bool)
}

// ContentKeyPolicyPlayReadyContentKeyLocation base class for content key ID location. A derived class must be
// used to represent the location.
type ContentKeyPolicyPlayReadyContentKeyLocation struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyPlayReadyContentKeyLocation', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier'
	OdataType OdataType `json:"@odata.type,omitempty"`
}

func unmarshalBasicContentKeyPolicyPlayReadyContentKeyLocation(body []byte) (BasicContentKeyPolicyPlayReadyContentKeyLocation, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader):
		var ckpprcekfh ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader
		err := json.Unmarshal(body, &ckpprcekfh)
		return ckpprcekfh, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier):
		var ckpprcekfki ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier
		err := json.Unmarshal(body, &ckpprcekfki)
		return ckpprcekfki, err
	default:
		var ckpprckl ContentKeyPolicyPlayReadyContentKeyLocation
		err := json.Unmarshal(body, &ckpprckl)
		return ckpprckl, err
	}
}
func unmarshalBasicContentKeyPolicyPlayReadyContentKeyLocationArray(body []byte) ([]BasicContentKeyPolicyPlayReadyContentKeyLocation, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ckpprcklArray := make([]BasicContentKeyPolicyPlayReadyContentKeyLocation, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ckpprckl, err := unmarshalBasicContentKeyPolicyPlayReadyContentKeyLocation(*rawMessage)
		if err != nil {
			return nil, err
		}
		ckpprcklArray[index] = ckpprckl
	}
	return ckpprcklArray, nil
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyPlayReadyContentKeyLocation.
func (ckpprckl ContentKeyPolicyPlayReadyContentKeyLocation) MarshalJSON() ([]byte, error) {
	ckpprckl.OdataType = OdataTypeContentKeyPolicyPlayReadyContentKeyLocation
	objectMap := make(map[string]interface{})
	if ckpprckl.OdataType != "" {
		objectMap["@odata.type"] = ckpprckl.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentKeyLocation.
func (ckpprckl ContentKeyPolicyPlayReadyContentKeyLocation) AsContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader() (*ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentKeyLocation.
func (ckpprckl ContentKeyPolicyPlayReadyContentKeyLocation) AsContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier() (*ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyContentKeyLocation is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentKeyLocation.
func (ckpprckl ContentKeyPolicyPlayReadyContentKeyLocation) AsContentKeyPolicyPlayReadyContentKeyLocation() (*ContentKeyPolicyPlayReadyContentKeyLocation, bool) {
	return &ckpprckl, true
}

// AsBasicContentKeyPolicyPlayReadyContentKeyLocation is the BasicContentKeyPolicyPlayReadyContentKeyLocation implementation for ContentKeyPolicyPlayReadyContentKeyLocation.
func (ckpprckl ContentKeyPolicyPlayReadyContentKeyLocation) AsBasicContentKeyPolicyPlayReadyContentKeyLocation() (BasicContentKeyPolicyPlayReadyContentKeyLocation, bool) {
	return &ckpprckl, true
}

// ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction configures the Explicit Analog Television
// Output Restriction control bits. For further details see the PlayReady Compliance Rules.
type ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction struct {
	// BestEffort - Indicates whether this restriction is enforced on a Best Effort basis.
	BestEffort *bool `json:"bestEffort,omitempty"`
	// ConfigurationData - Configures the restriction control bits. Must be between 0 and 3 inclusive.
	ConfigurationData *int32 `json:"configurationData,omitempty"`
}

// ContentKeyPolicyPlayReadyLicense the PlayReady license
type ContentKeyPolicyPlayReadyLicense struct {
	// AllowTestDevices - A flag indicating whether test devices can use the license.
	AllowTestDevices *bool `json:"allowTestDevices,omitempty"`
	// BeginDate - The begin date of license
	BeginDate *date.Time `json:"beginDate,omitempty"`
	// ExpirationDate - The expiration date of license.
	ExpirationDate *date.Time `json:"expirationDate,omitempty"`
	// RelativeBeginDate - The relative begin date of license.
	RelativeBeginDate *string `json:"relativeBeginDate,omitempty"`
	// RelativeExpirationDate - The relative expiration date of license.
	RelativeExpirationDate *string `json:"relativeExpirationDate,omitempty"`
	// GracePeriod - The grace period of license.
	GracePeriod *string `json:"gracePeriod,omitempty"`
	// PlayRight - The license PlayRight
	PlayRight *ContentKeyPolicyPlayReadyPlayRight `json:"playRight,omitempty"`
	// LicenseType - The license type. Possible values include: 'ContentKeyPolicyPlayReadyLicenseTypeUnknown', 'ContentKeyPolicyPlayReadyLicenseTypeNonPersistent', 'ContentKeyPolicyPlayReadyLicenseTypePersistent'
	LicenseType ContentKeyPolicyPlayReadyLicenseType `json:"licenseType,omitempty"`
	// ContentKeyLocation - The content key location.
	ContentKeyLocation BasicContentKeyPolicyPlayReadyContentKeyLocation `json:"contentKeyLocation,omitempty"`
	// ContentType - The PlayReady content type. Possible values include: 'ContentKeyPolicyPlayReadyContentTypeUnknown', 'ContentKeyPolicyPlayReadyContentTypeUnspecified', 'ContentKeyPolicyPlayReadyContentTypeUltraVioletDownload', 'ContentKeyPolicyPlayReadyContentTypeUltraVioletStreaming'
	ContentType ContentKeyPolicyPlayReadyContentType `json:"contentType,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ContentKeyPolicyPlayReadyLicense struct.
func (ckpprl *ContentKeyPolicyPlayReadyLicense) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "allowTestDevices":
			if v != nil {
				var allowTestDevices bool
				err = json.Unmarshal(*v, &allowTestDevices)
				if err != nil {
					return err
				}
				ckpprl.AllowTestDevices = &allowTestDevices
			}
		case "beginDate":
			if v != nil {
				var beginDate date.Time
				err = json.Unmarshal(*v, &beginDate)
				if err != nil {
					return err
				}
				ckpprl.BeginDate = &beginDate
			}
		case "expirationDate":
			if v != nil {
				var expirationDate date.Time
				err = json.Unmarshal(*v, &expirationDate)
				if err != nil {
					return err
				}
				ckpprl.ExpirationDate = &expirationDate
			}
		case "relativeBeginDate":
			if v != nil {
				var relativeBeginDate string
				err = json.Unmarshal(*v, &relativeBeginDate)
				if err != nil {
					return err
				}
				ckpprl.RelativeBeginDate = &relativeBeginDate
			}
		case "relativeExpirationDate":
			if v != nil {
				var relativeExpirationDate string
				err = json.Unmarshal(*v, &relativeExpirationDate)
				if err != nil {
					return err
				}
				ckpprl.RelativeExpirationDate = &relativeExpirationDate
			}
		case "gracePeriod":
			if v != nil {
				var gracePeriod string
				err = json.Unmarshal(*v, &gracePeriod)
				if err != nil {
					return err
				}
				ckpprl.GracePeriod = &gracePeriod
			}
		case "playRight":
			if v != nil {
				var playRight ContentKeyPolicyPlayReadyPlayRight
				err = json.Unmarshal(*v, &playRight)
				if err != nil {
					return err
				}
				ckpprl.PlayRight = &playRight
			}
		case "licenseType":
			if v != nil {
				var licenseType ContentKeyPolicyPlayReadyLicenseType
				err = json.Unmarshal(*v, &licenseType)
				if err != nil {
					return err
				}
				ckpprl.LicenseType = licenseType
			}
		case "contentKeyLocation":
			if v != nil {
				contentKeyLocation, err := unmarshalBasicContentKeyPolicyPlayReadyContentKeyLocation(*v)
				if err != nil {
					return err
				}
				ckpprl.ContentKeyLocation = contentKeyLocation
			}
		case "contentType":
			if v != nil {
				var contentType ContentKeyPolicyPlayReadyContentType
				err = json.Unmarshal(*v, &contentType)
				if err != nil {
					return err
				}
				ckpprl.ContentType = contentType
			}
		}
	}

	return nil
}

// ContentKeyPolicyPlayReadyPlayRight configures the Play Right in the PlayReady license.
type ContentKeyPolicyPlayReadyPlayRight struct {
	// FirstPlayExpiration - The amount of time that the license is valid after the license is first used to play content.
	FirstPlayExpiration *string `json:"firstPlayExpiration,omitempty"`
	// ScmsRestriction - Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3 inclusive.
	ScmsRestriction *int32 `json:"scmsRestriction,omitempty"`
	// AgcAndColorStripeRestriction - Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and 3 inclusive.
	AgcAndColorStripeRestriction *int32 `json:"agcAndColorStripeRestriction,omitempty"`
	// ExplicitAnalogTelevisionOutputRestriction - Configures the Explicit Analog Television Output Restriction in the license. Configuration data must be between 0 and 3 inclusive.
	ExplicitAnalogTelevisionOutputRestriction *ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction `json:"explicitAnalogTelevisionOutputRestriction,omitempty"`
	// DigitalVideoOnlyContentRestriction - Enables the Image Constraint For Analog Component Video Restriction in the license.
	DigitalVideoOnlyContentRestriction *bool `json:"digitalVideoOnlyContentRestriction,omitempty"`
	// ImageConstraintForAnalogComponentVideoRestriction - Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComponentVideoRestriction *bool `json:"imageConstraintForAnalogComponentVideoRestriction,omitempty"`
	// ImageConstraintForAnalogComputerMonitorRestriction - Enables the Image Constraint For Analog Component Video Restriction in the license.
	ImageConstraintForAnalogComputerMonitorRestriction *bool `json:"imageConstraintForAnalogComputerMonitorRestriction,omitempty"`
	// AllowPassingVideoContentToUnknownOutput - Configures Unknown output handling settings of the license. Possible values include: 'ContentKeyPolicyPlayReadyUnknownOutputPassingOptionUnknown', 'ContentKeyPolicyPlayReadyUnknownOutputPassingOptionNotAllowed', 'ContentKeyPolicyPlayReadyUnknownOutputPassingOptionAllowed', 'ContentKeyPolicyPlayReadyUnknownOutputPassingOptionAllowedWithVideoConstriction'
	AllowPassingVideoContentToUnknownOutput ContentKeyPolicyPlayReadyUnknownOutputPassingOption `json:"allowPassingVideoContentToUnknownOutput,omitempty"`
	// UncompressedDigitalVideoOpl - Specifies the output protection level for uncompressed digital video.
	UncompressedDigitalVideoOpl *int32 `json:"uncompressedDigitalVideoOpl,omitempty"`
	// CompressedDigitalVideoOpl - Specifies the output protection level for compressed digital video.
	CompressedDigitalVideoOpl *int32 `json:"compressedDigitalVideoOpl,omitempty"`
	// AnalogVideoOpl - Specifies the output protection level for compressed digital audio.
	AnalogVideoOpl *int32 `json:"analogVideoOpl,omitempty"`
	// CompressedDigitalAudioOpl - Specifies the output protection level for compressed digital audio.
	CompressedDigitalAudioOpl *int32 `json:"compressedDigitalAudioOpl,omitempty"`
	// UncompressedDigitalAudioOpl - Specifies the output protection level for uncompressed digital audio.
	UncompressedDigitalAudioOpl *int32 `json:"uncompressedDigitalAudioOpl,omitempty"`
}

// ContentKeyPolicyProperties the properties of the Content Key Policy.
type ContentKeyPolicyProperties struct {
	autorest.Response `json:"-"`
	// PolicyID - READ-ONLY; The legacy Policy ID.
	PolicyID *uuid.UUID `json:"policyId,omitempty"`
	// Created - READ-ONLY; The creation date of the Policy
	Created *date.Time `json:"created,omitempty"`
	// LastModified - READ-ONLY; The last modified date of the Policy
	LastModified *date.Time `json:"lastModified,omitempty"`
	// Description - A description for the Policy.
	Description *string `json:"description,omitempty"`
	// Options - The Key Policy options.
	Options *[]ContentKeyPolicyOption `json:"options,omitempty"`
}

// BasicContentKeyPolicyRestriction base class for Content Key Policy restrictions. A derived class must be used to
// create a restriction.
type BasicContentKeyPolicyRestriction interface {
	AsContentKeyPolicyOpenRestriction() (*ContentKeyPolicyOpenRestriction, bool)
	AsContentKeyPolicyUnknownRestriction() (*ContentKeyPolicyUnknownRestriction, bool)
	AsContentKeyPolicyTokenRestriction() (*ContentKeyPolicyTokenRestriction, bool)
	AsContentKeyPolicyRestriction() (*ContentKeyPolicyRestriction, bool)
}

// ContentKeyPolicyRestriction base class for Content Key Policy restrictions. A derived class must be used to
// create a restriction.
type ContentKeyPolicyRestriction struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction'
	OdataType OdataTypeBasicContentKeyPolicyRestriction `json:"@odata.type,omitempty"`
}

func unmarshalBasicContentKeyPolicyRestriction(body []byte) (BasicContentKeyPolicyRestriction, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction):
		var ckpor ContentKeyPolicyOpenRestriction
		err := json.Unmarshal(body, &ckpor)
		return ckpor, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction):
		var ckpur ContentKeyPolicyUnknownRestriction
		err := json.Unmarshal(body, &ckpur)
		return ckpur, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction):
		var ckptr ContentKeyPolicyTokenRestriction
		err := json.Unmarshal(body, &ckptr)
		return ckptr, err
	default:
		var ckpr ContentKeyPolicyRestriction
		err := json.Unmarshal(body, &ckpr)
		return ckpr, err
	}
}
func unmarshalBasicContentKeyPolicyRestrictionArray(body []byte) ([]BasicContentKeyPolicyRestriction, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ckprArray := make([]BasicContentKeyPolicyRestriction, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ckpr, err := unmarshalBasicContentKeyPolicyRestriction(*rawMessage)
		if err != nil {
			return nil, err
		}
		ckprArray[index] = ckpr
	}
	return ckprArray, nil
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyRestriction.
func (ckpr ContentKeyPolicyRestriction) MarshalJSON() ([]byte, error) {
	ckpr.OdataType = OdataTypeContentKeyPolicyRestriction
	objectMap := make(map[string]interface{})
	if ckpr.OdataType != "" {
		objectMap["@odata.type"] = ckpr.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyOpenRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyRestriction.
func (ckpr ContentKeyPolicyRestriction) AsContentKeyPolicyOpenRestriction() (*ContentKeyPolicyOpenRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyUnknownRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyRestriction.
func (ckpr ContentKeyPolicyRestriction) AsContentKeyPolicyUnknownRestriction() (*ContentKeyPolicyUnknownRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyTokenRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyRestriction.
func (ckpr ContentKeyPolicyRestriction) AsContentKeyPolicyTokenRestriction() (*ContentKeyPolicyTokenRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyRestriction.
func (ckpr ContentKeyPolicyRestriction) AsContentKeyPolicyRestriction() (*ContentKeyPolicyRestriction, bool) {
	return &ckpr, true
}

// AsBasicContentKeyPolicyRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyRestriction.
func (ckpr ContentKeyPolicyRestriction) AsBasicContentKeyPolicyRestriction() (BasicContentKeyPolicyRestriction, bool) {
	return &ckpr, true
}

// BasicContentKeyPolicyRestrictionTokenKey base class for Content Key Policy key for token validation. A derived class
// must be used to create a token key.
type BasicContentKeyPolicyRestrictionTokenKey interface {
	AsContentKeyPolicySymmetricTokenKey() (*ContentKeyPolicySymmetricTokenKey, bool)
	AsContentKeyPolicyRsaTokenKey() (*ContentKeyPolicyRsaTokenKey, bool)
	AsContentKeyPolicyX509CertificateTokenKey() (*ContentKeyPolicyX509CertificateTokenKey, bool)
	AsContentKeyPolicyRestrictionTokenKey() (*ContentKeyPolicyRestrictionTokenKey, bool)
}

// ContentKeyPolicyRestrictionTokenKey base class for Content Key Policy key for token validation. A derived
// class must be used to create a token key.
type ContentKeyPolicyRestrictionTokenKey struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyRestrictionTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey'
	OdataType OdataTypeBasicContentKeyPolicyRestrictionTokenKey `json:"@odata.type,omitempty"`
}

func unmarshalBasicContentKeyPolicyRestrictionTokenKey(body []byte) (BasicContentKeyPolicyRestrictionTokenKey, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey):
		var ckpstk ContentKeyPolicySymmetricTokenKey
		err := json.Unmarshal(body, &ckpstk)
		return ckpstk, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey):
		var ckprtk ContentKeyPolicyRsaTokenKey
		err := json.Unmarshal(body, &ckprtk)
		return ckprtk, err
	case string(OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey):
		var ckpxctk ContentKeyPolicyX509CertificateTokenKey
		err := json.Unmarshal(body, &ckpxctk)
		return ckpxctk, err
	default:
		var ckprtk ContentKeyPolicyRestrictionTokenKey
		err := json.Unmarshal(body, &ckprtk)
		return ckprtk, err
	}
}
func unmarshalBasicContentKeyPolicyRestrictionTokenKeyArray(body []byte) ([]BasicContentKeyPolicyRestrictionTokenKey, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ckprtkArray := make([]BasicContentKeyPolicyRestrictionTokenKey, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ckprtk, err := unmarshalBasicContentKeyPolicyRestrictionTokenKey(*rawMessage)
		if err != nil {
			return nil, err
		}
		ckprtkArray[index] = ckprtk
	}
	return ckprtkArray, nil
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyRestrictionTokenKey.
func (ckprtk ContentKeyPolicyRestrictionTokenKey) MarshalJSON() ([]byte, error) {
	ckprtk.OdataType = OdataTypeContentKeyPolicyRestrictionTokenKey
	objectMap := make(map[string]interface{})
	if ckprtk.OdataType != "" {
		objectMap["@odata.type"] = ckprtk.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicySymmetricTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRestrictionTokenKey.
func (ckprtk ContentKeyPolicyRestrictionTokenKey) AsContentKeyPolicySymmetricTokenKey() (*ContentKeyPolicySymmetricTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyRsaTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRestrictionTokenKey.
func (ckprtk ContentKeyPolicyRestrictionTokenKey) AsContentKeyPolicyRsaTokenKey() (*ContentKeyPolicyRsaTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyX509CertificateTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRestrictionTokenKey.
func (ckprtk ContentKeyPolicyRestrictionTokenKey) AsContentKeyPolicyX509CertificateTokenKey() (*ContentKeyPolicyX509CertificateTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyRestrictionTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRestrictionTokenKey.
func (ckprtk ContentKeyPolicyRestrictionTokenKey) AsContentKeyPolicyRestrictionTokenKey() (*ContentKeyPolicyRestrictionTokenKey, bool) {
	return &ckprtk, true
}

// AsBasicContentKeyPolicyRestrictionTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRestrictionTokenKey.
func (ckprtk ContentKeyPolicyRestrictionTokenKey) AsBasicContentKeyPolicyRestrictionTokenKey() (BasicContentKeyPolicyRestrictionTokenKey, bool) {
	return &ckprtk, true
}

// ContentKeyPolicyRsaTokenKey specifies a RSA key for token validation
type ContentKeyPolicyRsaTokenKey struct {
	// Exponent - The RSA Parameter exponent
	Exponent *[]byte `json:"exponent,omitempty"`
	// Modulus - The RSA Parameter modulus
	Modulus *[]byte `json:"modulus,omitempty"`
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyRestrictionTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey'
	OdataType OdataTypeBasicContentKeyPolicyRestrictionTokenKey `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyRsaTokenKey.
func (ckprtk ContentKeyPolicyRsaTokenKey) MarshalJSON() ([]byte, error) {
	ckprtk.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey
	objectMap := make(map[string]interface{})
	if ckprtk.Exponent != nil {
		objectMap["exponent"] = ckprtk.Exponent
	}
	if ckprtk.Modulus != nil {
		objectMap["modulus"] = ckprtk.Modulus
	}
	if ckprtk.OdataType != "" {
		objectMap["@odata.type"] = ckprtk.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicySymmetricTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRsaTokenKey.
func (ckprtk ContentKeyPolicyRsaTokenKey) AsContentKeyPolicySymmetricTokenKey() (*ContentKeyPolicySymmetricTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyRsaTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRsaTokenKey.
func (ckprtk ContentKeyPolicyRsaTokenKey) AsContentKeyPolicyRsaTokenKey() (*ContentKeyPolicyRsaTokenKey, bool) {
	return &ckprtk, true
}

// AsContentKeyPolicyX509CertificateTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRsaTokenKey.
func (ckprtk ContentKeyPolicyRsaTokenKey) AsContentKeyPolicyX509CertificateTokenKey() (*ContentKeyPolicyX509CertificateTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyRestrictionTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRsaTokenKey.
func (ckprtk ContentKeyPolicyRsaTokenKey) AsContentKeyPolicyRestrictionTokenKey() (*ContentKeyPolicyRestrictionTokenKey, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyRestrictionTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyRsaTokenKey.
func (ckprtk ContentKeyPolicyRsaTokenKey) AsBasicContentKeyPolicyRestrictionTokenKey() (BasicContentKeyPolicyRestrictionTokenKey, bool) {
	return &ckprtk, true
}

// ContentKeyPolicySymmetricTokenKey specifies a symmetric key for token validation.
type ContentKeyPolicySymmetricTokenKey struct {
	// KeyValue - The key value of the key
	KeyValue *[]byte `json:"keyValue,omitempty"`
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyRestrictionTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey'
	OdataType OdataTypeBasicContentKeyPolicyRestrictionTokenKey `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicySymmetricTokenKey.
func (ckpstk ContentKeyPolicySymmetricTokenKey) MarshalJSON() ([]byte, error) {
	ckpstk.OdataType = OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey
	objectMap := make(map[string]interface{})
	if ckpstk.KeyValue != nil {
		objectMap["keyValue"] = ckpstk.KeyValue
	}
	if ckpstk.OdataType != "" {
		objectMap["@odata.type"] = ckpstk.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicySymmetricTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicySymmetricTokenKey.
func (ckpstk ContentKeyPolicySymmetricTokenKey) AsContentKeyPolicySymmetricTokenKey() (*ContentKeyPolicySymmetricTokenKey, bool) {
	return &ckpstk, true
}

// AsContentKeyPolicyRsaTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicySymmetricTokenKey.
func (ckpstk ContentKeyPolicySymmetricTokenKey) AsContentKeyPolicyRsaTokenKey() (*ContentKeyPolicyRsaTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyX509CertificateTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicySymmetricTokenKey.
func (ckpstk ContentKeyPolicySymmetricTokenKey) AsContentKeyPolicyX509CertificateTokenKey() (*ContentKeyPolicyX509CertificateTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyRestrictionTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicySymmetricTokenKey.
func (ckpstk ContentKeyPolicySymmetricTokenKey) AsContentKeyPolicyRestrictionTokenKey() (*ContentKeyPolicyRestrictionTokenKey, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyRestrictionTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicySymmetricTokenKey.
func (ckpstk ContentKeyPolicySymmetricTokenKey) AsBasicContentKeyPolicyRestrictionTokenKey() (BasicContentKeyPolicyRestrictionTokenKey, bool) {
	return &ckpstk, true
}

// ContentKeyPolicyTokenClaim represents a token claim.
type ContentKeyPolicyTokenClaim struct {
	// ClaimType - Token claim type.
	ClaimType *string `json:"claimType,omitempty"`
	// ClaimValue - Token claim value.
	ClaimValue *string `json:"claimValue,omitempty"`
}

// ContentKeyPolicyTokenRestriction represents a token restriction. Provided token must match these
// requirements for successful license or key delivery.
type ContentKeyPolicyTokenRestriction struct {
	// Issuer - The token issuer.
	Issuer *string `json:"issuer,omitempty"`
	// Audience - The audience for the token.
	Audience *string `json:"audience,omitempty"`
	// PrimaryVerificationKey - The primary verification key.
	PrimaryVerificationKey BasicContentKeyPolicyRestrictionTokenKey `json:"primaryVerificationKey,omitempty"`
	// AlternateVerificationKeys - A list of alternative verification keys.
	AlternateVerificationKeys *[]BasicContentKeyPolicyRestrictionTokenKey `json:"alternateVerificationKeys,omitempty"`
	// RequiredClaims - A list of required token claims.
	RequiredClaims *[]ContentKeyPolicyTokenClaim `json:"requiredClaims,omitempty"`
	// RestrictionTokenType - The type of token. Possible values include: 'ContentKeyPolicyRestrictionTokenTypeUnknown', 'ContentKeyPolicyRestrictionTokenTypeSwt', 'ContentKeyPolicyRestrictionTokenTypeJwt'
	RestrictionTokenType ContentKeyPolicyRestrictionTokenType `json:"restrictionTokenType,omitempty"`
	// OpenIDConnectDiscoveryDocument - The OpenID connect discovery document.
	OpenIDConnectDiscoveryDocument *string `json:"openIdConnectDiscoveryDocument,omitempty"`
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction'
	OdataType OdataTypeBasicContentKeyPolicyRestriction `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyTokenRestriction.
func (ckptr ContentKeyPolicyTokenRestriction) MarshalJSON() ([]byte, error) {
	ckptr.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction
	objectMap := make(map[string]interface{})
	if ckptr.Issuer != nil {
		objectMap["issuer"] = ckptr.Issuer
	}
	if ckptr.Audience != nil {
		objectMap["audience"] = ckptr.Audience
	}
	objectMap["primaryVerificationKey"] = ckptr.PrimaryVerificationKey
	if ckptr.AlternateVerificationKeys != nil {
		objectMap["alternateVerificationKeys"] = ckptr.AlternateVerificationKeys
	}
	if ckptr.RequiredClaims != nil {
		objectMap["requiredClaims"] = ckptr.RequiredClaims
	}
	if ckptr.RestrictionTokenType != "" {
		objectMap["restrictionTokenType"] = ckptr.RestrictionTokenType
	}
	if ckptr.OpenIDConnectDiscoveryDocument != nil {
		objectMap["openIdConnectDiscoveryDocument"] = ckptr.OpenIDConnectDiscoveryDocument
	}
	if ckptr.OdataType != "" {
		objectMap["@odata.type"] = ckptr.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyOpenRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyTokenRestriction.
func (ckptr ContentKeyPolicyTokenRestriction) AsContentKeyPolicyOpenRestriction() (*ContentKeyPolicyOpenRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyUnknownRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyTokenRestriction.
func (ckptr ContentKeyPolicyTokenRestriction) AsContentKeyPolicyUnknownRestriction() (*ContentKeyPolicyUnknownRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyTokenRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyTokenRestriction.
func (ckptr ContentKeyPolicyTokenRestriction) AsContentKeyPolicyTokenRestriction() (*ContentKeyPolicyTokenRestriction, bool) {
	return &ckptr, true
}

// AsContentKeyPolicyRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyTokenRestriction.
func (ckptr ContentKeyPolicyTokenRestriction) AsContentKeyPolicyRestriction() (*ContentKeyPolicyRestriction, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyTokenRestriction.
func (ckptr ContentKeyPolicyTokenRestriction) AsBasicContentKeyPolicyRestriction() (BasicContentKeyPolicyRestriction, bool) {
	return &ckptr, true
}

// UnmarshalJSON is the custom unmarshaler for ContentKeyPolicyTokenRestriction struct.
func (ckptr *ContentKeyPolicyTokenRestriction) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "issuer":
			if v != nil {
				var issuer string
				err = json.Unmarshal(*v, &issuer)
				if err != nil {
					return err
				}
				ckptr.Issuer = &issuer
			}
		case "audience":
			if v != nil {
				var audience string
				err = json.Unmarshal(*v, &audience)
				if err != nil {
					return err
				}
				ckptr.Audience = &audience
			}
		case "primaryVerificationKey":
			if v != nil {
				primaryVerificationKey, err := unmarshalBasicContentKeyPolicyRestrictionTokenKey(*v)
				if err != nil {
					return err
				}
				ckptr.PrimaryVerificationKey = primaryVerificationKey
			}
		case "alternateVerificationKeys":
			if v != nil {
				alternateVerificationKeys, err := unmarshalBasicContentKeyPolicyRestrictionTokenKeyArray(*v)
				if err != nil {
					return err
				}
				ckptr.AlternateVerificationKeys = &alternateVerificationKeys
			}
		case "requiredClaims":
			if v != nil {
				var requiredClaims []ContentKeyPolicyTokenClaim
				err = json.Unmarshal(*v, &requiredClaims)
				if err != nil {
					return err
				}
				ckptr.RequiredClaims = &requiredClaims
			}
		case "restrictionTokenType":
			if v != nil {
				var restrictionTokenType ContentKeyPolicyRestrictionTokenType
				err = json.Unmarshal(*v, &restrictionTokenType)
				if err != nil {
					return err
				}
				ckptr.RestrictionTokenType = restrictionTokenType
			}
		case "openIdConnectDiscoveryDocument":
			if v != nil {
				var openIDConnectDiscoveryDocument string
				err = json.Unmarshal(*v, &openIDConnectDiscoveryDocument)
				if err != nil {
					return err
				}
				ckptr.OpenIDConnectDiscoveryDocument = &openIDConnectDiscoveryDocument
			}
		case "@odata.type":
			if v != nil {
				var odataType OdataTypeBasicContentKeyPolicyRestriction
				err = json.Unmarshal(*v, &odataType)
				if err != nil {
					return err
				}
				ckptr.OdataType = odataType
			}
		}
	}

	return nil
}

// ContentKeyPolicyUnknownConfiguration represents a ContentKeyPolicyConfiguration that is unavailable in
// the current API version.
type ContentKeyPolicyUnknownConfiguration struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration'
	OdataType OdataTypeBasicContentKeyPolicyConfiguration `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyUnknownConfiguration.
func (ckpuc ContentKeyPolicyUnknownConfiguration) MarshalJSON() ([]byte, error) {
	ckpuc.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration
	objectMap := make(map[string]interface{})
	if ckpuc.OdataType != "" {
		objectMap["@odata.type"] = ckpuc.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyClearKeyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyUnknownConfiguration.
func (ckpuc ContentKeyPolicyUnknownConfiguration) AsContentKeyPolicyClearKeyConfiguration() (*ContentKeyPolicyClearKeyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyUnknownConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyUnknownConfiguration.
func (ckpuc ContentKeyPolicyUnknownConfiguration) AsContentKeyPolicyUnknownConfiguration() (*ContentKeyPolicyUnknownConfiguration, bool) {
	return &ckpuc, true
}

// AsContentKeyPolicyWidevineConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyUnknownConfiguration.
func (ckpuc ContentKeyPolicyUnknownConfiguration) AsContentKeyPolicyWidevineConfiguration() (*ContentKeyPolicyWidevineConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyPlayReadyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyUnknownConfiguration.
func (ckpuc ContentKeyPolicyUnknownConfiguration) AsContentKeyPolicyPlayReadyConfiguration() (*ContentKeyPolicyPlayReadyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyFairPlayConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyUnknownConfiguration.
func (ckpuc ContentKeyPolicyUnknownConfiguration) AsContentKeyPolicyFairPlayConfiguration() (*ContentKeyPolicyFairPlayConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyUnknownConfiguration.
func (ckpuc ContentKeyPolicyUnknownConfiguration) AsContentKeyPolicyConfiguration() (*ContentKeyPolicyConfiguration, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyUnknownConfiguration.
func (ckpuc ContentKeyPolicyUnknownConfiguration) AsBasicContentKeyPolicyConfiguration() (BasicContentKeyPolicyConfiguration, bool) {
	return &ckpuc, true
}

// ContentKeyPolicyUnknownRestriction represents a ContentKeyPolicyRestriction that is unavailable in the
// current API version.
type ContentKeyPolicyUnknownRestriction struct {
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyOpenRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction', 'OdataTypeMicrosoftMediaContentKeyPolicyTokenRestriction'
	OdataType OdataTypeBasicContentKeyPolicyRestriction `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyUnknownRestriction.
func (ckpur ContentKeyPolicyUnknownRestriction) MarshalJSON() ([]byte, error) {
	ckpur.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyUnknownRestriction
	objectMap := make(map[string]interface{})
	if ckpur.OdataType != "" {
		objectMap["@odata.type"] = ckpur.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyOpenRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyUnknownRestriction.
func (ckpur ContentKeyPolicyUnknownRestriction) AsContentKeyPolicyOpenRestriction() (*ContentKeyPolicyOpenRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyUnknownRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyUnknownRestriction.
func (ckpur ContentKeyPolicyUnknownRestriction) AsContentKeyPolicyUnknownRestriction() (*ContentKeyPolicyUnknownRestriction, bool) {
	return &ckpur, true
}

// AsContentKeyPolicyTokenRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyUnknownRestriction.
func (ckpur ContentKeyPolicyUnknownRestriction) AsContentKeyPolicyTokenRestriction() (*ContentKeyPolicyTokenRestriction, bool) {
	return nil, false
}

// AsContentKeyPolicyRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyUnknownRestriction.
func (ckpur ContentKeyPolicyUnknownRestriction) AsContentKeyPolicyRestriction() (*ContentKeyPolicyRestriction, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyRestriction is the BasicContentKeyPolicyRestriction implementation for ContentKeyPolicyUnknownRestriction.
func (ckpur ContentKeyPolicyUnknownRestriction) AsBasicContentKeyPolicyRestriction() (BasicContentKeyPolicyRestriction, bool) {
	return &ckpur, true
}

// ContentKeyPolicyWidevineConfiguration specifies a configuration for Widevine licenses.
type ContentKeyPolicyWidevineConfiguration struct {
	// WidevineTemplate - The Widevine template.
	WidevineTemplate *string `json:"widevineTemplate,omitempty"`
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyClearKeyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyUnknownConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyPlayReadyConfiguration', 'OdataTypeMicrosoftMediaContentKeyPolicyFairPlayConfiguration'
	OdataType OdataTypeBasicContentKeyPolicyConfiguration `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyWidevineConfiguration.
func (ckpwc ContentKeyPolicyWidevineConfiguration) MarshalJSON() ([]byte, error) {
	ckpwc.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyWidevineConfiguration
	objectMap := make(map[string]interface{})
	if ckpwc.WidevineTemplate != nil {
		objectMap["widevineTemplate"] = ckpwc.WidevineTemplate
	}
	if ckpwc.OdataType != "" {
		objectMap["@odata.type"] = ckpwc.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicyClearKeyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyWidevineConfiguration.
func (ckpwc ContentKeyPolicyWidevineConfiguration) AsContentKeyPolicyClearKeyConfiguration() (*ContentKeyPolicyClearKeyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyUnknownConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyWidevineConfiguration.
func (ckpwc ContentKeyPolicyWidevineConfiguration) AsContentKeyPolicyUnknownConfiguration() (*ContentKeyPolicyUnknownConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyWidevineConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyWidevineConfiguration.
func (ckpwc ContentKeyPolicyWidevineConfiguration) AsContentKeyPolicyWidevineConfiguration() (*ContentKeyPolicyWidevineConfiguration, bool) {
	return &ckpwc, true
}

// AsContentKeyPolicyPlayReadyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyWidevineConfiguration.
func (ckpwc ContentKeyPolicyWidevineConfiguration) AsContentKeyPolicyPlayReadyConfiguration() (*ContentKeyPolicyPlayReadyConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyFairPlayConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyWidevineConfiguration.
func (ckpwc ContentKeyPolicyWidevineConfiguration) AsContentKeyPolicyFairPlayConfiguration() (*ContentKeyPolicyFairPlayConfiguration, bool) {
	return nil, false
}

// AsContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyWidevineConfiguration.
func (ckpwc ContentKeyPolicyWidevineConfiguration) AsContentKeyPolicyConfiguration() (*ContentKeyPolicyConfiguration, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyConfiguration is the BasicContentKeyPolicyConfiguration implementation for ContentKeyPolicyWidevineConfiguration.
func (ckpwc ContentKeyPolicyWidevineConfiguration) AsBasicContentKeyPolicyConfiguration() (BasicContentKeyPolicyConfiguration, bool) {
	return &ckpwc, true
}

// ContentKeyPolicyX509CertificateTokenKey specifies a certificate for token validation.
type ContentKeyPolicyX509CertificateTokenKey struct {
	// RawBody - The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
	RawBody *[]byte `json:"rawBody,omitempty"`
	// OdataType - Possible values include: 'OdataTypeContentKeyPolicyRestrictionTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicySymmetricTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicyRsaTokenKey', 'OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey'
	OdataType OdataTypeBasicContentKeyPolicyRestrictionTokenKey `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for ContentKeyPolicyX509CertificateTokenKey.
func (ckpxctk ContentKeyPolicyX509CertificateTokenKey) MarshalJSON() ([]byte, error) {
	ckpxctk.OdataType = OdataTypeMicrosoftMediaContentKeyPolicyX509CertificateTokenKey
	objectMap := make(map[string]interface{})
	if ckpxctk.RawBody != nil {
		objectMap["rawBody"] = ckpxctk.RawBody
	}
	if ckpxctk.OdataType != "" {
		objectMap["@odata.type"] = ckpxctk.OdataType
	}
	return json.Marshal(objectMap)
}

// AsContentKeyPolicySymmetricTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyX509CertificateTokenKey.
func (ckpxctk ContentKeyPolicyX509CertificateTokenKey) AsContentKeyPolicySymmetricTokenKey() (*ContentKeyPolicySymmetricTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyRsaTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyX509CertificateTokenKey.
func (ckpxctk ContentKeyPolicyX509CertificateTokenKey) AsContentKeyPolicyRsaTokenKey() (*ContentKeyPolicyRsaTokenKey, bool) {
	return nil, false
}

// AsContentKeyPolicyX509CertificateTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyX509CertificateTokenKey.
func (ckpxctk ContentKeyPolicyX509CertificateTokenKey) AsContentKeyPolicyX509CertificateTokenKey() (*ContentKeyPolicyX509CertificateTokenKey, bool) {
	return &ckpxctk, true
}

// AsContentKeyPolicyRestrictionTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyX509CertificateTokenKey.
func (ckpxctk ContentKeyPolicyX509CertificateTokenKey) AsContentKeyPolicyRestrictionTokenKey() (*ContentKeyPolicyRestrictionTokenKey, bool) {
	return nil, false
}

// AsBasicContentKeyPolicyRestrictionTokenKey is the BasicContentKeyPolicyRestrictionTokenKey implementation for ContentKeyPolicyX509CertificateTokenKey.
func (ckpxctk ContentKeyPolicyX509CertificateTokenKey) AsBasicContentKeyPolicyRestrictionTokenKey() (BasicContentKeyPolicyRestrictionTokenKey, bool) {
	return &ckpxctk, true
}

// CopyAudio a codec flag, which tells the encoder to copy the input audio bitstream.
type CopyAudio struct {
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for CopyAudio.
func (ca CopyAudio) MarshalJSON() ([]byte, error) {
	ca.OdataType = OdataTypeMicrosoftMediaCopyAudio
	objectMap := make(map[string]interface{})
	if ca.Label != nil {
		objectMap["label"] = ca.Label
	}
	if ca.OdataType != "" {
		objectMap["@odata.type"] = ca.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsBasicAudio() (BasicAudio, bool) {
	return nil, false
}

// AsAacAudio is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsBasicVideo() (BasicVideo, bool) {
	return nil, false
}

// AsImage is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsBasicImage() (BasicImage, bool) {
	return nil, false
}

// AsCopyAudio is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsCopyAudio() (*CopyAudio, bool) {
	return &ca, true
}

// AsH264Video is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for CopyAudio.
func (ca CopyAudio) AsBasicCodec() (BasicCodec, bool) {
	return &ca, true
}

// CopyVideo a codec flag, which tells the encoder to copy the input video bitstream without re-encoding.
type CopyVideo struct {
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for CopyVideo.
func (cv CopyVideo) MarshalJSON() ([]byte, error) {
	cv.OdataType = OdataTypeMicrosoftMediaCopyVideo
	objectMap := make(map[string]interface{})
	if cv.Label != nil {
		objectMap["label"] = cv.Label
	}
	if cv.OdataType != "" {
		objectMap["@odata.type"] = cv.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsBasicAudio() (BasicAudio, bool) {
	return nil, false
}

// AsAacAudio is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsCopyVideo() (*CopyVideo, bool) {
	return &cv, true
}

// AsVideo is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsBasicVideo() (BasicVideo, bool) {
	return nil, false
}

// AsImage is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsBasicImage() (BasicImage, bool) {
	return nil, false
}

// AsCopyAudio is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for CopyVideo.
func (cv CopyVideo) AsBasicCodec() (BasicCodec, bool) {
	return &cv, true
}

// CrossSiteAccessPolicies the client access policy.
type CrossSiteAccessPolicies struct {
	// ClientAccessPolicy - The content of clientaccesspolicy.xml used by Silverlight.
	ClientAccessPolicy *string `json:"clientAccessPolicy,omitempty"`
	// CrossDomainPolicy - The content of crossdomain.xml used by Silverlight.
	CrossDomainPolicy *string `json:"crossDomainPolicy,omitempty"`
}

// DefaultKey class to specify properties of default content key for each encryption scheme
type DefaultKey struct {
	// Label - Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `json:"label,omitempty"`
	// PolicyName - Policy used by Default Key
	PolicyName *string `json:"policyName,omitempty"`
}

// Deinterlace describes the de-interlacing settings.
type Deinterlace struct {
	// Parity - The field parity for de-interlacing, defaults to Auto. Possible values include: 'Auto', 'TopFieldFirst', 'BottomFieldFirst'
	Parity DeinterlaceParity `json:"parity,omitempty"`
	// Mode - The deinterlacing mode. Defaults to AutoPixelAdaptive. Possible values include: 'Off', 'AutoPixelAdaptive'
	Mode DeinterlaceMode `json:"mode,omitempty"`
}

// EdgePolicies ...
type EdgePolicies struct {
	autorest.Response         `json:"-"`
	UsageDataCollectionPolicy *EdgeUsageDataCollectionPolicy `json:"usageDataCollectionPolicy,omitempty"`
}

// EdgeUsageDataCollectionPolicy ...
type EdgeUsageDataCollectionPolicy struct {
	// DataCollectionFrequency - Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataCollectionFrequency *string `json:"dataCollectionFrequency,omitempty"`
	// DataReportingFrequency - Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
	DataReportingFrequency *string `json:"dataReportingFrequency,omitempty"`
	// MaxAllowedUnreportedUsageDuration - Maximum time for which the functionality of the device will not be hampered for not reporting the usage data.
	MaxAllowedUnreportedUsageDuration *string `json:"maxAllowedUnreportedUsageDuration,omitempty"`
	// EventHubDetails - Details of Event Hub where the usage will be reported.
	EventHubDetails *EdgeUsageDataEventHub `json:"eventHubDetails,omitempty"`
}

// EdgeUsageDataEventHub ...
type EdgeUsageDataEventHub struct {
	// Name - Name of the Event Hub where usage will be reported.
	Name *string `json:"name,omitempty"`
	// Namespace - Namespace of the Event Hub where usage will be reported.
	Namespace *string `json:"namespace,omitempty"`
	// Token - SAS token needed to interact with Event Hub.
	Token *string `json:"token,omitempty"`
}

// EnabledProtocols class to specify which protocols are enabled
type EnabledProtocols struct {
	// Download - Enable Download protocol or not
	Download *bool `json:"download,omitempty"`
	// Dash - Enable DASH protocol or not
	Dash *bool `json:"dash,omitempty"`
	// Hls - Enable HLS protocol or not
	Hls *bool `json:"hls,omitempty"`
	// SmoothStreaming - Enable SmoothStreaming protocol or not
	SmoothStreaming *bool `json:"smoothStreaming,omitempty"`
}

// EntityNameAvailabilityCheckOutput the response from the check name availability request.
type EntityNameAvailabilityCheckOutput struct {
	autorest.Response `json:"-"`
	// NameAvailable - Specifies if the name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty"`
	// Reason - Specifies the reason if the name is not available.
	Reason *string `json:"reason,omitempty"`
	// Message - Specifies the detailed reason if the name is not available.
	Message *string `json:"message,omitempty"`
}

// EnvelopeEncryption class for EnvelopeEncryption encryption scheme
type EnvelopeEncryption struct {
	// EnabledProtocols - Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
	// ClearTracks - Representing which tracks should not be encrypted
	ClearTracks *[]TrackSelection `json:"clearTracks,omitempty"`
	// ContentKeys - Representing default content key for each encryption scheme and separate content keys for specific tracks
	ContentKeys *StreamingPolicyContentKeys `json:"contentKeys,omitempty"`
	// CustomKeyAcquisitionURLTemplate - Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomKeyAcquisitionURLTemplate *string `json:"customKeyAcquisitionUrlTemplate,omitempty"`
}

// FaceDetectorPreset describes all the settings to be used when analyzing a video in order to detect all
// the faces present.
type FaceDetectorPreset struct {
	// Resolution - Specifies the maximum resolution at which your video is analyzed. The default behavior is "SourceResolution," which will keep the input video at its original resolution when analyzed. Using "StandardDefinition" will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to "StandardDefinition" will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics for details). However, faces that end up being too small in the resized video may not be detected. Possible values include: 'SourceResolution', 'StandardDefinition'
	Resolution AnalysisResolution `json:"resolution,omitempty"`
	// ExperimentalOptions - Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]*string `json:"experimentalOptions"`
	// OdataType - Possible values include: 'OdataTypePreset', 'OdataTypeMicrosoftMediaFaceDetectorPreset', 'OdataTypeMicrosoftMediaAudioAnalyzerPreset', 'OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset', 'OdataTypeMicrosoftMediaStandardEncoderPreset', 'OdataTypeMicrosoftMediaVideoAnalyzerPreset'
	OdataType OdataTypeBasicPreset `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for FaceDetectorPreset.
func (fdp FaceDetectorPreset) MarshalJSON() ([]byte, error) {
	fdp.OdataType = OdataTypeMicrosoftMediaFaceDetectorPreset
	objectMap := make(map[string]interface{})
	if fdp.Resolution != "" {
		objectMap["resolution"] = fdp.Resolution
	}
	if fdp.ExperimentalOptions != nil {
		objectMap["experimentalOptions"] = fdp.ExperimentalOptions
	}
	if fdp.OdataType != "" {
		objectMap["@odata.type"] = fdp.OdataType
	}
	return json.Marshal(objectMap)
}

// AsFaceDetectorPreset is the BasicPreset implementation for FaceDetectorPreset.
func (fdp FaceDetectorPreset) AsFaceDetectorPreset() (*FaceDetectorPreset, bool) {
	return &fdp, true
}

// AsAudioAnalyzerPreset is the BasicPreset implementation for FaceDetectorPreset.
func (fdp FaceDetectorPreset) AsAudioAnalyzerPreset() (*AudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBasicAudioAnalyzerPreset is the BasicPreset implementation for FaceDetectorPreset.
func (fdp FaceDetectorPreset) AsBasicAudioAnalyzerPreset() (BasicAudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBuiltInStandardEncoderPreset is the BasicPreset implementation for FaceDetectorPreset.
func (fdp FaceDetectorPreset) AsBuiltInStandardEncoderPreset() (*BuiltInStandardEncoderPreset, bool) {
	return nil, false
}

// AsStandardEncoderPreset is the BasicPreset implementation for FaceDetectorPreset.
func (fdp FaceDetectorPreset) AsStandardEncoderPreset() (*StandardEncoderPreset, bool) {
	return nil, false
}

// AsVideoAnalyzerPreset is the BasicPreset implementation for FaceDetectorPreset.
func (fdp FaceDetectorPreset) AsVideoAnalyzerPreset() (*VideoAnalyzerPreset, bool) {
	return nil, false
}

// AsPreset is the BasicPreset implementation for FaceDetectorPreset.
func (fdp FaceDetectorPreset) AsPreset() (*Preset, bool) {
	return nil, false
}

// AsBasicPreset is the BasicPreset implementation for FaceDetectorPreset.
func (fdp FaceDetectorPreset) AsBasicPreset() (BasicPreset, bool) {
	return &fdp, true
}

// FilterProperties the Media Filter properties.
type FilterProperties struct {
	// PresentationTimeRange - The presentation time range.
	PresentationTimeRange *PresentationTimeRange `json:"presentationTimeRange,omitempty"`
	// FirstQuality - The first quality.
	FirstQuality *FirstQuality `json:"firstQuality,omitempty"`
	// Tracks - The tracks selection conditions.
	Tracks *[]FilterTrackSelection `json:"tracks,omitempty"`
}

// Filters describes all the filtering operations, such as de-interlacing, rotation etc. that are to be
// applied to the input media before encoding.
type Filters struct {
	// Deinterlace - The de-interlacing settings.
	Deinterlace *Deinterlace `json:"deinterlace,omitempty"`
	// Rotation - The rotation, if any, to be applied to the input video, before it is encoded. Default is Auto. Possible values include: 'RotationAuto', 'RotationNone', 'RotationRotate0', 'RotationRotate90', 'RotationRotate180', 'RotationRotate270'
	Rotation Rotation `json:"rotation,omitempty"`
	// Crop - The parameters for the rectangular window with which to crop the input video.
	Crop *Rectangle `json:"crop,omitempty"`
	// Overlays - The properties of overlays to be applied to the input video. These could be audio, image or video overlays.
	Overlays *[]BasicOverlay `json:"overlays,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for Filters struct.
func (f *Filters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "deinterlace":
			if v != nil {
				var deinterlace Deinterlace
				err = json.Unmarshal(*v, &deinterlace)
				if err != nil {
					return err
				}
				f.Deinterlace = &deinterlace
			}
		case "rotation":
			if v != nil {
				var rotation Rotation
				err = json.Unmarshal(*v, &rotation)
				if err != nil {
					return err
				}
				f.Rotation = rotation
			}
		case "crop":
			if v != nil {
				var crop Rectangle
				err = json.Unmarshal(*v, &crop)
				if err != nil {
					return err
				}
				f.Crop = &crop
			}
		case "overlays":
			if v != nil {
				overlays, err := unmarshalBasicOverlayArray(*v)
				if err != nil {
					return err
				}
				f.Overlays = &overlays
			}
		}
	}

	return nil
}

// FilterTrackPropertyCondition the class to specify one track property condition.
type FilterTrackPropertyCondition struct {
	// Property - The track property type. Possible values include: 'FilterTrackPropertyTypeUnknown', 'FilterTrackPropertyTypeType', 'FilterTrackPropertyTypeName', 'FilterTrackPropertyTypeLanguage', 'FilterTrackPropertyTypeFourCC', 'FilterTrackPropertyTypeBitrate'
	Property FilterTrackPropertyType `json:"property,omitempty"`
	// Value - The track property value.
	Value *string `json:"value,omitempty"`
	// Operation - The track property condition operation. Possible values include: 'Equal', 'NotEqual'
	Operation FilterTrackPropertyCompareOperation `json:"operation,omitempty"`
}

// FilterTrackSelection representing a list of FilterTrackPropertyConditions to select a track.  The
// filters are combined using a logical AND operation.
type FilterTrackSelection struct {
	// TrackSelections - The track selections.
	TrackSelections *[]FilterTrackPropertyCondition `json:"trackSelections,omitempty"`
}

// FirstQuality filter First Quality
type FirstQuality struct {
	// Bitrate - The first quality bitrate.
	Bitrate *int32 `json:"bitrate,omitempty"`
}

// BasicFormat base class for output.
type BasicFormat interface {
	AsImageFormat() (*ImageFormat, bool)
	AsBasicImageFormat() (BasicImageFormat, bool)
	AsJpgFormat() (*JpgFormat, bool)
	AsPngFormat() (*PngFormat, bool)
	AsMultiBitrateFormat() (*MultiBitrateFormat, bool)
	AsBasicMultiBitrateFormat() (BasicMultiBitrateFormat, bool)
	AsMp4Format() (*Mp4Format, bool)
	AsTransportStreamFormat() (*TransportStreamFormat, bool)
	AsFormat() (*Format, bool)
}

// Format base class for output.
type Format struct {
	// FilenamePattern - The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - The base name of the input video {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`
	// OdataType - Possible values include: 'OdataTypeFormat', 'OdataTypeMicrosoftMediaImageFormat', 'OdataTypeMicrosoftMediaJpgFormat', 'OdataTypeMicrosoftMediaPngFormat', 'OdataTypeMicrosoftMediaMultiBitrateFormat', 'OdataTypeMicrosoftMediaMp4Format', 'OdataTypeMicrosoftMediaTransportStreamFormat'
	OdataType OdataTypeBasicFormat `json:"@odata.type,omitempty"`
}

func unmarshalBasicFormat(body []byte) (BasicFormat, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaImageFormat):
		var ifVar ImageFormat
		err := json.Unmarshal(body, &ifVar)
		return ifVar, err
	case string(OdataTypeMicrosoftMediaJpgFormat):
		var jf JpgFormat
		err := json.Unmarshal(body, &jf)
		return jf, err
	case string(OdataTypeMicrosoftMediaPngFormat):
		var pf PngFormat
		err := json.Unmarshal(body, &pf)
		return pf, err
	case string(OdataTypeMicrosoftMediaMultiBitrateFormat):
		var mbf MultiBitrateFormat
		err := json.Unmarshal(body, &mbf)
		return mbf, err
	case string(OdataTypeMicrosoftMediaMp4Format):
		var m4f Mp4Format
		err := json.Unmarshal(body, &m4f)
		return m4f, err
	case string(OdataTypeMicrosoftMediaTransportStreamFormat):
		var tsf TransportStreamFormat
		err := json.Unmarshal(body, &tsf)
		return tsf, err
	default:
		var f Format
		err := json.Unmarshal(body, &f)
		return f, err
	}
}
func unmarshalBasicFormatArray(body []byte) ([]BasicFormat, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	fArray := make([]BasicFormat, len(rawMessages))

	for index, rawMessage := range rawMessages {
		f, err := unmarshalBasicFormat(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

// MarshalJSON is the custom marshaler for Format.
func (f Format) MarshalJSON() ([]byte, error) {
	f.OdataType = OdataTypeFormat
	objectMap := make(map[string]interface{})
	if f.FilenamePattern != nil {
		objectMap["filenamePattern"] = f.FilenamePattern
	}
	if f.OdataType != "" {
		objectMap["@odata.type"] = f.OdataType
	}
	return json.Marshal(objectMap)
}

// AsImageFormat is the BasicFormat implementation for Format.
func (f Format) AsImageFormat() (*ImageFormat, bool) {
	return nil, false
}

// AsBasicImageFormat is the BasicFormat implementation for Format.
func (f Format) AsBasicImageFormat() (BasicImageFormat, bool) {
	return nil, false
}

// AsJpgFormat is the BasicFormat implementation for Format.
func (f Format) AsJpgFormat() (*JpgFormat, bool) {
	return nil, false
}

// AsPngFormat is the BasicFormat implementation for Format.
func (f Format) AsPngFormat() (*PngFormat, bool) {
	return nil, false
}

// AsMultiBitrateFormat is the BasicFormat implementation for Format.
func (f Format) AsMultiBitrateFormat() (*MultiBitrateFormat, bool) {
	return nil, false
}

// AsBasicMultiBitrateFormat is the BasicFormat implementation for Format.
func (f Format) AsBasicMultiBitrateFormat() (BasicMultiBitrateFormat, bool) {
	return nil, false
}

// AsMp4Format is the BasicFormat implementation for Format.
func (f Format) AsMp4Format() (*Mp4Format, bool) {
	return nil, false
}

// AsTransportStreamFormat is the BasicFormat implementation for Format.
func (f Format) AsTransportStreamFormat() (*TransportStreamFormat, bool) {
	return nil, false
}

// AsFormat is the BasicFormat implementation for Format.
func (f Format) AsFormat() (*Format, bool) {
	return &f, true
}

// AsBasicFormat is the BasicFormat implementation for Format.
func (f Format) AsBasicFormat() (BasicFormat, bool) {
	return &f, true
}

// H264Layer describes the settings to be used when encoding the input video into a desired output bitrate
// layer with the H.264 video codec.
type H264Layer struct {
	// Profile - We currently support Baseline, Main, High, High422, High444. Default is Auto. Possible values include: 'H264VideoProfileAuto', 'H264VideoProfileBaseline', 'H264VideoProfileMain', 'H264VideoProfileHigh', 'H264VideoProfileHigh422', 'H264VideoProfileHigh444'
	Profile H264VideoProfile `json:"profile,omitempty"`
	// Level - We currently support Level up to 6.2. The value can be Auto, or a number that matches the H.264 profile. If not specified, the default is Auto, which lets the encoder choose the Level that is appropriate for this layer.
	Level *string `json:"level,omitempty"`
	// BufferWindow - The VBV buffer window length. The value should be in ISO 8601 format. The value should be in the range [0.1-100] seconds. The default is 5 seconds (for example, PT5S).
	BufferWindow *string `json:"bufferWindow,omitempty"`
	// ReferenceFrames - The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
	ReferenceFrames *int32 `json:"referenceFrames,omitempty"`
	// EntropyMode - The entropy mode to be used for this layer. If not specified, the encoder chooses the mode that is appropriate for the profile and level. Possible values include: 'Cabac', 'Cavlc'
	EntropyMode EntropyMode `json:"entropyMode,omitempty"`
	// Bitrate - The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
	Bitrate *int32 `json:"bitrate,omitempty"`
	// MaxBitrate - The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int32 `json:"maxBitrate,omitempty"`
	// BFrames - The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int32 `json:"bFrames,omitempty"`
	// FrameRate - The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `json:"frameRate,omitempty"`
	// Slices - The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int32 `json:"slices,omitempty"`
	// AdaptiveBFrame - Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `json:"adaptiveBFrame,omitempty"`
	// Width - The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
	// Height - The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`
	// Label - The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeLayer', 'OdataTypeMicrosoftMediaVideoLayer', 'OdataTypeMicrosoftMediaH264Layer', 'OdataTypeMicrosoftMediaJpgLayer', 'OdataTypeMicrosoftMediaPngLayer'
	OdataType OdataTypeBasicLayer `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for H264Layer.
func (hl H264Layer) MarshalJSON() ([]byte, error) {
	hl.OdataType = OdataTypeMicrosoftMediaH264Layer
	objectMap := make(map[string]interface{})
	if hl.Profile != "" {
		objectMap["profile"] = hl.Profile
	}
	if hl.Level != nil {
		objectMap["level"] = hl.Level
	}
	if hl.BufferWindow != nil {
		objectMap["bufferWindow"] = hl.BufferWindow
	}
	if hl.ReferenceFrames != nil {
		objectMap["referenceFrames"] = hl.ReferenceFrames
	}
	if hl.EntropyMode != "" {
		objectMap["entropyMode"] = hl.EntropyMode
	}
	if hl.Bitrate != nil {
		objectMap["bitrate"] = hl.Bitrate
	}
	if hl.MaxBitrate != nil {
		objectMap["maxBitrate"] = hl.MaxBitrate
	}
	if hl.BFrames != nil {
		objectMap["bFrames"] = hl.BFrames
	}
	if hl.FrameRate != nil {
		objectMap["frameRate"] = hl.FrameRate
	}
	if hl.Slices != nil {
		objectMap["slices"] = hl.Slices
	}
	if hl.AdaptiveBFrame != nil {
		objectMap["adaptiveBFrame"] = hl.AdaptiveBFrame
	}
	if hl.Width != nil {
		objectMap["width"] = hl.Width
	}
	if hl.Height != nil {
		objectMap["height"] = hl.Height
	}
	if hl.Label != nil {
		objectMap["label"] = hl.Label
	}
	if hl.OdataType != "" {
		objectMap["@odata.type"] = hl.OdataType
	}
	return json.Marshal(objectMap)
}

// AsVideoLayer is the BasicLayer implementation for H264Layer.
func (hl H264Layer) AsVideoLayer() (*VideoLayer, bool) {
	return nil, false
}

// AsBasicVideoLayer is the BasicLayer implementation for H264Layer.
func (hl H264Layer) AsBasicVideoLayer() (BasicVideoLayer, bool) {
	return &hl, true
}

// AsH264Layer is the BasicLayer implementation for H264Layer.
func (hl H264Layer) AsH264Layer() (*H264Layer, bool) {
	return &hl, true
}

// AsJpgLayer is the BasicLayer implementation for H264Layer.
func (hl H264Layer) AsJpgLayer() (*JpgLayer, bool) {
	return nil, false
}

// AsPngLayer is the BasicLayer implementation for H264Layer.
func (hl H264Layer) AsPngLayer() (*PngLayer, bool) {
	return nil, false
}

// AsLayer is the BasicLayer implementation for H264Layer.
func (hl H264Layer) AsLayer() (*Layer, bool) {
	return nil, false
}

// AsBasicLayer is the BasicLayer implementation for H264Layer.
func (hl H264Layer) AsBasicLayer() (BasicLayer, bool) {
	return &hl, true
}

// H264Video describes all the properties for encoding a video with the H.264 codec.
type H264Video struct {
	// SceneChangeDetection - Whether or not the encoder should insert key frames at scene changes. If not specified, the default is false. This flag should be set to true only when the encoder is being configured to produce a single output video.
	SceneChangeDetection *bool `json:"sceneChangeDetection,omitempty"`
	// Complexity - Tells the encoder how to choose its encoding settings. The default value is Balanced. Possible values include: 'Speed', 'Balanced', 'Quality'
	Complexity H264Complexity `json:"complexity,omitempty"`
	// Layers - The collection of output H.264 layers to be produced by the encoder.
	Layers *[]H264Layer `json:"layers,omitempty"`
	// KeyFrameInterval - The distance between two key frames, thereby defining a group of pictures (GOP). The value should be a non-zero integer in the range [1, 30] seconds, specified in ISO 8601 format. The default is 2 seconds (PT2S).
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`
	// StretchMode - The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize. Possible values include: 'StretchModeNone', 'StretchModeAutoSize', 'StretchModeAutoFit'
	StretchMode StretchMode `json:"stretchMode,omitempty"`
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for H264Video.
func (hv H264Video) MarshalJSON() ([]byte, error) {
	hv.OdataType = OdataTypeMicrosoftMediaH264Video
	objectMap := make(map[string]interface{})
	if hv.SceneChangeDetection != nil {
		objectMap["sceneChangeDetection"] = hv.SceneChangeDetection
	}
	if hv.Complexity != "" {
		objectMap["complexity"] = hv.Complexity
	}
	if hv.Layers != nil {
		objectMap["layers"] = hv.Layers
	}
	if hv.KeyFrameInterval != nil {
		objectMap["keyFrameInterval"] = hv.KeyFrameInterval
	}
	if hv.StretchMode != "" {
		objectMap["stretchMode"] = hv.StretchMode
	}
	if hv.Label != nil {
		objectMap["label"] = hv.Label
	}
	if hv.OdataType != "" {
		objectMap["@odata.type"] = hv.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for H264Video.
func (hv H264Video) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for H264Video.
func (hv H264Video) AsBasicAudio() (BasicAudio, bool) {
	return nil, false
}

// AsAacAudio is the BasicCodec implementation for H264Video.
func (hv H264Video) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for H264Video.
func (hv H264Video) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for H264Video.
func (hv H264Video) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for H264Video.
func (hv H264Video) AsBasicVideo() (BasicVideo, bool) {
	return &hv, true
}

// AsImage is the BasicCodec implementation for H264Video.
func (hv H264Video) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for H264Video.
func (hv H264Video) AsBasicImage() (BasicImage, bool) {
	return nil, false
}

// AsCopyAudio is the BasicCodec implementation for H264Video.
func (hv H264Video) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for H264Video.
func (hv H264Video) AsH264Video() (*H264Video, bool) {
	return &hv, true
}

// AsJpgImage is the BasicCodec implementation for H264Video.
func (hv H264Video) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for H264Video.
func (hv H264Video) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for H264Video.
func (hv H264Video) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for H264Video.
func (hv H264Video) AsBasicCodec() (BasicCodec, bool) {
	return &hv, true
}

// Hls the HLS configuration.
type Hls struct {
	// FragmentsPerTsSegment - The amount of fragments per HTTP Live Streaming (HLS) segment.
	FragmentsPerTsSegment *int32 `json:"fragmentsPerTsSegment,omitempty"`
}

// BasicImage describes the basic properties for generating thumbnails from the input video
type BasicImage interface {
	AsJpgImage() (*JpgImage, bool)
	AsPngImage() (*PngImage, bool)
	AsImage() (*Image, bool)
}

// Image describes the basic properties for generating thumbnails from the input video
type Image struct {
	// Start - The position in the input video from where to start generating thumbnails. The value can be in absolute timestamp (ISO 8601, e.g: PT05S), or a frame count (For example, 10 for the 10th frame), or a relative value (For example, 1%). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video.
	Start *string `json:"start,omitempty"`
	// Step - The intervals at which thumbnails are generated. The value can be in absolute timestamp (ISO 8601, e.g: PT05S for one image every 5 seconds), or a frame count (For example, 30 for every 30 frames), or a relative value (For example, 1%).
	Step *string `json:"step,omitempty"`
	// Range - The position in the input video at which to stop generating thumbnails. The value can be in absolute timestamp (ISO 8601, e.g: PT5M30S to stop at 5 minutes and 30 seconds), or a frame count (For example, 300 to stop at the 300th frame), or a relative value (For example, 100%).
	Range *string `json:"range,omitempty"`
	// KeyFrameInterval - The distance between two key frames, thereby defining a group of pictures (GOP). The value should be a non-zero integer in the range [1, 30] seconds, specified in ISO 8601 format. The default is 2 seconds (PT2S).
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`
	// StretchMode - The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize. Possible values include: 'StretchModeNone', 'StretchModeAutoSize', 'StretchModeAutoFit'
	StretchMode StretchMode `json:"stretchMode,omitempty"`
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

func unmarshalBasicImage(body []byte) (BasicImage, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaJpgImage):
		var ji JpgImage
		err := json.Unmarshal(body, &ji)
		return ji, err
	case string(OdataTypeMicrosoftMediaPngImage):
		var pi PngImage
		err := json.Unmarshal(body, &pi)
		return pi, err
	default:
		var i Image
		err := json.Unmarshal(body, &i)
		return i, err
	}
}
func unmarshalBasicImageArray(body []byte) ([]BasicImage, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	iArray := make([]BasicImage, len(rawMessages))

	for index, rawMessage := range rawMessages {
		i, err := unmarshalBasicImage(*rawMessage)
		if err != nil {
			return nil, err
		}
		iArray[index] = i
	}
	return iArray, nil
}

// MarshalJSON is the custom marshaler for Image.
func (i Image) MarshalJSON() ([]byte, error) {
	i.OdataType = OdataTypeMicrosoftMediaImage
	objectMap := make(map[string]interface{})
	if i.Start != nil {
		objectMap["start"] = i.Start
	}
	if i.Step != nil {
		objectMap["step"] = i.Step
	}
	if i.Range != nil {
		objectMap["range"] = i.Range
	}
	if i.KeyFrameInterval != nil {
		objectMap["keyFrameInterval"] = i.KeyFrameInterval
	}
	if i.StretchMode != "" {
		objectMap["stretchMode"] = i.StretchMode
	}
	if i.Label != nil {
		objectMap["label"] = i.Label
	}
	if i.OdataType != "" {
		objectMap["@odata.type"] = i.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for Image.
func (i Image) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for Image.
func (i Image) AsBasicAudio() (BasicAudio, bool) {
	return nil, false
}

// AsAacAudio is the BasicCodec implementation for Image.
func (i Image) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for Image.
func (i Image) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for Image.
func (i Image) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for Image.
func (i Image) AsBasicVideo() (BasicVideo, bool) {
	return &i, true
}

// AsImage is the BasicCodec implementation for Image.
func (i Image) AsImage() (*Image, bool) {
	return &i, true
}

// AsBasicImage is the BasicCodec implementation for Image.
func (i Image) AsBasicImage() (BasicImage, bool) {
	return &i, true
}

// AsCopyAudio is the BasicCodec implementation for Image.
func (i Image) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for Image.
func (i Image) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for Image.
func (i Image) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for Image.
func (i Image) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for Image.
func (i Image) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for Image.
func (i Image) AsBasicCodec() (BasicCodec, bool) {
	return &i, true
}

// BasicImageFormat describes the properties for an output image file.
type BasicImageFormat interface {
	AsJpgFormat() (*JpgFormat, bool)
	AsPngFormat() (*PngFormat, bool)
	AsImageFormat() (*ImageFormat, bool)
}

// ImageFormat describes the properties for an output image file.
type ImageFormat struct {
	// FilenamePattern - The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - The base name of the input video {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`
	// OdataType - Possible values include: 'OdataTypeFormat', 'OdataTypeMicrosoftMediaImageFormat', 'OdataTypeMicrosoftMediaJpgFormat', 'OdataTypeMicrosoftMediaPngFormat', 'OdataTypeMicrosoftMediaMultiBitrateFormat', 'OdataTypeMicrosoftMediaMp4Format', 'OdataTypeMicrosoftMediaTransportStreamFormat'
	OdataType OdataTypeBasicFormat `json:"@odata.type,omitempty"`
}

func unmarshalBasicImageFormat(body []byte) (BasicImageFormat, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaJpgFormat):
		var jf JpgFormat
		err := json.Unmarshal(body, &jf)
		return jf, err
	case string(OdataTypeMicrosoftMediaPngFormat):
		var pf PngFormat
		err := json.Unmarshal(body, &pf)
		return pf, err
	default:
		var ifVar ImageFormat
		err := json.Unmarshal(body, &ifVar)
		return ifVar, err
	}
}
func unmarshalBasicImageFormatArray(body []byte) ([]BasicImageFormat, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ifVarArray := make([]BasicImageFormat, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ifVar, err := unmarshalBasicImageFormat(*rawMessage)
		if err != nil {
			return nil, err
		}
		ifVarArray[index] = ifVar
	}
	return ifVarArray, nil
}

// MarshalJSON is the custom marshaler for ImageFormat.
func (ifVar ImageFormat) MarshalJSON() ([]byte, error) {
	ifVar.OdataType = OdataTypeMicrosoftMediaImageFormat
	objectMap := make(map[string]interface{})
	if ifVar.FilenamePattern != nil {
		objectMap["filenamePattern"] = ifVar.FilenamePattern
	}
	if ifVar.OdataType != "" {
		objectMap["@odata.type"] = ifVar.OdataType
	}
	return json.Marshal(objectMap)
}

// AsImageFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsImageFormat() (*ImageFormat, bool) {
	return &ifVar, true
}

// AsBasicImageFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsBasicImageFormat() (BasicImageFormat, bool) {
	return &ifVar, true
}

// AsJpgFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsJpgFormat() (*JpgFormat, bool) {
	return nil, false
}

// AsPngFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsPngFormat() (*PngFormat, bool) {
	return nil, false
}

// AsMultiBitrateFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsMultiBitrateFormat() (*MultiBitrateFormat, bool) {
	return nil, false
}

// AsBasicMultiBitrateFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsBasicMultiBitrateFormat() (BasicMultiBitrateFormat, bool) {
	return nil, false
}

// AsMp4Format is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsMp4Format() (*Mp4Format, bool) {
	return nil, false
}

// AsTransportStreamFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsTransportStreamFormat() (*TransportStreamFormat, bool) {
	return nil, false
}

// AsFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsFormat() (*Format, bool) {
	return nil, false
}

// AsBasicFormat is the BasicFormat implementation for ImageFormat.
func (ifVar ImageFormat) AsBasicFormat() (BasicFormat, bool) {
	return &ifVar, true
}

// IPAccessControl the IP access control.
type IPAccessControl struct {
	// Allow - The IP allow list.
	Allow *[]IPRange `json:"allow,omitempty"`
}

// IPRange the IP address range in the CIDR scheme.
type IPRange struct {
	// Name - The friendly name for the IP address range.
	Name *string `json:"name,omitempty"`
	// Address - The IP address.
	Address *string `json:"address,omitempty"`
	// SubnetPrefixLength - The subnet mask prefix length (see CIDR notation).
	SubnetPrefixLength *int32 `json:"subnetPrefixLength,omitempty"`
}

// Job a Job resource type. The progress and state can be obtained by polling a Job or subscribing to
// events using EventGrid.
type Job struct {
	autorest.Response `json:"-"`
	// JobProperties - The resource properties.
	*JobProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if j.JobProperties != nil {
		objectMap["properties"] = j.JobProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Job struct.
func (j *Job) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var jobProperties JobProperties
				err = json.Unmarshal(*v, &jobProperties)
				if err != nil {
					return err
				}
				j.JobProperties = &jobProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				j.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				j.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				j.Type = &typeVar
			}
		}
	}

	return nil
}

// JobCollection a collection of Job items.
type JobCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of Job items.
	Value *[]Job `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// JobCollectionIterator provides access to a complete listing of Job values.
type JobCollectionIterator struct {
	i    int
	page JobCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *JobCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *JobCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter JobCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter JobCollectionIterator) Response() JobCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter JobCollectionIterator) Value() Job {
	if !iter.page.NotDone() {
		return Job{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the JobCollectionIterator type.
func NewJobCollectionIterator(page JobCollectionPage) JobCollectionIterator {
	return JobCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (jc JobCollection) IsEmpty() bool {
	return jc.Value == nil || len(*jc.Value) == 0
}

// jobCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (jc JobCollection) jobCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if jc.OdataNextLink == nil || len(to.String(jc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(jc.OdataNextLink)))
}

// JobCollectionPage contains a page of Job values.
type JobCollectionPage struct {
	fn func(context.Context, JobCollection) (JobCollection, error)
	jc JobCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *JobCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.jc)
	if err != nil {
		return err
	}
	page.jc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *JobCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page JobCollectionPage) NotDone() bool {
	return !page.jc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page JobCollectionPage) Response() JobCollection {
	return page.jc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page JobCollectionPage) Values() []Job {
	if page.jc.IsEmpty() {
		return nil
	}
	return *page.jc.Value
}

// Creates a new instance of the JobCollectionPage type.
func NewJobCollectionPage(getNextPage func(context.Context, JobCollection) (JobCollection, error)) JobCollectionPage {
	return JobCollectionPage{fn: getNextPage}
}

// JobError details of JobOutput errors.
type JobError struct {
	// Code - READ-ONLY; Error code describing the error. Possible values include: 'ServiceError', 'ServiceTransientError', 'DownloadNotAccessible', 'DownloadTransientError', 'UploadNotAccessible', 'UploadTransientError', 'ConfigurationUnsupported', 'ContentMalformed', 'ContentUnsupported'
	Code JobErrorCode `json:"code,omitempty"`
	// Message - READ-ONLY; A human-readable language-dependent representation of the error.
	Message *string `json:"message,omitempty"`
	// Category - READ-ONLY; Helps with categorization of errors. Possible values include: 'JobErrorCategoryService', 'JobErrorCategoryDownload', 'JobErrorCategoryUpload', 'JobErrorCategoryConfiguration', 'JobErrorCategoryContent'
	Category JobErrorCategory `json:"category,omitempty"`
	// Retry - READ-ONLY; Indicates that it may be possible to retry the Job. If retry is unsuccessful, please contact Azure support via Azure Portal. Possible values include: 'DoNotRetry', 'MayRetry'
	Retry JobRetry `json:"retry,omitempty"`
	// Details - READ-ONLY; An array of details about specific errors that led to this reported error.
	Details *[]JobErrorDetail `json:"details,omitempty"`
}

// JobErrorDetail details of JobOutput errors.
type JobErrorDetail struct {
	// Code - READ-ONLY; Code describing the error detail.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; A human-readable representation of the error.
	Message *string `json:"message,omitempty"`
}

// BasicJobInput base class for inputs to a Job.
type BasicJobInput interface {
	AsJobInputClip() (*JobInputClip, bool)
	AsBasicJobInputClip() (BasicJobInputClip, bool)
	AsJobInputs() (*JobInputs, bool)
	AsJobInputAsset() (*JobInputAsset, bool)
	AsJobInputHTTP() (*JobInputHTTP, bool)
	AsJobInput() (*JobInput, bool)
}

// JobInput base class for inputs to a Job.
type JobInput struct {
	// OdataType - Possible values include: 'OdataTypeJobInput', 'OdataTypeMicrosoftMediaJobInputClip', 'OdataTypeMicrosoftMediaJobInputs', 'OdataTypeMicrosoftMediaJobInputAsset', 'OdataTypeMicrosoftMediaJobInputHTTP'
	OdataType OdataTypeBasicJobInput `json:"@odata.type,omitempty"`
}

func unmarshalBasicJobInput(body []byte) (BasicJobInput, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaJobInputClip):
		var jic JobInputClip
		err := json.Unmarshal(body, &jic)
		return jic, err
	case string(OdataTypeMicrosoftMediaJobInputs):
		var ji JobInputs
		err := json.Unmarshal(body, &ji)
		return ji, err
	case string(OdataTypeMicrosoftMediaJobInputAsset):
		var jia JobInputAsset
		err := json.Unmarshal(body, &jia)
		return jia, err
	case string(OdataTypeMicrosoftMediaJobInputHTTP):
		var jih JobInputHTTP
		err := json.Unmarshal(body, &jih)
		return jih, err
	default:
		var ji JobInput
		err := json.Unmarshal(body, &ji)
		return ji, err
	}
}
func unmarshalBasicJobInputArray(body []byte) ([]BasicJobInput, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	jiArray := make([]BasicJobInput, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ji, err := unmarshalBasicJobInput(*rawMessage)
		if err != nil {
			return nil, err
		}
		jiArray[index] = ji
	}
	return jiArray, nil
}

// MarshalJSON is the custom marshaler for JobInput.
func (ji JobInput) MarshalJSON() ([]byte, error) {
	ji.OdataType = OdataTypeJobInput
	objectMap := make(map[string]interface{})
	if ji.OdataType != "" {
		objectMap["@odata.type"] = ji.OdataType
	}
	return json.Marshal(objectMap)
}

// AsJobInputClip is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsJobInputClip() (*JobInputClip, bool) {
	return nil, false
}

// AsBasicJobInputClip is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsBasicJobInputClip() (BasicJobInputClip, bool) {
	return nil, false
}

// AsJobInputs is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsJobInputs() (*JobInputs, bool) {
	return nil, false
}

// AsJobInputAsset is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsJobInputAsset() (*JobInputAsset, bool) {
	return nil, false
}

// AsJobInputHTTP is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsJobInputHTTP() (*JobInputHTTP, bool) {
	return nil, false
}

// AsJobInput is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsJobInput() (*JobInput, bool) {
	return &ji, true
}

// AsBasicJobInput is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsBasicJobInput() (BasicJobInput, bool) {
	return &ji, true
}

// JobInputAsset represents an Asset for input into a Job.
type JobInputAsset struct {
	// AssetName - The name of the input Asset.
	AssetName *string `json:"assetName,omitempty"`
	// Files - List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files *[]string `json:"files,omitempty"`
	// Start - Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start BasicClipTime `json:"start,omitempty"`
	// End - Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End BasicClipTime `json:"end,omitempty"`
	// Label - A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeJobInput', 'OdataTypeMicrosoftMediaJobInputClip', 'OdataTypeMicrosoftMediaJobInputs', 'OdataTypeMicrosoftMediaJobInputAsset', 'OdataTypeMicrosoftMediaJobInputHTTP'
	OdataType OdataTypeBasicJobInput `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for JobInputAsset.
func (jia JobInputAsset) MarshalJSON() ([]byte, error) {
	jia.OdataType = OdataTypeMicrosoftMediaJobInputAsset
	objectMap := make(map[string]interface{})
	if jia.AssetName != nil {
		objectMap["assetName"] = jia.AssetName
	}
	if jia.Files != nil {
		objectMap["files"] = jia.Files
	}
	objectMap["start"] = jia.Start
	objectMap["end"] = jia.End
	if jia.Label != nil {
		objectMap["label"] = jia.Label
	}
	if jia.OdataType != "" {
		objectMap["@odata.type"] = jia.OdataType
	}
	return json.Marshal(objectMap)
}

// AsJobInputClip is the BasicJobInput implementation for JobInputAsset.
func (jia JobInputAsset) AsJobInputClip() (*JobInputClip, bool) {
	return nil, false
}

// AsBasicJobInputClip is the BasicJobInput implementation for JobInputAsset.
func (jia JobInputAsset) AsBasicJobInputClip() (BasicJobInputClip, bool) {
	return &jia, true
}

// AsJobInputs is the BasicJobInput implementation for JobInputAsset.
func (jia JobInputAsset) AsJobInputs() (*JobInputs, bool) {
	return nil, false
}

// AsJobInputAsset is the BasicJobInput implementation for JobInputAsset.
func (jia JobInputAsset) AsJobInputAsset() (*JobInputAsset, bool) {
	return &jia, true
}

// AsJobInputHTTP is the BasicJobInput implementation for JobInputAsset.
func (jia JobInputAsset) AsJobInputHTTP() (*JobInputHTTP, bool) {
	return nil, false
}

// AsJobInput is the BasicJobInput implementation for JobInputAsset.
func (jia JobInputAsset) AsJobInput() (*JobInput, bool) {
	return nil, false
}

// AsBasicJobInput is the BasicJobInput implementation for JobInputAsset.
func (jia JobInputAsset) AsBasicJobInput() (BasicJobInput, bool) {
	return &jia, true
}

// UnmarshalJSON is the custom unmarshaler for JobInputAsset struct.
func (jia *JobInputAsset) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "assetName":
			if v != nil {
				var assetName string
				err = json.Unmarshal(*v, &assetName)
				if err != nil {
					return err
				}
				jia.AssetName = &assetName
			}
		case "files":
			if v != nil {
				var files []string
				err = json.Unmarshal(*v, &files)
				if err != nil {
					return err
				}
				jia.Files = &files
			}
		case "start":
			if v != nil {
				start, err := unmarshalBasicClipTime(*v)
				if err != nil {
					return err
				}
				jia.Start = start
			}
		case "end":
			if v != nil {
				end, err := unmarshalBasicClipTime(*v)
				if err != nil {
					return err
				}
				jia.End = end
			}
		case "label":
			if v != nil {
				var label string
				err = json.Unmarshal(*v, &label)
				if err != nil {
					return err
				}
				jia.Label = &label
			}
		case "@odata.type":
			if v != nil {
				var odataType OdataTypeBasicJobInput
				err = json.Unmarshal(*v, &odataType)
				if err != nil {
					return err
				}
				jia.OdataType = odataType
			}
		}
	}

	return nil
}

// BasicJobInputClip represents input files for a Job.
type BasicJobInputClip interface {
	AsJobInputAsset() (*JobInputAsset, bool)
	AsJobInputHTTP() (*JobInputHTTP, bool)
	AsJobInputClip() (*JobInputClip, bool)
}

// JobInputClip represents input files for a Job.
type JobInputClip struct {
	// Files - List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files *[]string `json:"files,omitempty"`
	// Start - Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start BasicClipTime `json:"start,omitempty"`
	// End - Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End BasicClipTime `json:"end,omitempty"`
	// Label - A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeJobInput', 'OdataTypeMicrosoftMediaJobInputClip', 'OdataTypeMicrosoftMediaJobInputs', 'OdataTypeMicrosoftMediaJobInputAsset', 'OdataTypeMicrosoftMediaJobInputHTTP'
	OdataType OdataTypeBasicJobInput `json:"@odata.type,omitempty"`
}

func unmarshalBasicJobInputClip(body []byte) (BasicJobInputClip, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaJobInputAsset):
		var jia JobInputAsset
		err := json.Unmarshal(body, &jia)
		return jia, err
	case string(OdataTypeMicrosoftMediaJobInputHTTP):
		var jih JobInputHTTP
		err := json.Unmarshal(body, &jih)
		return jih, err
	default:
		var jic JobInputClip
		err := json.Unmarshal(body, &jic)
		return jic, err
	}
}
func unmarshalBasicJobInputClipArray(body []byte) ([]BasicJobInputClip, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	jicArray := make([]BasicJobInputClip, len(rawMessages))

	for index, rawMessage := range rawMessages {
		jic, err := unmarshalBasicJobInputClip(*rawMessage)
		if err != nil {
			return nil, err
		}
		jicArray[index] = jic
	}
	return jicArray, nil
}

// MarshalJSON is the custom marshaler for JobInputClip.
func (jic JobInputClip) MarshalJSON() ([]byte, error) {
	jic.OdataType = OdataTypeMicrosoftMediaJobInputClip
	objectMap := make(map[string]interface{})
	if jic.Files != nil {
		objectMap["files"] = jic.Files
	}
	objectMap["start"] = jic.Start
	objectMap["end"] = jic.End
	if jic.Label != nil {
		objectMap["label"] = jic.Label
	}
	if jic.OdataType != "" {
		objectMap["@odata.type"] = jic.OdataType
	}
	return json.Marshal(objectMap)
}

// AsJobInputClip is the BasicJobInput implementation for JobInputClip.
func (jic JobInputClip) AsJobInputClip() (*JobInputClip, bool) {
	return &jic, true
}

// AsBasicJobInputClip is the BasicJobInput implementation for JobInputClip.
func (jic JobInputClip) AsBasicJobInputClip() (BasicJobInputClip, bool) {
	return &jic, true
}

// AsJobInputs is the BasicJobInput implementation for JobInputClip.
func (jic JobInputClip) AsJobInputs() (*JobInputs, bool) {
	return nil, false
}

// AsJobInputAsset is the BasicJobInput implementation for JobInputClip.
func (jic JobInputClip) AsJobInputAsset() (*JobInputAsset, bool) {
	return nil, false
}

// AsJobInputHTTP is the BasicJobInput implementation for JobInputClip.
func (jic JobInputClip) AsJobInputHTTP() (*JobInputHTTP, bool) {
	return nil, false
}

// AsJobInput is the BasicJobInput implementation for JobInputClip.
func (jic JobInputClip) AsJobInput() (*JobInput, bool) {
	return nil, false
}

// AsBasicJobInput is the BasicJobInput implementation for JobInputClip.
func (jic JobInputClip) AsBasicJobInput() (BasicJobInput, bool) {
	return &jic, true
}

// UnmarshalJSON is the custom unmarshaler for JobInputClip struct.
func (jic *JobInputClip) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "files":
			if v != nil {
				var files []string
				err = json.Unmarshal(*v, &files)
				if err != nil {
					return err
				}
				jic.Files = &files
			}
		case "start":
			if v != nil {
				start, err := unmarshalBasicClipTime(*v)
				if err != nil {
					return err
				}
				jic.Start = start
			}
		case "end":
			if v != nil {
				end, err := unmarshalBasicClipTime(*v)
				if err != nil {
					return err
				}
				jic.End = end
			}
		case "label":
			if v != nil {
				var label string
				err = json.Unmarshal(*v, &label)
				if err != nil {
					return err
				}
				jic.Label = &label
			}
		case "@odata.type":
			if v != nil {
				var odataType OdataTypeBasicJobInput
				err = json.Unmarshal(*v, &odataType)
				if err != nil {
					return err
				}
				jic.OdataType = odataType
			}
		}
	}

	return nil
}

// JobInputHTTP represents HTTPS job input.
type JobInputHTTP struct {
	// BaseURI - Base URI for HTTPS job input. It will be concatenated with provided file names. If no base uri is given, then the provided file list is assumed to be fully qualified uris. Maximum length of 4000 characters.
	BaseURI *string `json:"baseUri,omitempty"`
	// Files - List of files. Required for JobInputHttp. Maximum of 4000 characters each.
	Files *[]string `json:"files,omitempty"`
	// Start - Defines a point on the timeline of the input media at which processing will start. Defaults to the beginning of the input media.
	Start BasicClipTime `json:"start,omitempty"`
	// End - Defines a point on the timeline of the input media at which processing will end. Defaults to the end of the input media.
	End BasicClipTime `json:"end,omitempty"`
	// Label - A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeJobInput', 'OdataTypeMicrosoftMediaJobInputClip', 'OdataTypeMicrosoftMediaJobInputs', 'OdataTypeMicrosoftMediaJobInputAsset', 'OdataTypeMicrosoftMediaJobInputHTTP'
	OdataType OdataTypeBasicJobInput `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for JobInputHTTP.
func (jih JobInputHTTP) MarshalJSON() ([]byte, error) {
	jih.OdataType = OdataTypeMicrosoftMediaJobInputHTTP
	objectMap := make(map[string]interface{})
	if jih.BaseURI != nil {
		objectMap["baseUri"] = jih.BaseURI
	}
	if jih.Files != nil {
		objectMap["files"] = jih.Files
	}
	objectMap["start"] = jih.Start
	objectMap["end"] = jih.End
	if jih.Label != nil {
		objectMap["label"] = jih.Label
	}
	if jih.OdataType != "" {
		objectMap["@odata.type"] = jih.OdataType
	}
	return json.Marshal(objectMap)
}

// AsJobInputClip is the BasicJobInput implementation for JobInputHTTP.
func (jih JobInputHTTP) AsJobInputClip() (*JobInputClip, bool) {
	return nil, false
}

// AsBasicJobInputClip is the BasicJobInput implementation for JobInputHTTP.
func (jih JobInputHTTP) AsBasicJobInputClip() (BasicJobInputClip, bool) {
	return &jih, true
}

// AsJobInputs is the BasicJobInput implementation for JobInputHTTP.
func (jih JobInputHTTP) AsJobInputs() (*JobInputs, bool) {
	return nil, false
}

// AsJobInputAsset is the BasicJobInput implementation for JobInputHTTP.
func (jih JobInputHTTP) AsJobInputAsset() (*JobInputAsset, bool) {
	return nil, false
}

// AsJobInputHTTP is the BasicJobInput implementation for JobInputHTTP.
func (jih JobInputHTTP) AsJobInputHTTP() (*JobInputHTTP, bool) {
	return &jih, true
}

// AsJobInput is the BasicJobInput implementation for JobInputHTTP.
func (jih JobInputHTTP) AsJobInput() (*JobInput, bool) {
	return nil, false
}

// AsBasicJobInput is the BasicJobInput implementation for JobInputHTTP.
func (jih JobInputHTTP) AsBasicJobInput() (BasicJobInput, bool) {
	return &jih, true
}

// UnmarshalJSON is the custom unmarshaler for JobInputHTTP struct.
func (jih *JobInputHTTP) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "baseUri":
			if v != nil {
				var baseURI string
				err = json.Unmarshal(*v, &baseURI)
				if err != nil {
					return err
				}
				jih.BaseURI = &baseURI
			}
		case "files":
			if v != nil {
				var files []string
				err = json.Unmarshal(*v, &files)
				if err != nil {
					return err
				}
				jih.Files = &files
			}
		case "start":
			if v != nil {
				start, err := unmarshalBasicClipTime(*v)
				if err != nil {
					return err
				}
				jih.Start = start
			}
		case "end":
			if v != nil {
				end, err := unmarshalBasicClipTime(*v)
				if err != nil {
					return err
				}
				jih.End = end
			}
		case "label":
			if v != nil {
				var label string
				err = json.Unmarshal(*v, &label)
				if err != nil {
					return err
				}
				jih.Label = &label
			}
		case "@odata.type":
			if v != nil {
				var odataType OdataTypeBasicJobInput
				err = json.Unmarshal(*v, &odataType)
				if err != nil {
					return err
				}
				jih.OdataType = odataType
			}
		}
	}

	return nil
}

// JobInputs describes a list of inputs to a Job.
type JobInputs struct {
	// Inputs - List of inputs to a Job.
	Inputs *[]BasicJobInput `json:"inputs,omitempty"`
	// OdataType - Possible values include: 'OdataTypeJobInput', 'OdataTypeMicrosoftMediaJobInputClip', 'OdataTypeMicrosoftMediaJobInputs', 'OdataTypeMicrosoftMediaJobInputAsset', 'OdataTypeMicrosoftMediaJobInputHTTP'
	OdataType OdataTypeBasicJobInput `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for JobInputs.
func (ji JobInputs) MarshalJSON() ([]byte, error) {
	ji.OdataType = OdataTypeMicrosoftMediaJobInputs
	objectMap := make(map[string]interface{})
	if ji.Inputs != nil {
		objectMap["inputs"] = ji.Inputs
	}
	if ji.OdataType != "" {
		objectMap["@odata.type"] = ji.OdataType
	}
	return json.Marshal(objectMap)
}

// AsJobInputClip is the BasicJobInput implementation for JobInputs.
func (ji JobInputs) AsJobInputClip() (*JobInputClip, bool) {
	return nil, false
}

// AsBasicJobInputClip is the BasicJobInput implementation for JobInputs.
func (ji JobInputs) AsBasicJobInputClip() (BasicJobInputClip, bool) {
	return nil, false
}

// AsJobInputs is the BasicJobInput implementation for JobInputs.
func (ji JobInputs) AsJobInputs() (*JobInputs, bool) {
	return &ji, true
}

// AsJobInputAsset is the BasicJobInput implementation for JobInputs.
func (ji JobInputs) AsJobInputAsset() (*JobInputAsset, bool) {
	return nil, false
}

// AsJobInputHTTP is the BasicJobInput implementation for JobInputs.
func (ji JobInputs) AsJobInputHTTP() (*JobInputHTTP, bool) {
	return nil, false
}

// AsJobInput is the BasicJobInput implementation for JobInputs.
func (ji JobInputs) AsJobInput() (*JobInput, bool) {
	return nil, false
}

// AsBasicJobInput is the BasicJobInput implementation for JobInputs.
func (ji JobInputs) AsBasicJobInput() (BasicJobInput, bool) {
	return &ji, true
}

// UnmarshalJSON is the custom unmarshaler for JobInputs struct.
func (ji *JobInputs) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "inputs":
			if v != nil {
				inputs, err := unmarshalBasicJobInputArray(*v)
				if err != nil {
					return err
				}
				ji.Inputs = &inputs
			}
		case "@odata.type":
			if v != nil {
				var odataType OdataTypeBasicJobInput
				err = json.Unmarshal(*v, &odataType)
				if err != nil {
					return err
				}
				ji.OdataType = odataType
			}
		}
	}

	return nil
}

// BasicJobOutput describes all the properties of a JobOutput.
type BasicJobOutput interface {
	AsJobOutputAsset() (*JobOutputAsset, bool)
	AsJobOutput() (*JobOutput, bool)
}

// JobOutput describes all the properties of a JobOutput.
type JobOutput struct {
	// Error - READ-ONLY; If the JobOutput is in the Error state, it contains the details of the error.
	Error *JobError `json:"error,omitempty"`
	// State - READ-ONLY; Describes the state of the JobOutput. Possible values include: 'Canceled', 'Canceling', 'Error', 'Finished', 'Processing', 'Queued', 'Scheduled'
	State JobState `json:"state,omitempty"`
	// Progress - READ-ONLY; If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
	Progress *int32 `json:"progress,omitempty"`
	// Label - A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label *string `json:"label,omitempty"`
	// StartTime - READ-ONLY; The UTC date and time at which this Job Output began processing.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; The UTC date and time at which this Job Output finished processing.
	EndTime *date.Time `json:"endTime,omitempty"`
	// OdataType - Possible values include: 'OdataTypeJobOutput', 'OdataTypeMicrosoftMediaJobOutputAsset'
	OdataType OdataTypeBasicJobOutput `json:"@odata.type,omitempty"`
}

func unmarshalBasicJobOutput(body []byte) (BasicJobOutput, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaJobOutputAsset):
		var joa JobOutputAsset
		err := json.Unmarshal(body, &joa)
		return joa, err
	default:
		var jo JobOutput
		err := json.Unmarshal(body, &jo)
		return jo, err
	}
}
func unmarshalBasicJobOutputArray(body []byte) ([]BasicJobOutput, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	joArray := make([]BasicJobOutput, len(rawMessages))

	for index, rawMessage := range rawMessages {
		jo, err := unmarshalBasicJobOutput(*rawMessage)
		if err != nil {
			return nil, err
		}
		joArray[index] = jo
	}
	return joArray, nil
}

// MarshalJSON is the custom marshaler for JobOutput.
func (jo JobOutput) MarshalJSON() ([]byte, error) {
	jo.OdataType = OdataTypeJobOutput
	objectMap := make(map[string]interface{})
	if jo.Label != nil {
		objectMap["label"] = jo.Label
	}
	if jo.OdataType != "" {
		objectMap["@odata.type"] = jo.OdataType
	}
	return json.Marshal(objectMap)
}

// AsJobOutputAsset is the BasicJobOutput implementation for JobOutput.
func (jo JobOutput) AsJobOutputAsset() (*JobOutputAsset, bool) {
	return nil, false
}

// AsJobOutput is the BasicJobOutput implementation for JobOutput.
func (jo JobOutput) AsJobOutput() (*JobOutput, bool) {
	return &jo, true
}

// AsBasicJobOutput is the BasicJobOutput implementation for JobOutput.
func (jo JobOutput) AsBasicJobOutput() (BasicJobOutput, bool) {
	return &jo, true
}

// JobOutputAsset represents an Asset used as a JobOutput.
type JobOutputAsset struct {
	// AssetName - The name of the output Asset.
	AssetName *string `json:"assetName,omitempty"`
	// Error - READ-ONLY; If the JobOutput is in the Error state, it contains the details of the error.
	Error *JobError `json:"error,omitempty"`
	// State - READ-ONLY; Describes the state of the JobOutput. Possible values include: 'Canceled', 'Canceling', 'Error', 'Finished', 'Processing', 'Queued', 'Scheduled'
	State JobState `json:"state,omitempty"`
	// Progress - READ-ONLY; If the JobOutput is in a Processing state, this contains the Job completion percentage. The value is an estimate and not intended to be used to predict Job completion times. To determine if the JobOutput is complete, use the State property.
	Progress *int32 `json:"progress,omitempty"`
	// Label - A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform.
	Label *string `json:"label,omitempty"`
	// StartTime - READ-ONLY; The UTC date and time at which this Job Output began processing.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; The UTC date and time at which this Job Output finished processing.
	EndTime *date.Time `json:"endTime,omitempty"`
	// OdataType - Possible values include: 'OdataTypeJobOutput', 'OdataTypeMicrosoftMediaJobOutputAsset'
	OdataType OdataTypeBasicJobOutput `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for JobOutputAsset.
func (joa JobOutputAsset) MarshalJSON() ([]byte, error) {
	joa.OdataType = OdataTypeMicrosoftMediaJobOutputAsset
	objectMap := make(map[string]interface{})
	if joa.AssetName != nil {
		objectMap["assetName"] = joa.AssetName
	}
	if joa.Label != nil {
		objectMap["label"] = joa.Label
	}
	if joa.OdataType != "" {
		objectMap["@odata.type"] = joa.OdataType
	}
	return json.Marshal(objectMap)
}

// AsJobOutputAsset is the BasicJobOutput implementation for JobOutputAsset.
func (joa JobOutputAsset) AsJobOutputAsset() (*JobOutputAsset, bool) {
	return &joa, true
}

// AsJobOutput is the BasicJobOutput implementation for JobOutputAsset.
func (joa JobOutputAsset) AsJobOutput() (*JobOutput, bool) {
	return nil, false
}

// AsBasicJobOutput is the BasicJobOutput implementation for JobOutputAsset.
func (joa JobOutputAsset) AsBasicJobOutput() (BasicJobOutput, bool) {
	return &joa, true
}

// JobProperties properties of the Job.
type JobProperties struct {
	// Created - READ-ONLY; The UTC date and time when the Job was created, in 'YYYY-MM-DDThh:mm:ssZ' format.
	Created *date.Time `json:"created,omitempty"`
	// State - READ-ONLY; The current state of the job. Possible values include: 'Canceled', 'Canceling', 'Error', 'Finished', 'Processing', 'Queued', 'Scheduled'
	State JobState `json:"state,omitempty"`
	// Description - Optional customer supplied description of the Job.
	Description *string `json:"description,omitempty"`
	// Input - The inputs for the Job.
	Input BasicJobInput `json:"input,omitempty"`
	// LastModified - READ-ONLY; The UTC date and time when the Job was last updated, in 'YYYY-MM-DDThh:mm:ssZ' format.
	LastModified *date.Time `json:"lastModified,omitempty"`
	// Outputs - The outputs for the Job.
	Outputs *[]BasicJobOutput `json:"outputs,omitempty"`
	// Priority - Priority with which the job should be processed. Higher priority jobs are processed before lower priority jobs. If not set, the default is normal. Possible values include: 'Low', 'Normal', 'High'
	Priority Priority `json:"priority,omitempty"`
	// CorrelationData - Customer provided key, value pairs that will be returned in Job and JobOutput state events.
	CorrelationData map[string]*string `json:"correlationData"`
	// StartTime - READ-ONLY; The UTC date and time at which this Job began processing.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - READ-ONLY; The UTC date and time at which this Job finished processing.
	EndTime *date.Time `json:"endTime,omitempty"`
}

// MarshalJSON is the custom marshaler for JobProperties.
func (jp JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if jp.Description != nil {
		objectMap["description"] = jp.Description
	}
	objectMap["input"] = jp.Input
	if jp.Outputs != nil {
		objectMap["outputs"] = jp.Outputs
	}
	if jp.Priority != "" {
		objectMap["priority"] = jp.Priority
	}
	if jp.CorrelationData != nil {
		objectMap["correlationData"] = jp.CorrelationData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for JobProperties struct.
func (jp *JobProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "created":
			if v != nil {
				var created date.Time
				err = json.Unmarshal(*v, &created)
				if err != nil {
					return err
				}
				jp.Created = &created
			}
		case "state":
			if v != nil {
				var state JobState
				err = json.Unmarshal(*v, &state)
				if err != nil {
					return err
				}
				jp.State = state
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				jp.Description = &description
			}
		case "input":
			if v != nil {
				input, err := unmarshalBasicJobInput(*v)
				if err != nil {
					return err
				}
				jp.Input = input
			}
		case "lastModified":
			if v != nil {
				var lastModified date.Time
				err = json.Unmarshal(*v, &lastModified)
				if err != nil {
					return err
				}
				jp.LastModified = &lastModified
			}
		case "outputs":
			if v != nil {
				outputs, err := unmarshalBasicJobOutputArray(*v)
				if err != nil {
					return err
				}
				jp.Outputs = &outputs
			}
		case "priority":
			if v != nil {
				var priority Priority
				err = json.Unmarshal(*v, &priority)
				if err != nil {
					return err
				}
				jp.Priority = priority
			}
		case "correlationData":
			if v != nil {
				var correlationData map[string]*string
				err = json.Unmarshal(*v, &correlationData)
				if err != nil {
					return err
				}
				jp.CorrelationData = correlationData
			}
		case "startTime":
			if v != nil {
				var startTime date.Time
				err = json.Unmarshal(*v, &startTime)
				if err != nil {
					return err
				}
				jp.StartTime = &startTime
			}
		case "endTime":
			if v != nil {
				var endTime date.Time
				err = json.Unmarshal(*v, &endTime)
				if err != nil {
					return err
				}
				jp.EndTime = &endTime
			}
		}
	}

	return nil
}

// JpgFormat describes the settings for producing JPEG thumbnails.
type JpgFormat struct {
	// FilenamePattern - The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - The base name of the input video {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`
	// OdataType - Possible values include: 'OdataTypeFormat', 'OdataTypeMicrosoftMediaImageFormat', 'OdataTypeMicrosoftMediaJpgFormat', 'OdataTypeMicrosoftMediaPngFormat', 'OdataTypeMicrosoftMediaMultiBitrateFormat', 'OdataTypeMicrosoftMediaMp4Format', 'OdataTypeMicrosoftMediaTransportStreamFormat'
	OdataType OdataTypeBasicFormat `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for JpgFormat.
func (jf JpgFormat) MarshalJSON() ([]byte, error) {
	jf.OdataType = OdataTypeMicrosoftMediaJpgFormat
	objectMap := make(map[string]interface{})
	if jf.FilenamePattern != nil {
		objectMap["filenamePattern"] = jf.FilenamePattern
	}
	if jf.OdataType != "" {
		objectMap["@odata.type"] = jf.OdataType
	}
	return json.Marshal(objectMap)
}

// AsImageFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsImageFormat() (*ImageFormat, bool) {
	return nil, false
}

// AsBasicImageFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsBasicImageFormat() (BasicImageFormat, bool) {
	return &jf, true
}

// AsJpgFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsJpgFormat() (*JpgFormat, bool) {
	return &jf, true
}

// AsPngFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsPngFormat() (*PngFormat, bool) {
	return nil, false
}

// AsMultiBitrateFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsMultiBitrateFormat() (*MultiBitrateFormat, bool) {
	return nil, false
}

// AsBasicMultiBitrateFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsBasicMultiBitrateFormat() (BasicMultiBitrateFormat, bool) {
	return nil, false
}

// AsMp4Format is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsMp4Format() (*Mp4Format, bool) {
	return nil, false
}

// AsTransportStreamFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsTransportStreamFormat() (*TransportStreamFormat, bool) {
	return nil, false
}

// AsFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsFormat() (*Format, bool) {
	return nil, false
}

// AsBasicFormat is the BasicFormat implementation for JpgFormat.
func (jf JpgFormat) AsBasicFormat() (BasicFormat, bool) {
	return &jf, true
}

// JpgImage describes the properties for producing a series of JPEG images from the input video.
type JpgImage struct {
	// Layers - A collection of output JPEG image layers to be produced by the encoder.
	Layers *[]JpgLayer `json:"layers,omitempty"`
	// Start - The position in the input video from where to start generating thumbnails. The value can be in absolute timestamp (ISO 8601, e.g: PT05S), or a frame count (For example, 10 for the 10th frame), or a relative value (For example, 1%). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video.
	Start *string `json:"start,omitempty"`
	// Step - The intervals at which thumbnails are generated. The value can be in absolute timestamp (ISO 8601, e.g: PT05S for one image every 5 seconds), or a frame count (For example, 30 for every 30 frames), or a relative value (For example, 1%).
	Step *string `json:"step,omitempty"`
	// Range - The position in the input video at which to stop generating thumbnails. The value can be in absolute timestamp (ISO 8601, e.g: PT5M30S to stop at 5 minutes and 30 seconds), or a frame count (For example, 300 to stop at the 300th frame), or a relative value (For example, 100%).
	Range *string `json:"range,omitempty"`
	// KeyFrameInterval - The distance between two key frames, thereby defining a group of pictures (GOP). The value should be a non-zero integer in the range [1, 30] seconds, specified in ISO 8601 format. The default is 2 seconds (PT2S).
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`
	// StretchMode - The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize. Possible values include: 'StretchModeNone', 'StretchModeAutoSize', 'StretchModeAutoFit'
	StretchMode StretchMode `json:"stretchMode,omitempty"`
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for JpgImage.
func (ji JpgImage) MarshalJSON() ([]byte, error) {
	ji.OdataType = OdataTypeMicrosoftMediaJpgImage
	objectMap := make(map[string]interface{})
	if ji.Layers != nil {
		objectMap["layers"] = ji.Layers
	}
	if ji.Start != nil {
		objectMap["start"] = ji.Start
	}
	if ji.Step != nil {
		objectMap["step"] = ji.Step
	}
	if ji.Range != nil {
		objectMap["range"] = ji.Range
	}
	if ji.KeyFrameInterval != nil {
		objectMap["keyFrameInterval"] = ji.KeyFrameInterval
	}
	if ji.StretchMode != "" {
		objectMap["stretchMode"] = ji.StretchMode
	}
	if ji.Label != nil {
		objectMap["label"] = ji.Label
	}
	if ji.OdataType != "" {
		objectMap["@odata.type"] = ji.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsBasicAudio() (BasicAudio, bool) {
	return nil, false
}

// AsAacAudio is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsBasicVideo() (BasicVideo, bool) {
	return &ji, true
}

// AsImage is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsBasicImage() (BasicImage, bool) {
	return &ji, true
}

// AsCopyAudio is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsJpgImage() (*JpgImage, bool) {
	return &ji, true
}

// AsPngImage is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for JpgImage.
func (ji JpgImage) AsBasicCodec() (BasicCodec, bool) {
	return &ji, true
}

// JpgLayer describes the settings to produce a JPEG image from the input video.
type JpgLayer struct {
	// Quality - The compression quality of the JPEG output. Range is from 0-100 and the default is 70.
	Quality *int32 `json:"quality,omitempty"`
	// Width - The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
	// Height - The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`
	// Label - The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeLayer', 'OdataTypeMicrosoftMediaVideoLayer', 'OdataTypeMicrosoftMediaH264Layer', 'OdataTypeMicrosoftMediaJpgLayer', 'OdataTypeMicrosoftMediaPngLayer'
	OdataType OdataTypeBasicLayer `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for JpgLayer.
func (jl JpgLayer) MarshalJSON() ([]byte, error) {
	jl.OdataType = OdataTypeMicrosoftMediaJpgLayer
	objectMap := make(map[string]interface{})
	if jl.Quality != nil {
		objectMap["quality"] = jl.Quality
	}
	if jl.Width != nil {
		objectMap["width"] = jl.Width
	}
	if jl.Height != nil {
		objectMap["height"] = jl.Height
	}
	if jl.Label != nil {
		objectMap["label"] = jl.Label
	}
	if jl.OdataType != "" {
		objectMap["@odata.type"] = jl.OdataType
	}
	return json.Marshal(objectMap)
}

// AsVideoLayer is the BasicLayer implementation for JpgLayer.
func (jl JpgLayer) AsVideoLayer() (*VideoLayer, bool) {
	return nil, false
}

// AsBasicVideoLayer is the BasicLayer implementation for JpgLayer.
func (jl JpgLayer) AsBasicVideoLayer() (BasicVideoLayer, bool) {
	return nil, false
}

// AsH264Layer is the BasicLayer implementation for JpgLayer.
func (jl JpgLayer) AsH264Layer() (*H264Layer, bool) {
	return nil, false
}

// AsJpgLayer is the BasicLayer implementation for JpgLayer.
func (jl JpgLayer) AsJpgLayer() (*JpgLayer, bool) {
	return &jl, true
}

// AsPngLayer is the BasicLayer implementation for JpgLayer.
func (jl JpgLayer) AsPngLayer() (*PngLayer, bool) {
	return nil, false
}

// AsLayer is the BasicLayer implementation for JpgLayer.
func (jl JpgLayer) AsLayer() (*Layer, bool) {
	return nil, false
}

// AsBasicLayer is the BasicLayer implementation for JpgLayer.
func (jl JpgLayer) AsBasicLayer() (BasicLayer, bool) {
	return &jl, true
}

// BasicLayer the encoder can be configured to produce video and/or images (thumbnails) at different resolutions, by
// specifying a layer for each desired resolution. A layer represents the properties for the video or image at a
// resolution.
type BasicLayer interface {
	AsVideoLayer() (*VideoLayer, bool)
	AsBasicVideoLayer() (BasicVideoLayer, bool)
	AsH264Layer() (*H264Layer, bool)
	AsJpgLayer() (*JpgLayer, bool)
	AsPngLayer() (*PngLayer, bool)
	AsLayer() (*Layer, bool)
}

// Layer the encoder can be configured to produce video and/or images (thumbnails) at different resolutions, by
// specifying a layer for each desired resolution. A layer represents the properties for the video or image at
// a resolution.
type Layer struct {
	// Width - The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
	// Height - The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`
	// Label - The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeLayer', 'OdataTypeMicrosoftMediaVideoLayer', 'OdataTypeMicrosoftMediaH264Layer', 'OdataTypeMicrosoftMediaJpgLayer', 'OdataTypeMicrosoftMediaPngLayer'
	OdataType OdataTypeBasicLayer `json:"@odata.type,omitempty"`
}

func unmarshalBasicLayer(body []byte) (BasicLayer, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaVideoLayer):
		var vl VideoLayer
		err := json.Unmarshal(body, &vl)
		return vl, err
	case string(OdataTypeMicrosoftMediaH264Layer):
		var hl H264Layer
		err := json.Unmarshal(body, &hl)
		return hl, err
	case string(OdataTypeMicrosoftMediaJpgLayer):
		var jl JpgLayer
		err := json.Unmarshal(body, &jl)
		return jl, err
	case string(OdataTypeMicrosoftMediaPngLayer):
		var pl PngLayer
		err := json.Unmarshal(body, &pl)
		return pl, err
	default:
		var l Layer
		err := json.Unmarshal(body, &l)
		return l, err
	}
}
func unmarshalBasicLayerArray(body []byte) ([]BasicLayer, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	lArray := make([]BasicLayer, len(rawMessages))

	for index, rawMessage := range rawMessages {
		l, err := unmarshalBasicLayer(*rawMessage)
		if err != nil {
			return nil, err
		}
		lArray[index] = l
	}
	return lArray, nil
}

// MarshalJSON is the custom marshaler for Layer.
func (l Layer) MarshalJSON() ([]byte, error) {
	l.OdataType = OdataTypeLayer
	objectMap := make(map[string]interface{})
	if l.Width != nil {
		objectMap["width"] = l.Width
	}
	if l.Height != nil {
		objectMap["height"] = l.Height
	}
	if l.Label != nil {
		objectMap["label"] = l.Label
	}
	if l.OdataType != "" {
		objectMap["@odata.type"] = l.OdataType
	}
	return json.Marshal(objectMap)
}

// AsVideoLayer is the BasicLayer implementation for Layer.
func (l Layer) AsVideoLayer() (*VideoLayer, bool) {
	return nil, false
}

// AsBasicVideoLayer is the BasicLayer implementation for Layer.
func (l Layer) AsBasicVideoLayer() (BasicVideoLayer, bool) {
	return nil, false
}

// AsH264Layer is the BasicLayer implementation for Layer.
func (l Layer) AsH264Layer() (*H264Layer, bool) {
	return nil, false
}

// AsJpgLayer is the BasicLayer implementation for Layer.
func (l Layer) AsJpgLayer() (*JpgLayer, bool) {
	return nil, false
}

// AsPngLayer is the BasicLayer implementation for Layer.
func (l Layer) AsPngLayer() (*PngLayer, bool) {
	return nil, false
}

// AsLayer is the BasicLayer implementation for Layer.
func (l Layer) AsLayer() (*Layer, bool) {
	return &l, true
}

// AsBasicLayer is the BasicLayer implementation for Layer.
func (l Layer) AsBasicLayer() (BasicLayer, bool) {
	return &l, true
}

// ListContainerSasInput the parameters to the list SAS request.
type ListContainerSasInput struct {
	// Permissions - The permissions to set on the SAS URL. Possible values include: 'Read', 'ReadWrite', 'ReadWriteDelete'
	Permissions AssetContainerPermission `json:"permissions,omitempty"`
	// ExpiryTime - The SAS URL expiration time.  This must be less than 24 hours from the current time.
	ExpiryTime *date.Time `json:"expiryTime,omitempty"`
}

// ListContentKeysResponse class of response for listContentKeys action
type ListContentKeysResponse struct {
	autorest.Response `json:"-"`
	// ContentKeys - ContentKeys used by current Streaming Locator
	ContentKeys *[]StreamingLocatorContentKey `json:"contentKeys,omitempty"`
}

// ListEdgePoliciesInput ...
type ListEdgePoliciesInput struct {
	// DeviceID - Unique identifier of the edge device.
	DeviceID *string `json:"deviceId,omitempty"`
}

// ListPathsResponse class of response for listPaths action
type ListPathsResponse struct {
	autorest.Response `json:"-"`
	// StreamingPaths - Streaming Paths supported by current Streaming Locator
	StreamingPaths *[]StreamingPath `json:"streamingPaths,omitempty"`
	// DownloadPaths - Download Paths supported by current Streaming Locator
	DownloadPaths *[]string `json:"downloadPaths,omitempty"`
}

// ListStreamingLocatorsResponse the Streaming Locators associated with this Asset.
type ListStreamingLocatorsResponse struct {
	autorest.Response `json:"-"`
	// StreamingLocators - READ-ONLY; The list of Streaming Locators.
	StreamingLocators *[]AssetStreamingLocator `json:"streamingLocators,omitempty"`
}

// LiveEvent the Live Event.
type LiveEvent struct {
	autorest.Response `json:"-"`
	// LiveEventProperties - The Live Event properties.
	*LiveEventProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The Azure Region of the resource.
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for LiveEvent.
func (le LiveEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if le.LiveEventProperties != nil {
		objectMap["properties"] = le.LiveEventProperties
	}
	if le.Tags != nil {
		objectMap["tags"] = le.Tags
	}
	if le.Location != nil {
		objectMap["location"] = le.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LiveEvent struct.
func (le *LiveEvent) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var liveEventProperties LiveEventProperties
				err = json.Unmarshal(*v, &liveEventProperties)
				if err != nil {
					return err
				}
				le.LiveEventProperties = &liveEventProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				le.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				le.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				le.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				le.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				le.Type = &typeVar
			}
		}
	}

	return nil
}

// LiveEventActionInput the LiveEvent action input parameter definition.
type LiveEventActionInput struct {
	// RemoveOutputsOnStop - The flag indicates if remove LiveOutputs on Stop.
	RemoveOutputsOnStop *bool `json:"removeOutputsOnStop,omitempty"`
}

// LiveEventEncoding the Live Event encoding.
type LiveEventEncoding struct {
	// EncodingType - The encoding type for Live Event.  This value is specified at creation time and cannot be updated. Possible values include: 'LiveEventEncodingTypeNone', 'LiveEventEncodingTypeBasic', 'LiveEventEncodingTypeStandard', 'LiveEventEncodingTypePremium1080p'
	EncodingType LiveEventEncodingType `json:"encodingType,omitempty"`
	// PresetName - The encoding preset name.  This value is specified at creation time and cannot be updated.
	PresetName *string `json:"presetName,omitempty"`
}

// LiveEventEndpoint the Live Event endpoint.
type LiveEventEndpoint struct {
	// Protocol - The endpoint protocol.
	Protocol *string `json:"protocol,omitempty"`
	// URL - The endpoint URL.
	URL *string `json:"url,omitempty"`
}

// LiveEventInput the Live Event input.
type LiveEventInput struct {
	// StreamingProtocol - The streaming protocol for the Live Event.  This is specified at creation time and cannot be updated. Possible values include: 'FragmentedMP4', 'RTMP'
	StreamingProtocol LiveEventInputProtocol `json:"streamingProtocol,omitempty"`
	// AccessControl - The access control for LiveEvent Input.
	AccessControl *LiveEventInputAccessControl `json:"accessControl,omitempty"`
	// KeyFrameIntervalDuration - ISO 8601 timespan duration of the key frame interval duration.
	KeyFrameIntervalDuration *string `json:"keyFrameIntervalDuration,omitempty"`
	// AccessToken - A unique identifier for a stream.  This can be specified at creation time but cannot be updated.  If omitted, the service will generate a unique value.
	AccessToken *string `json:"accessToken,omitempty"`
	// Endpoints - The input endpoints for the Live Event.
	Endpoints *[]LiveEventEndpoint `json:"endpoints,omitempty"`
}

// LiveEventInputAccessControl the IP access control for Live Event Input.
type LiveEventInputAccessControl struct {
	// IP - The IP access control properties.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// LiveEventListResult the LiveEvent list result.
type LiveEventListResult struct {
	autorest.Response `json:"-"`
	// Value - The result of the List Live Event operation.
	Value *[]LiveEvent `json:"value,omitempty"`
	// OdataCount - The number of result.
	OdataCount *int32 `json:"@odata.count,omitempty"`
	// OdataNextLink - Th link to the next set of results. Not empty if value contains incomplete list of Live Outputs.
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// LiveEventListResultIterator provides access to a complete listing of LiveEvent values.
type LiveEventListResultIterator struct {
	i    int
	page LiveEventListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LiveEventListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LiveEventListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LiveEventListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LiveEventListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LiveEventListResultIterator) Response() LiveEventListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LiveEventListResultIterator) Value() LiveEvent {
	if !iter.page.NotDone() {
		return LiveEvent{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LiveEventListResultIterator type.
func NewLiveEventListResultIterator(page LiveEventListResultPage) LiveEventListResultIterator {
	return LiveEventListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lelr LiveEventListResult) IsEmpty() bool {
	return lelr.Value == nil || len(*lelr.Value) == 0
}

// liveEventListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lelr LiveEventListResult) liveEventListResultPreparer(ctx context.Context) (*http.Request, error) {
	if lelr.OdataNextLink == nil || len(to.String(lelr.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lelr.OdataNextLink)))
}

// LiveEventListResultPage contains a page of LiveEvent values.
type LiveEventListResultPage struct {
	fn   func(context.Context, LiveEventListResult) (LiveEventListResult, error)
	lelr LiveEventListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LiveEventListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LiveEventListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.lelr)
	if err != nil {
		return err
	}
	page.lelr = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LiveEventListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LiveEventListResultPage) NotDone() bool {
	return !page.lelr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LiveEventListResultPage) Response() LiveEventListResult {
	return page.lelr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LiveEventListResultPage) Values() []LiveEvent {
	if page.lelr.IsEmpty() {
		return nil
	}
	return *page.lelr.Value
}

// Creates a new instance of the LiveEventListResultPage type.
func NewLiveEventListResultPage(getNextPage func(context.Context, LiveEventListResult) (LiveEventListResult, error)) LiveEventListResultPage {
	return LiveEventListResultPage{fn: getNextPage}
}

// LiveEventPreview the Live Event preview.
type LiveEventPreview struct {
	// Endpoints - The endpoints for preview.
	Endpoints *[]LiveEventEndpoint `json:"endpoints,omitempty"`
	// AccessControl - The access control for LiveEvent preview.
	AccessControl *LiveEventPreviewAccessControl `json:"accessControl,omitempty"`
	// PreviewLocator - The identifier of the preview locator in Guid format.  Specifying this at creation time allows the caller to know the preview locator url before the event is created.  If omitted, the service will generate a random identifier.  This value cannot be updated once the live event is created.
	PreviewLocator *string `json:"previewLocator,omitempty"`
	// StreamingPolicyName - The name of streaming policy used for the LiveEvent preview.  This value is specified at creation time and cannot be updated.
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty"`
	// AlternativeMediaID - An Alternative Media Identifier associated with the StreamingLocator created for the preview.  This value is specified at creation time and cannot be updated.  The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty"`
}

// LiveEventPreviewAccessControl the IP access control for Live Event preview.
type LiveEventPreviewAccessControl struct {
	// IP - The IP access control properties.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// LiveEventProperties the Live Event properties.
type LiveEventProperties struct {
	// Description - The Live Event description.
	Description *string `json:"description,omitempty"`
	// Input - The Live Event input.
	Input *LiveEventInput `json:"input,omitempty"`
	// Preview - The Live Event preview.
	Preview *LiveEventPreview `json:"preview,omitempty"`
	// Encoding - The Live Event encoding.
	Encoding *LiveEventEncoding `json:"encoding,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the Live Event.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// ResourceState - READ-ONLY; The resource state of the Live Event. Possible values include: 'Stopped', 'Starting', 'Running', 'Stopping', 'Deleting'
	ResourceState LiveEventResourceState `json:"resourceState,omitempty"`
	// CrossSiteAccessPolicies - The Live Event access policies.
	CrossSiteAccessPolicies *CrossSiteAccessPolicies `json:"crossSiteAccessPolicies,omitempty"`
	// VanityURL - Specifies whether to use a vanity url with the Live Event.  This value is specified at creation time and cannot be updated.
	VanityURL *bool `json:"vanityUrl,omitempty"`
	// StreamOptions - The options to use for the LiveEvent.  This value is specified at creation time and cannot be updated.
	StreamOptions *[]StreamOptionsFlag `json:"streamOptions,omitempty"`
	// Created - READ-ONLY; The exact time the Live Event was created.
	Created *date.Time `json:"created,omitempty"`
	// LastModified - READ-ONLY; The exact time the Live Event was last modified.
	LastModified *date.Time `json:"lastModified,omitempty"`
}

// LiveEventsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LiveEventsCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LiveEventsCreateFuture) Result(client LiveEventsClient) (le LiveEvent, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.LiveEventsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.LiveEventsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if le.Response.Response, err = future.GetResult(sender); err == nil && le.Response.Response.StatusCode != http.StatusNoContent {
		le, err = client.CreateResponder(le.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "media.LiveEventsCreateFuture", "Result", le.Response.Response, "Failure responding to request")
		}
	}
	return
}

// LiveEventsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LiveEventsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LiveEventsDeleteFuture) Result(client LiveEventsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.LiveEventsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.LiveEventsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// LiveEventsResetFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LiveEventsResetFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LiveEventsResetFuture) Result(client LiveEventsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.LiveEventsResetFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.LiveEventsResetFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// LiveEventsStartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LiveEventsStartFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LiveEventsStartFuture) Result(client LiveEventsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.LiveEventsStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.LiveEventsStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// LiveEventsStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LiveEventsStopFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LiveEventsStopFuture) Result(client LiveEventsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.LiveEventsStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.LiveEventsStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// LiveEventsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LiveEventsUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LiveEventsUpdateFuture) Result(client LiveEventsClient) (le LiveEvent, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.LiveEventsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.LiveEventsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if le.Response.Response, err = future.GetResult(sender); err == nil && le.Response.Response.StatusCode != http.StatusNoContent {
		le, err = client.UpdateResponder(le.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "media.LiveEventsUpdateFuture", "Result", le.Response.Response, "Failure responding to request")
		}
	}
	return
}

// LiveOutput the Live Output.
type LiveOutput struct {
	autorest.Response `json:"-"`
	// LiveOutputProperties - The Live Output properties.
	*LiveOutputProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for LiveOutput.
func (lo LiveOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lo.LiveOutputProperties != nil {
		objectMap["properties"] = lo.LiveOutputProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LiveOutput struct.
func (lo *LiveOutput) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var liveOutputProperties LiveOutputProperties
				err = json.Unmarshal(*v, &liveOutputProperties)
				if err != nil {
					return err
				}
				lo.LiveOutputProperties = &liveOutputProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				lo.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lo.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lo.Type = &typeVar
			}
		}
	}

	return nil
}

// LiveOutputListResult the LiveOutput list result.
type LiveOutputListResult struct {
	autorest.Response `json:"-"`
	// Value - The result of the List Live Output operation.
	Value *[]LiveOutput `json:"value,omitempty"`
	// OdataCount - The number of result.
	OdataCount *int32 `json:"@odata.count,omitempty"`
	// OdataNextLink - Th link to the next set of results. Not empty if value contains incomplete list of Live Outputs.
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// LiveOutputListResultIterator provides access to a complete listing of LiveOutput values.
type LiveOutputListResultIterator struct {
	i    int
	page LiveOutputListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LiveOutputListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LiveOutputListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LiveOutputListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LiveOutputListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LiveOutputListResultIterator) Response() LiveOutputListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LiveOutputListResultIterator) Value() LiveOutput {
	if !iter.page.NotDone() {
		return LiveOutput{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LiveOutputListResultIterator type.
func NewLiveOutputListResultIterator(page LiveOutputListResultPage) LiveOutputListResultIterator {
	return LiveOutputListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lolr LiveOutputListResult) IsEmpty() bool {
	return lolr.Value == nil || len(*lolr.Value) == 0
}

// liveOutputListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lolr LiveOutputListResult) liveOutputListResultPreparer(ctx context.Context) (*http.Request, error) {
	if lolr.OdataNextLink == nil || len(to.String(lolr.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lolr.OdataNextLink)))
}

// LiveOutputListResultPage contains a page of LiveOutput values.
type LiveOutputListResultPage struct {
	fn   func(context.Context, LiveOutputListResult) (LiveOutputListResult, error)
	lolr LiveOutputListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LiveOutputListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LiveOutputListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.lolr)
	if err != nil {
		return err
	}
	page.lolr = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LiveOutputListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LiveOutputListResultPage) NotDone() bool {
	return !page.lolr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LiveOutputListResultPage) Response() LiveOutputListResult {
	return page.lolr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LiveOutputListResultPage) Values() []LiveOutput {
	if page.lolr.IsEmpty() {
		return nil
	}
	return *page.lolr.Value
}

// Creates a new instance of the LiveOutputListResultPage type.
func NewLiveOutputListResultPage(getNextPage func(context.Context, LiveOutputListResult) (LiveOutputListResult, error)) LiveOutputListResultPage {
	return LiveOutputListResultPage{fn: getNextPage}
}

// LiveOutputProperties the JSON object that contains the properties required to create a Live Output.
type LiveOutputProperties struct {
	// Description - The description of the Live Output.
	Description *string `json:"description,omitempty"`
	// AssetName - The asset name.
	AssetName *string `json:"assetName,omitempty"`
	// ArchiveWindowLength - ISO 8601 timespan duration of the archive window length. This is duration that customer want to retain the recorded content.
	ArchiveWindowLength *string `json:"archiveWindowLength,omitempty"`
	// ManifestName - The manifest file name.  If not provided, the service will generate one automatically.
	ManifestName *string `json:"manifestName,omitempty"`
	// Hls - The HLS configuration.
	Hls *Hls `json:"hls,omitempty"`
	// OutputSnapTime - The output snapshot time.
	OutputSnapTime *int64 `json:"outputSnapTime,omitempty"`
	// Created - READ-ONLY; The exact time the Live Output was created.
	Created *date.Time `json:"created,omitempty"`
	// LastModified - READ-ONLY; The exact time the Live Output was last modified.
	LastModified *date.Time `json:"lastModified,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the Live Output.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// ResourceState - READ-ONLY; The resource state of the Live Output. Possible values include: 'LiveOutputResourceStateCreating', 'LiveOutputResourceStateRunning', 'LiveOutputResourceStateDeleting'
	ResourceState LiveOutputResourceState `json:"resourceState,omitempty"`
}

// LiveOutputsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LiveOutputsCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LiveOutputsCreateFuture) Result(client LiveOutputsClient) (lo LiveOutput, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.LiveOutputsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.LiveOutputsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lo.Response.Response, err = future.GetResult(sender); err == nil && lo.Response.Response.StatusCode != http.StatusNoContent {
		lo, err = client.CreateResponder(lo.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "media.LiveOutputsCreateFuture", "Result", lo.Response.Response, "Failure responding to request")
		}
	}
	return
}

// LiveOutputsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LiveOutputsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LiveOutputsDeleteFuture) Result(client LiveOutputsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.LiveOutputsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.LiveOutputsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// Location ...
type Location struct {
	Name *string `json:"name,omitempty"`
}

// Metric a metric emitted by service.
type Metric struct {
	// Name - READ-ONLY; The metric name.
	Name *string `json:"name,omitempty"`
	// DisplayName - READ-ONLY; The metric display name.
	DisplayName *string `json:"displayName,omitempty"`
	// DisplayDescription - READ-ONLY; The metric display description.
	DisplayDescription *string `json:"displayDescription,omitempty"`
	// Unit - READ-ONLY; The metric unit. Possible values include: 'MetricUnitBytes', 'MetricUnitCount', 'MetricUnitMilliseconds'
	Unit MetricUnit `json:"unit,omitempty"`
	// AggregationType - READ-ONLY; The metric aggregation type. Possible values include: 'Average', 'Count', 'Total'
	AggregationType MetricAggregationType `json:"aggregationType,omitempty"`
	// Dimensions - READ-ONLY; The metric dimensions.
	Dimensions *[]MetricDimension `json:"dimensions,omitempty"`
}

// MetricDimension a metric dimension.
type MetricDimension struct {
	// Name - READ-ONLY; The metric dimension name.
	Name *string `json:"name,omitempty"`
	// DisplayName - READ-ONLY; The display name for the dimension.
	DisplayName *string `json:"displayName,omitempty"`
	// ToBeExportedForShoebox - READ-ONLY; Whether to export metric to shoebox.
	ToBeExportedForShoebox *bool `json:"toBeExportedForShoebox,omitempty"`
}

// MetricProperties metric properties.
type MetricProperties struct {
	// ServiceSpecification - READ-ONLY; The service specifications.
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty"`
}

// Mp4Format describes the properties for an output ISO MP4 file.
type Mp4Format struct {
	// OutputFiles - The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles *[]OutputFile `json:"outputFiles,omitempty"`
	// FilenamePattern - The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - The base name of the input video {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`
	// OdataType - Possible values include: 'OdataTypeFormat', 'OdataTypeMicrosoftMediaImageFormat', 'OdataTypeMicrosoftMediaJpgFormat', 'OdataTypeMicrosoftMediaPngFormat', 'OdataTypeMicrosoftMediaMultiBitrateFormat', 'OdataTypeMicrosoftMediaMp4Format', 'OdataTypeMicrosoftMediaTransportStreamFormat'
	OdataType OdataTypeBasicFormat `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for Mp4Format.
func (m4f Mp4Format) MarshalJSON() ([]byte, error) {
	m4f.OdataType = OdataTypeMicrosoftMediaMp4Format
	objectMap := make(map[string]interface{})
	if m4f.OutputFiles != nil {
		objectMap["outputFiles"] = m4f.OutputFiles
	}
	if m4f.FilenamePattern != nil {
		objectMap["filenamePattern"] = m4f.FilenamePattern
	}
	if m4f.OdataType != "" {
		objectMap["@odata.type"] = m4f.OdataType
	}
	return json.Marshal(objectMap)
}

// AsImageFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsImageFormat() (*ImageFormat, bool) {
	return nil, false
}

// AsBasicImageFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsBasicImageFormat() (BasicImageFormat, bool) {
	return nil, false
}

// AsJpgFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsJpgFormat() (*JpgFormat, bool) {
	return nil, false
}

// AsPngFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsPngFormat() (*PngFormat, bool) {
	return nil, false
}

// AsMultiBitrateFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsMultiBitrateFormat() (*MultiBitrateFormat, bool) {
	return nil, false
}

// AsBasicMultiBitrateFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsBasicMultiBitrateFormat() (BasicMultiBitrateFormat, bool) {
	return &m4f, true
}

// AsMp4Format is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsMp4Format() (*Mp4Format, bool) {
	return &m4f, true
}

// AsTransportStreamFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsTransportStreamFormat() (*TransportStreamFormat, bool) {
	return nil, false
}

// AsFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsFormat() (*Format, bool) {
	return nil, false
}

// AsBasicFormat is the BasicFormat implementation for Mp4Format.
func (m4f Mp4Format) AsBasicFormat() (BasicFormat, bool) {
	return &m4f, true
}

// BasicMultiBitrateFormat describes the properties for producing a collection of GOP aligned multi-bitrate files. The
// default behavior is to produce one output file for each video layer which is muxed together with all the audios. The
// exact output files produced can be controlled by specifying the outputFiles collection.
type BasicMultiBitrateFormat interface {
	AsMp4Format() (*Mp4Format, bool)
	AsTransportStreamFormat() (*TransportStreamFormat, bool)
	AsMultiBitrateFormat() (*MultiBitrateFormat, bool)
}

// MultiBitrateFormat describes the properties for producing a collection of GOP aligned multi-bitrate files.
// The default behavior is to produce one output file for each video layer which is muxed together with all the
// audios. The exact output files produced can be controlled by specifying the outputFiles collection.
type MultiBitrateFormat struct {
	// OutputFiles - The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles *[]OutputFile `json:"outputFiles,omitempty"`
	// FilenamePattern - The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - The base name of the input video {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`
	// OdataType - Possible values include: 'OdataTypeFormat', 'OdataTypeMicrosoftMediaImageFormat', 'OdataTypeMicrosoftMediaJpgFormat', 'OdataTypeMicrosoftMediaPngFormat', 'OdataTypeMicrosoftMediaMultiBitrateFormat', 'OdataTypeMicrosoftMediaMp4Format', 'OdataTypeMicrosoftMediaTransportStreamFormat'
	OdataType OdataTypeBasicFormat `json:"@odata.type,omitempty"`
}

func unmarshalBasicMultiBitrateFormat(body []byte) (BasicMultiBitrateFormat, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaMp4Format):
		var m4f Mp4Format
		err := json.Unmarshal(body, &m4f)
		return m4f, err
	case string(OdataTypeMicrosoftMediaTransportStreamFormat):
		var tsf TransportStreamFormat
		err := json.Unmarshal(body, &tsf)
		return tsf, err
	default:
		var mbf MultiBitrateFormat
		err := json.Unmarshal(body, &mbf)
		return mbf, err
	}
}
func unmarshalBasicMultiBitrateFormatArray(body []byte) ([]BasicMultiBitrateFormat, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	mbfArray := make([]BasicMultiBitrateFormat, len(rawMessages))

	for index, rawMessage := range rawMessages {
		mbf, err := unmarshalBasicMultiBitrateFormat(*rawMessage)
		if err != nil {
			return nil, err
		}
		mbfArray[index] = mbf
	}
	return mbfArray, nil
}

// MarshalJSON is the custom marshaler for MultiBitrateFormat.
func (mbf MultiBitrateFormat) MarshalJSON() ([]byte, error) {
	mbf.OdataType = OdataTypeMicrosoftMediaMultiBitrateFormat
	objectMap := make(map[string]interface{})
	if mbf.OutputFiles != nil {
		objectMap["outputFiles"] = mbf.OutputFiles
	}
	if mbf.FilenamePattern != nil {
		objectMap["filenamePattern"] = mbf.FilenamePattern
	}
	if mbf.OdataType != "" {
		objectMap["@odata.type"] = mbf.OdataType
	}
	return json.Marshal(objectMap)
}

// AsImageFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsImageFormat() (*ImageFormat, bool) {
	return nil, false
}

// AsBasicImageFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsBasicImageFormat() (BasicImageFormat, bool) {
	return nil, false
}

// AsJpgFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsJpgFormat() (*JpgFormat, bool) {
	return nil, false
}

// AsPngFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsPngFormat() (*PngFormat, bool) {
	return nil, false
}

// AsMultiBitrateFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsMultiBitrateFormat() (*MultiBitrateFormat, bool) {
	return &mbf, true
}

// AsBasicMultiBitrateFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsBasicMultiBitrateFormat() (BasicMultiBitrateFormat, bool) {
	return &mbf, true
}

// AsMp4Format is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsMp4Format() (*Mp4Format, bool) {
	return nil, false
}

// AsTransportStreamFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsTransportStreamFormat() (*TransportStreamFormat, bool) {
	return nil, false
}

// AsFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsFormat() (*Format, bool) {
	return nil, false
}

// AsBasicFormat is the BasicFormat implementation for MultiBitrateFormat.
func (mbf MultiBitrateFormat) AsBasicFormat() (BasicFormat, bool) {
	return &mbf, true
}

// NoEncryption class for NoEncryption scheme
type NoEncryption struct {
	// EnabledProtocols - Representing supported protocols
	EnabledProtocols *EnabledProtocols `json:"enabledProtocols,omitempty"`
}

// ODataError information about an error.
type ODataError struct {
	// Code - A language-independent error name.
	Code *string `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Target - The target of the error (for example, the name of the property in error).
	Target *string `json:"target,omitempty"`
	// Details - The error details.
	Details *[]ODataError `json:"details,omitempty"`
}

// Operation an operation.
type Operation struct {
	// Name - The operation name.
	Name *string `json:"name,omitempty"`
	// Display - The operation display name.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - Origin of the operation.
	Origin *string `json:"origin,omitempty"`
	// Properties - Operation properties format.
	Properties *MetricProperties `json:"properties,omitempty"`
}

// OperationCollection a collection of Operation items.
type OperationCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of Operation items.
	Value *[]Operation `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// OperationCollectionIterator provides access to a complete listing of Operation values.
type OperationCollectionIterator struct {
	i    int
	page OperationCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationCollectionIterator) Response() OperationCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationCollectionIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationCollectionIterator type.
func NewOperationCollectionIterator(page OperationCollectionPage) OperationCollectionIterator {
	return OperationCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (oc OperationCollection) IsEmpty() bool {
	return oc.Value == nil || len(*oc.Value) == 0
}

// operationCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (oc OperationCollection) operationCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if oc.OdataNextLink == nil || len(to.String(oc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(oc.OdataNextLink)))
}

// OperationCollectionPage contains a page of Operation values.
type OperationCollectionPage struct {
	fn func(context.Context, OperationCollection) (OperationCollection, error)
	oc OperationCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.oc)
	if err != nil {
		return err
	}
	page.oc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationCollectionPage) NotDone() bool {
	return !page.oc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationCollectionPage) Response() OperationCollection {
	return page.oc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationCollectionPage) Values() []Operation {
	if page.oc.IsEmpty() {
		return nil
	}
	return *page.oc.Value
}

// Creates a new instance of the OperationCollectionPage type.
func NewOperationCollectionPage(getNextPage func(context.Context, OperationCollection) (OperationCollection, error)) OperationCollectionPage {
	return OperationCollectionPage{fn: getNextPage}
}

// OperationDisplay operation details.
type OperationDisplay struct {
	// Provider - The service provider.
	Provider *string `json:"provider,omitempty"`
	// Resource - Resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Operation - The operation type.
	Operation *string `json:"operation,omitempty"`
	// Description - The operation description.
	Description *string `json:"description,omitempty"`
}

// OutputFile represents an output file produced.
type OutputFile struct {
	// Labels - The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels v1 and v2, and one audio layer with label a1, then an array like '[v1, a1]' tells the encoder to produce an output file with the video track represented by v1 and the audio track represented by a1.
	Labels *[]string `json:"labels,omitempty"`
}

// BasicOverlay base type for all overlays - image, audio or video.
type BasicOverlay interface {
	AsAudioOverlay() (*AudioOverlay, bool)
	AsVideoOverlay() (*VideoOverlay, bool)
	AsOverlay() (*Overlay, bool)
}

// Overlay base type for all overlays - image, audio or video.
type Overlay struct {
	// InputLabel - The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG or PNG formats, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel *string `json:"inputLabel,omitempty"`
	// Start - The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds in to the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `json:"start,omitempty"`
	// End - The position in the input video at which the overlay ends. The value should be in ISO 8601 duration format. For example, PT30S to end the overlay at 30 seconds in to the input video. If not specified the overlay will be applied until the end of the input video if inputLoop is true. Else, if inputLoop is false, then overlay will last as long as the duration of the overlay media.
	End *string `json:"end,omitempty"`
	// FadeInDuration - The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `json:"fadeInDuration,omitempty"`
	// FadeOutDuration - The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `json:"fadeOutDuration,omitempty"`
	// AudioGainLevel - The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `json:"audioGainLevel,omitempty"`
	// OdataType - Possible values include: 'OdataTypeOverlay', 'OdataTypeMicrosoftMediaAudioOverlay', 'OdataTypeMicrosoftMediaVideoOverlay'
	OdataType OdataTypeBasicOverlay `json:"@odata.type,omitempty"`
}

func unmarshalBasicOverlay(body []byte) (BasicOverlay, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaAudioOverlay):
		var ao AudioOverlay
		err := json.Unmarshal(body, &ao)
		return ao, err
	case string(OdataTypeMicrosoftMediaVideoOverlay):
		var vo VideoOverlay
		err := json.Unmarshal(body, &vo)
		return vo, err
	default:
		var o Overlay
		err := json.Unmarshal(body, &o)
		return o, err
	}
}
func unmarshalBasicOverlayArray(body []byte) ([]BasicOverlay, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	oArray := make([]BasicOverlay, len(rawMessages))

	for index, rawMessage := range rawMessages {
		o, err := unmarshalBasicOverlay(*rawMessage)
		if err != nil {
			return nil, err
		}
		oArray[index] = o
	}
	return oArray, nil
}

// MarshalJSON is the custom marshaler for Overlay.
func (o Overlay) MarshalJSON() ([]byte, error) {
	o.OdataType = OdataTypeOverlay
	objectMap := make(map[string]interface{})
	if o.InputLabel != nil {
		objectMap["inputLabel"] = o.InputLabel
	}
	if o.Start != nil {
		objectMap["start"] = o.Start
	}
	if o.End != nil {
		objectMap["end"] = o.End
	}
	if o.FadeInDuration != nil {
		objectMap["fadeInDuration"] = o.FadeInDuration
	}
	if o.FadeOutDuration != nil {
		objectMap["fadeOutDuration"] = o.FadeOutDuration
	}
	if o.AudioGainLevel != nil {
		objectMap["audioGainLevel"] = o.AudioGainLevel
	}
	if o.OdataType != "" {
		objectMap["@odata.type"] = o.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudioOverlay is the BasicOverlay implementation for Overlay.
func (o Overlay) AsAudioOverlay() (*AudioOverlay, bool) {
	return nil, false
}

// AsVideoOverlay is the BasicOverlay implementation for Overlay.
func (o Overlay) AsVideoOverlay() (*VideoOverlay, bool) {
	return nil, false
}

// AsOverlay is the BasicOverlay implementation for Overlay.
func (o Overlay) AsOverlay() (*Overlay, bool) {
	return &o, true
}

// AsBasicOverlay is the BasicOverlay implementation for Overlay.
func (o Overlay) AsBasicOverlay() (BasicOverlay, bool) {
	return &o, true
}

// PngFormat describes the settings for producing PNG thumbnails.
type PngFormat struct {
	// FilenamePattern - The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - The base name of the input video {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`
	// OdataType - Possible values include: 'OdataTypeFormat', 'OdataTypeMicrosoftMediaImageFormat', 'OdataTypeMicrosoftMediaJpgFormat', 'OdataTypeMicrosoftMediaPngFormat', 'OdataTypeMicrosoftMediaMultiBitrateFormat', 'OdataTypeMicrosoftMediaMp4Format', 'OdataTypeMicrosoftMediaTransportStreamFormat'
	OdataType OdataTypeBasicFormat `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for PngFormat.
func (pf PngFormat) MarshalJSON() ([]byte, error) {
	pf.OdataType = OdataTypeMicrosoftMediaPngFormat
	objectMap := make(map[string]interface{})
	if pf.FilenamePattern != nil {
		objectMap["filenamePattern"] = pf.FilenamePattern
	}
	if pf.OdataType != "" {
		objectMap["@odata.type"] = pf.OdataType
	}
	return json.Marshal(objectMap)
}

// AsImageFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsImageFormat() (*ImageFormat, bool) {
	return nil, false
}

// AsBasicImageFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsBasicImageFormat() (BasicImageFormat, bool) {
	return &pf, true
}

// AsJpgFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsJpgFormat() (*JpgFormat, bool) {
	return nil, false
}

// AsPngFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsPngFormat() (*PngFormat, bool) {
	return &pf, true
}

// AsMultiBitrateFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsMultiBitrateFormat() (*MultiBitrateFormat, bool) {
	return nil, false
}

// AsBasicMultiBitrateFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsBasicMultiBitrateFormat() (BasicMultiBitrateFormat, bool) {
	return nil, false
}

// AsMp4Format is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsMp4Format() (*Mp4Format, bool) {
	return nil, false
}

// AsTransportStreamFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsTransportStreamFormat() (*TransportStreamFormat, bool) {
	return nil, false
}

// AsFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsFormat() (*Format, bool) {
	return nil, false
}

// AsBasicFormat is the BasicFormat implementation for PngFormat.
func (pf PngFormat) AsBasicFormat() (BasicFormat, bool) {
	return &pf, true
}

// PngImage describes the properties for producing a series of PNG images from the input video.
type PngImage struct {
	// Layers - A collection of output PNG image layers to be produced by the encoder.
	Layers *[]PngLayer `json:"layers,omitempty"`
	// Start - The position in the input video from where to start generating thumbnails. The value can be in absolute timestamp (ISO 8601, e.g: PT05S), or a frame count (For example, 10 for the 10th frame), or a relative value (For example, 1%). Also supports a macro {Best}, which tells the encoder to select the best thumbnail from the first few seconds of the video.
	Start *string `json:"start,omitempty"`
	// Step - The intervals at which thumbnails are generated. The value can be in absolute timestamp (ISO 8601, e.g: PT05S for one image every 5 seconds), or a frame count (For example, 30 for every 30 frames), or a relative value (For example, 1%).
	Step *string `json:"step,omitempty"`
	// Range - The position in the input video at which to stop generating thumbnails. The value can be in absolute timestamp (ISO 8601, e.g: PT5M30S to stop at 5 minutes and 30 seconds), or a frame count (For example, 300 to stop at the 300th frame), or a relative value (For example, 100%).
	Range *string `json:"range,omitempty"`
	// KeyFrameInterval - The distance between two key frames, thereby defining a group of pictures (GOP). The value should be a non-zero integer in the range [1, 30] seconds, specified in ISO 8601 format. The default is 2 seconds (PT2S).
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`
	// StretchMode - The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize. Possible values include: 'StretchModeNone', 'StretchModeAutoSize', 'StretchModeAutoFit'
	StretchMode StretchMode `json:"stretchMode,omitempty"`
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for PngImage.
func (pi PngImage) MarshalJSON() ([]byte, error) {
	pi.OdataType = OdataTypeMicrosoftMediaPngImage
	objectMap := make(map[string]interface{})
	if pi.Layers != nil {
		objectMap["layers"] = pi.Layers
	}
	if pi.Start != nil {
		objectMap["start"] = pi.Start
	}
	if pi.Step != nil {
		objectMap["step"] = pi.Step
	}
	if pi.Range != nil {
		objectMap["range"] = pi.Range
	}
	if pi.KeyFrameInterval != nil {
		objectMap["keyFrameInterval"] = pi.KeyFrameInterval
	}
	if pi.StretchMode != "" {
		objectMap["stretchMode"] = pi.StretchMode
	}
	if pi.Label != nil {
		objectMap["label"] = pi.Label
	}
	if pi.OdataType != "" {
		objectMap["@odata.type"] = pi.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for PngImage.
func (pi PngImage) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for PngImage.
func (pi PngImage) AsBasicAudio() (BasicAudio, bool) {
	return nil, false
}

// AsAacAudio is the BasicCodec implementation for PngImage.
func (pi PngImage) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for PngImage.
func (pi PngImage) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for PngImage.
func (pi PngImage) AsVideo() (*Video, bool) {
	return nil, false
}

// AsBasicVideo is the BasicCodec implementation for PngImage.
func (pi PngImage) AsBasicVideo() (BasicVideo, bool) {
	return &pi, true
}

// AsImage is the BasicCodec implementation for PngImage.
func (pi PngImage) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for PngImage.
func (pi PngImage) AsBasicImage() (BasicImage, bool) {
	return &pi, true
}

// AsCopyAudio is the BasicCodec implementation for PngImage.
func (pi PngImage) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for PngImage.
func (pi PngImage) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for PngImage.
func (pi PngImage) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for PngImage.
func (pi PngImage) AsPngImage() (*PngImage, bool) {
	return &pi, true
}

// AsCodec is the BasicCodec implementation for PngImage.
func (pi PngImage) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for PngImage.
func (pi PngImage) AsBasicCodec() (BasicCodec, bool) {
	return &pi, true
}

// PngLayer describes the settings to produce a PNG image from the input video.
type PngLayer struct {
	// Width - The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
	// Height - The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`
	// Label - The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeLayer', 'OdataTypeMicrosoftMediaVideoLayer', 'OdataTypeMicrosoftMediaH264Layer', 'OdataTypeMicrosoftMediaJpgLayer', 'OdataTypeMicrosoftMediaPngLayer'
	OdataType OdataTypeBasicLayer `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for PngLayer.
func (pl PngLayer) MarshalJSON() ([]byte, error) {
	pl.OdataType = OdataTypeMicrosoftMediaPngLayer
	objectMap := make(map[string]interface{})
	if pl.Width != nil {
		objectMap["width"] = pl.Width
	}
	if pl.Height != nil {
		objectMap["height"] = pl.Height
	}
	if pl.Label != nil {
		objectMap["label"] = pl.Label
	}
	if pl.OdataType != "" {
		objectMap["@odata.type"] = pl.OdataType
	}
	return json.Marshal(objectMap)
}

// AsVideoLayer is the BasicLayer implementation for PngLayer.
func (pl PngLayer) AsVideoLayer() (*VideoLayer, bool) {
	return nil, false
}

// AsBasicVideoLayer is the BasicLayer implementation for PngLayer.
func (pl PngLayer) AsBasicVideoLayer() (BasicVideoLayer, bool) {
	return nil, false
}

// AsH264Layer is the BasicLayer implementation for PngLayer.
func (pl PngLayer) AsH264Layer() (*H264Layer, bool) {
	return nil, false
}

// AsJpgLayer is the BasicLayer implementation for PngLayer.
func (pl PngLayer) AsJpgLayer() (*JpgLayer, bool) {
	return nil, false
}

// AsPngLayer is the BasicLayer implementation for PngLayer.
func (pl PngLayer) AsPngLayer() (*PngLayer, bool) {
	return &pl, true
}

// AsLayer is the BasicLayer implementation for PngLayer.
func (pl PngLayer) AsLayer() (*Layer, bool) {
	return nil, false
}

// AsBasicLayer is the BasicLayer implementation for PngLayer.
func (pl PngLayer) AsBasicLayer() (BasicLayer, bool) {
	return &pl, true
}

// PresentationTimeRange the presentation time range, this is asset related and not recommended for Account
// Filter.
type PresentationTimeRange struct {
	// StartTimestamp - The absolute start time boundary.
	StartTimestamp *int64 `json:"startTimestamp,omitempty"`
	// EndTimestamp - The absolute end time boundary.
	EndTimestamp *int64 `json:"endTimestamp,omitempty"`
	// PresentationWindowDuration - The relative to end sliding window.
	PresentationWindowDuration *int64 `json:"presentationWindowDuration,omitempty"`
	// LiveBackoffDuration - The relative to end right edge.
	LiveBackoffDuration *int64 `json:"liveBackoffDuration,omitempty"`
	// Timescale - The time scale of time stamps.
	Timescale *int64 `json:"timescale,omitempty"`
	// ForceEndTimestamp - The indicator of forcing existing of end time stamp.
	ForceEndTimestamp *bool `json:"forceEndTimestamp,omitempty"`
}

// BasicPreset base type for all Presets, which define the recipe or instructions on how the input media files should
// be processed.
type BasicPreset interface {
	AsFaceDetectorPreset() (*FaceDetectorPreset, bool)
	AsAudioAnalyzerPreset() (*AudioAnalyzerPreset, bool)
	AsBasicAudioAnalyzerPreset() (BasicAudioAnalyzerPreset, bool)
	AsBuiltInStandardEncoderPreset() (*BuiltInStandardEncoderPreset, bool)
	AsStandardEncoderPreset() (*StandardEncoderPreset, bool)
	AsVideoAnalyzerPreset() (*VideoAnalyzerPreset, bool)
	AsPreset() (*Preset, bool)
}

// Preset base type for all Presets, which define the recipe or instructions on how the input media files
// should be processed.
type Preset struct {
	// OdataType - Possible values include: 'OdataTypePreset', 'OdataTypeMicrosoftMediaFaceDetectorPreset', 'OdataTypeMicrosoftMediaAudioAnalyzerPreset', 'OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset', 'OdataTypeMicrosoftMediaStandardEncoderPreset', 'OdataTypeMicrosoftMediaVideoAnalyzerPreset'
	OdataType OdataTypeBasicPreset `json:"@odata.type,omitempty"`
}

func unmarshalBasicPreset(body []byte) (BasicPreset, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaFaceDetectorPreset):
		var fdp FaceDetectorPreset
		err := json.Unmarshal(body, &fdp)
		return fdp, err
	case string(OdataTypeMicrosoftMediaAudioAnalyzerPreset):
		var aap AudioAnalyzerPreset
		err := json.Unmarshal(body, &aap)
		return aap, err
	case string(OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset):
		var bisep BuiltInStandardEncoderPreset
		err := json.Unmarshal(body, &bisep)
		return bisep, err
	case string(OdataTypeMicrosoftMediaStandardEncoderPreset):
		var sep StandardEncoderPreset
		err := json.Unmarshal(body, &sep)
		return sep, err
	case string(OdataTypeMicrosoftMediaVideoAnalyzerPreset):
		var vap VideoAnalyzerPreset
		err := json.Unmarshal(body, &vap)
		return vap, err
	default:
		var p Preset
		err := json.Unmarshal(body, &p)
		return p, err
	}
}
func unmarshalBasicPresetArray(body []byte) ([]BasicPreset, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	pArray := make([]BasicPreset, len(rawMessages))

	for index, rawMessage := range rawMessages {
		p, err := unmarshalBasicPreset(*rawMessage)
		if err != nil {
			return nil, err
		}
		pArray[index] = p
	}
	return pArray, nil
}

// MarshalJSON is the custom marshaler for Preset.
func (p Preset) MarshalJSON() ([]byte, error) {
	p.OdataType = OdataTypePreset
	objectMap := make(map[string]interface{})
	if p.OdataType != "" {
		objectMap["@odata.type"] = p.OdataType
	}
	return json.Marshal(objectMap)
}

// AsFaceDetectorPreset is the BasicPreset implementation for Preset.
func (p Preset) AsFaceDetectorPreset() (*FaceDetectorPreset, bool) {
	return nil, false
}

// AsAudioAnalyzerPreset is the BasicPreset implementation for Preset.
func (p Preset) AsAudioAnalyzerPreset() (*AudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBasicAudioAnalyzerPreset is the BasicPreset implementation for Preset.
func (p Preset) AsBasicAudioAnalyzerPreset() (BasicAudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBuiltInStandardEncoderPreset is the BasicPreset implementation for Preset.
func (p Preset) AsBuiltInStandardEncoderPreset() (*BuiltInStandardEncoderPreset, bool) {
	return nil, false
}

// AsStandardEncoderPreset is the BasicPreset implementation for Preset.
func (p Preset) AsStandardEncoderPreset() (*StandardEncoderPreset, bool) {
	return nil, false
}

// AsVideoAnalyzerPreset is the BasicPreset implementation for Preset.
func (p Preset) AsVideoAnalyzerPreset() (*VideoAnalyzerPreset, bool) {
	return nil, false
}

// AsPreset is the BasicPreset implementation for Preset.
func (p Preset) AsPreset() (*Preset, bool) {
	return &p, true
}

// AsBasicPreset is the BasicPreset implementation for Preset.
func (p Preset) AsBasicPreset() (BasicPreset, bool) {
	return &p, true
}

// Provider a resource provider.
type Provider struct {
	// ProviderName - The provider name.
	ProviderName *string `json:"providerName,omitempty"`
}

// ProxyResource the resource model definition for a ARM proxy resource.
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// Rectangle describes the properties of a rectangular window applied to the input media before processing
// it.
type Rectangle struct {
	// Left - The number of pixels from the left-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Left *string `json:"left,omitempty"`
	// Top - The number of pixels from the top-margin. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Top *string `json:"top,omitempty"`
	// Width - The width of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Width *string `json:"width,omitempty"`
	// Height - The height of the rectangular region in pixels. This can be absolute pixel value (e.g 100), or relative to the size of the video (For example, 50%).
	Height *string `json:"height,omitempty"`
}

// Resource the core properties of ARM resources.
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// Service a Media Services account.
type Service struct {
	autorest.Response `json:"-"`
	// ServiceProperties - The resource properties.
	*ServiceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The Azure Region of the resource.
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Service.
func (s Service) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.ServiceProperties != nil {
		objectMap["properties"] = s.ServiceProperties
	}
	if s.Tags != nil {
		objectMap["tags"] = s.Tags
	}
	if s.Location != nil {
		objectMap["location"] = s.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Service struct.
func (s *Service) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serviceProperties ServiceProperties
				err = json.Unmarshal(*v, &serviceProperties)
				if err != nil {
					return err
				}
				s.ServiceProperties = &serviceProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				s.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				s.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				s.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				s.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				s.Type = &typeVar
			}
		}
	}

	return nil
}

// ServiceCollection a collection of MediaService items.
type ServiceCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of MediaService items.
	Value *[]Service `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// ServiceCollectionIterator provides access to a complete listing of Service values.
type ServiceCollectionIterator struct {
	i    int
	page ServiceCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ServiceCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServiceCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ServiceCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ServiceCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ServiceCollectionIterator) Response() ServiceCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ServiceCollectionIterator) Value() Service {
	if !iter.page.NotDone() {
		return Service{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ServiceCollectionIterator type.
func NewServiceCollectionIterator(page ServiceCollectionPage) ServiceCollectionIterator {
	return ServiceCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sc ServiceCollection) IsEmpty() bool {
	return sc.Value == nil || len(*sc.Value) == 0
}

// serviceCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sc ServiceCollection) serviceCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if sc.OdataNextLink == nil || len(to.String(sc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sc.OdataNextLink)))
}

// ServiceCollectionPage contains a page of Service values.
type ServiceCollectionPage struct {
	fn func(context.Context, ServiceCollection) (ServiceCollection, error)
	sc ServiceCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ServiceCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServiceCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.sc)
	if err != nil {
		return err
	}
	page.sc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ServiceCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ServiceCollectionPage) NotDone() bool {
	return !page.sc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ServiceCollectionPage) Response() ServiceCollection {
	return page.sc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ServiceCollectionPage) Values() []Service {
	if page.sc.IsEmpty() {
		return nil
	}
	return *page.sc.Value
}

// Creates a new instance of the ServiceCollectionPage type.
func NewServiceCollectionPage(getNextPage func(context.Context, ServiceCollection) (ServiceCollection, error)) ServiceCollectionPage {
	return ServiceCollectionPage{fn: getNextPage}
}

// ServiceProperties properties of the Media Services account.
type ServiceProperties struct {
	// MediaServiceID - READ-ONLY; The Media Services account ID.
	MediaServiceID *uuid.UUID `json:"mediaServiceId,omitempty"`
	// StorageAccounts - The storage accounts for this resource.
	StorageAccounts *[]StorageAccount `json:"storageAccounts,omitempty"`
}

// ServiceSpecification the service metric specifications.
type ServiceSpecification struct {
	// MetricSpecifications - READ-ONLY; List of metric specifications.
	MetricSpecifications *[]Metric `json:"metricSpecifications,omitempty"`
}

// StandardEncoderPreset describes all the settings to be used when encoding the input video with the
// Standard Encoder.
type StandardEncoderPreset struct {
	// Filters - One or more filtering operations that are applied to the input media before encoding.
	Filters *Filters `json:"filters,omitempty"`
	// Codecs - The list of codecs to be used when encoding the input video.
	Codecs *[]BasicCodec `json:"codecs,omitempty"`
	// Formats - The list of outputs to be produced by the encoder.
	Formats *[]BasicFormat `json:"formats,omitempty"`
	// OdataType - Possible values include: 'OdataTypePreset', 'OdataTypeMicrosoftMediaFaceDetectorPreset', 'OdataTypeMicrosoftMediaAudioAnalyzerPreset', 'OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset', 'OdataTypeMicrosoftMediaStandardEncoderPreset', 'OdataTypeMicrosoftMediaVideoAnalyzerPreset'
	OdataType OdataTypeBasicPreset `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for StandardEncoderPreset.
func (sep StandardEncoderPreset) MarshalJSON() ([]byte, error) {
	sep.OdataType = OdataTypeMicrosoftMediaStandardEncoderPreset
	objectMap := make(map[string]interface{})
	if sep.Filters != nil {
		objectMap["filters"] = sep.Filters
	}
	if sep.Codecs != nil {
		objectMap["codecs"] = sep.Codecs
	}
	if sep.Formats != nil {
		objectMap["formats"] = sep.Formats
	}
	if sep.OdataType != "" {
		objectMap["@odata.type"] = sep.OdataType
	}
	return json.Marshal(objectMap)
}

// AsFaceDetectorPreset is the BasicPreset implementation for StandardEncoderPreset.
func (sep StandardEncoderPreset) AsFaceDetectorPreset() (*FaceDetectorPreset, bool) {
	return nil, false
}

// AsAudioAnalyzerPreset is the BasicPreset implementation for StandardEncoderPreset.
func (sep StandardEncoderPreset) AsAudioAnalyzerPreset() (*AudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBasicAudioAnalyzerPreset is the BasicPreset implementation for StandardEncoderPreset.
func (sep StandardEncoderPreset) AsBasicAudioAnalyzerPreset() (BasicAudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBuiltInStandardEncoderPreset is the BasicPreset implementation for StandardEncoderPreset.
func (sep StandardEncoderPreset) AsBuiltInStandardEncoderPreset() (*BuiltInStandardEncoderPreset, bool) {
	return nil, false
}

// AsStandardEncoderPreset is the BasicPreset implementation for StandardEncoderPreset.
func (sep StandardEncoderPreset) AsStandardEncoderPreset() (*StandardEncoderPreset, bool) {
	return &sep, true
}

// AsVideoAnalyzerPreset is the BasicPreset implementation for StandardEncoderPreset.
func (sep StandardEncoderPreset) AsVideoAnalyzerPreset() (*VideoAnalyzerPreset, bool) {
	return nil, false
}

// AsPreset is the BasicPreset implementation for StandardEncoderPreset.
func (sep StandardEncoderPreset) AsPreset() (*Preset, bool) {
	return nil, false
}

// AsBasicPreset is the BasicPreset implementation for StandardEncoderPreset.
func (sep StandardEncoderPreset) AsBasicPreset() (BasicPreset, bool) {
	return &sep, true
}

// UnmarshalJSON is the custom unmarshaler for StandardEncoderPreset struct.
func (sep *StandardEncoderPreset) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "filters":
			if v != nil {
				var filters Filters
				err = json.Unmarshal(*v, &filters)
				if err != nil {
					return err
				}
				sep.Filters = &filters
			}
		case "codecs":
			if v != nil {
				codecs, err := unmarshalBasicCodecArray(*v)
				if err != nil {
					return err
				}
				sep.Codecs = &codecs
			}
		case "formats":
			if v != nil {
				formats, err := unmarshalBasicFormatArray(*v)
				if err != nil {
					return err
				}
				sep.Formats = &formats
			}
		case "@odata.type":
			if v != nil {
				var odataType OdataTypeBasicPreset
				err = json.Unmarshal(*v, &odataType)
				if err != nil {
					return err
				}
				sep.OdataType = odataType
			}
		}
	}

	return nil
}

// StorageAccount the storage account details.
type StorageAccount struct {
	// ID - The ID of the storage account resource. Media Services relies on tables and queues as well as blobs, so the primary storage account must be a Standard Storage account (either Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as secondary storage accounts.
	ID *string `json:"id,omitempty"`
	// Type - The type of the storage account. Possible values include: 'Primary', 'Secondary'
	Type StorageAccountType `json:"type,omitempty"`
}

// StorageEncryptedAssetDecryptionData data needed to decrypt asset files encrypted with legacy storage
// encryption.
type StorageEncryptedAssetDecryptionData struct {
	autorest.Response `json:"-"`
	// Key - The Asset File storage encryption key.
	Key *[]byte `json:"key,omitempty"`
	// AssetFileEncryptionMetadata - Asset File encryption metadata.
	AssetFileEncryptionMetadata *[]AssetFileEncryptionMetadata `json:"assetFileEncryptionMetadata,omitempty"`
}

// StreamingEndpoint the StreamingEndpoint.
type StreamingEndpoint struct {
	autorest.Response `json:"-"`
	// StreamingEndpointProperties - The StreamingEndpoint properties.
	*StreamingEndpointProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The Azure Region of the resource.
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StreamingEndpoint.
func (se StreamingEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if se.StreamingEndpointProperties != nil {
		objectMap["properties"] = se.StreamingEndpointProperties
	}
	if se.Tags != nil {
		objectMap["tags"] = se.Tags
	}
	if se.Location != nil {
		objectMap["location"] = se.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StreamingEndpoint struct.
func (se *StreamingEndpoint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var streamingEndpointProperties StreamingEndpointProperties
				err = json.Unmarshal(*v, &streamingEndpointProperties)
				if err != nil {
					return err
				}
				se.StreamingEndpointProperties = &streamingEndpointProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				se.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				se.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				se.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				se.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				se.Type = &typeVar
			}
		}
	}

	return nil
}

// StreamingEndpointAccessControl streamingEndpoint access control definition.
type StreamingEndpointAccessControl struct {
	// Akamai - The access control of Akamai
	Akamai *AkamaiAccessControl `json:"akamai,omitempty"`
	// IP - The IP access control of the StreamingEndpoint.
	IP *IPAccessControl `json:"ip,omitempty"`
}

// StreamingEndpointListResult the StreamingEndpoint list result.
type StreamingEndpointListResult struct {
	autorest.Response `json:"-"`
	// Value - The result of the List StreamingEndpoint operation.
	Value *[]StreamingEndpoint `json:"value,omitempty"`
	// OdataCount - The number of result.
	OdataCount *int32 `json:"@odata.count,omitempty"`
	// OdataNextLink - Th link to the next set of results. Not empty if value contains incomplete list of StreamingEndpoints.
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// StreamingEndpointListResultIterator provides access to a complete listing of StreamingEndpoint values.
type StreamingEndpointListResultIterator struct {
	i    int
	page StreamingEndpointListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StreamingEndpointListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StreamingEndpointListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StreamingEndpointListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StreamingEndpointListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StreamingEndpointListResultIterator) Response() StreamingEndpointListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StreamingEndpointListResultIterator) Value() StreamingEndpoint {
	if !iter.page.NotDone() {
		return StreamingEndpoint{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StreamingEndpointListResultIterator type.
func NewStreamingEndpointListResultIterator(page StreamingEndpointListResultPage) StreamingEndpointListResultIterator {
	return StreamingEndpointListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (selr StreamingEndpointListResult) IsEmpty() bool {
	return selr.Value == nil || len(*selr.Value) == 0
}

// streamingEndpointListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (selr StreamingEndpointListResult) streamingEndpointListResultPreparer(ctx context.Context) (*http.Request, error) {
	if selr.OdataNextLink == nil || len(to.String(selr.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(selr.OdataNextLink)))
}

// StreamingEndpointListResultPage contains a page of StreamingEndpoint values.
type StreamingEndpointListResultPage struct {
	fn   func(context.Context, StreamingEndpointListResult) (StreamingEndpointListResult, error)
	selr StreamingEndpointListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StreamingEndpointListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StreamingEndpointListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.selr)
	if err != nil {
		return err
	}
	page.selr = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StreamingEndpointListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StreamingEndpointListResultPage) NotDone() bool {
	return !page.selr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StreamingEndpointListResultPage) Response() StreamingEndpointListResult {
	return page.selr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StreamingEndpointListResultPage) Values() []StreamingEndpoint {
	if page.selr.IsEmpty() {
		return nil
	}
	return *page.selr.Value
}

// Creates a new instance of the StreamingEndpointListResultPage type.
func NewStreamingEndpointListResultPage(getNextPage func(context.Context, StreamingEndpointListResult) (StreamingEndpointListResult, error)) StreamingEndpointListResultPage {
	return StreamingEndpointListResultPage{fn: getNextPage}
}

// StreamingEndpointProperties the StreamingEndpoint properties.
type StreamingEndpointProperties struct {
	// Description - The StreamingEndpoint description.
	Description *string `json:"description,omitempty"`
	// ScaleUnits - The number of scale units.  Use the Scale operation to adjust this value.
	ScaleUnits *int32 `json:"scaleUnits,omitempty"`
	// AvailabilitySetName - The name of the AvailabilitySet used with this StreamingEndpoint for high availability streaming.  This value can only be set at creation time.
	AvailabilitySetName *string `json:"availabilitySetName,omitempty"`
	// AccessControl - The access control definition of the StreamingEndpoint.
	AccessControl *StreamingEndpointAccessControl `json:"accessControl,omitempty"`
	// MaxCacheAge - Max cache age
	MaxCacheAge *int64 `json:"maxCacheAge,omitempty"`
	// CustomHostNames - The custom host names of the StreamingEndpoint
	CustomHostNames *[]string `json:"customHostNames,omitempty"`
	// HostName - READ-ONLY; The StreamingEndpoint host name.
	HostName *string `json:"hostName,omitempty"`
	// CdnEnabled - The CDN enabled flag.
	CdnEnabled *bool `json:"cdnEnabled,omitempty"`
	// CdnProvider - The CDN provider name.
	CdnProvider *string `json:"cdnProvider,omitempty"`
	// CdnProfile - The CDN profile name.
	CdnProfile *string `json:"cdnProfile,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the StreamingEndpoint.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// ResourceState - READ-ONLY; The resource state of the StreamingEndpoint. Possible values include: 'StreamingEndpointResourceStateStopped', 'StreamingEndpointResourceStateStarting', 'StreamingEndpointResourceStateRunning', 'StreamingEndpointResourceStateStopping', 'StreamingEndpointResourceStateDeleting', 'StreamingEndpointResourceStateScaling'
	ResourceState StreamingEndpointResourceState `json:"resourceState,omitempty"`
	// CrossSiteAccessPolicies - The StreamingEndpoint access policies.
	CrossSiteAccessPolicies *CrossSiteAccessPolicies `json:"crossSiteAccessPolicies,omitempty"`
	// FreeTrialEndTime - READ-ONLY; The free trial expiration time.
	FreeTrialEndTime *date.Time `json:"freeTrialEndTime,omitempty"`
	// Created - READ-ONLY; The exact time the StreamingEndpoint was created.
	Created *date.Time `json:"created,omitempty"`
	// LastModified - READ-ONLY; The exact time the StreamingEndpoint was last modified.
	LastModified *date.Time `json:"lastModified,omitempty"`
}

// StreamingEndpointsCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StreamingEndpointsCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *StreamingEndpointsCreateFuture) Result(client StreamingEndpointsClient) (se StreamingEndpoint, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.StreamingEndpointsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.StreamingEndpointsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if se.Response.Response, err = future.GetResult(sender); err == nil && se.Response.Response.StatusCode != http.StatusNoContent {
		se, err = client.CreateResponder(se.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "media.StreamingEndpointsCreateFuture", "Result", se.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StreamingEndpointsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StreamingEndpointsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *StreamingEndpointsDeleteFuture) Result(client StreamingEndpointsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.StreamingEndpointsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.StreamingEndpointsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StreamingEndpointsScaleFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type StreamingEndpointsScaleFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *StreamingEndpointsScaleFuture) Result(client StreamingEndpointsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.StreamingEndpointsScaleFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.StreamingEndpointsScaleFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StreamingEndpointsStartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type StreamingEndpointsStartFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *StreamingEndpointsStartFuture) Result(client StreamingEndpointsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.StreamingEndpointsStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.StreamingEndpointsStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StreamingEndpointsStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type StreamingEndpointsStopFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *StreamingEndpointsStopFuture) Result(client StreamingEndpointsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.StreamingEndpointsStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.StreamingEndpointsStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// StreamingEndpointsUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type StreamingEndpointsUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *StreamingEndpointsUpdateFuture) Result(client StreamingEndpointsClient) (se StreamingEndpoint, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "media.StreamingEndpointsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("media.StreamingEndpointsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if se.Response.Response, err = future.GetResult(sender); err == nil && se.Response.Response.StatusCode != http.StatusNoContent {
		se, err = client.UpdateResponder(se.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "media.StreamingEndpointsUpdateFuture", "Result", se.Response.Response, "Failure responding to request")
		}
	}
	return
}

// StreamingEntityScaleUnit scale units definition
type StreamingEntityScaleUnit struct {
	// ScaleUnit - The scale unit number of the StreamingEndpoint.
	ScaleUnit *int32 `json:"scaleUnit,omitempty"`
}

// StreamingLocator a Streaming Locator resource
type StreamingLocator struct {
	autorest.Response           `json:"-"`
	*StreamingLocatorProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StreamingLocator.
func (sl StreamingLocator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sl.StreamingLocatorProperties != nil {
		objectMap["properties"] = sl.StreamingLocatorProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StreamingLocator struct.
func (sl *StreamingLocator) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var streamingLocatorProperties StreamingLocatorProperties
				err = json.Unmarshal(*v, &streamingLocatorProperties)
				if err != nil {
					return err
				}
				sl.StreamingLocatorProperties = &streamingLocatorProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sl.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sl.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sl.Type = &typeVar
			}
		}
	}

	return nil
}

// StreamingLocatorCollection a collection of StreamingLocator items.
type StreamingLocatorCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of StreamingLocator items.
	Value *[]StreamingLocator `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// StreamingLocatorCollectionIterator provides access to a complete listing of StreamingLocator values.
type StreamingLocatorCollectionIterator struct {
	i    int
	page StreamingLocatorCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StreamingLocatorCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StreamingLocatorCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StreamingLocatorCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StreamingLocatorCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StreamingLocatorCollectionIterator) Response() StreamingLocatorCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StreamingLocatorCollectionIterator) Value() StreamingLocator {
	if !iter.page.NotDone() {
		return StreamingLocator{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StreamingLocatorCollectionIterator type.
func NewStreamingLocatorCollectionIterator(page StreamingLocatorCollectionPage) StreamingLocatorCollectionIterator {
	return StreamingLocatorCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (slc StreamingLocatorCollection) IsEmpty() bool {
	return slc.Value == nil || len(*slc.Value) == 0
}

// streamingLocatorCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (slc StreamingLocatorCollection) streamingLocatorCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if slc.OdataNextLink == nil || len(to.String(slc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(slc.OdataNextLink)))
}

// StreamingLocatorCollectionPage contains a page of StreamingLocator values.
type StreamingLocatorCollectionPage struct {
	fn  func(context.Context, StreamingLocatorCollection) (StreamingLocatorCollection, error)
	slc StreamingLocatorCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StreamingLocatorCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StreamingLocatorCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.slc)
	if err != nil {
		return err
	}
	page.slc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StreamingLocatorCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StreamingLocatorCollectionPage) NotDone() bool {
	return !page.slc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StreamingLocatorCollectionPage) Response() StreamingLocatorCollection {
	return page.slc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StreamingLocatorCollectionPage) Values() []StreamingLocator {
	if page.slc.IsEmpty() {
		return nil
	}
	return *page.slc.Value
}

// Creates a new instance of the StreamingLocatorCollectionPage type.
func NewStreamingLocatorCollectionPage(getNextPage func(context.Context, StreamingLocatorCollection) (StreamingLocatorCollection, error)) StreamingLocatorCollectionPage {
	return StreamingLocatorCollectionPage{fn: getNextPage}
}

// StreamingLocatorContentKey class for content key in Streaming Locator
type StreamingLocatorContentKey struct {
	// ID - ID of Content Key
	ID *uuid.UUID `json:"id,omitempty"`
	// Type - READ-ONLY; Encryption type of Content Key. Possible values include: 'StreamingLocatorContentKeyTypeCommonEncryptionCenc', 'StreamingLocatorContentKeyTypeCommonEncryptionCbcs', 'StreamingLocatorContentKeyTypeEnvelopeEncryption'
	Type StreamingLocatorContentKeyType `json:"type,omitempty"`
	// LabelReferenceInStreamingPolicy - Label of Content Key as specified in the Streaming Policy
	LabelReferenceInStreamingPolicy *string `json:"labelReferenceInStreamingPolicy,omitempty"`
	// Value - Value of Content Key
	Value *string `json:"value,omitempty"`
	// PolicyName - READ-ONLY; ContentKeyPolicy used by Content Key
	PolicyName *string `json:"policyName,omitempty"`
	// Tracks - READ-ONLY; Tracks which use this Content Key
	Tracks *[]TrackSelection `json:"tracks,omitempty"`
}

// StreamingLocatorProperties properties of the Streaming Locator.
type StreamingLocatorProperties struct {
	// AssetName - Asset Name
	AssetName *string `json:"assetName,omitempty"`
	// Created - READ-ONLY; The creation time of the Streaming Locator.
	Created *date.Time `json:"created,omitempty"`
	// StartTime - The start time of the Streaming Locator.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time of the Streaming Locator.
	EndTime *date.Time `json:"endTime,omitempty"`
	// StreamingLocatorID - The StreamingLocatorId of the Streaming Locator.
	StreamingLocatorID *uuid.UUID `json:"streamingLocatorId,omitempty"`
	// StreamingPolicyName - Name of the Streaming Policy used by this Streaming Locator. Either specify the name of Streaming Policy you created or use one of the predefined Streaming Policies. The predefined Streaming Policies available are: 'Predefined_DownloadOnly', 'Predefined_ClearStreamingOnly', 'Predefined_DownloadAndClearStreaming', 'Predefined_ClearKey', 'Predefined_MultiDrmCencStreaming' and 'Predefined_MultiDrmStreaming'
	StreamingPolicyName *string `json:"streamingPolicyName,omitempty"`
	// DefaultContentKeyPolicyName - Name of the default ContentKeyPolicy used by this Streaming Locator.
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty"`
	// ContentKeys - The ContentKeys used by this Streaming Locator.
	ContentKeys *[]StreamingLocatorContentKey `json:"contentKeys,omitempty"`
	// AlternativeMediaID - Alternative Media ID of this Streaming Locator
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty"`
	// Filters - A list of asset or account filters which apply to this streaming locator
	Filters *[]string `json:"filters,omitempty"`
}

// StreamingPath class of paths for streaming
type StreamingPath struct {
	// StreamingProtocol - Streaming protocol. Possible values include: 'StreamingPolicyStreamingProtocolHls', 'StreamingPolicyStreamingProtocolDash', 'StreamingPolicyStreamingProtocolSmoothStreaming', 'StreamingPolicyStreamingProtocolDownload'
	StreamingProtocol StreamingPolicyStreamingProtocol `json:"streamingProtocol,omitempty"`
	// EncryptionScheme - Encryption scheme. Possible values include: 'EncryptionSchemeNoEncryption', 'EncryptionSchemeEnvelopeEncryption', 'EncryptionSchemeCommonEncryptionCenc', 'EncryptionSchemeCommonEncryptionCbcs'
	EncryptionScheme EncryptionScheme `json:"encryptionScheme,omitempty"`
	// Paths - Streaming paths for each protocol and encryptionScheme pair
	Paths *[]string `json:"paths,omitempty"`
}

// StreamingPolicy a Streaming Policy resource
type StreamingPolicy struct {
	autorest.Response          `json:"-"`
	*StreamingPolicyProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for StreamingPolicy.
func (sp StreamingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.StreamingPolicyProperties != nil {
		objectMap["properties"] = sp.StreamingPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for StreamingPolicy struct.
func (sp *StreamingPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var streamingPolicyProperties StreamingPolicyProperties
				err = json.Unmarshal(*v, &streamingPolicyProperties)
				if err != nil {
					return err
				}
				sp.StreamingPolicyProperties = &streamingPolicyProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sp.Type = &typeVar
			}
		}
	}

	return nil
}

// StreamingPolicyCollection a collection of StreamingPolicy items.
type StreamingPolicyCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of StreamingPolicy items.
	Value *[]StreamingPolicy `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// StreamingPolicyCollectionIterator provides access to a complete listing of StreamingPolicy values.
type StreamingPolicyCollectionIterator struct {
	i    int
	page StreamingPolicyCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *StreamingPolicyCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StreamingPolicyCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *StreamingPolicyCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter StreamingPolicyCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter StreamingPolicyCollectionIterator) Response() StreamingPolicyCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter StreamingPolicyCollectionIterator) Value() StreamingPolicy {
	if !iter.page.NotDone() {
		return StreamingPolicy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the StreamingPolicyCollectionIterator type.
func NewStreamingPolicyCollectionIterator(page StreamingPolicyCollectionPage) StreamingPolicyCollectionIterator {
	return StreamingPolicyCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (spc StreamingPolicyCollection) IsEmpty() bool {
	return spc.Value == nil || len(*spc.Value) == 0
}

// streamingPolicyCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (spc StreamingPolicyCollection) streamingPolicyCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if spc.OdataNextLink == nil || len(to.String(spc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(spc.OdataNextLink)))
}

// StreamingPolicyCollectionPage contains a page of StreamingPolicy values.
type StreamingPolicyCollectionPage struct {
	fn  func(context.Context, StreamingPolicyCollection) (StreamingPolicyCollection, error)
	spc StreamingPolicyCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *StreamingPolicyCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/StreamingPolicyCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.spc)
	if err != nil {
		return err
	}
	page.spc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *StreamingPolicyCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page StreamingPolicyCollectionPage) NotDone() bool {
	return !page.spc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page StreamingPolicyCollectionPage) Response() StreamingPolicyCollection {
	return page.spc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page StreamingPolicyCollectionPage) Values() []StreamingPolicy {
	if page.spc.IsEmpty() {
		return nil
	}
	return *page.spc.Value
}

// Creates a new instance of the StreamingPolicyCollectionPage type.
func NewStreamingPolicyCollectionPage(getNextPage func(context.Context, StreamingPolicyCollection) (StreamingPolicyCollection, error)) StreamingPolicyCollectionPage {
	return StreamingPolicyCollectionPage{fn: getNextPage}
}

// StreamingPolicyContentKey class to specify properties of content key
type StreamingPolicyContentKey struct {
	// Label - Label can be used to specify Content Key when creating a Streaming Locator
	Label *string `json:"label,omitempty"`
	// PolicyName - Policy used by Content Key
	PolicyName *string `json:"policyName,omitempty"`
	// Tracks - Tracks which use this content key
	Tracks *[]TrackSelection `json:"tracks,omitempty"`
}

// StreamingPolicyContentKeys class to specify properties of all content keys in Streaming Policy
type StreamingPolicyContentKeys struct {
	// DefaultKey - Default content key for an encryption scheme
	DefaultKey *DefaultKey `json:"defaultKey,omitempty"`
	// KeyToTrackMappings - Representing tracks needs separate content key
	KeyToTrackMappings *[]StreamingPolicyContentKey `json:"keyToTrackMappings,omitempty"`
}

// StreamingPolicyFairPlayConfiguration class to specify configurations of FairPlay in Streaming Policy
type StreamingPolicyFairPlayConfiguration struct {
	// CustomLicenseAcquisitionURLTemplate - Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`
	// AllowPersistentLicense - All license to be persistent or not
	AllowPersistentLicense *bool `json:"allowPersistentLicense,omitempty"`
}

// StreamingPolicyPlayReadyConfiguration class to specify configurations of PlayReady in Streaming Policy
type StreamingPolicyPlayReadyConfiguration struct {
	// CustomLicenseAcquisitionURLTemplate - Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`
	// PlayReadyCustomAttributes - Custom attributes for PlayReady
	PlayReadyCustomAttributes *string `json:"playReadyCustomAttributes,omitempty"`
}

// StreamingPolicyProperties class to specify properties of Streaming Policy
type StreamingPolicyProperties struct {
	// Created - READ-ONLY; Creation time of Streaming Policy
	Created *date.Time `json:"created,omitempty"`
	// DefaultContentKeyPolicyName - Default ContentKey used by current Streaming Policy
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty"`
	// EnvelopeEncryption - Configuration of EnvelopeEncryption
	EnvelopeEncryption *EnvelopeEncryption `json:"envelopeEncryption,omitempty"`
	// CommonEncryptionCenc - Configuration of CommonEncryptionCenc
	CommonEncryptionCenc *CommonEncryptionCenc `json:"commonEncryptionCenc,omitempty"`
	// CommonEncryptionCbcs - Configuration of CommonEncryptionCbcs
	CommonEncryptionCbcs *CommonEncryptionCbcs `json:"commonEncryptionCbcs,omitempty"`
	// NoEncryption - Configurations of NoEncryption
	NoEncryption *NoEncryption `json:"noEncryption,omitempty"`
}

// StreamingPolicyWidevineConfiguration class to specify configurations of Widevine in Streaming Policy
type StreamingPolicyWidevineConfiguration struct {
	// CustomLicenseAcquisitionURLTemplate - Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty"`
}

// SubscriptionMediaService a Media Services account.
type SubscriptionMediaService struct {
	autorest.Response `json:"-"`
	// ServiceProperties - The resource properties.
	*ServiceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The Azure Region of the resource.
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionMediaService.
func (sms SubscriptionMediaService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sms.ServiceProperties != nil {
		objectMap["properties"] = sms.ServiceProperties
	}
	if sms.Tags != nil {
		objectMap["tags"] = sms.Tags
	}
	if sms.Location != nil {
		objectMap["location"] = sms.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SubscriptionMediaService struct.
func (sms *SubscriptionMediaService) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serviceProperties ServiceProperties
				err = json.Unmarshal(*v, &serviceProperties)
				if err != nil {
					return err
				}
				sms.ServiceProperties = &serviceProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sms.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sms.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sms.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sms.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sms.Type = &typeVar
			}
		}
	}

	return nil
}

// SubscriptionMediaServiceCollection a collection of SubscriptionMediaService items.
type SubscriptionMediaServiceCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of SubscriptionMediaService items.
	Value *[]SubscriptionMediaService `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// SubscriptionMediaServiceCollectionIterator provides access to a complete listing of
// SubscriptionMediaService values.
type SubscriptionMediaServiceCollectionIterator struct {
	i    int
	page SubscriptionMediaServiceCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SubscriptionMediaServiceCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubscriptionMediaServiceCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SubscriptionMediaServiceCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SubscriptionMediaServiceCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SubscriptionMediaServiceCollectionIterator) Response() SubscriptionMediaServiceCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SubscriptionMediaServiceCollectionIterator) Value() SubscriptionMediaService {
	if !iter.page.NotDone() {
		return SubscriptionMediaService{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SubscriptionMediaServiceCollectionIterator type.
func NewSubscriptionMediaServiceCollectionIterator(page SubscriptionMediaServiceCollectionPage) SubscriptionMediaServiceCollectionIterator {
	return SubscriptionMediaServiceCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (smsc SubscriptionMediaServiceCollection) IsEmpty() bool {
	return smsc.Value == nil || len(*smsc.Value) == 0
}

// subscriptionMediaServiceCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (smsc SubscriptionMediaServiceCollection) subscriptionMediaServiceCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if smsc.OdataNextLink == nil || len(to.String(smsc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(smsc.OdataNextLink)))
}

// SubscriptionMediaServiceCollectionPage contains a page of SubscriptionMediaService values.
type SubscriptionMediaServiceCollectionPage struct {
	fn   func(context.Context, SubscriptionMediaServiceCollection) (SubscriptionMediaServiceCollection, error)
	smsc SubscriptionMediaServiceCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SubscriptionMediaServiceCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubscriptionMediaServiceCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.smsc)
	if err != nil {
		return err
	}
	page.smsc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SubscriptionMediaServiceCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SubscriptionMediaServiceCollectionPage) NotDone() bool {
	return !page.smsc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SubscriptionMediaServiceCollectionPage) Response() SubscriptionMediaServiceCollection {
	return page.smsc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SubscriptionMediaServiceCollectionPage) Values() []SubscriptionMediaService {
	if page.smsc.IsEmpty() {
		return nil
	}
	return *page.smsc.Value
}

// Creates a new instance of the SubscriptionMediaServiceCollectionPage type.
func NewSubscriptionMediaServiceCollectionPage(getNextPage func(context.Context, SubscriptionMediaServiceCollection) (SubscriptionMediaServiceCollection, error)) SubscriptionMediaServiceCollectionPage {
	return SubscriptionMediaServiceCollectionPage{fn: getNextPage}
}

// SyncStorageKeysInput the input to the sync storage keys request.
type SyncStorageKeysInput struct {
	// ID - The ID of the storage account resource.
	ID *string `json:"id,omitempty"`
}

// TrackedResource the resource model definition for a ARM tracked resource.
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The Azure Region of the resource.
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// TrackPropertyCondition class to specify one track property condition
type TrackPropertyCondition struct {
	// Property - Track property type. Possible values include: 'TrackPropertyTypeUnknown', 'TrackPropertyTypeFourCC'
	Property TrackPropertyType `json:"property,omitempty"`
	// Operation - Track property condition operation. Possible values include: 'TrackPropertyCompareOperationUnknown', 'TrackPropertyCompareOperationEqual'
	Operation TrackPropertyCompareOperation `json:"operation,omitempty"`
	// Value - Track property value
	Value *string `json:"value,omitempty"`
}

// TrackSelection class to select a track
type TrackSelection struct {
	// TrackSelections - TrackSelections is a track property condition list which can specify track(s)
	TrackSelections *[]TrackPropertyCondition `json:"trackSelections,omitempty"`
}

// Transform a Transform encapsulates the rules or instructions for generating desired outputs from input
// media, such as by transcoding or by extracting insights. After the Transform is created, it can be
// applied to input media by creating Jobs.
type Transform struct {
	autorest.Response `json:"-"`
	// TransformProperties - The resource properties.
	*TransformProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Transform.
func (t Transform) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.TransformProperties != nil {
		objectMap["properties"] = t.TransformProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Transform struct.
func (t *Transform) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var transformProperties TransformProperties
				err = json.Unmarshal(*v, &transformProperties)
				if err != nil {
					return err
				}
				t.TransformProperties = &transformProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				t.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				t.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				t.Type = &typeVar
			}
		}
	}

	return nil
}

// TransformCollection a collection of Transform items.
type TransformCollection struct {
	autorest.Response `json:"-"`
	// Value - A collection of Transform items.
	Value *[]Transform `json:"value,omitempty"`
	// OdataNextLink - A link to the next page of the collection (when the collection contains too many results to return in one response).
	OdataNextLink *string `json:"@odata.nextLink,omitempty"`
}

// TransformCollectionIterator provides access to a complete listing of Transform values.
type TransformCollectionIterator struct {
	i    int
	page TransformCollectionPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TransformCollectionIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TransformCollectionIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TransformCollectionIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TransformCollectionIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TransformCollectionIterator) Response() TransformCollection {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TransformCollectionIterator) Value() Transform {
	if !iter.page.NotDone() {
		return Transform{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TransformCollectionIterator type.
func NewTransformCollectionIterator(page TransformCollectionPage) TransformCollectionIterator {
	return TransformCollectionIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (tc TransformCollection) IsEmpty() bool {
	return tc.Value == nil || len(*tc.Value) == 0
}

// transformCollectionPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (tc TransformCollection) transformCollectionPreparer(ctx context.Context) (*http.Request, error) {
	if tc.OdataNextLink == nil || len(to.String(tc.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(tc.OdataNextLink)))
}

// TransformCollectionPage contains a page of Transform values.
type TransformCollectionPage struct {
	fn func(context.Context, TransformCollection) (TransformCollection, error)
	tc TransformCollection
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TransformCollectionPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TransformCollectionPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.tc)
	if err != nil {
		return err
	}
	page.tc = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TransformCollectionPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TransformCollectionPage) NotDone() bool {
	return !page.tc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TransformCollectionPage) Response() TransformCollection {
	return page.tc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TransformCollectionPage) Values() []Transform {
	if page.tc.IsEmpty() {
		return nil
	}
	return *page.tc.Value
}

// Creates a new instance of the TransformCollectionPage type.
func NewTransformCollectionPage(getNextPage func(context.Context, TransformCollection) (TransformCollection, error)) TransformCollectionPage {
	return TransformCollectionPage{fn: getNextPage}
}

// TransformOutput describes the properties of a TransformOutput, which are the rules to be applied while
// generating the desired output.
type TransformOutput struct {
	// OnError - A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with 'ContinueJob'. The default is 'StopProcessingJob'. Possible values include: 'StopProcessingJob', 'ContinueJob'
	OnError OnErrorType `json:"onError,omitempty"`
	// RelativePriority - Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing TransformOutputs. The default priority is Normal. Possible values include: 'Low', 'Normal', 'High'
	RelativePriority Priority `json:"relativePriority,omitempty"`
	// Preset - Preset that describes the operations that will be used to modify, transcode, or extract insights from the source file to generate the output.
	Preset BasicPreset `json:"preset,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for TransformOutput struct.
func (toVar *TransformOutput) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "onError":
			if v != nil {
				var onError OnErrorType
				err = json.Unmarshal(*v, &onError)
				if err != nil {
					return err
				}
				toVar.OnError = onError
			}
		case "relativePriority":
			if v != nil {
				var relativePriority Priority
				err = json.Unmarshal(*v, &relativePriority)
				if err != nil {
					return err
				}
				toVar.RelativePriority = relativePriority
			}
		case "preset":
			if v != nil {
				preset, err := unmarshalBasicPreset(*v)
				if err != nil {
					return err
				}
				toVar.Preset = preset
			}
		}
	}

	return nil
}

// TransformProperties a Transform.
type TransformProperties struct {
	// Created - READ-ONLY; The UTC date and time when the Transform was created, in 'YYYY-MM-DDThh:mm:ssZ' format.
	Created *date.Time `json:"created,omitempty"`
	// Description - An optional verbose description of the Transform.
	Description *string `json:"description,omitempty"`
	// LastModified - READ-ONLY; The UTC date and time when the Transform was last updated, in 'YYYY-MM-DDThh:mm:ssZ' format.
	LastModified *date.Time `json:"lastModified,omitempty"`
	// Outputs - An array of one or more TransformOutputs that the Transform should generate.
	Outputs *[]TransformOutput `json:"outputs,omitempty"`
}

// TransportStreamFormat describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC
// 13818-1) output video file(s).
type TransportStreamFormat struct {
	// OutputFiles - The list of output files to produce.  Each entry in the list is a set of audio and video layer labels to be muxed together .
	OutputFiles *[]OutputFile `json:"outputFiles,omitempty"`
	// FilenamePattern - The pattern of the file names for the generated output files. The following macros are supported in the file name: {Basename} - The base name of the input video {Extension} - The appropriate extension for this format. {Label} - The label assigned to the codec/layer. {Index} - A unique index for thumbnails. Only applicable to thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted macros will be collapsed and removed from the filename.
	FilenamePattern *string `json:"filenamePattern,omitempty"`
	// OdataType - Possible values include: 'OdataTypeFormat', 'OdataTypeMicrosoftMediaImageFormat', 'OdataTypeMicrosoftMediaJpgFormat', 'OdataTypeMicrosoftMediaPngFormat', 'OdataTypeMicrosoftMediaMultiBitrateFormat', 'OdataTypeMicrosoftMediaMp4Format', 'OdataTypeMicrosoftMediaTransportStreamFormat'
	OdataType OdataTypeBasicFormat `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for TransportStreamFormat.
func (tsf TransportStreamFormat) MarshalJSON() ([]byte, error) {
	tsf.OdataType = OdataTypeMicrosoftMediaTransportStreamFormat
	objectMap := make(map[string]interface{})
	if tsf.OutputFiles != nil {
		objectMap["outputFiles"] = tsf.OutputFiles
	}
	if tsf.FilenamePattern != nil {
		objectMap["filenamePattern"] = tsf.FilenamePattern
	}
	if tsf.OdataType != "" {
		objectMap["@odata.type"] = tsf.OdataType
	}
	return json.Marshal(objectMap)
}

// AsImageFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsImageFormat() (*ImageFormat, bool) {
	return nil, false
}

// AsBasicImageFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsBasicImageFormat() (BasicImageFormat, bool) {
	return nil, false
}

// AsJpgFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsJpgFormat() (*JpgFormat, bool) {
	return nil, false
}

// AsPngFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsPngFormat() (*PngFormat, bool) {
	return nil, false
}

// AsMultiBitrateFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsMultiBitrateFormat() (*MultiBitrateFormat, bool) {
	return nil, false
}

// AsBasicMultiBitrateFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsBasicMultiBitrateFormat() (BasicMultiBitrateFormat, bool) {
	return &tsf, true
}

// AsMp4Format is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsMp4Format() (*Mp4Format, bool) {
	return nil, false
}

// AsTransportStreamFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsTransportStreamFormat() (*TransportStreamFormat, bool) {
	return &tsf, true
}

// AsFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsFormat() (*Format, bool) {
	return nil, false
}

// AsBasicFormat is the BasicFormat implementation for TransportStreamFormat.
func (tsf TransportStreamFormat) AsBasicFormat() (BasicFormat, bool) {
	return &tsf, true
}

// BasicVideo describes the basic properties for encoding the input video.
type BasicVideo interface {
	AsImage() (*Image, bool)
	AsBasicImage() (BasicImage, bool)
	AsH264Video() (*H264Video, bool)
	AsJpgImage() (*JpgImage, bool)
	AsPngImage() (*PngImage, bool)
	AsVideo() (*Video, bool)
}

// Video describes the basic properties for encoding the input video.
type Video struct {
	// KeyFrameInterval - The distance between two key frames, thereby defining a group of pictures (GOP). The value should be a non-zero integer in the range [1, 30] seconds, specified in ISO 8601 format. The default is 2 seconds (PT2S).
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty"`
	// StretchMode - The resizing mode - how the input video will be resized to fit the desired output resolution(s). Default is AutoSize. Possible values include: 'StretchModeNone', 'StretchModeAutoSize', 'StretchModeAutoFit'
	StretchMode StretchMode `json:"stretchMode,omitempty"`
	// Label - An optional label for the codec. The label can be used to control muxing behavior.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeCodec', 'OdataTypeMicrosoftMediaAudio', 'OdataTypeMicrosoftMediaAacAudio', 'OdataTypeMicrosoftMediaCopyVideo', 'OdataTypeMicrosoftMediaVideo', 'OdataTypeMicrosoftMediaImage', 'OdataTypeMicrosoftMediaCopyAudio', 'OdataTypeMicrosoftMediaH264Video', 'OdataTypeMicrosoftMediaJpgImage', 'OdataTypeMicrosoftMediaPngImage'
	OdataType OdataTypeBasicCodec `json:"@odata.type,omitempty"`
}

func unmarshalBasicVideo(body []byte) (BasicVideo, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaImage):
		var i Image
		err := json.Unmarshal(body, &i)
		return i, err
	case string(OdataTypeMicrosoftMediaH264Video):
		var hv H264Video
		err := json.Unmarshal(body, &hv)
		return hv, err
	case string(OdataTypeMicrosoftMediaJpgImage):
		var ji JpgImage
		err := json.Unmarshal(body, &ji)
		return ji, err
	case string(OdataTypeMicrosoftMediaPngImage):
		var pi PngImage
		err := json.Unmarshal(body, &pi)
		return pi, err
	default:
		var vVar Video
		err := json.Unmarshal(body, &vVar)
		return vVar, err
	}
}
func unmarshalBasicVideoArray(body []byte) ([]BasicVideo, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	vVarArray := make([]BasicVideo, len(rawMessages))

	for index, rawMessage := range rawMessages {
		vVar, err := unmarshalBasicVideo(*rawMessage)
		if err != nil {
			return nil, err
		}
		vVarArray[index] = vVar
	}
	return vVarArray, nil
}

// MarshalJSON is the custom marshaler for Video.
func (vVar Video) MarshalJSON() ([]byte, error) {
	vVar.OdataType = OdataTypeMicrosoftMediaVideo
	objectMap := make(map[string]interface{})
	if vVar.KeyFrameInterval != nil {
		objectMap["keyFrameInterval"] = vVar.KeyFrameInterval
	}
	if vVar.StretchMode != "" {
		objectMap["stretchMode"] = vVar.StretchMode
	}
	if vVar.Label != nil {
		objectMap["label"] = vVar.Label
	}
	if vVar.OdataType != "" {
		objectMap["@odata.type"] = vVar.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudio is the BasicCodec implementation for Video.
func (vVar Video) AsAudio() (*Audio, bool) {
	return nil, false
}

// AsBasicAudio is the BasicCodec implementation for Video.
func (vVar Video) AsBasicAudio() (BasicAudio, bool) {
	return nil, false
}

// AsAacAudio is the BasicCodec implementation for Video.
func (vVar Video) AsAacAudio() (*AacAudio, bool) {
	return nil, false
}

// AsCopyVideo is the BasicCodec implementation for Video.
func (vVar Video) AsCopyVideo() (*CopyVideo, bool) {
	return nil, false
}

// AsVideo is the BasicCodec implementation for Video.
func (vVar Video) AsVideo() (*Video, bool) {
	return &vVar, true
}

// AsBasicVideo is the BasicCodec implementation for Video.
func (vVar Video) AsBasicVideo() (BasicVideo, bool) {
	return &vVar, true
}

// AsImage is the BasicCodec implementation for Video.
func (vVar Video) AsImage() (*Image, bool) {
	return nil, false
}

// AsBasicImage is the BasicCodec implementation for Video.
func (vVar Video) AsBasicImage() (BasicImage, bool) {
	return nil, false
}

// AsCopyAudio is the BasicCodec implementation for Video.
func (vVar Video) AsCopyAudio() (*CopyAudio, bool) {
	return nil, false
}

// AsH264Video is the BasicCodec implementation for Video.
func (vVar Video) AsH264Video() (*H264Video, bool) {
	return nil, false
}

// AsJpgImage is the BasicCodec implementation for Video.
func (vVar Video) AsJpgImage() (*JpgImage, bool) {
	return nil, false
}

// AsPngImage is the BasicCodec implementation for Video.
func (vVar Video) AsPngImage() (*PngImage, bool) {
	return nil, false
}

// AsCodec is the BasicCodec implementation for Video.
func (vVar Video) AsCodec() (*Codec, bool) {
	return nil, false
}

// AsBasicCodec is the BasicCodec implementation for Video.
func (vVar Video) AsBasicCodec() (BasicCodec, bool) {
	return &vVar, true
}

// VideoAnalyzerPreset a video analyzer preset that extracts insights (rich metadata) from both audio and
// video, and outputs a JSON format file.
type VideoAnalyzerPreset struct {
	// InsightsToExtract - Defines the type of insights that you want the service to generate. The allowed values are 'AudioInsightsOnly', 'VideoInsightsOnly', and 'AllInsights'. The default is AllInsights. If you set this to AllInsights and the input is audio only, then only audio insights are generated. Similarly if the input is video only, then only video insights are generated. It is recommended that you not use AudioInsightsOnly if you expect some of your inputs to be video only; or use VideoInsightsOnly if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out. Possible values include: 'AudioInsightsOnly', 'VideoInsightsOnly', 'AllInsights'
	InsightsToExtract InsightsType `json:"insightsToExtract,omitempty"`
	// AudioLanguage - The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US').  If you know the language of your content, it is recommended that you specify it. If the language isn't specified or set to null, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernable speech. If automatic detection fails to find the language, transcription would fallback to 'en-US'." The list of supported languages is available here: https://go.microsoft.com/fwlink/?linkid=2109463
	AudioLanguage *string `json:"audioLanguage,omitempty"`
	// ExperimentalOptions - Dictionary containing key value pairs for parameters not exposed in the preset itself
	ExperimentalOptions map[string]*string `json:"experimentalOptions"`
	// OdataType - Possible values include: 'OdataTypePreset', 'OdataTypeMicrosoftMediaFaceDetectorPreset', 'OdataTypeMicrosoftMediaAudioAnalyzerPreset', 'OdataTypeMicrosoftMediaBuiltInStandardEncoderPreset', 'OdataTypeMicrosoftMediaStandardEncoderPreset', 'OdataTypeMicrosoftMediaVideoAnalyzerPreset'
	OdataType OdataTypeBasicPreset `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) MarshalJSON() ([]byte, error) {
	vap.OdataType = OdataTypeMicrosoftMediaVideoAnalyzerPreset
	objectMap := make(map[string]interface{})
	if vap.InsightsToExtract != "" {
		objectMap["insightsToExtract"] = vap.InsightsToExtract
	}
	if vap.AudioLanguage != nil {
		objectMap["audioLanguage"] = vap.AudioLanguage
	}
	if vap.ExperimentalOptions != nil {
		objectMap["experimentalOptions"] = vap.ExperimentalOptions
	}
	if vap.OdataType != "" {
		objectMap["@odata.type"] = vap.OdataType
	}
	return json.Marshal(objectMap)
}

// AsFaceDetectorPreset is the BasicPreset implementation for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) AsFaceDetectorPreset() (*FaceDetectorPreset, bool) {
	return nil, false
}

// AsAudioAnalyzerPreset is the BasicPreset implementation for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) AsAudioAnalyzerPreset() (*AudioAnalyzerPreset, bool) {
	return nil, false
}

// AsBasicAudioAnalyzerPreset is the BasicPreset implementation for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) AsBasicAudioAnalyzerPreset() (BasicAudioAnalyzerPreset, bool) {
	return &vap, true
}

// AsBuiltInStandardEncoderPreset is the BasicPreset implementation for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) AsBuiltInStandardEncoderPreset() (*BuiltInStandardEncoderPreset, bool) {
	return nil, false
}

// AsStandardEncoderPreset is the BasicPreset implementation for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) AsStandardEncoderPreset() (*StandardEncoderPreset, bool) {
	return nil, false
}

// AsVideoAnalyzerPreset is the BasicPreset implementation for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) AsVideoAnalyzerPreset() (*VideoAnalyzerPreset, bool) {
	return &vap, true
}

// AsPreset is the BasicPreset implementation for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) AsPreset() (*Preset, bool) {
	return nil, false
}

// AsBasicPreset is the BasicPreset implementation for VideoAnalyzerPreset.
func (vap VideoAnalyzerPreset) AsBasicPreset() (BasicPreset, bool) {
	return &vap, true
}

// BasicVideoLayer describes the settings to be used when encoding the input video into a desired output bitrate layer.
type BasicVideoLayer interface {
	AsH264Layer() (*H264Layer, bool)
	AsVideoLayer() (*VideoLayer, bool)
}

// VideoLayer describes the settings to be used when encoding the input video into a desired output bitrate
// layer.
type VideoLayer struct {
	// Bitrate - The average bitrate in bits per second at which to encode the input video when generating this layer. This is a required field.
	Bitrate *int32 `json:"bitrate,omitempty"`
	// MaxBitrate - The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
	MaxBitrate *int32 `json:"maxBitrate,omitempty"`
	// BFrames - The number of B-frames to be used when encoding this layer.  If not specified, the encoder chooses an appropriate number based on the video profile and level.
	BFrames *int32 `json:"bFrames,omitempty"`
	// FrameRate - The frame rate (in frames per second) at which to encode this layer. The value can be in the form of M/N where M and N are integers (For example, 30000/1001), or in the form of a number (For example, 30, or 29.97). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
	FrameRate *string `json:"frameRate,omitempty"`
	// Slices - The number of slices to be used when encoding this layer. If not specified, default is zero, which means that encoder will use a single slice for each frame.
	Slices *int32 `json:"slices,omitempty"`
	// AdaptiveBFrame - Whether or not adaptive B-frames are to be used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use.
	AdaptiveBFrame *bool `json:"adaptiveBFrame,omitempty"`
	// Width - The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in width as the input.
	Width *string `json:"width,omitempty"`
	// Height - The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example 50% means the output video has half as many pixels in height as the input.
	Height *string `json:"height,omitempty"`
	// Label - The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
	Label *string `json:"label,omitempty"`
	// OdataType - Possible values include: 'OdataTypeLayer', 'OdataTypeMicrosoftMediaVideoLayer', 'OdataTypeMicrosoftMediaH264Layer', 'OdataTypeMicrosoftMediaJpgLayer', 'OdataTypeMicrosoftMediaPngLayer'
	OdataType OdataTypeBasicLayer `json:"@odata.type,omitempty"`
}

func unmarshalBasicVideoLayer(body []byte) (BasicVideoLayer, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["@odata.type"] {
	case string(OdataTypeMicrosoftMediaH264Layer):
		var hl H264Layer
		err := json.Unmarshal(body, &hl)
		return hl, err
	default:
		var vl VideoLayer
		err := json.Unmarshal(body, &vl)
		return vl, err
	}
}
func unmarshalBasicVideoLayerArray(body []byte) ([]BasicVideoLayer, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	vlArray := make([]BasicVideoLayer, len(rawMessages))

	for index, rawMessage := range rawMessages {
		vl, err := unmarshalBasicVideoLayer(*rawMessage)
		if err != nil {
			return nil, err
		}
		vlArray[index] = vl
	}
	return vlArray, nil
}

// MarshalJSON is the custom marshaler for VideoLayer.
func (vl VideoLayer) MarshalJSON() ([]byte, error) {
	vl.OdataType = OdataTypeMicrosoftMediaVideoLayer
	objectMap := make(map[string]interface{})
	if vl.Bitrate != nil {
		objectMap["bitrate"] = vl.Bitrate
	}
	if vl.MaxBitrate != nil {
		objectMap["maxBitrate"] = vl.MaxBitrate
	}
	if vl.BFrames != nil {
		objectMap["bFrames"] = vl.BFrames
	}
	if vl.FrameRate != nil {
		objectMap["frameRate"] = vl.FrameRate
	}
	if vl.Slices != nil {
		objectMap["slices"] = vl.Slices
	}
	if vl.AdaptiveBFrame != nil {
		objectMap["adaptiveBFrame"] = vl.AdaptiveBFrame
	}
	if vl.Width != nil {
		objectMap["width"] = vl.Width
	}
	if vl.Height != nil {
		objectMap["height"] = vl.Height
	}
	if vl.Label != nil {
		objectMap["label"] = vl.Label
	}
	if vl.OdataType != "" {
		objectMap["@odata.type"] = vl.OdataType
	}
	return json.Marshal(objectMap)
}

// AsVideoLayer is the BasicLayer implementation for VideoLayer.
func (vl VideoLayer) AsVideoLayer() (*VideoLayer, bool) {
	return &vl, true
}

// AsBasicVideoLayer is the BasicLayer implementation for VideoLayer.
func (vl VideoLayer) AsBasicVideoLayer() (BasicVideoLayer, bool) {
	return &vl, true
}

// AsH264Layer is the BasicLayer implementation for VideoLayer.
func (vl VideoLayer) AsH264Layer() (*H264Layer, bool) {
	return nil, false
}

// AsJpgLayer is the BasicLayer implementation for VideoLayer.
func (vl VideoLayer) AsJpgLayer() (*JpgLayer, bool) {
	return nil, false
}

// AsPngLayer is the BasicLayer implementation for VideoLayer.
func (vl VideoLayer) AsPngLayer() (*PngLayer, bool) {
	return nil, false
}

// AsLayer is the BasicLayer implementation for VideoLayer.
func (vl VideoLayer) AsLayer() (*Layer, bool) {
	return nil, false
}

// AsBasicLayer is the BasicLayer implementation for VideoLayer.
func (vl VideoLayer) AsBasicLayer() (BasicLayer, bool) {
	return &vl, true
}

// VideoOverlay describes the properties of a video overlay.
type VideoOverlay struct {
	// Position - The location in the input video where the overlay is applied.
	Position *Rectangle `json:"position,omitempty"`
	// Opacity - The opacity of the overlay. This is a value in the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
	Opacity *float64 `json:"opacity,omitempty"`
	// CropRectangle - An optional rectangular window used to crop the overlay image or video.
	CropRectangle *Rectangle `json:"cropRectangle,omitempty"`
	// InputLabel - The label of the job input which is to be used as an overlay. The Input must specify exactly one file. You can specify an image file in JPG or PNG formats, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats for the complete list of supported audio and video file formats.
	InputLabel *string `json:"inputLabel,omitempty"`
	// Start - The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, PT05S to start the overlay at 5 seconds in to the input video. If not specified the overlay starts from the beginning of the input video.
	Start *string `json:"start,omitempty"`
	// End - The position in the input video at which the overlay ends. The value should be in ISO 8601 duration format. For example, PT30S to end the overlay at 30 seconds in to the input video. If not specified the overlay will be applied until the end of the input video if inputLoop is true. Else, if inputLoop is false, then overlay will last as long as the duration of the overlay media.
	End *string `json:"end,omitempty"`
	// FadeInDuration - The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as PT0S).
	FadeInDuration *string `json:"fadeInDuration,omitempty"`
	// FadeOutDuration - The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as PT0S).
	FadeOutDuration *string `json:"fadeOutDuration,omitempty"`
	// AudioGainLevel - The gain level of audio in the overlay. The value should be in the range [0, 1.0]. The default is 1.0.
	AudioGainLevel *float64 `json:"audioGainLevel,omitempty"`
	// OdataType - Possible values include: 'OdataTypeOverlay', 'OdataTypeMicrosoftMediaAudioOverlay', 'OdataTypeMicrosoftMediaVideoOverlay'
	OdataType OdataTypeBasicOverlay `json:"@odata.type,omitempty"`
}

// MarshalJSON is the custom marshaler for VideoOverlay.
func (vo VideoOverlay) MarshalJSON() ([]byte, error) {
	vo.OdataType = OdataTypeMicrosoftMediaVideoOverlay
	objectMap := make(map[string]interface{})
	if vo.Position != nil {
		objectMap["position"] = vo.Position
	}
	if vo.Opacity != nil {
		objectMap["opacity"] = vo.Opacity
	}
	if vo.CropRectangle != nil {
		objectMap["cropRectangle"] = vo.CropRectangle
	}
	if vo.InputLabel != nil {
		objectMap["inputLabel"] = vo.InputLabel
	}
	if vo.Start != nil {
		objectMap["start"] = vo.Start
	}
	if vo.End != nil {
		objectMap["end"] = vo.End
	}
	if vo.FadeInDuration != nil {
		objectMap["fadeInDuration"] = vo.FadeInDuration
	}
	if vo.FadeOutDuration != nil {
		objectMap["fadeOutDuration"] = vo.FadeOutDuration
	}
	if vo.AudioGainLevel != nil {
		objectMap["audioGainLevel"] = vo.AudioGainLevel
	}
	if vo.OdataType != "" {
		objectMap["@odata.type"] = vo.OdataType
	}
	return json.Marshal(objectMap)
}

// AsAudioOverlay is the BasicOverlay implementation for VideoOverlay.
func (vo VideoOverlay) AsAudioOverlay() (*AudioOverlay, bool) {
	return nil, false
}

// AsVideoOverlay is the BasicOverlay implementation for VideoOverlay.
func (vo VideoOverlay) AsVideoOverlay() (*VideoOverlay, bool) {
	return &vo, true
}

// AsOverlay is the BasicOverlay implementation for VideoOverlay.
func (vo VideoOverlay) AsOverlay() (*Overlay, bool) {
	return nil, false
}

// AsBasicOverlay is the BasicOverlay implementation for VideoOverlay.
func (vo VideoOverlay) AsBasicOverlay() (BasicOverlay, bool) {
	return &vo, true
}
