package network

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/network/mgmt/2020-11-01/network"

// AadAuthenticationParameters AAD Vpn authentication type related parameters.
type AadAuthenticationParameters struct {
	// AadTenant - AAD Vpn authentication parameter AAD tenant.
	AadTenant *string `json:"aadTenant,omitempty"`
	// AadAudience - AAD Vpn authentication parameter AAD audience.
	AadAudience *string `json:"aadAudience,omitempty"`
	// AadIssuer - AAD Vpn authentication parameter AAD issuer.
	AadIssuer *string `json:"aadIssuer,omitempty"`
}

// AddressSpace addressSpace contains an array of IP address ranges that can be used by subnets of the
// virtual network.
type AddressSpace struct {
	// AddressPrefixes - A list of address blocks reserved for this virtual network in CIDR notation.
	AddressPrefixes *[]string `json:"addressPrefixes,omitempty"`
}

// ApplicationGateway application gateway resource.
type ApplicationGateway struct {
	autorest.Response `json:"-"`
	// ApplicationGatewayPropertiesFormat - Properties of the application gateway.
	*ApplicationGatewayPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Zones - A list of availability zones denoting where the resource needs to come from.
	Zones *[]string `json:"zones,omitempty"`
	// Identity - The identity of the application gateway, if configured.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ApplicationGateway.
func (ag ApplicationGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ag.ApplicationGatewayPropertiesFormat != nil {
		objectMap["properties"] = ag.ApplicationGatewayPropertiesFormat
	}
	if ag.Zones != nil {
		objectMap["zones"] = ag.Zones
	}
	if ag.Identity != nil {
		objectMap["identity"] = ag.Identity
	}
	if ag.ID != nil {
		objectMap["id"] = ag.ID
	}
	if ag.Location != nil {
		objectMap["location"] = ag.Location
	}
	if ag.Tags != nil {
		objectMap["tags"] = ag.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGateway struct.
func (ag *ApplicationGateway) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayPropertiesFormat ApplicationGatewayPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayPropertiesFormat)
				if err != nil {
					return err
				}
				ag.ApplicationGatewayPropertiesFormat = &applicationGatewayPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ag.Etag = &etag
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				ag.Zones = &zones
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				ag.Identity = &identity
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ag.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ag.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ag.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ag.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ag.Tags = tags
			}
		}
	}

	return nil
}

// ApplicationGatewayAuthenticationCertificate authentication certificates of an application gateway.
type ApplicationGatewayAuthenticationCertificate struct {
	// ApplicationGatewayAuthenticationCertificatePropertiesFormat - Properties of the application gateway authentication certificate.
	*ApplicationGatewayAuthenticationCertificatePropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the authentication certificate that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayAuthenticationCertificate.
func (agac ApplicationGatewayAuthenticationCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agac.ApplicationGatewayAuthenticationCertificatePropertiesFormat != nil {
		objectMap["properties"] = agac.ApplicationGatewayAuthenticationCertificatePropertiesFormat
	}
	if agac.Name != nil {
		objectMap["name"] = agac.Name
	}
	if agac.ID != nil {
		objectMap["id"] = agac.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayAuthenticationCertificate struct.
func (agac *ApplicationGatewayAuthenticationCertificate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayAuthenticationCertificatePropertiesFormat ApplicationGatewayAuthenticationCertificatePropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayAuthenticationCertificatePropertiesFormat)
				if err != nil {
					return err
				}
				agac.ApplicationGatewayAuthenticationCertificatePropertiesFormat = &applicationGatewayAuthenticationCertificatePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agac.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agac.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agac.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agac.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayAuthenticationCertificatePropertiesFormat authentication certificates properties of an
// application gateway.
type ApplicationGatewayAuthenticationCertificatePropertiesFormat struct {
	// Data - Certificate public data.
	Data *string `json:"data,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the authentication certificate resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayAuthenticationCertificatePropertiesFormat.
func (agacpf ApplicationGatewayAuthenticationCertificatePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agacpf.Data != nil {
		objectMap["data"] = agacpf.Data
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayAutoscaleConfiguration application Gateway autoscale configuration.
type ApplicationGatewayAutoscaleConfiguration struct {
	// MinCapacity - Lower bound on number of Application Gateway capacity.
	MinCapacity *int32 `json:"minCapacity,omitempty"`
	// MaxCapacity - Upper bound on number of Application Gateway capacity.
	MaxCapacity *int32 `json:"maxCapacity,omitempty"`
}

// ApplicationGatewayAvailableSslOptions response for ApplicationGatewayAvailableSslOptions API service
// call.
type ApplicationGatewayAvailableSslOptions struct {
	autorest.Response `json:"-"`
	// ApplicationGatewayAvailableSslOptionsPropertiesFormat - Properties of the application gateway available SSL options.
	*ApplicationGatewayAvailableSslOptionsPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayAvailableSslOptions.
func (agaso ApplicationGatewayAvailableSslOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agaso.ApplicationGatewayAvailableSslOptionsPropertiesFormat != nil {
		objectMap["properties"] = agaso.ApplicationGatewayAvailableSslOptionsPropertiesFormat
	}
	if agaso.ID != nil {
		objectMap["id"] = agaso.ID
	}
	if agaso.Location != nil {
		objectMap["location"] = agaso.Location
	}
	if agaso.Tags != nil {
		objectMap["tags"] = agaso.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayAvailableSslOptions struct.
func (agaso *ApplicationGatewayAvailableSslOptions) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayAvailableSslOptionsPropertiesFormat ApplicationGatewayAvailableSslOptionsPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayAvailableSslOptionsPropertiesFormat)
				if err != nil {
					return err
				}
				agaso.ApplicationGatewayAvailableSslOptionsPropertiesFormat = &applicationGatewayAvailableSslOptionsPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agaso.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agaso.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agaso.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				agaso.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				agaso.Tags = tags
			}
		}
	}

	return nil
}

// ApplicationGatewayAvailableSslOptionsPropertiesFormat properties of
// ApplicationGatewayAvailableSslOptions.
type ApplicationGatewayAvailableSslOptionsPropertiesFormat struct {
	// PredefinedPolicies - List of available Ssl predefined policy.
	PredefinedPolicies *[]SubResource `json:"predefinedPolicies,omitempty"`
	// DefaultPolicy - Name of the Ssl predefined policy applied by default to application gateway. Possible values include: 'ApplicationGatewaySslPolicyNameAppGwSslPolicy20150501', 'ApplicationGatewaySslPolicyNameAppGwSslPolicy20170401', 'ApplicationGatewaySslPolicyNameAppGwSslPolicy20170401S'
	DefaultPolicy ApplicationGatewaySslPolicyName `json:"defaultPolicy,omitempty"`
	// AvailableCipherSuites - List of available Ssl cipher suites.
	AvailableCipherSuites *[]ApplicationGatewaySslCipherSuite `json:"availableCipherSuites,omitempty"`
	// AvailableProtocols - List of available Ssl protocols.
	AvailableProtocols *[]ApplicationGatewaySslProtocol `json:"availableProtocols,omitempty"`
}

// ApplicationGatewayAvailableSslPredefinedPolicies response for ApplicationGatewayAvailableSslOptions API
// service call.
type ApplicationGatewayAvailableSslPredefinedPolicies struct {
	autorest.Response `json:"-"`
	// Value - List of available Ssl predefined policy.
	Value *[]ApplicationGatewaySslPredefinedPolicy `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ApplicationGatewayAvailableSslPredefinedPoliciesIterator provides access to a complete listing of
// ApplicationGatewaySslPredefinedPolicy values.
type ApplicationGatewayAvailableSslPredefinedPoliciesIterator struct {
	i    int
	page ApplicationGatewayAvailableSslPredefinedPoliciesPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ApplicationGatewayAvailableSslPredefinedPoliciesIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationGatewayAvailableSslPredefinedPoliciesIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ApplicationGatewayAvailableSslPredefinedPoliciesIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ApplicationGatewayAvailableSslPredefinedPoliciesIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ApplicationGatewayAvailableSslPredefinedPoliciesIterator) Response() ApplicationGatewayAvailableSslPredefinedPolicies {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ApplicationGatewayAvailableSslPredefinedPoliciesIterator) Value() ApplicationGatewaySslPredefinedPolicy {
	if !iter.page.NotDone() {
		return ApplicationGatewaySslPredefinedPolicy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ApplicationGatewayAvailableSslPredefinedPoliciesIterator type.
func NewApplicationGatewayAvailableSslPredefinedPoliciesIterator(page ApplicationGatewayAvailableSslPredefinedPoliciesPage) ApplicationGatewayAvailableSslPredefinedPoliciesIterator {
	return ApplicationGatewayAvailableSslPredefinedPoliciesIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (agaspp ApplicationGatewayAvailableSslPredefinedPolicies) IsEmpty() bool {
	return agaspp.Value == nil || len(*agaspp.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (agaspp ApplicationGatewayAvailableSslPredefinedPolicies) hasNextLink() bool {
	return agaspp.NextLink != nil && len(*agaspp.NextLink) != 0
}

// applicationGatewayAvailableSslPredefinedPoliciesPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (agaspp ApplicationGatewayAvailableSslPredefinedPolicies) applicationGatewayAvailableSslPredefinedPoliciesPreparer(ctx context.Context) (*http.Request, error) {
	if !agaspp.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(agaspp.NextLink)))
}

// ApplicationGatewayAvailableSslPredefinedPoliciesPage contains a page of
// ApplicationGatewaySslPredefinedPolicy values.
type ApplicationGatewayAvailableSslPredefinedPoliciesPage struct {
	fn     func(context.Context, ApplicationGatewayAvailableSslPredefinedPolicies) (ApplicationGatewayAvailableSslPredefinedPolicies, error)
	agaspp ApplicationGatewayAvailableSslPredefinedPolicies
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ApplicationGatewayAvailableSslPredefinedPoliciesPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationGatewayAvailableSslPredefinedPoliciesPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.agaspp)
		if err != nil {
			return err
		}
		page.agaspp = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ApplicationGatewayAvailableSslPredefinedPoliciesPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ApplicationGatewayAvailableSslPredefinedPoliciesPage) NotDone() bool {
	return !page.agaspp.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ApplicationGatewayAvailableSslPredefinedPoliciesPage) Response() ApplicationGatewayAvailableSslPredefinedPolicies {
	return page.agaspp
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ApplicationGatewayAvailableSslPredefinedPoliciesPage) Values() []ApplicationGatewaySslPredefinedPolicy {
	if page.agaspp.IsEmpty() {
		return nil
	}
	return *page.agaspp.Value
}

// Creates a new instance of the ApplicationGatewayAvailableSslPredefinedPoliciesPage type.
func NewApplicationGatewayAvailableSslPredefinedPoliciesPage(cur ApplicationGatewayAvailableSslPredefinedPolicies, getNextPage func(context.Context, ApplicationGatewayAvailableSslPredefinedPolicies) (ApplicationGatewayAvailableSslPredefinedPolicies, error)) ApplicationGatewayAvailableSslPredefinedPoliciesPage {
	return ApplicationGatewayAvailableSslPredefinedPoliciesPage{
		fn:     getNextPage,
		agaspp: cur,
	}
}

// ApplicationGatewayAvailableWafRuleSetsResult response for ApplicationGatewayAvailableWafRuleSets API
// service call.
type ApplicationGatewayAvailableWafRuleSetsResult struct {
	autorest.Response `json:"-"`
	// Value - The list of application gateway rule sets.
	Value *[]ApplicationGatewayFirewallRuleSet `json:"value,omitempty"`
}

// ApplicationGatewayBackendAddress backend address of an application gateway.
type ApplicationGatewayBackendAddress struct {
	// Fqdn - Fully qualified domain name (FQDN).
	Fqdn *string `json:"fqdn,omitempty"`
	// IPAddress - IP address.
	IPAddress *string `json:"ipAddress,omitempty"`
}

// ApplicationGatewayBackendAddressPool backend Address Pool of an application gateway.
type ApplicationGatewayBackendAddressPool struct {
	// ApplicationGatewayBackendAddressPoolPropertiesFormat - Properties of the application gateway backend address pool.
	*ApplicationGatewayBackendAddressPoolPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the backend address pool that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayBackendAddressPool.
func (agbap ApplicationGatewayBackendAddressPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agbap.ApplicationGatewayBackendAddressPoolPropertiesFormat != nil {
		objectMap["properties"] = agbap.ApplicationGatewayBackendAddressPoolPropertiesFormat
	}
	if agbap.Name != nil {
		objectMap["name"] = agbap.Name
	}
	if agbap.ID != nil {
		objectMap["id"] = agbap.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayBackendAddressPool struct.
func (agbap *ApplicationGatewayBackendAddressPool) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayBackendAddressPoolPropertiesFormat ApplicationGatewayBackendAddressPoolPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayBackendAddressPoolPropertiesFormat)
				if err != nil {
					return err
				}
				agbap.ApplicationGatewayBackendAddressPoolPropertiesFormat = &applicationGatewayBackendAddressPoolPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agbap.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agbap.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agbap.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agbap.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayBackendAddressPoolPropertiesFormat properties of Backend Address Pool of an
// application gateway.
type ApplicationGatewayBackendAddressPoolPropertiesFormat struct {
	// BackendIPConfigurations - READ-ONLY; Collection of references to IPs defined in network interfaces.
	BackendIPConfigurations *[]InterfaceIPConfiguration `json:"backendIPConfigurations,omitempty"`
	// BackendAddresses - Backend addresses.
	BackendAddresses *[]ApplicationGatewayBackendAddress `json:"backendAddresses,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the backend address pool resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayBackendAddressPoolPropertiesFormat.
func (agbappf ApplicationGatewayBackendAddressPoolPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agbappf.BackendAddresses != nil {
		objectMap["backendAddresses"] = agbappf.BackendAddresses
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayBackendHealth response for ApplicationGatewayBackendHealth API service call.
type ApplicationGatewayBackendHealth struct {
	autorest.Response `json:"-"`
	// BackendAddressPools - A list of ApplicationGatewayBackendHealthPool resources.
	BackendAddressPools *[]ApplicationGatewayBackendHealthPool `json:"backendAddressPools,omitempty"`
}

// ApplicationGatewayBackendHealthHTTPSettings application gateway BackendHealthHttp settings.
type ApplicationGatewayBackendHealthHTTPSettings struct {
	// BackendHTTPSettings - Reference to an ApplicationGatewayBackendHttpSettings resource.
	BackendHTTPSettings *ApplicationGatewayBackendHTTPSettings `json:"backendHttpSettings,omitempty"`
	// Servers - List of ApplicationGatewayBackendHealthServer resources.
	Servers *[]ApplicationGatewayBackendHealthServer `json:"servers,omitempty"`
}

// ApplicationGatewayBackendHealthOnDemand result of on demand test probe.
type ApplicationGatewayBackendHealthOnDemand struct {
	autorest.Response `json:"-"`
	// BackendAddressPool - Reference to an ApplicationGatewayBackendAddressPool resource.
	BackendAddressPool *ApplicationGatewayBackendAddressPool `json:"backendAddressPool,omitempty"`
	// BackendHealthHTTPSettings - Application gateway BackendHealthHttp settings.
	BackendHealthHTTPSettings *ApplicationGatewayBackendHealthHTTPSettings `json:"backendHealthHttpSettings,omitempty"`
}

// ApplicationGatewayBackendHealthPool application gateway BackendHealth pool.
type ApplicationGatewayBackendHealthPool struct {
	// BackendAddressPool - Reference to an ApplicationGatewayBackendAddressPool resource.
	BackendAddressPool *ApplicationGatewayBackendAddressPool `json:"backendAddressPool,omitempty"`
	// BackendHTTPSettingsCollection - List of ApplicationGatewayBackendHealthHttpSettings resources.
	BackendHTTPSettingsCollection *[]ApplicationGatewayBackendHealthHTTPSettings `json:"backendHttpSettingsCollection,omitempty"`
}

// ApplicationGatewayBackendHealthServer application gateway backendhealth http settings.
type ApplicationGatewayBackendHealthServer struct {
	// Address - IP address or FQDN of backend server.
	Address *string `json:"address,omitempty"`
	// IPConfiguration - Reference to IP configuration of backend server.
	IPConfiguration *InterfaceIPConfiguration `json:"ipConfiguration,omitempty"`
	// Health - Health of backend server. Possible values include: 'ApplicationGatewayBackendHealthServerHealthUnknown', 'ApplicationGatewayBackendHealthServerHealthUp', 'ApplicationGatewayBackendHealthServerHealthDown', 'ApplicationGatewayBackendHealthServerHealthPartial', 'ApplicationGatewayBackendHealthServerHealthDraining'
	Health ApplicationGatewayBackendHealthServerHealth `json:"health,omitempty"`
	// HealthProbeLog - Health Probe Log.
	HealthProbeLog *string `json:"healthProbeLog,omitempty"`
}

// ApplicationGatewayBackendHTTPSettings backend address pool settings of an application gateway.
type ApplicationGatewayBackendHTTPSettings struct {
	// ApplicationGatewayBackendHTTPSettingsPropertiesFormat - Properties of the application gateway backend HTTP settings.
	*ApplicationGatewayBackendHTTPSettingsPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the backend http settings that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayBackendHTTPSettings.
func (agbhs ApplicationGatewayBackendHTTPSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agbhs.ApplicationGatewayBackendHTTPSettingsPropertiesFormat != nil {
		objectMap["properties"] = agbhs.ApplicationGatewayBackendHTTPSettingsPropertiesFormat
	}
	if agbhs.Name != nil {
		objectMap["name"] = agbhs.Name
	}
	if agbhs.ID != nil {
		objectMap["id"] = agbhs.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayBackendHTTPSettings struct.
func (agbhs *ApplicationGatewayBackendHTTPSettings) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayBackendHTTPSettingsPropertiesFormat ApplicationGatewayBackendHTTPSettingsPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayBackendHTTPSettingsPropertiesFormat)
				if err != nil {
					return err
				}
				agbhs.ApplicationGatewayBackendHTTPSettingsPropertiesFormat = &applicationGatewayBackendHTTPSettingsPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agbhs.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agbhs.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agbhs.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agbhs.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayBackendHTTPSettingsPropertiesFormat properties of Backend address pool settings of an
// application gateway.
type ApplicationGatewayBackendHTTPSettingsPropertiesFormat struct {
	// Port - The destination port on the backend.
	Port *int32 `json:"port,omitempty"`
	// Protocol - The protocol used to communicate with the backend. Possible values include: 'ApplicationGatewayProtocolHTTP', 'ApplicationGatewayProtocolHTTPS'
	Protocol ApplicationGatewayProtocol `json:"protocol,omitempty"`
	// CookieBasedAffinity - Cookie based affinity. Possible values include: 'ApplicationGatewayCookieBasedAffinityEnabled', 'ApplicationGatewayCookieBasedAffinityDisabled'
	CookieBasedAffinity ApplicationGatewayCookieBasedAffinity `json:"cookieBasedAffinity,omitempty"`
	// RequestTimeout - Request timeout in seconds. Application Gateway will fail the request if response is not received within RequestTimeout. Acceptable values are from 1 second to 86400 seconds.
	RequestTimeout *int32 `json:"requestTimeout,omitempty"`
	// Probe - Probe resource of an application gateway.
	Probe *SubResource `json:"probe,omitempty"`
	// AuthenticationCertificates - Array of references to application gateway authentication certificates.
	AuthenticationCertificates *[]SubResource `json:"authenticationCertificates,omitempty"`
	// TrustedRootCertificates - Array of references to application gateway trusted root certificates.
	TrustedRootCertificates *[]SubResource `json:"trustedRootCertificates,omitempty"`
	// ConnectionDraining - Connection draining of the backend http settings resource.
	ConnectionDraining *ApplicationGatewayConnectionDraining `json:"connectionDraining,omitempty"`
	// HostName - Host header to be sent to the backend servers.
	HostName *string `json:"hostName,omitempty"`
	// PickHostNameFromBackendAddress - Whether to pick host header should be picked from the host name of the backend server. Default value is false.
	PickHostNameFromBackendAddress *bool `json:"pickHostNameFromBackendAddress,omitempty"`
	// AffinityCookieName - Cookie name to use for the affinity cookie.
	AffinityCookieName *string `json:"affinityCookieName,omitempty"`
	// ProbeEnabled - Whether the probe is enabled. Default value is false.
	ProbeEnabled *bool `json:"probeEnabled,omitempty"`
	// Path - Path which should be used as a prefix for all HTTP requests. Null means no path will be prefixed. Default value is null.
	Path *string `json:"path,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the backend HTTP settings resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayBackendHTTPSettingsPropertiesFormat.
func (agbhspf ApplicationGatewayBackendHTTPSettingsPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agbhspf.Port != nil {
		objectMap["port"] = agbhspf.Port
	}
	if agbhspf.Protocol != "" {
		objectMap["protocol"] = agbhspf.Protocol
	}
	if agbhspf.CookieBasedAffinity != "" {
		objectMap["cookieBasedAffinity"] = agbhspf.CookieBasedAffinity
	}
	if agbhspf.RequestTimeout != nil {
		objectMap["requestTimeout"] = agbhspf.RequestTimeout
	}
	if agbhspf.Probe != nil {
		objectMap["probe"] = agbhspf.Probe
	}
	if agbhspf.AuthenticationCertificates != nil {
		objectMap["authenticationCertificates"] = agbhspf.AuthenticationCertificates
	}
	if agbhspf.TrustedRootCertificates != nil {
		objectMap["trustedRootCertificates"] = agbhspf.TrustedRootCertificates
	}
	if agbhspf.ConnectionDraining != nil {
		objectMap["connectionDraining"] = agbhspf.ConnectionDraining
	}
	if agbhspf.HostName != nil {
		objectMap["hostName"] = agbhspf.HostName
	}
	if agbhspf.PickHostNameFromBackendAddress != nil {
		objectMap["pickHostNameFromBackendAddress"] = agbhspf.PickHostNameFromBackendAddress
	}
	if agbhspf.AffinityCookieName != nil {
		objectMap["affinityCookieName"] = agbhspf.AffinityCookieName
	}
	if agbhspf.ProbeEnabled != nil {
		objectMap["probeEnabled"] = agbhspf.ProbeEnabled
	}
	if agbhspf.Path != nil {
		objectMap["path"] = agbhspf.Path
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayClientAuthConfiguration application gateway client authentication configuration.
type ApplicationGatewayClientAuthConfiguration struct {
	// VerifyClientCertIssuerDN - Verify client certificate issuer name on the application gateway.
	VerifyClientCertIssuerDN *bool `json:"verifyClientCertIssuerDN,omitempty"`
}

// ApplicationGatewayConnectionDraining connection draining allows open connections to a backend server to
// be active for a specified time after the backend server got removed from the configuration.
type ApplicationGatewayConnectionDraining struct {
	// Enabled - Whether connection draining is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
	// DrainTimeoutInSec - The number of seconds connection draining is active. Acceptable values are from 1 second to 3600 seconds.
	DrainTimeoutInSec *int32 `json:"drainTimeoutInSec,omitempty"`
}

// ApplicationGatewayCustomError customer error of an application gateway.
type ApplicationGatewayCustomError struct {
	// StatusCode - Status code of the application gateway customer error. Possible values include: 'ApplicationGatewayCustomErrorStatusCodeHTTPStatus403', 'ApplicationGatewayCustomErrorStatusCodeHTTPStatus502'
	StatusCode ApplicationGatewayCustomErrorStatusCode `json:"statusCode,omitempty"`
	// CustomErrorPageURL - Error page URL of the application gateway customer error.
	CustomErrorPageURL *string `json:"customErrorPageUrl,omitempty"`
}

// ApplicationGatewayFirewallDisabledRuleGroup allows to disable rules within a rule group or an entire
// rule group.
type ApplicationGatewayFirewallDisabledRuleGroup struct {
	// RuleGroupName - The name of the rule group that will be disabled.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`
	// Rules - The list of rules that will be disabled. If null, all rules of the rule group will be disabled.
	Rules *[]int32 `json:"rules,omitempty"`
}

// ApplicationGatewayFirewallExclusion allow to exclude some variable satisfy the condition for the WAF
// check.
type ApplicationGatewayFirewallExclusion struct {
	// MatchVariable - The variable to be excluded.
	MatchVariable *string `json:"matchVariable,omitempty"`
	// SelectorMatchOperator - When matchVariable is a collection, operate on the selector to specify which elements in the collection this exclusion applies to.
	SelectorMatchOperator *string `json:"selectorMatchOperator,omitempty"`
	// Selector - When matchVariable is a collection, operator used to specify which elements in the collection this exclusion applies to.
	Selector *string `json:"selector,omitempty"`
}

// ApplicationGatewayFirewallRule a web application firewall rule.
type ApplicationGatewayFirewallRule struct {
	// RuleID - The identifier of the web application firewall rule.
	RuleID *int32 `json:"ruleId,omitempty"`
	// Description - The description of the web application firewall rule.
	Description *string `json:"description,omitempty"`
}

// ApplicationGatewayFirewallRuleGroup a web application firewall rule group.
type ApplicationGatewayFirewallRuleGroup struct {
	// RuleGroupName - The name of the web application firewall rule group.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`
	// Description - The description of the web application firewall rule group.
	Description *string `json:"description,omitempty"`
	// Rules - The rules of the web application firewall rule group.
	Rules *[]ApplicationGatewayFirewallRule `json:"rules,omitempty"`
}

// ApplicationGatewayFirewallRuleSet a web application firewall rule set.
type ApplicationGatewayFirewallRuleSet struct {
	// ApplicationGatewayFirewallRuleSetPropertiesFormat - Properties of the application gateway firewall rule set.
	*ApplicationGatewayFirewallRuleSetPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayFirewallRuleSet.
func (agfrs ApplicationGatewayFirewallRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agfrs.ApplicationGatewayFirewallRuleSetPropertiesFormat != nil {
		objectMap["properties"] = agfrs.ApplicationGatewayFirewallRuleSetPropertiesFormat
	}
	if agfrs.ID != nil {
		objectMap["id"] = agfrs.ID
	}
	if agfrs.Location != nil {
		objectMap["location"] = agfrs.Location
	}
	if agfrs.Tags != nil {
		objectMap["tags"] = agfrs.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayFirewallRuleSet struct.
func (agfrs *ApplicationGatewayFirewallRuleSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayFirewallRuleSetPropertiesFormat ApplicationGatewayFirewallRuleSetPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayFirewallRuleSetPropertiesFormat)
				if err != nil {
					return err
				}
				agfrs.ApplicationGatewayFirewallRuleSetPropertiesFormat = &applicationGatewayFirewallRuleSetPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agfrs.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agfrs.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agfrs.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				agfrs.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				agfrs.Tags = tags
			}
		}
	}

	return nil
}

// ApplicationGatewayFirewallRuleSetPropertiesFormat properties of the web application firewall rule set.
type ApplicationGatewayFirewallRuleSetPropertiesFormat struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the web application firewall rule set. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// RuleSetType - The type of the web application firewall rule set.
	RuleSetType *string `json:"ruleSetType,omitempty"`
	// RuleSetVersion - The version of the web application firewall rule set type.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
	// RuleGroups - The rule groups of the web application firewall rule set.
	RuleGroups *[]ApplicationGatewayFirewallRuleGroup `json:"ruleGroups,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayFirewallRuleSetPropertiesFormat.
func (agfrspf ApplicationGatewayFirewallRuleSetPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agfrspf.RuleSetType != nil {
		objectMap["ruleSetType"] = agfrspf.RuleSetType
	}
	if agfrspf.RuleSetVersion != nil {
		objectMap["ruleSetVersion"] = agfrspf.RuleSetVersion
	}
	if agfrspf.RuleGroups != nil {
		objectMap["ruleGroups"] = agfrspf.RuleGroups
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayFrontendIPConfiguration frontend IP configuration of an application gateway.
type ApplicationGatewayFrontendIPConfiguration struct {
	// ApplicationGatewayFrontendIPConfigurationPropertiesFormat - Properties of the application gateway frontend IP configuration.
	*ApplicationGatewayFrontendIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the frontend IP configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayFrontendIPConfiguration.
func (agfic ApplicationGatewayFrontendIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agfic.ApplicationGatewayFrontendIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = agfic.ApplicationGatewayFrontendIPConfigurationPropertiesFormat
	}
	if agfic.Name != nil {
		objectMap["name"] = agfic.Name
	}
	if agfic.ID != nil {
		objectMap["id"] = agfic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayFrontendIPConfiguration struct.
func (agfic *ApplicationGatewayFrontendIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayFrontendIPConfigurationPropertiesFormat ApplicationGatewayFrontendIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayFrontendIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				agfic.ApplicationGatewayFrontendIPConfigurationPropertiesFormat = &applicationGatewayFrontendIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agfic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agfic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agfic.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agfic.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayFrontendIPConfigurationPropertiesFormat properties of Frontend IP configuration of an
// application gateway.
type ApplicationGatewayFrontendIPConfigurationPropertiesFormat struct {
	// PrivateIPAddress - PrivateIPAddress of the network interface IP Configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	// Subnet - Reference to the subnet resource.
	Subnet *SubResource `json:"subnet,omitempty"`
	// PublicIPAddress - Reference to the PublicIP resource.
	PublicIPAddress *SubResource `json:"publicIPAddress,omitempty"`
	// PrivateLinkConfiguration - Reference to the application gateway private link configuration.
	PrivateLinkConfiguration *SubResource `json:"privateLinkConfiguration,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the frontend IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayFrontendIPConfigurationPropertiesFormat.
func (agficpf ApplicationGatewayFrontendIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agficpf.PrivateIPAddress != nil {
		objectMap["privateIPAddress"] = agficpf.PrivateIPAddress
	}
	if agficpf.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = agficpf.PrivateIPAllocationMethod
	}
	if agficpf.Subnet != nil {
		objectMap["subnet"] = agficpf.Subnet
	}
	if agficpf.PublicIPAddress != nil {
		objectMap["publicIPAddress"] = agficpf.PublicIPAddress
	}
	if agficpf.PrivateLinkConfiguration != nil {
		objectMap["privateLinkConfiguration"] = agficpf.PrivateLinkConfiguration
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayFrontendPort frontend port of an application gateway.
type ApplicationGatewayFrontendPort struct {
	// ApplicationGatewayFrontendPortPropertiesFormat - Properties of the application gateway frontend port.
	*ApplicationGatewayFrontendPortPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the frontend port that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayFrontendPort.
func (agfp ApplicationGatewayFrontendPort) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agfp.ApplicationGatewayFrontendPortPropertiesFormat != nil {
		objectMap["properties"] = agfp.ApplicationGatewayFrontendPortPropertiesFormat
	}
	if agfp.Name != nil {
		objectMap["name"] = agfp.Name
	}
	if agfp.ID != nil {
		objectMap["id"] = agfp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayFrontendPort struct.
func (agfp *ApplicationGatewayFrontendPort) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayFrontendPortPropertiesFormat ApplicationGatewayFrontendPortPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayFrontendPortPropertiesFormat)
				if err != nil {
					return err
				}
				agfp.ApplicationGatewayFrontendPortPropertiesFormat = &applicationGatewayFrontendPortPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agfp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agfp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agfp.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agfp.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayFrontendPortPropertiesFormat properties of Frontend port of an application gateway.
type ApplicationGatewayFrontendPortPropertiesFormat struct {
	// Port - Frontend port.
	Port *int32 `json:"port,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the frontend port resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayFrontendPortPropertiesFormat.
func (agfppf ApplicationGatewayFrontendPortPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agfppf.Port != nil {
		objectMap["port"] = agfppf.Port
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayHeaderConfiguration header configuration of the Actions set in Application Gateway.
type ApplicationGatewayHeaderConfiguration struct {
	// HeaderName - Header name of the header configuration.
	HeaderName *string `json:"headerName,omitempty"`
	// HeaderValue - Header value of the header configuration.
	HeaderValue *string `json:"headerValue,omitempty"`
}

// ApplicationGatewayHTTPListener http listener of an application gateway.
type ApplicationGatewayHTTPListener struct {
	// ApplicationGatewayHTTPListenerPropertiesFormat - Properties of the application gateway HTTP listener.
	*ApplicationGatewayHTTPListenerPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the HTTP listener that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayHTTPListener.
func (aghl ApplicationGatewayHTTPListener) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aghl.ApplicationGatewayHTTPListenerPropertiesFormat != nil {
		objectMap["properties"] = aghl.ApplicationGatewayHTTPListenerPropertiesFormat
	}
	if aghl.Name != nil {
		objectMap["name"] = aghl.Name
	}
	if aghl.ID != nil {
		objectMap["id"] = aghl.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayHTTPListener struct.
func (aghl *ApplicationGatewayHTTPListener) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayHTTPListenerPropertiesFormat ApplicationGatewayHTTPListenerPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayHTTPListenerPropertiesFormat)
				if err != nil {
					return err
				}
				aghl.ApplicationGatewayHTTPListenerPropertiesFormat = &applicationGatewayHTTPListenerPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				aghl.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				aghl.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				aghl.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				aghl.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayHTTPListenerPropertiesFormat properties of HTTP listener of an application gateway.
type ApplicationGatewayHTTPListenerPropertiesFormat struct {
	// FrontendIPConfiguration - Frontend IP configuration resource of an application gateway.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`
	// FrontendPort - Frontend port resource of an application gateway.
	FrontendPort *SubResource `json:"frontendPort,omitempty"`
	// Protocol - Protocol of the HTTP listener. Possible values include: 'ApplicationGatewayProtocolHTTP', 'ApplicationGatewayProtocolHTTPS'
	Protocol ApplicationGatewayProtocol `json:"protocol,omitempty"`
	// HostName - Host name of HTTP listener.
	HostName *string `json:"hostName,omitempty"`
	// SslCertificate - SSL certificate resource of an application gateway.
	SslCertificate *SubResource `json:"sslCertificate,omitempty"`
	// SslProfile - SSL profile resource of the application gateway.
	SslProfile *SubResource `json:"sslProfile,omitempty"`
	// RequireServerNameIndication - Applicable only if protocol is https. Enables SNI for multi-hosting.
	RequireServerNameIndication *bool `json:"requireServerNameIndication,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the HTTP listener resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// CustomErrorConfigurations - Custom error configurations of the HTTP listener.
	CustomErrorConfigurations *[]ApplicationGatewayCustomError `json:"customErrorConfigurations,omitempty"`
	// FirewallPolicy - Reference to the FirewallPolicy resource.
	FirewallPolicy *SubResource `json:"firewallPolicy,omitempty"`
	// HostNames - List of Host names for HTTP Listener that allows special wildcard characters as well.
	HostNames *[]string `json:"hostNames,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayHTTPListenerPropertiesFormat.
func (aghlpf ApplicationGatewayHTTPListenerPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aghlpf.FrontendIPConfiguration != nil {
		objectMap["frontendIPConfiguration"] = aghlpf.FrontendIPConfiguration
	}
	if aghlpf.FrontendPort != nil {
		objectMap["frontendPort"] = aghlpf.FrontendPort
	}
	if aghlpf.Protocol != "" {
		objectMap["protocol"] = aghlpf.Protocol
	}
	if aghlpf.HostName != nil {
		objectMap["hostName"] = aghlpf.HostName
	}
	if aghlpf.SslCertificate != nil {
		objectMap["sslCertificate"] = aghlpf.SslCertificate
	}
	if aghlpf.SslProfile != nil {
		objectMap["sslProfile"] = aghlpf.SslProfile
	}
	if aghlpf.RequireServerNameIndication != nil {
		objectMap["requireServerNameIndication"] = aghlpf.RequireServerNameIndication
	}
	if aghlpf.CustomErrorConfigurations != nil {
		objectMap["customErrorConfigurations"] = aghlpf.CustomErrorConfigurations
	}
	if aghlpf.FirewallPolicy != nil {
		objectMap["firewallPolicy"] = aghlpf.FirewallPolicy
	}
	if aghlpf.HostNames != nil {
		objectMap["hostNames"] = aghlpf.HostNames
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayIPConfiguration IP configuration of an application gateway. Currently 1 public and 1
// private IP configuration is allowed.
type ApplicationGatewayIPConfiguration struct {
	// ApplicationGatewayIPConfigurationPropertiesFormat - Properties of the application gateway IP configuration.
	*ApplicationGatewayIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the IP configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayIPConfiguration.
func (agic ApplicationGatewayIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agic.ApplicationGatewayIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = agic.ApplicationGatewayIPConfigurationPropertiesFormat
	}
	if agic.Name != nil {
		objectMap["name"] = agic.Name
	}
	if agic.ID != nil {
		objectMap["id"] = agic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayIPConfiguration struct.
func (agic *ApplicationGatewayIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayIPConfigurationPropertiesFormat ApplicationGatewayIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				agic.ApplicationGatewayIPConfigurationPropertiesFormat = &applicationGatewayIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agic.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agic.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayIPConfigurationPropertiesFormat properties of IP configuration of an application
// gateway.
type ApplicationGatewayIPConfigurationPropertiesFormat struct {
	// Subnet - Reference to the subnet resource. A subnet from where application gateway gets its private address.
	Subnet *SubResource `json:"subnet,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the application gateway IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayIPConfigurationPropertiesFormat.
func (agicpf ApplicationGatewayIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agicpf.Subnet != nil {
		objectMap["subnet"] = agicpf.Subnet
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayListResult response for ListApplicationGateways API service call.
type ApplicationGatewayListResult struct {
	autorest.Response `json:"-"`
	// Value - List of an application gateways in a resource group.
	Value *[]ApplicationGateway `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ApplicationGatewayListResultIterator provides access to a complete listing of ApplicationGateway values.
type ApplicationGatewayListResultIterator struct {
	i    int
	page ApplicationGatewayListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ApplicationGatewayListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationGatewayListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ApplicationGatewayListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ApplicationGatewayListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ApplicationGatewayListResultIterator) Response() ApplicationGatewayListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ApplicationGatewayListResultIterator) Value() ApplicationGateway {
	if !iter.page.NotDone() {
		return ApplicationGateway{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ApplicationGatewayListResultIterator type.
func NewApplicationGatewayListResultIterator(page ApplicationGatewayListResultPage) ApplicationGatewayListResultIterator {
	return ApplicationGatewayListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aglr ApplicationGatewayListResult) IsEmpty() bool {
	return aglr.Value == nil || len(*aglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aglr ApplicationGatewayListResult) hasNextLink() bool {
	return aglr.NextLink != nil && len(*aglr.NextLink) != 0
}

// applicationGatewayListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aglr ApplicationGatewayListResult) applicationGatewayListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !aglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aglr.NextLink)))
}

// ApplicationGatewayListResultPage contains a page of ApplicationGateway values.
type ApplicationGatewayListResultPage struct {
	fn   func(context.Context, ApplicationGatewayListResult) (ApplicationGatewayListResult, error)
	aglr ApplicationGatewayListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ApplicationGatewayListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationGatewayListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aglr)
		if err != nil {
			return err
		}
		page.aglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ApplicationGatewayListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ApplicationGatewayListResultPage) NotDone() bool {
	return !page.aglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ApplicationGatewayListResultPage) Response() ApplicationGatewayListResult {
	return page.aglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ApplicationGatewayListResultPage) Values() []ApplicationGateway {
	if page.aglr.IsEmpty() {
		return nil
	}
	return *page.aglr.Value
}

// Creates a new instance of the ApplicationGatewayListResultPage type.
func NewApplicationGatewayListResultPage(cur ApplicationGatewayListResult, getNextPage func(context.Context, ApplicationGatewayListResult) (ApplicationGatewayListResult, error)) ApplicationGatewayListResultPage {
	return ApplicationGatewayListResultPage{
		fn:   getNextPage,
		aglr: cur,
	}
}

// ApplicationGatewayOnDemandProbe details of on demand test probe request.
type ApplicationGatewayOnDemandProbe struct {
	// Protocol - The protocol used for the probe. Possible values include: 'ApplicationGatewayProtocolHTTP', 'ApplicationGatewayProtocolHTTPS'
	Protocol ApplicationGatewayProtocol `json:"protocol,omitempty"`
	// Host - Host name to send the probe to.
	Host *string `json:"host,omitempty"`
	// Path - Relative path of probe. Valid path starts from '/'. Probe is sent to <Protocol>://<host>:<port><path>.
	Path *string `json:"path,omitempty"`
	// Timeout - The probe timeout in seconds. Probe marked as failed if valid response is not received with this timeout period. Acceptable values are from 1 second to 86400 seconds.
	Timeout *int32 `json:"timeout,omitempty"`
	// PickHostNameFromBackendHTTPSettings - Whether the host header should be picked from the backend http settings. Default value is false.
	PickHostNameFromBackendHTTPSettings *bool `json:"pickHostNameFromBackendHttpSettings,omitempty"`
	// Match - Criterion for classifying a healthy probe response.
	Match *ApplicationGatewayProbeHealthResponseMatch `json:"match,omitempty"`
	// BackendAddressPool - Reference to backend pool of application gateway to which probe request will be sent.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`
	// BackendHTTPSettings - Reference to backend http setting of application gateway to be used for test probe.
	BackendHTTPSettings *SubResource `json:"backendHttpSettings,omitempty"`
}

// ApplicationGatewayPathRule path rule of URL path map of an application gateway.
type ApplicationGatewayPathRule struct {
	// ApplicationGatewayPathRulePropertiesFormat - Properties of the application gateway path rule.
	*ApplicationGatewayPathRulePropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the path rule that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPathRule.
func (agpr ApplicationGatewayPathRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agpr.ApplicationGatewayPathRulePropertiesFormat != nil {
		objectMap["properties"] = agpr.ApplicationGatewayPathRulePropertiesFormat
	}
	if agpr.Name != nil {
		objectMap["name"] = agpr.Name
	}
	if agpr.ID != nil {
		objectMap["id"] = agpr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayPathRule struct.
func (agpr *ApplicationGatewayPathRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayPathRulePropertiesFormat ApplicationGatewayPathRulePropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayPathRulePropertiesFormat)
				if err != nil {
					return err
				}
				agpr.ApplicationGatewayPathRulePropertiesFormat = &applicationGatewayPathRulePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agpr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agpr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agpr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agpr.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayPathRulePropertiesFormat properties of path rule of an application gateway.
type ApplicationGatewayPathRulePropertiesFormat struct {
	// Paths - Path rules of URL path map.
	Paths *[]string `json:"paths,omitempty"`
	// BackendAddressPool - Backend address pool resource of URL path map path rule.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`
	// BackendHTTPSettings - Backend http settings resource of URL path map path rule.
	BackendHTTPSettings *SubResource `json:"backendHttpSettings,omitempty"`
	// RedirectConfiguration - Redirect configuration resource of URL path map path rule.
	RedirectConfiguration *SubResource `json:"redirectConfiguration,omitempty"`
	// RewriteRuleSet - Rewrite rule set resource of URL path map path rule.
	RewriteRuleSet *SubResource `json:"rewriteRuleSet,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the path rule resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// FirewallPolicy - Reference to the FirewallPolicy resource.
	FirewallPolicy *SubResource `json:"firewallPolicy,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPathRulePropertiesFormat.
func (agprpf ApplicationGatewayPathRulePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agprpf.Paths != nil {
		objectMap["paths"] = agprpf.Paths
	}
	if agprpf.BackendAddressPool != nil {
		objectMap["backendAddressPool"] = agprpf.BackendAddressPool
	}
	if agprpf.BackendHTTPSettings != nil {
		objectMap["backendHttpSettings"] = agprpf.BackendHTTPSettings
	}
	if agprpf.RedirectConfiguration != nil {
		objectMap["redirectConfiguration"] = agprpf.RedirectConfiguration
	}
	if agprpf.RewriteRuleSet != nil {
		objectMap["rewriteRuleSet"] = agprpf.RewriteRuleSet
	}
	if agprpf.FirewallPolicy != nil {
		objectMap["firewallPolicy"] = agprpf.FirewallPolicy
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayPrivateEndpointConnection private Endpoint connection on an application gateway.
type ApplicationGatewayPrivateEndpointConnection struct {
	autorest.Response `json:"-"`
	// ApplicationGatewayPrivateEndpointConnectionProperties - Properties of the application gateway private endpoint connection.
	*ApplicationGatewayPrivateEndpointConnectionProperties `json:"properties,omitempty"`
	// Name - Name of the private endpoint connection on an application gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPrivateEndpointConnection.
func (agpec ApplicationGatewayPrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agpec.ApplicationGatewayPrivateEndpointConnectionProperties != nil {
		objectMap["properties"] = agpec.ApplicationGatewayPrivateEndpointConnectionProperties
	}
	if agpec.Name != nil {
		objectMap["name"] = agpec.Name
	}
	if agpec.ID != nil {
		objectMap["id"] = agpec.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayPrivateEndpointConnection struct.
func (agpec *ApplicationGatewayPrivateEndpointConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayPrivateEndpointConnectionProperties ApplicationGatewayPrivateEndpointConnectionProperties
				err = json.Unmarshal(*v, &applicationGatewayPrivateEndpointConnectionProperties)
				if err != nil {
					return err
				}
				agpec.ApplicationGatewayPrivateEndpointConnectionProperties = &applicationGatewayPrivateEndpointConnectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agpec.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agpec.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agpec.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agpec.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayPrivateEndpointConnectionListResult response for
// ListApplicationGatewayPrivateEndpointConnection API service call. Gets all private endpoint connections
// for an application gateway.
type ApplicationGatewayPrivateEndpointConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - List of private endpoint connections on an application gateway.
	Value *[]ApplicationGatewayPrivateEndpointConnection `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ApplicationGatewayPrivateEndpointConnectionListResultIterator provides access to a complete listing of
// ApplicationGatewayPrivateEndpointConnection values.
type ApplicationGatewayPrivateEndpointConnectionListResultIterator struct {
	i    int
	page ApplicationGatewayPrivateEndpointConnectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ApplicationGatewayPrivateEndpointConnectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationGatewayPrivateEndpointConnectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ApplicationGatewayPrivateEndpointConnectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ApplicationGatewayPrivateEndpointConnectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ApplicationGatewayPrivateEndpointConnectionListResultIterator) Response() ApplicationGatewayPrivateEndpointConnectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ApplicationGatewayPrivateEndpointConnectionListResultIterator) Value() ApplicationGatewayPrivateEndpointConnection {
	if !iter.page.NotDone() {
		return ApplicationGatewayPrivateEndpointConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ApplicationGatewayPrivateEndpointConnectionListResultIterator type.
func NewApplicationGatewayPrivateEndpointConnectionListResultIterator(page ApplicationGatewayPrivateEndpointConnectionListResultPage) ApplicationGatewayPrivateEndpointConnectionListResultIterator {
	return ApplicationGatewayPrivateEndpointConnectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (agpeclr ApplicationGatewayPrivateEndpointConnectionListResult) IsEmpty() bool {
	return agpeclr.Value == nil || len(*agpeclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (agpeclr ApplicationGatewayPrivateEndpointConnectionListResult) hasNextLink() bool {
	return agpeclr.NextLink != nil && len(*agpeclr.NextLink) != 0
}

// applicationGatewayPrivateEndpointConnectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (agpeclr ApplicationGatewayPrivateEndpointConnectionListResult) applicationGatewayPrivateEndpointConnectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !agpeclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(agpeclr.NextLink)))
}

// ApplicationGatewayPrivateEndpointConnectionListResultPage contains a page of
// ApplicationGatewayPrivateEndpointConnection values.
type ApplicationGatewayPrivateEndpointConnectionListResultPage struct {
	fn      func(context.Context, ApplicationGatewayPrivateEndpointConnectionListResult) (ApplicationGatewayPrivateEndpointConnectionListResult, error)
	agpeclr ApplicationGatewayPrivateEndpointConnectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ApplicationGatewayPrivateEndpointConnectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationGatewayPrivateEndpointConnectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.agpeclr)
		if err != nil {
			return err
		}
		page.agpeclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ApplicationGatewayPrivateEndpointConnectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ApplicationGatewayPrivateEndpointConnectionListResultPage) NotDone() bool {
	return !page.agpeclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ApplicationGatewayPrivateEndpointConnectionListResultPage) Response() ApplicationGatewayPrivateEndpointConnectionListResult {
	return page.agpeclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ApplicationGatewayPrivateEndpointConnectionListResultPage) Values() []ApplicationGatewayPrivateEndpointConnection {
	if page.agpeclr.IsEmpty() {
		return nil
	}
	return *page.agpeclr.Value
}

// Creates a new instance of the ApplicationGatewayPrivateEndpointConnectionListResultPage type.
func NewApplicationGatewayPrivateEndpointConnectionListResultPage(cur ApplicationGatewayPrivateEndpointConnectionListResult, getNextPage func(context.Context, ApplicationGatewayPrivateEndpointConnectionListResult) (ApplicationGatewayPrivateEndpointConnectionListResult, error)) ApplicationGatewayPrivateEndpointConnectionListResultPage {
	return ApplicationGatewayPrivateEndpointConnectionListResultPage{
		fn:      getNextPage,
		agpeclr: cur,
	}
}

// ApplicationGatewayPrivateEndpointConnectionProperties properties of Private Link Resource of an
// application gateway.
type ApplicationGatewayPrivateEndpointConnectionProperties struct {
	// PrivateEndpoint - READ-ONLY; The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`
	// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the application gateway private endpoint connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// LinkIdentifier - READ-ONLY; The consumer link id.
	LinkIdentifier *string `json:"linkIdentifier,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPrivateEndpointConnectionProperties.
func (agpecp ApplicationGatewayPrivateEndpointConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agpecp.PrivateLinkServiceConnectionState != nil {
		objectMap["privateLinkServiceConnectionState"] = agpecp.PrivateLinkServiceConnectionState
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayPrivateEndpointConnectionsDeleteFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type ApplicationGatewayPrivateEndpointConnectionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationGatewayPrivateEndpointConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationGatewayPrivateEndpointConnectionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationGatewayPrivateEndpointConnectionsDeleteFuture.Result.
func (future *ApplicationGatewayPrivateEndpointConnectionsDeleteFuture) result(client ApplicationGatewayPrivateEndpointConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationGatewayPrivateEndpointConnectionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationGatewayPrivateEndpointConnectionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ApplicationGatewayPrivateEndpointConnectionsUpdateFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type ApplicationGatewayPrivateEndpointConnectionsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationGatewayPrivateEndpointConnectionsClient) (ApplicationGatewayPrivateEndpointConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationGatewayPrivateEndpointConnectionsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationGatewayPrivateEndpointConnectionsUpdateFuture.Result.
func (future *ApplicationGatewayPrivateEndpointConnectionsUpdateFuture) result(client ApplicationGatewayPrivateEndpointConnectionsClient) (agpec ApplicationGatewayPrivateEndpointConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationGatewayPrivateEndpointConnectionsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		agpec.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationGatewayPrivateEndpointConnectionsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if agpec.Response.Response, err = future.GetResult(sender); err == nil && agpec.Response.Response.StatusCode != http.StatusNoContent {
		agpec, err = client.UpdateResponder(agpec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ApplicationGatewayPrivateEndpointConnectionsUpdateFuture", "Result", agpec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ApplicationGatewayPrivateLinkConfiguration private Link Configuration on an application gateway.
type ApplicationGatewayPrivateLinkConfiguration struct {
	// ApplicationGatewayPrivateLinkConfigurationProperties - Properties of the application gateway private link configuration.
	*ApplicationGatewayPrivateLinkConfigurationProperties `json:"properties,omitempty"`
	// Name - Name of the private link configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPrivateLinkConfiguration.
func (agplc ApplicationGatewayPrivateLinkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agplc.ApplicationGatewayPrivateLinkConfigurationProperties != nil {
		objectMap["properties"] = agplc.ApplicationGatewayPrivateLinkConfigurationProperties
	}
	if agplc.Name != nil {
		objectMap["name"] = agplc.Name
	}
	if agplc.ID != nil {
		objectMap["id"] = agplc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayPrivateLinkConfiguration struct.
func (agplc *ApplicationGatewayPrivateLinkConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayPrivateLinkConfigurationProperties ApplicationGatewayPrivateLinkConfigurationProperties
				err = json.Unmarshal(*v, &applicationGatewayPrivateLinkConfigurationProperties)
				if err != nil {
					return err
				}
				agplc.ApplicationGatewayPrivateLinkConfigurationProperties = &applicationGatewayPrivateLinkConfigurationProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agplc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agplc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agplc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agplc.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayPrivateLinkConfigurationProperties properties of private link configuration on an
// application gateway.
type ApplicationGatewayPrivateLinkConfigurationProperties struct {
	// IPConfigurations - An array of application gateway private link ip configurations.
	IPConfigurations *[]ApplicationGatewayPrivateLinkIPConfiguration `json:"ipConfigurations,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the application gateway private link configuration. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPrivateLinkConfigurationProperties.
func (agplcp ApplicationGatewayPrivateLinkConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agplcp.IPConfigurations != nil {
		objectMap["ipConfigurations"] = agplcp.IPConfigurations
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayPrivateLinkIPConfiguration the application gateway private link ip configuration.
type ApplicationGatewayPrivateLinkIPConfiguration struct {
	// ApplicationGatewayPrivateLinkIPConfigurationProperties - Properties of an application gateway private link ip configuration.
	*ApplicationGatewayPrivateLinkIPConfigurationProperties `json:"properties,omitempty"`
	// Name - The name of application gateway private link ip configuration.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPrivateLinkIPConfiguration.
func (agplic ApplicationGatewayPrivateLinkIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agplic.ApplicationGatewayPrivateLinkIPConfigurationProperties != nil {
		objectMap["properties"] = agplic.ApplicationGatewayPrivateLinkIPConfigurationProperties
	}
	if agplic.Name != nil {
		objectMap["name"] = agplic.Name
	}
	if agplic.ID != nil {
		objectMap["id"] = agplic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayPrivateLinkIPConfiguration struct.
func (agplic *ApplicationGatewayPrivateLinkIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayPrivateLinkIPConfigurationProperties ApplicationGatewayPrivateLinkIPConfigurationProperties
				err = json.Unmarshal(*v, &applicationGatewayPrivateLinkIPConfigurationProperties)
				if err != nil {
					return err
				}
				agplic.ApplicationGatewayPrivateLinkIPConfigurationProperties = &applicationGatewayPrivateLinkIPConfigurationProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agplic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agplic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agplic.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agplic.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayPrivateLinkIPConfigurationProperties properties of an application gateway private link
// IP configuration.
type ApplicationGatewayPrivateLinkIPConfigurationProperties struct {
	// PrivateIPAddress - The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	// Subnet - Reference to the subnet resource.
	Subnet *SubResource `json:"subnet,omitempty"`
	// Primary - Whether the ip configuration is primary or not.
	Primary *bool `json:"primary,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the application gateway private link IP configuration. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPrivateLinkIPConfigurationProperties.
func (agplicp ApplicationGatewayPrivateLinkIPConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agplicp.PrivateIPAddress != nil {
		objectMap["privateIPAddress"] = agplicp.PrivateIPAddress
	}
	if agplicp.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = agplicp.PrivateIPAllocationMethod
	}
	if agplicp.Subnet != nil {
		objectMap["subnet"] = agplicp.Subnet
	}
	if agplicp.Primary != nil {
		objectMap["primary"] = agplicp.Primary
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayPrivateLinkResource privateLink Resource of an application gateway.
type ApplicationGatewayPrivateLinkResource struct {
	// ApplicationGatewayPrivateLinkResourceProperties - Properties of the application gateway private link resource.
	*ApplicationGatewayPrivateLinkResourceProperties `json:"properties,omitempty"`
	// Name - Name of the private link resource that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPrivateLinkResource.
func (agplr ApplicationGatewayPrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agplr.ApplicationGatewayPrivateLinkResourceProperties != nil {
		objectMap["properties"] = agplr.ApplicationGatewayPrivateLinkResourceProperties
	}
	if agplr.Name != nil {
		objectMap["name"] = agplr.Name
	}
	if agplr.ID != nil {
		objectMap["id"] = agplr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayPrivateLinkResource struct.
func (agplr *ApplicationGatewayPrivateLinkResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayPrivateLinkResourceProperties ApplicationGatewayPrivateLinkResourceProperties
				err = json.Unmarshal(*v, &applicationGatewayPrivateLinkResourceProperties)
				if err != nil {
					return err
				}
				agplr.ApplicationGatewayPrivateLinkResourceProperties = &applicationGatewayPrivateLinkResourceProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agplr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agplr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agplr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agplr.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayPrivateLinkResourceListResult response for ListApplicationGatewayPrivateLinkResources
// API service call. Gets all private link resources for an application gateway.
type ApplicationGatewayPrivateLinkResourceListResult struct {
	autorest.Response `json:"-"`
	// Value - List of private link resources of an application gateway.
	Value *[]ApplicationGatewayPrivateLinkResource `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ApplicationGatewayPrivateLinkResourceListResultIterator provides access to a complete listing of
// ApplicationGatewayPrivateLinkResource values.
type ApplicationGatewayPrivateLinkResourceListResultIterator struct {
	i    int
	page ApplicationGatewayPrivateLinkResourceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ApplicationGatewayPrivateLinkResourceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationGatewayPrivateLinkResourceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ApplicationGatewayPrivateLinkResourceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ApplicationGatewayPrivateLinkResourceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ApplicationGatewayPrivateLinkResourceListResultIterator) Response() ApplicationGatewayPrivateLinkResourceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ApplicationGatewayPrivateLinkResourceListResultIterator) Value() ApplicationGatewayPrivateLinkResource {
	if !iter.page.NotDone() {
		return ApplicationGatewayPrivateLinkResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ApplicationGatewayPrivateLinkResourceListResultIterator type.
func NewApplicationGatewayPrivateLinkResourceListResultIterator(page ApplicationGatewayPrivateLinkResourceListResultPage) ApplicationGatewayPrivateLinkResourceListResultIterator {
	return ApplicationGatewayPrivateLinkResourceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (agplrlr ApplicationGatewayPrivateLinkResourceListResult) IsEmpty() bool {
	return agplrlr.Value == nil || len(*agplrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (agplrlr ApplicationGatewayPrivateLinkResourceListResult) hasNextLink() bool {
	return agplrlr.NextLink != nil && len(*agplrlr.NextLink) != 0
}

// applicationGatewayPrivateLinkResourceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (agplrlr ApplicationGatewayPrivateLinkResourceListResult) applicationGatewayPrivateLinkResourceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !agplrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(agplrlr.NextLink)))
}

// ApplicationGatewayPrivateLinkResourceListResultPage contains a page of
// ApplicationGatewayPrivateLinkResource values.
type ApplicationGatewayPrivateLinkResourceListResultPage struct {
	fn      func(context.Context, ApplicationGatewayPrivateLinkResourceListResult) (ApplicationGatewayPrivateLinkResourceListResult, error)
	agplrlr ApplicationGatewayPrivateLinkResourceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ApplicationGatewayPrivateLinkResourceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationGatewayPrivateLinkResourceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.agplrlr)
		if err != nil {
			return err
		}
		page.agplrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ApplicationGatewayPrivateLinkResourceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ApplicationGatewayPrivateLinkResourceListResultPage) NotDone() bool {
	return !page.agplrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ApplicationGatewayPrivateLinkResourceListResultPage) Response() ApplicationGatewayPrivateLinkResourceListResult {
	return page.agplrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ApplicationGatewayPrivateLinkResourceListResultPage) Values() []ApplicationGatewayPrivateLinkResource {
	if page.agplrlr.IsEmpty() {
		return nil
	}
	return *page.agplrlr.Value
}

// Creates a new instance of the ApplicationGatewayPrivateLinkResourceListResultPage type.
func NewApplicationGatewayPrivateLinkResourceListResultPage(cur ApplicationGatewayPrivateLinkResourceListResult, getNextPage func(context.Context, ApplicationGatewayPrivateLinkResourceListResult) (ApplicationGatewayPrivateLinkResourceListResult, error)) ApplicationGatewayPrivateLinkResourceListResultPage {
	return ApplicationGatewayPrivateLinkResourceListResultPage{
		fn:      getNextPage,
		agplrlr: cur,
	}
}

// ApplicationGatewayPrivateLinkResourceProperties properties of a private link resource.
type ApplicationGatewayPrivateLinkResourceProperties struct {
	// GroupID - READ-ONLY; Group identifier of private link resource.
	GroupID *string `json:"groupId,omitempty"`
	// RequiredMembers - READ-ONLY; Required member names of private link resource.
	RequiredMembers *[]string `json:"requiredMembers,omitempty"`
	// RequiredZoneNames - Required DNS zone names of the the private link resource.
	RequiredZoneNames *[]string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPrivateLinkResourceProperties.
func (agplrp ApplicationGatewayPrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agplrp.RequiredZoneNames != nil {
		objectMap["requiredZoneNames"] = agplrp.RequiredZoneNames
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayProbe probe of the application gateway.
type ApplicationGatewayProbe struct {
	// ApplicationGatewayProbePropertiesFormat - Properties of the application gateway probe.
	*ApplicationGatewayProbePropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the probe that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayProbe.
func (agp ApplicationGatewayProbe) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agp.ApplicationGatewayProbePropertiesFormat != nil {
		objectMap["properties"] = agp.ApplicationGatewayProbePropertiesFormat
	}
	if agp.Name != nil {
		objectMap["name"] = agp.Name
	}
	if agp.ID != nil {
		objectMap["id"] = agp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayProbe struct.
func (agp *ApplicationGatewayProbe) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayProbePropertiesFormat ApplicationGatewayProbePropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayProbePropertiesFormat)
				if err != nil {
					return err
				}
				agp.ApplicationGatewayProbePropertiesFormat = &applicationGatewayProbePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agp.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agp.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayProbeHealthResponseMatch application gateway probe health response match.
type ApplicationGatewayProbeHealthResponseMatch struct {
	// Body - Body that must be contained in the health response. Default value is empty.
	Body *string `json:"body,omitempty"`
	// StatusCodes - Allowed ranges of healthy status codes. Default range of healthy status codes is 200-399.
	StatusCodes *[]string `json:"statusCodes,omitempty"`
}

// ApplicationGatewayProbePropertiesFormat properties of probe of an application gateway.
type ApplicationGatewayProbePropertiesFormat struct {
	// Protocol - The protocol used for the probe. Possible values include: 'ApplicationGatewayProtocolHTTP', 'ApplicationGatewayProtocolHTTPS'
	Protocol ApplicationGatewayProtocol `json:"protocol,omitempty"`
	// Host - Host name to send the probe to.
	Host *string `json:"host,omitempty"`
	// Path - Relative path of probe. Valid path starts from '/'. Probe is sent to <Protocol>://<host>:<port><path>.
	Path *string `json:"path,omitempty"`
	// Interval - The probing interval in seconds. This is the time interval between two consecutive probes. Acceptable values are from 1 second to 86400 seconds.
	Interval *int32 `json:"interval,omitempty"`
	// Timeout - The probe timeout in seconds. Probe marked as failed if valid response is not received with this timeout period. Acceptable values are from 1 second to 86400 seconds.
	Timeout *int32 `json:"timeout,omitempty"`
	// UnhealthyThreshold - The probe retry count. Backend server is marked down after consecutive probe failure count reaches UnhealthyThreshold. Acceptable values are from 1 second to 20.
	UnhealthyThreshold *int32 `json:"unhealthyThreshold,omitempty"`
	// PickHostNameFromBackendHTTPSettings - Whether the host header should be picked from the backend http settings. Default value is false.
	PickHostNameFromBackendHTTPSettings *bool `json:"pickHostNameFromBackendHttpSettings,omitempty"`
	// MinServers - Minimum number of servers that are always marked healthy. Default value is 0.
	MinServers *int32 `json:"minServers,omitempty"`
	// Match - Criterion for classifying a healthy probe response.
	Match *ApplicationGatewayProbeHealthResponseMatch `json:"match,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the probe resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Port - Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from http settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
	Port *int32 `json:"port,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayProbePropertiesFormat.
func (agppf ApplicationGatewayProbePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agppf.Protocol != "" {
		objectMap["protocol"] = agppf.Protocol
	}
	if agppf.Host != nil {
		objectMap["host"] = agppf.Host
	}
	if agppf.Path != nil {
		objectMap["path"] = agppf.Path
	}
	if agppf.Interval != nil {
		objectMap["interval"] = agppf.Interval
	}
	if agppf.Timeout != nil {
		objectMap["timeout"] = agppf.Timeout
	}
	if agppf.UnhealthyThreshold != nil {
		objectMap["unhealthyThreshold"] = agppf.UnhealthyThreshold
	}
	if agppf.PickHostNameFromBackendHTTPSettings != nil {
		objectMap["pickHostNameFromBackendHttpSettings"] = agppf.PickHostNameFromBackendHTTPSettings
	}
	if agppf.MinServers != nil {
		objectMap["minServers"] = agppf.MinServers
	}
	if agppf.Match != nil {
		objectMap["match"] = agppf.Match
	}
	if agppf.Port != nil {
		objectMap["port"] = agppf.Port
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayPropertiesFormat properties of the application gateway.
type ApplicationGatewayPropertiesFormat struct {
	// Sku - SKU of the application gateway resource.
	Sku *ApplicationGatewaySku `json:"sku,omitempty"`
	// SslPolicy - SSL policy of the application gateway resource.
	SslPolicy *ApplicationGatewaySslPolicy `json:"sslPolicy,omitempty"`
	// OperationalState - READ-ONLY; Operational state of the application gateway resource. Possible values include: 'ApplicationGatewayOperationalStateStopped', 'ApplicationGatewayOperationalStateStarting', 'ApplicationGatewayOperationalStateRunning', 'ApplicationGatewayOperationalStateStopping'
	OperationalState ApplicationGatewayOperationalState `json:"operationalState,omitempty"`
	// GatewayIPConfigurations - Subnets of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	GatewayIPConfigurations *[]ApplicationGatewayIPConfiguration `json:"gatewayIPConfigurations,omitempty"`
	// AuthenticationCertificates - Authentication certificates of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	AuthenticationCertificates *[]ApplicationGatewayAuthenticationCertificate `json:"authenticationCertificates,omitempty"`
	// TrustedRootCertificates - Trusted Root certificates of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	TrustedRootCertificates *[]ApplicationGatewayTrustedRootCertificate `json:"trustedRootCertificates,omitempty"`
	// TrustedClientCertificates - Trusted client certificates of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	TrustedClientCertificates *[]ApplicationGatewayTrustedClientCertificate `json:"trustedClientCertificates,omitempty"`
	// SslCertificates - SSL certificates of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	SslCertificates *[]ApplicationGatewaySslCertificate `json:"sslCertificates,omitempty"`
	// FrontendIPConfigurations - Frontend IP addresses of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	FrontendIPConfigurations *[]ApplicationGatewayFrontendIPConfiguration `json:"frontendIPConfigurations,omitempty"`
	// FrontendPorts - Frontend ports of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	FrontendPorts *[]ApplicationGatewayFrontendPort `json:"frontendPorts,omitempty"`
	// Probes - Probes of the application gateway resource.
	Probes *[]ApplicationGatewayProbe `json:"probes,omitempty"`
	// BackendAddressPools - Backend address pool of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	BackendAddressPools *[]ApplicationGatewayBackendAddressPool `json:"backendAddressPools,omitempty"`
	// BackendHTTPSettingsCollection - Backend http settings of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	BackendHTTPSettingsCollection *[]ApplicationGatewayBackendHTTPSettings `json:"backendHttpSettingsCollection,omitempty"`
	// HTTPListeners - Http listeners of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	HTTPListeners *[]ApplicationGatewayHTTPListener `json:"httpListeners,omitempty"`
	// SslProfiles - SSL profiles of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	SslProfiles *[]ApplicationGatewaySslProfile `json:"sslProfiles,omitempty"`
	// URLPathMaps - URL path map of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	URLPathMaps *[]ApplicationGatewayURLPathMap `json:"urlPathMaps,omitempty"`
	// RequestRoutingRules - Request routing rules of the application gateway resource.
	RequestRoutingRules *[]ApplicationGatewayRequestRoutingRule `json:"requestRoutingRules,omitempty"`
	// RewriteRuleSets - Rewrite rules for the application gateway resource.
	RewriteRuleSets *[]ApplicationGatewayRewriteRuleSet `json:"rewriteRuleSets,omitempty"`
	// RedirectConfigurations - Redirect configurations of the application gateway resource. For default limits, see [Application Gateway limits](https://docs.microsoft.com/azure/azure-subscription-service-limits#application-gateway-limits).
	RedirectConfigurations *[]ApplicationGatewayRedirectConfiguration `json:"redirectConfigurations,omitempty"`
	// WebApplicationFirewallConfiguration - Web application firewall configuration.
	WebApplicationFirewallConfiguration *ApplicationGatewayWebApplicationFirewallConfiguration `json:"webApplicationFirewallConfiguration,omitempty"`
	// FirewallPolicy - Reference to the FirewallPolicy resource.
	FirewallPolicy *SubResource `json:"firewallPolicy,omitempty"`
	// EnableHTTP2 - Whether HTTP2 is enabled on the application gateway resource.
	EnableHTTP2 *bool `json:"enableHttp2,omitempty"`
	// EnableFips - Whether FIPS is enabled on the application gateway resource.
	EnableFips *bool `json:"enableFips,omitempty"`
	// AutoscaleConfiguration - Autoscale Configuration.
	AutoscaleConfiguration *ApplicationGatewayAutoscaleConfiguration `json:"autoscaleConfiguration,omitempty"`
	// PrivateLinkConfigurations - PrivateLink configurations on application gateway.
	PrivateLinkConfigurations *[]ApplicationGatewayPrivateLinkConfiguration `json:"privateLinkConfigurations,omitempty"`
	// PrivateEndpointConnections - READ-ONLY; Private Endpoint connections on application gateway.
	PrivateEndpointConnections *[]ApplicationGatewayPrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the application gateway resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the application gateway resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// CustomErrorConfigurations - Custom error configurations of the application gateway resource.
	CustomErrorConfigurations *[]ApplicationGatewayCustomError `json:"customErrorConfigurations,omitempty"`
	// ForceFirewallPolicyAssociation - If true, associates a firewall policy with an application gateway regardless whether the policy differs from the WAF Config.
	ForceFirewallPolicyAssociation *bool `json:"forceFirewallPolicyAssociation,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayPropertiesFormat.
func (agpf ApplicationGatewayPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agpf.Sku != nil {
		objectMap["sku"] = agpf.Sku
	}
	if agpf.SslPolicy != nil {
		objectMap["sslPolicy"] = agpf.SslPolicy
	}
	if agpf.GatewayIPConfigurations != nil {
		objectMap["gatewayIPConfigurations"] = agpf.GatewayIPConfigurations
	}
	if agpf.AuthenticationCertificates != nil {
		objectMap["authenticationCertificates"] = agpf.AuthenticationCertificates
	}
	if agpf.TrustedRootCertificates != nil {
		objectMap["trustedRootCertificates"] = agpf.TrustedRootCertificates
	}
	if agpf.TrustedClientCertificates != nil {
		objectMap["trustedClientCertificates"] = agpf.TrustedClientCertificates
	}
	if agpf.SslCertificates != nil {
		objectMap["sslCertificates"] = agpf.SslCertificates
	}
	if agpf.FrontendIPConfigurations != nil {
		objectMap["frontendIPConfigurations"] = agpf.FrontendIPConfigurations
	}
	if agpf.FrontendPorts != nil {
		objectMap["frontendPorts"] = agpf.FrontendPorts
	}
	if agpf.Probes != nil {
		objectMap["probes"] = agpf.Probes
	}
	if agpf.BackendAddressPools != nil {
		objectMap["backendAddressPools"] = agpf.BackendAddressPools
	}
	if agpf.BackendHTTPSettingsCollection != nil {
		objectMap["backendHttpSettingsCollection"] = agpf.BackendHTTPSettingsCollection
	}
	if agpf.HTTPListeners != nil {
		objectMap["httpListeners"] = agpf.HTTPListeners
	}
	if agpf.SslProfiles != nil {
		objectMap["sslProfiles"] = agpf.SslProfiles
	}
	if agpf.URLPathMaps != nil {
		objectMap["urlPathMaps"] = agpf.URLPathMaps
	}
	if agpf.RequestRoutingRules != nil {
		objectMap["requestRoutingRules"] = agpf.RequestRoutingRules
	}
	if agpf.RewriteRuleSets != nil {
		objectMap["rewriteRuleSets"] = agpf.RewriteRuleSets
	}
	if agpf.RedirectConfigurations != nil {
		objectMap["redirectConfigurations"] = agpf.RedirectConfigurations
	}
	if agpf.WebApplicationFirewallConfiguration != nil {
		objectMap["webApplicationFirewallConfiguration"] = agpf.WebApplicationFirewallConfiguration
	}
	if agpf.FirewallPolicy != nil {
		objectMap["firewallPolicy"] = agpf.FirewallPolicy
	}
	if agpf.EnableHTTP2 != nil {
		objectMap["enableHttp2"] = agpf.EnableHTTP2
	}
	if agpf.EnableFips != nil {
		objectMap["enableFips"] = agpf.EnableFips
	}
	if agpf.AutoscaleConfiguration != nil {
		objectMap["autoscaleConfiguration"] = agpf.AutoscaleConfiguration
	}
	if agpf.PrivateLinkConfigurations != nil {
		objectMap["privateLinkConfigurations"] = agpf.PrivateLinkConfigurations
	}
	if agpf.CustomErrorConfigurations != nil {
		objectMap["customErrorConfigurations"] = agpf.CustomErrorConfigurations
	}
	if agpf.ForceFirewallPolicyAssociation != nil {
		objectMap["forceFirewallPolicyAssociation"] = agpf.ForceFirewallPolicyAssociation
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayRedirectConfiguration redirect configuration of an application gateway.
type ApplicationGatewayRedirectConfiguration struct {
	// ApplicationGatewayRedirectConfigurationPropertiesFormat - Properties of the application gateway redirect configuration.
	*ApplicationGatewayRedirectConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the redirect configuration that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayRedirectConfiguration.
func (agrc ApplicationGatewayRedirectConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agrc.ApplicationGatewayRedirectConfigurationPropertiesFormat != nil {
		objectMap["properties"] = agrc.ApplicationGatewayRedirectConfigurationPropertiesFormat
	}
	if agrc.Name != nil {
		objectMap["name"] = agrc.Name
	}
	if agrc.ID != nil {
		objectMap["id"] = agrc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayRedirectConfiguration struct.
func (agrc *ApplicationGatewayRedirectConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayRedirectConfigurationPropertiesFormat ApplicationGatewayRedirectConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayRedirectConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				agrc.ApplicationGatewayRedirectConfigurationPropertiesFormat = &applicationGatewayRedirectConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agrc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agrc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agrc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agrc.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayRedirectConfigurationPropertiesFormat properties of redirect configuration of the
// application gateway.
type ApplicationGatewayRedirectConfigurationPropertiesFormat struct {
	// RedirectType - HTTP redirection type. Possible values include: 'ApplicationGatewayRedirectTypePermanent', 'ApplicationGatewayRedirectTypeFound', 'ApplicationGatewayRedirectTypeSeeOther', 'ApplicationGatewayRedirectTypeTemporary'
	RedirectType ApplicationGatewayRedirectType `json:"redirectType,omitempty"`
	// TargetListener - Reference to a listener to redirect the request to.
	TargetListener *SubResource `json:"targetListener,omitempty"`
	// TargetURL - Url to redirect the request to.
	TargetURL *string `json:"targetUrl,omitempty"`
	// IncludePath - Include path in the redirected url.
	IncludePath *bool `json:"includePath,omitempty"`
	// IncludeQueryString - Include query string in the redirected url.
	IncludeQueryString *bool `json:"includeQueryString,omitempty"`
	// RequestRoutingRules - Request routing specifying redirect configuration.
	RequestRoutingRules *[]SubResource `json:"requestRoutingRules,omitempty"`
	// URLPathMaps - Url path maps specifying default redirect configuration.
	URLPathMaps *[]SubResource `json:"urlPathMaps,omitempty"`
	// PathRules - Path rules specifying redirect configuration.
	PathRules *[]SubResource `json:"pathRules,omitempty"`
}

// ApplicationGatewayRequestRoutingRule request routing rule of an application gateway.
type ApplicationGatewayRequestRoutingRule struct {
	// ApplicationGatewayRequestRoutingRulePropertiesFormat - Properties of the application gateway request routing rule.
	*ApplicationGatewayRequestRoutingRulePropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the request routing rule that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayRequestRoutingRule.
func (agrrr ApplicationGatewayRequestRoutingRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agrrr.ApplicationGatewayRequestRoutingRulePropertiesFormat != nil {
		objectMap["properties"] = agrrr.ApplicationGatewayRequestRoutingRulePropertiesFormat
	}
	if agrrr.Name != nil {
		objectMap["name"] = agrrr.Name
	}
	if agrrr.ID != nil {
		objectMap["id"] = agrrr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayRequestRoutingRule struct.
func (agrrr *ApplicationGatewayRequestRoutingRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayRequestRoutingRulePropertiesFormat ApplicationGatewayRequestRoutingRulePropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayRequestRoutingRulePropertiesFormat)
				if err != nil {
					return err
				}
				agrrr.ApplicationGatewayRequestRoutingRulePropertiesFormat = &applicationGatewayRequestRoutingRulePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agrrr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agrrr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agrrr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agrrr.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayRequestRoutingRulePropertiesFormat properties of request routing rule of the
// application gateway.
type ApplicationGatewayRequestRoutingRulePropertiesFormat struct {
	// RuleType - Rule type. Possible values include: 'ApplicationGatewayRequestRoutingRuleTypeBasic', 'ApplicationGatewayRequestRoutingRuleTypePathBasedRouting'
	RuleType ApplicationGatewayRequestRoutingRuleType `json:"ruleType,omitempty"`
	// Priority - Priority of the request routing rule.
	Priority *int32 `json:"priority,omitempty"`
	// BackendAddressPool - Backend address pool resource of the application gateway.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`
	// BackendHTTPSettings - Backend http settings resource of the application gateway.
	BackendHTTPSettings *SubResource `json:"backendHttpSettings,omitempty"`
	// HTTPListener - Http listener resource of the application gateway.
	HTTPListener *SubResource `json:"httpListener,omitempty"`
	// URLPathMap - URL path map resource of the application gateway.
	URLPathMap *SubResource `json:"urlPathMap,omitempty"`
	// RewriteRuleSet - Rewrite Rule Set resource in Basic rule of the application gateway.
	RewriteRuleSet *SubResource `json:"rewriteRuleSet,omitempty"`
	// RedirectConfiguration - Redirect configuration resource of the application gateway.
	RedirectConfiguration *SubResource `json:"redirectConfiguration,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the request routing rule resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayRequestRoutingRulePropertiesFormat.
func (agrrrpf ApplicationGatewayRequestRoutingRulePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agrrrpf.RuleType != "" {
		objectMap["ruleType"] = agrrrpf.RuleType
	}
	if agrrrpf.Priority != nil {
		objectMap["priority"] = agrrrpf.Priority
	}
	if agrrrpf.BackendAddressPool != nil {
		objectMap["backendAddressPool"] = agrrrpf.BackendAddressPool
	}
	if agrrrpf.BackendHTTPSettings != nil {
		objectMap["backendHttpSettings"] = agrrrpf.BackendHTTPSettings
	}
	if agrrrpf.HTTPListener != nil {
		objectMap["httpListener"] = agrrrpf.HTTPListener
	}
	if agrrrpf.URLPathMap != nil {
		objectMap["urlPathMap"] = agrrrpf.URLPathMap
	}
	if agrrrpf.RewriteRuleSet != nil {
		objectMap["rewriteRuleSet"] = agrrrpf.RewriteRuleSet
	}
	if agrrrpf.RedirectConfiguration != nil {
		objectMap["redirectConfiguration"] = agrrrpf.RedirectConfiguration
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayRewriteRule rewrite rule of an application gateway.
type ApplicationGatewayRewriteRule struct {
	// Name - Name of the rewrite rule that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// RuleSequence - Rule Sequence of the rewrite rule that determines the order of execution of a particular rule in a RewriteRuleSet.
	RuleSequence *int32 `json:"ruleSequence,omitempty"`
	// Conditions - Conditions based on which the action set execution will be evaluated.
	Conditions *[]ApplicationGatewayRewriteRuleCondition `json:"conditions,omitempty"`
	// ActionSet - Set of actions to be done as part of the rewrite Rule.
	ActionSet *ApplicationGatewayRewriteRuleActionSet `json:"actionSet,omitempty"`
}

// ApplicationGatewayRewriteRuleActionSet set of actions in the Rewrite Rule in Application Gateway.
type ApplicationGatewayRewriteRuleActionSet struct {
	// RequestHeaderConfigurations - Request Header Actions in the Action Set.
	RequestHeaderConfigurations *[]ApplicationGatewayHeaderConfiguration `json:"requestHeaderConfigurations,omitempty"`
	// ResponseHeaderConfigurations - Response Header Actions in the Action Set.
	ResponseHeaderConfigurations *[]ApplicationGatewayHeaderConfiguration `json:"responseHeaderConfigurations,omitempty"`
	// URLConfiguration - Url Configuration Action in the Action Set.
	URLConfiguration *ApplicationGatewayURLConfiguration `json:"urlConfiguration,omitempty"`
}

// ApplicationGatewayRewriteRuleCondition set of conditions in the Rewrite Rule in Application Gateway.
type ApplicationGatewayRewriteRuleCondition struct {
	// Variable - The condition parameter of the RewriteRuleCondition.
	Variable *string `json:"variable,omitempty"`
	// Pattern - The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
	Pattern *string `json:"pattern,omitempty"`
	// IgnoreCase - Setting this parameter to truth value with force the pattern to do a case in-sensitive comparison.
	IgnoreCase *bool `json:"ignoreCase,omitempty"`
	// Negate - Setting this value as truth will force to check the negation of the condition given by the user.
	Negate *bool `json:"negate,omitempty"`
}

// ApplicationGatewayRewriteRuleSet rewrite rule set of an application gateway.
type ApplicationGatewayRewriteRuleSet struct {
	// ApplicationGatewayRewriteRuleSetPropertiesFormat - Properties of the application gateway rewrite rule set.
	*ApplicationGatewayRewriteRuleSetPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the rewrite rule set that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayRewriteRuleSet.
func (agrrs ApplicationGatewayRewriteRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agrrs.ApplicationGatewayRewriteRuleSetPropertiesFormat != nil {
		objectMap["properties"] = agrrs.ApplicationGatewayRewriteRuleSetPropertiesFormat
	}
	if agrrs.Name != nil {
		objectMap["name"] = agrrs.Name
	}
	if agrrs.ID != nil {
		objectMap["id"] = agrrs.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayRewriteRuleSet struct.
func (agrrs *ApplicationGatewayRewriteRuleSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayRewriteRuleSetPropertiesFormat ApplicationGatewayRewriteRuleSetPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayRewriteRuleSetPropertiesFormat)
				if err != nil {
					return err
				}
				agrrs.ApplicationGatewayRewriteRuleSetPropertiesFormat = &applicationGatewayRewriteRuleSetPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agrrs.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agrrs.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agrrs.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayRewriteRuleSetPropertiesFormat properties of rewrite rule set of the application
// gateway.
type ApplicationGatewayRewriteRuleSetPropertiesFormat struct {
	// RewriteRules - Rewrite rules in the rewrite rule set.
	RewriteRules *[]ApplicationGatewayRewriteRule `json:"rewriteRules,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the rewrite rule set resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayRewriteRuleSetPropertiesFormat.
func (agrrspf ApplicationGatewayRewriteRuleSetPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agrrspf.RewriteRules != nil {
		objectMap["rewriteRules"] = agrrspf.RewriteRules
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewaysBackendHealthFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ApplicationGatewaysBackendHealthFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationGatewaysClient) (ApplicationGatewayBackendHealth, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationGatewaysBackendHealthFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationGatewaysBackendHealthFuture.Result.
func (future *ApplicationGatewaysBackendHealthFuture) result(client ApplicationGatewaysClient) (agbh ApplicationGatewayBackendHealth, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysBackendHealthFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		agbh.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationGatewaysBackendHealthFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if agbh.Response.Response, err = future.GetResult(sender); err == nil && agbh.Response.Response.StatusCode != http.StatusNoContent {
		agbh, err = client.BackendHealthResponder(agbh.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysBackendHealthFuture", "Result", agbh.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ApplicationGatewaysBackendHealthOnDemandFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type ApplicationGatewaysBackendHealthOnDemandFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationGatewaysClient) (ApplicationGatewayBackendHealthOnDemand, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationGatewaysBackendHealthOnDemandFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationGatewaysBackendHealthOnDemandFuture.Result.
func (future *ApplicationGatewaysBackendHealthOnDemandFuture) result(client ApplicationGatewaysClient) (agbhod ApplicationGatewayBackendHealthOnDemand, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysBackendHealthOnDemandFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		agbhod.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationGatewaysBackendHealthOnDemandFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if agbhod.Response.Response, err = future.GetResult(sender); err == nil && agbhod.Response.Response.StatusCode != http.StatusNoContent {
		agbhod, err = client.BackendHealthOnDemandResponder(agbhod.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysBackendHealthOnDemandFuture", "Result", agbhod.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ApplicationGatewaysCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ApplicationGatewaysCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationGatewaysClient) (ApplicationGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationGatewaysCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationGatewaysCreateOrUpdateFuture.Result.
func (future *ApplicationGatewaysCreateOrUpdateFuture) result(client ApplicationGatewaysClient) (ag ApplicationGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ag.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationGatewaysCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ag.Response.Response, err = future.GetResult(sender); err == nil && ag.Response.Response.StatusCode != http.StatusNoContent {
		ag, err = client.CreateOrUpdateResponder(ag.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysCreateOrUpdateFuture", "Result", ag.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ApplicationGatewaysDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ApplicationGatewaysDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationGatewaysDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationGatewaysDeleteFuture.Result.
func (future *ApplicationGatewaysDeleteFuture) result(client ApplicationGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationGatewaysDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ApplicationGatewaySku SKU of an application gateway.
type ApplicationGatewaySku struct {
	// Name - Name of an application gateway SKU. Possible values include: 'ApplicationGatewaySkuNameStandardSmall', 'ApplicationGatewaySkuNameStandardMedium', 'ApplicationGatewaySkuNameStandardLarge', 'ApplicationGatewaySkuNameWAFMedium', 'ApplicationGatewaySkuNameWAFLarge', 'ApplicationGatewaySkuNameStandardV2', 'ApplicationGatewaySkuNameWAFV2'
	Name ApplicationGatewaySkuName `json:"name,omitempty"`
	// Tier - Tier of an application gateway. Possible values include: 'ApplicationGatewayTierStandard', 'ApplicationGatewayTierWAF', 'ApplicationGatewayTierStandardV2', 'ApplicationGatewayTierWAFV2'
	Tier ApplicationGatewayTier `json:"tier,omitempty"`
	// Capacity - Capacity (instance count) of an application gateway.
	Capacity *int32 `json:"capacity,omitempty"`
}

// ApplicationGatewaySslCertificate SSL certificates of an application gateway.
type ApplicationGatewaySslCertificate struct {
	// ApplicationGatewaySslCertificatePropertiesFormat - Properties of the application gateway SSL certificate.
	*ApplicationGatewaySslCertificatePropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the SSL certificate that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewaySslCertificate.
func (agsc ApplicationGatewaySslCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agsc.ApplicationGatewaySslCertificatePropertiesFormat != nil {
		objectMap["properties"] = agsc.ApplicationGatewaySslCertificatePropertiesFormat
	}
	if agsc.Name != nil {
		objectMap["name"] = agsc.Name
	}
	if agsc.ID != nil {
		objectMap["id"] = agsc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewaySslCertificate struct.
func (agsc *ApplicationGatewaySslCertificate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewaySslCertificatePropertiesFormat ApplicationGatewaySslCertificatePropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewaySslCertificatePropertiesFormat)
				if err != nil {
					return err
				}
				agsc.ApplicationGatewaySslCertificatePropertiesFormat = &applicationGatewaySslCertificatePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agsc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agsc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agsc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agsc.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewaySslCertificatePropertiesFormat properties of SSL certificates of an application
// gateway.
type ApplicationGatewaySslCertificatePropertiesFormat struct {
	// Data - Base-64 encoded pfx certificate. Only applicable in PUT Request.
	Data *string `json:"data,omitempty"`
	// Password - Password for the pfx file specified in data. Only applicable in PUT request.
	Password *string `json:"password,omitempty"`
	// PublicCertData - READ-ONLY; Base-64 encoded Public cert data corresponding to pfx specified in data. Only applicable in GET request.
	PublicCertData *string `json:"publicCertData,omitempty"`
	// KeyVaultSecretID - Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
	KeyVaultSecretID *string `json:"keyVaultSecretId,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the SSL certificate resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewaySslCertificatePropertiesFormat.
func (agscpf ApplicationGatewaySslCertificatePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agscpf.Data != nil {
		objectMap["data"] = agscpf.Data
	}
	if agscpf.Password != nil {
		objectMap["password"] = agscpf.Password
	}
	if agscpf.KeyVaultSecretID != nil {
		objectMap["keyVaultSecretId"] = agscpf.KeyVaultSecretID
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewaySslPolicy application Gateway Ssl policy.
type ApplicationGatewaySslPolicy struct {
	// DisabledSslProtocols - Ssl protocols to be disabled on application gateway.
	DisabledSslProtocols *[]ApplicationGatewaySslProtocol `json:"disabledSslProtocols,omitempty"`
	// PolicyType - Type of Ssl Policy. Possible values include: 'ApplicationGatewaySslPolicyTypePredefined', 'ApplicationGatewaySslPolicyTypeCustom'
	PolicyType ApplicationGatewaySslPolicyType `json:"policyType,omitempty"`
	// PolicyName - Name of Ssl predefined policy. Possible values include: 'ApplicationGatewaySslPolicyNameAppGwSslPolicy20150501', 'ApplicationGatewaySslPolicyNameAppGwSslPolicy20170401', 'ApplicationGatewaySslPolicyNameAppGwSslPolicy20170401S'
	PolicyName ApplicationGatewaySslPolicyName `json:"policyName,omitempty"`
	// CipherSuites - Ssl cipher suites to be enabled in the specified order to application gateway.
	CipherSuites *[]ApplicationGatewaySslCipherSuite `json:"cipherSuites,omitempty"`
	// MinProtocolVersion - Minimum version of Ssl protocol to be supported on application gateway. Possible values include: 'ApplicationGatewaySslProtocolTLSv10', 'ApplicationGatewaySslProtocolTLSv11', 'ApplicationGatewaySslProtocolTLSv12'
	MinProtocolVersion ApplicationGatewaySslProtocol `json:"minProtocolVersion,omitempty"`
}

// ApplicationGatewaySslPredefinedPolicy an Ssl predefined policy.
type ApplicationGatewaySslPredefinedPolicy struct {
	autorest.Response `json:"-"`
	// Name - Name of the Ssl predefined policy.
	Name *string `json:"name,omitempty"`
	// ApplicationGatewaySslPredefinedPolicyPropertiesFormat - Properties of the application gateway SSL predefined policy.
	*ApplicationGatewaySslPredefinedPolicyPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewaySslPredefinedPolicy.
func (agspp ApplicationGatewaySslPredefinedPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agspp.Name != nil {
		objectMap["name"] = agspp.Name
	}
	if agspp.ApplicationGatewaySslPredefinedPolicyPropertiesFormat != nil {
		objectMap["properties"] = agspp.ApplicationGatewaySslPredefinedPolicyPropertiesFormat
	}
	if agspp.ID != nil {
		objectMap["id"] = agspp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewaySslPredefinedPolicy struct.
func (agspp *ApplicationGatewaySslPredefinedPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agspp.Name = &name
			}
		case "properties":
			if v != nil {
				var applicationGatewaySslPredefinedPolicyPropertiesFormat ApplicationGatewaySslPredefinedPolicyPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewaySslPredefinedPolicyPropertiesFormat)
				if err != nil {
					return err
				}
				agspp.ApplicationGatewaySslPredefinedPolicyPropertiesFormat = &applicationGatewaySslPredefinedPolicyPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agspp.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewaySslPredefinedPolicyPropertiesFormat properties of
// ApplicationGatewaySslPredefinedPolicy.
type ApplicationGatewaySslPredefinedPolicyPropertiesFormat struct {
	// CipherSuites - Ssl cipher suites to be enabled in the specified order for application gateway.
	CipherSuites *[]ApplicationGatewaySslCipherSuite `json:"cipherSuites,omitempty"`
	// MinProtocolVersion - Minimum version of Ssl protocol to be supported on application gateway. Possible values include: 'ApplicationGatewaySslProtocolTLSv10', 'ApplicationGatewaySslProtocolTLSv11', 'ApplicationGatewaySslProtocolTLSv12'
	MinProtocolVersion ApplicationGatewaySslProtocol `json:"minProtocolVersion,omitempty"`
}

// ApplicationGatewaySslProfile SSL profile of an application gateway.
type ApplicationGatewaySslProfile struct {
	// ApplicationGatewaySslProfilePropertiesFormat - Properties of the application gateway SSL profile.
	*ApplicationGatewaySslProfilePropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the SSL profile that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewaySslProfile.
func (agsp ApplicationGatewaySslProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agsp.ApplicationGatewaySslProfilePropertiesFormat != nil {
		objectMap["properties"] = agsp.ApplicationGatewaySslProfilePropertiesFormat
	}
	if agsp.Name != nil {
		objectMap["name"] = agsp.Name
	}
	if agsp.ID != nil {
		objectMap["id"] = agsp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewaySslProfile struct.
func (agsp *ApplicationGatewaySslProfile) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewaySslProfilePropertiesFormat ApplicationGatewaySslProfilePropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewaySslProfilePropertiesFormat)
				if err != nil {
					return err
				}
				agsp.ApplicationGatewaySslProfilePropertiesFormat = &applicationGatewaySslProfilePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agsp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agsp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agsp.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agsp.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewaySslProfilePropertiesFormat properties of SSL profile of an application gateway.
type ApplicationGatewaySslProfilePropertiesFormat struct {
	// TrustedClientCertificates - Array of references to application gateway trusted client certificates.
	TrustedClientCertificates *[]SubResource `json:"trustedClientCertificates,omitempty"`
	// SslPolicy - SSL policy of the application gateway resource.
	SslPolicy *ApplicationGatewaySslPolicy `json:"sslPolicy,omitempty"`
	// ClientAuthConfiguration - Client authentication configuration of the application gateway resource.
	ClientAuthConfiguration *ApplicationGatewayClientAuthConfiguration `json:"clientAuthConfiguration,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the HTTP listener resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewaySslProfilePropertiesFormat.
func (agsppf ApplicationGatewaySslProfilePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agsppf.TrustedClientCertificates != nil {
		objectMap["trustedClientCertificates"] = agsppf.TrustedClientCertificates
	}
	if agsppf.SslPolicy != nil {
		objectMap["sslPolicy"] = agsppf.SslPolicy
	}
	if agsppf.ClientAuthConfiguration != nil {
		objectMap["clientAuthConfiguration"] = agsppf.ClientAuthConfiguration
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewaysStartFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ApplicationGatewaysStartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationGatewaysStartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationGatewaysStartFuture.Result.
func (future *ApplicationGatewaysStartFuture) result(client ApplicationGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationGatewaysStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ApplicationGatewaysStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ApplicationGatewaysStopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationGatewaysStopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationGatewaysStopFuture.Result.
func (future *ApplicationGatewaysStopFuture) result(client ApplicationGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationGatewaysStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationGatewaysStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ApplicationGatewayTrustedClientCertificate trusted client certificates of an application gateway.
type ApplicationGatewayTrustedClientCertificate struct {
	// ApplicationGatewayTrustedClientCertificatePropertiesFormat - Properties of the application gateway trusted client certificate.
	*ApplicationGatewayTrustedClientCertificatePropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the trusted client certificate that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayTrustedClientCertificate.
func (agtcc ApplicationGatewayTrustedClientCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agtcc.ApplicationGatewayTrustedClientCertificatePropertiesFormat != nil {
		objectMap["properties"] = agtcc.ApplicationGatewayTrustedClientCertificatePropertiesFormat
	}
	if agtcc.Name != nil {
		objectMap["name"] = agtcc.Name
	}
	if agtcc.ID != nil {
		objectMap["id"] = agtcc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayTrustedClientCertificate struct.
func (agtcc *ApplicationGatewayTrustedClientCertificate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayTrustedClientCertificatePropertiesFormat ApplicationGatewayTrustedClientCertificatePropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayTrustedClientCertificatePropertiesFormat)
				if err != nil {
					return err
				}
				agtcc.ApplicationGatewayTrustedClientCertificatePropertiesFormat = &applicationGatewayTrustedClientCertificatePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agtcc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agtcc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agtcc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agtcc.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayTrustedClientCertificatePropertiesFormat trusted client certificates properties of an
// application gateway.
type ApplicationGatewayTrustedClientCertificatePropertiesFormat struct {
	// Data - Certificate public data.
	Data *string `json:"data,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the trusted client certificate resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayTrustedClientCertificatePropertiesFormat.
func (agtccpf ApplicationGatewayTrustedClientCertificatePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agtccpf.Data != nil {
		objectMap["data"] = agtccpf.Data
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayTrustedRootCertificate trusted Root certificates of an application gateway.
type ApplicationGatewayTrustedRootCertificate struct {
	// ApplicationGatewayTrustedRootCertificatePropertiesFormat - Properties of the application gateway trusted root certificate.
	*ApplicationGatewayTrustedRootCertificatePropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the trusted root certificate that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayTrustedRootCertificate.
func (agtrc ApplicationGatewayTrustedRootCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agtrc.ApplicationGatewayTrustedRootCertificatePropertiesFormat != nil {
		objectMap["properties"] = agtrc.ApplicationGatewayTrustedRootCertificatePropertiesFormat
	}
	if agtrc.Name != nil {
		objectMap["name"] = agtrc.Name
	}
	if agtrc.ID != nil {
		objectMap["id"] = agtrc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayTrustedRootCertificate struct.
func (agtrc *ApplicationGatewayTrustedRootCertificate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayTrustedRootCertificatePropertiesFormat ApplicationGatewayTrustedRootCertificatePropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayTrustedRootCertificatePropertiesFormat)
				if err != nil {
					return err
				}
				agtrc.ApplicationGatewayTrustedRootCertificatePropertiesFormat = &applicationGatewayTrustedRootCertificatePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agtrc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agtrc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agtrc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agtrc.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayTrustedRootCertificatePropertiesFormat trusted Root certificates properties of an
// application gateway.
type ApplicationGatewayTrustedRootCertificatePropertiesFormat struct {
	// Data - Certificate public data.
	Data *string `json:"data,omitempty"`
	// KeyVaultSecretID - Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
	KeyVaultSecretID *string `json:"keyVaultSecretId,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the trusted root certificate resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayTrustedRootCertificatePropertiesFormat.
func (agtrcpf ApplicationGatewayTrustedRootCertificatePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agtrcpf.Data != nil {
		objectMap["data"] = agtrcpf.Data
	}
	if agtrcpf.KeyVaultSecretID != nil {
		objectMap["keyVaultSecretId"] = agtrcpf.KeyVaultSecretID
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayURLConfiguration url configuration of the Actions set in Application Gateway.
type ApplicationGatewayURLConfiguration struct {
	// ModifiedPath - Url path which user has provided for url rewrite. Null means no path will be updated. Default value is null.
	ModifiedPath *string `json:"modifiedPath,omitempty"`
	// ModifiedQueryString - Query string which user has provided for url rewrite. Null means no query string will be updated. Default value is null.
	ModifiedQueryString *string `json:"modifiedQueryString,omitempty"`
	// Reroute - If set as true, it will re-evaluate the url path map provided in path based request routing rules using modified path. Default value is false.
	Reroute *bool `json:"reroute,omitempty"`
}

// ApplicationGatewayURLPathMap urlPathMaps give a url path to the backend mapping information for
// PathBasedRouting.
type ApplicationGatewayURLPathMap struct {
	// ApplicationGatewayURLPathMapPropertiesFormat - Properties of the application gateway URL path map.
	*ApplicationGatewayURLPathMapPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the URL path map that is unique within an Application Gateway.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayURLPathMap.
func (agupm ApplicationGatewayURLPathMap) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agupm.ApplicationGatewayURLPathMapPropertiesFormat != nil {
		objectMap["properties"] = agupm.ApplicationGatewayURLPathMapPropertiesFormat
	}
	if agupm.Name != nil {
		objectMap["name"] = agupm.Name
	}
	if agupm.ID != nil {
		objectMap["id"] = agupm.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationGatewayURLPathMap struct.
func (agupm *ApplicationGatewayURLPathMap) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationGatewayURLPathMapPropertiesFormat ApplicationGatewayURLPathMapPropertiesFormat
				err = json.Unmarshal(*v, &applicationGatewayURLPathMapPropertiesFormat)
				if err != nil {
					return err
				}
				agupm.ApplicationGatewayURLPathMapPropertiesFormat = &applicationGatewayURLPathMapPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				agupm.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				agupm.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				agupm.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				agupm.ID = &ID
			}
		}
	}

	return nil
}

// ApplicationGatewayURLPathMapPropertiesFormat properties of UrlPathMap of the application gateway.
type ApplicationGatewayURLPathMapPropertiesFormat struct {
	// DefaultBackendAddressPool - Default backend address pool resource of URL path map.
	DefaultBackendAddressPool *SubResource `json:"defaultBackendAddressPool,omitempty"`
	// DefaultBackendHTTPSettings - Default backend http settings resource of URL path map.
	DefaultBackendHTTPSettings *SubResource `json:"defaultBackendHttpSettings,omitempty"`
	// DefaultRewriteRuleSet - Default Rewrite rule set resource of URL path map.
	DefaultRewriteRuleSet *SubResource `json:"defaultRewriteRuleSet,omitempty"`
	// DefaultRedirectConfiguration - Default redirect configuration resource of URL path map.
	DefaultRedirectConfiguration *SubResource `json:"defaultRedirectConfiguration,omitempty"`
	// PathRules - Path rule of URL path map resource.
	PathRules *[]ApplicationGatewayPathRule `json:"pathRules,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the URL path map resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationGatewayURLPathMapPropertiesFormat.
func (agupmpf ApplicationGatewayURLPathMapPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if agupmpf.DefaultBackendAddressPool != nil {
		objectMap["defaultBackendAddressPool"] = agupmpf.DefaultBackendAddressPool
	}
	if agupmpf.DefaultBackendHTTPSettings != nil {
		objectMap["defaultBackendHttpSettings"] = agupmpf.DefaultBackendHTTPSettings
	}
	if agupmpf.DefaultRewriteRuleSet != nil {
		objectMap["defaultRewriteRuleSet"] = agupmpf.DefaultRewriteRuleSet
	}
	if agupmpf.DefaultRedirectConfiguration != nil {
		objectMap["defaultRedirectConfiguration"] = agupmpf.DefaultRedirectConfiguration
	}
	if agupmpf.PathRules != nil {
		objectMap["pathRules"] = agupmpf.PathRules
	}
	return json.Marshal(objectMap)
}

// ApplicationGatewayWebApplicationFirewallConfiguration application gateway web application firewall
// configuration.
type ApplicationGatewayWebApplicationFirewallConfiguration struct {
	// Enabled - Whether the web application firewall is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
	// FirewallMode - Web application firewall mode. Possible values include: 'ApplicationGatewayFirewallModeDetection', 'ApplicationGatewayFirewallModePrevention'
	FirewallMode ApplicationGatewayFirewallMode `json:"firewallMode,omitempty"`
	// RuleSetType - The type of the web application firewall rule set. Possible values are: 'OWASP'.
	RuleSetType *string `json:"ruleSetType,omitempty"`
	// RuleSetVersion - The version of the rule set type.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
	// DisabledRuleGroups - The disabled rule groups.
	DisabledRuleGroups *[]ApplicationGatewayFirewallDisabledRuleGroup `json:"disabledRuleGroups,omitempty"`
	// RequestBodyCheck - Whether allow WAF to check request Body.
	RequestBodyCheck *bool `json:"requestBodyCheck,omitempty"`
	// MaxRequestBodySize - Maximum request body size for WAF.
	MaxRequestBodySize *int32 `json:"maxRequestBodySize,omitempty"`
	// MaxRequestBodySizeInKb - Maximum request body size in Kb for WAF.
	MaxRequestBodySizeInKb *int32 `json:"maxRequestBodySizeInKb,omitempty"`
	// FileUploadLimitInMb - Maximum file upload size in Mb for WAF.
	FileUploadLimitInMb *int32 `json:"fileUploadLimitInMb,omitempty"`
	// Exclusions - The exclusion list.
	Exclusions *[]ApplicationGatewayFirewallExclusion `json:"exclusions,omitempty"`
}

// ApplicationRule rule of type application.
type ApplicationRule struct {
	// SourceAddresses - List of source IP addresses for this rule.
	SourceAddresses *[]string `json:"sourceAddresses,omitempty"`
	// DestinationAddresses - List of destination IP addresses or Service Tags.
	DestinationAddresses *[]string `json:"destinationAddresses,omitempty"`
	// Protocols - Array of Application Protocols.
	Protocols *[]FirewallPolicyRuleApplicationProtocol `json:"protocols,omitempty"`
	// TargetFqdns - List of FQDNs for this rule.
	TargetFqdns *[]string `json:"targetFqdns,omitempty"`
	// TargetUrls - List of Urls for this rule condition.
	TargetUrls *[]string `json:"targetUrls,omitempty"`
	// FqdnTags - List of FQDN Tags for this rule.
	FqdnTags *[]string `json:"fqdnTags,omitempty"`
	// SourceIPGroups - List of source IpGroups for this rule.
	SourceIPGroups *[]string `json:"sourceIpGroups,omitempty"`
	// TerminateTLS - Terminate TLS connections for this rule.
	TerminateTLS *bool `json:"terminateTLS,omitempty"`
	// WebCategories - List of destination azure web categories.
	WebCategories *[]string `json:"webCategories,omitempty"`
	// Name - Name of the rule.
	Name *string `json:"name,omitempty"`
	// Description - Description of the rule.
	Description *string `json:"description,omitempty"`
	// RuleType - Possible values include: 'RuleTypeFirewallPolicyRule', 'RuleTypeApplicationRule', 'RuleTypeNatRule', 'RuleTypeNetworkRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationRule.
func (ar ApplicationRule) MarshalJSON() ([]byte, error) {
	ar.RuleType = RuleTypeApplicationRule
	objectMap := make(map[string]interface{})
	if ar.SourceAddresses != nil {
		objectMap["sourceAddresses"] = ar.SourceAddresses
	}
	if ar.DestinationAddresses != nil {
		objectMap["destinationAddresses"] = ar.DestinationAddresses
	}
	if ar.Protocols != nil {
		objectMap["protocols"] = ar.Protocols
	}
	if ar.TargetFqdns != nil {
		objectMap["targetFqdns"] = ar.TargetFqdns
	}
	if ar.TargetUrls != nil {
		objectMap["targetUrls"] = ar.TargetUrls
	}
	if ar.FqdnTags != nil {
		objectMap["fqdnTags"] = ar.FqdnTags
	}
	if ar.SourceIPGroups != nil {
		objectMap["sourceIpGroups"] = ar.SourceIPGroups
	}
	if ar.TerminateTLS != nil {
		objectMap["terminateTLS"] = ar.TerminateTLS
	}
	if ar.WebCategories != nil {
		objectMap["webCategories"] = ar.WebCategories
	}
	if ar.Name != nil {
		objectMap["name"] = ar.Name
	}
	if ar.Description != nil {
		objectMap["description"] = ar.Description
	}
	if ar.RuleType != "" {
		objectMap["ruleType"] = ar.RuleType
	}
	return json.Marshal(objectMap)
}

// AsApplicationRule is the BasicFirewallPolicyRule implementation for ApplicationRule.
func (ar ApplicationRule) AsApplicationRule() (*ApplicationRule, bool) {
	return &ar, true
}

// AsNatRule is the BasicFirewallPolicyRule implementation for ApplicationRule.
func (ar ApplicationRule) AsNatRule() (*NatRule, bool) {
	return nil, false
}

// AsRule is the BasicFirewallPolicyRule implementation for ApplicationRule.
func (ar ApplicationRule) AsRule() (*Rule, bool) {
	return nil, false
}

// AsFirewallPolicyRule is the BasicFirewallPolicyRule implementation for ApplicationRule.
func (ar ApplicationRule) AsFirewallPolicyRule() (*FirewallPolicyRule, bool) {
	return nil, false
}

// AsBasicFirewallPolicyRule is the BasicFirewallPolicyRule implementation for ApplicationRule.
func (ar ApplicationRule) AsBasicFirewallPolicyRule() (BasicFirewallPolicyRule, bool) {
	return &ar, true
}

// ApplicationSecurityGroup an application security group in a resource group.
type ApplicationSecurityGroup struct {
	autorest.Response `json:"-"`
	// ApplicationSecurityGroupPropertiesFormat - Properties of the application security group.
	*ApplicationSecurityGroupPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ApplicationSecurityGroup.
func (asg ApplicationSecurityGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asg.ApplicationSecurityGroupPropertiesFormat != nil {
		objectMap["properties"] = asg.ApplicationSecurityGroupPropertiesFormat
	}
	if asg.ID != nil {
		objectMap["id"] = asg.ID
	}
	if asg.Location != nil {
		objectMap["location"] = asg.Location
	}
	if asg.Tags != nil {
		objectMap["tags"] = asg.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationSecurityGroup struct.
func (asg *ApplicationSecurityGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var applicationSecurityGroupPropertiesFormat ApplicationSecurityGroupPropertiesFormat
				err = json.Unmarshal(*v, &applicationSecurityGroupPropertiesFormat)
				if err != nil {
					return err
				}
				asg.ApplicationSecurityGroupPropertiesFormat = &applicationSecurityGroupPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				asg.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				asg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				asg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				asg.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				asg.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				asg.Tags = tags
			}
		}
	}

	return nil
}

// ApplicationSecurityGroupListResult a list of application security groups.
type ApplicationSecurityGroupListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of application security groups.
	Value *[]ApplicationSecurityGroup `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationSecurityGroupListResult.
func (asglr ApplicationSecurityGroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asglr.Value != nil {
		objectMap["value"] = asglr.Value
	}
	return json.Marshal(objectMap)
}

// ApplicationSecurityGroupListResultIterator provides access to a complete listing of
// ApplicationSecurityGroup values.
type ApplicationSecurityGroupListResultIterator struct {
	i    int
	page ApplicationSecurityGroupListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ApplicationSecurityGroupListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationSecurityGroupListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ApplicationSecurityGroupListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ApplicationSecurityGroupListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ApplicationSecurityGroupListResultIterator) Response() ApplicationSecurityGroupListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ApplicationSecurityGroupListResultIterator) Value() ApplicationSecurityGroup {
	if !iter.page.NotDone() {
		return ApplicationSecurityGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ApplicationSecurityGroupListResultIterator type.
func NewApplicationSecurityGroupListResultIterator(page ApplicationSecurityGroupListResultPage) ApplicationSecurityGroupListResultIterator {
	return ApplicationSecurityGroupListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (asglr ApplicationSecurityGroupListResult) IsEmpty() bool {
	return asglr.Value == nil || len(*asglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (asglr ApplicationSecurityGroupListResult) hasNextLink() bool {
	return asglr.NextLink != nil && len(*asglr.NextLink) != 0
}

// applicationSecurityGroupListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (asglr ApplicationSecurityGroupListResult) applicationSecurityGroupListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !asglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(asglr.NextLink)))
}

// ApplicationSecurityGroupListResultPage contains a page of ApplicationSecurityGroup values.
type ApplicationSecurityGroupListResultPage struct {
	fn    func(context.Context, ApplicationSecurityGroupListResult) (ApplicationSecurityGroupListResult, error)
	asglr ApplicationSecurityGroupListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ApplicationSecurityGroupListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationSecurityGroupListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.asglr)
		if err != nil {
			return err
		}
		page.asglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ApplicationSecurityGroupListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ApplicationSecurityGroupListResultPage) NotDone() bool {
	return !page.asglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ApplicationSecurityGroupListResultPage) Response() ApplicationSecurityGroupListResult {
	return page.asglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ApplicationSecurityGroupListResultPage) Values() []ApplicationSecurityGroup {
	if page.asglr.IsEmpty() {
		return nil
	}
	return *page.asglr.Value
}

// Creates a new instance of the ApplicationSecurityGroupListResultPage type.
func NewApplicationSecurityGroupListResultPage(cur ApplicationSecurityGroupListResult, getNextPage func(context.Context, ApplicationSecurityGroupListResult) (ApplicationSecurityGroupListResult, error)) ApplicationSecurityGroupListResultPage {
	return ApplicationSecurityGroupListResultPage{
		fn:    getNextPage,
		asglr: cur,
	}
}

// ApplicationSecurityGroupPropertiesFormat application security group properties.
type ApplicationSecurityGroupPropertiesFormat struct {
	// ResourceGUID - READ-ONLY; The resource GUID property of the application security group resource. It uniquely identifies a resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the application security group resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationSecurityGroupPropertiesFormat.
func (asgpf ApplicationSecurityGroupPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ApplicationSecurityGroupsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type ApplicationSecurityGroupsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationSecurityGroupsClient) (ApplicationSecurityGroup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationSecurityGroupsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationSecurityGroupsCreateOrUpdateFuture.Result.
func (future *ApplicationSecurityGroupsCreateOrUpdateFuture) result(client ApplicationSecurityGroupsClient) (asg ApplicationSecurityGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationSecurityGroupsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		asg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationSecurityGroupsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if asg.Response.Response, err = future.GetResult(sender); err == nil && asg.Response.Response.StatusCode != http.StatusNoContent {
		asg, err = client.CreateOrUpdateResponder(asg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ApplicationSecurityGroupsCreateOrUpdateFuture", "Result", asg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ApplicationSecurityGroupsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ApplicationSecurityGroupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ApplicationSecurityGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ApplicationSecurityGroupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ApplicationSecurityGroupsDeleteFuture.Result.
func (future *ApplicationSecurityGroupsDeleteFuture) result(client ApplicationSecurityGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ApplicationSecurityGroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ApplicationSecurityGroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AuthorizationListResult response for ListAuthorizations API service call retrieves all authorizations
// that belongs to an ExpressRouteCircuit.
type AuthorizationListResult struct {
	autorest.Response `json:"-"`
	// Value - The authorizations in an ExpressRoute Circuit.
	Value *[]ExpressRouteCircuitAuthorization `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AuthorizationListResultIterator provides access to a complete listing of
// ExpressRouteCircuitAuthorization values.
type AuthorizationListResultIterator struct {
	i    int
	page AuthorizationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AuthorizationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AuthorizationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AuthorizationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AuthorizationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AuthorizationListResultIterator) Response() AuthorizationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AuthorizationListResultIterator) Value() ExpressRouteCircuitAuthorization {
	if !iter.page.NotDone() {
		return ExpressRouteCircuitAuthorization{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AuthorizationListResultIterator type.
func NewAuthorizationListResultIterator(page AuthorizationListResultPage) AuthorizationListResultIterator {
	return AuthorizationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (alr AuthorizationListResult) IsEmpty() bool {
	return alr.Value == nil || len(*alr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (alr AuthorizationListResult) hasNextLink() bool {
	return alr.NextLink != nil && len(*alr.NextLink) != 0
}

// authorizationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (alr AuthorizationListResult) authorizationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !alr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(alr.NextLink)))
}

// AuthorizationListResultPage contains a page of ExpressRouteCircuitAuthorization values.
type AuthorizationListResultPage struct {
	fn  func(context.Context, AuthorizationListResult) (AuthorizationListResult, error)
	alr AuthorizationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AuthorizationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AuthorizationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.alr)
		if err != nil {
			return err
		}
		page.alr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AuthorizationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AuthorizationListResultPage) NotDone() bool {
	return !page.alr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AuthorizationListResultPage) Response() AuthorizationListResult {
	return page.alr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AuthorizationListResultPage) Values() []ExpressRouteCircuitAuthorization {
	if page.alr.IsEmpty() {
		return nil
	}
	return *page.alr.Value
}

// Creates a new instance of the AuthorizationListResultPage type.
func NewAuthorizationListResultPage(cur AuthorizationListResult, getNextPage func(context.Context, AuthorizationListResult) (AuthorizationListResult, error)) AuthorizationListResultPage {
	return AuthorizationListResultPage{
		fn:  getNextPage,
		alr: cur,
	}
}

// AuthorizationPropertiesFormat properties of ExpressRouteCircuitAuthorization.
type AuthorizationPropertiesFormat struct {
	// AuthorizationKey - The authorization key.
	AuthorizationKey *string `json:"authorizationKey,omitempty"`
	// AuthorizationUseStatus - The authorization use status. Possible values include: 'AuthorizationUseStatusAvailable', 'AuthorizationUseStatusInUse'
	AuthorizationUseStatus AuthorizationUseStatus `json:"authorizationUseStatus,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the authorization resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for AuthorizationPropertiesFormat.
func (apf AuthorizationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if apf.AuthorizationKey != nil {
		objectMap["authorizationKey"] = apf.AuthorizationKey
	}
	if apf.AuthorizationUseStatus != "" {
		objectMap["authorizationUseStatus"] = apf.AuthorizationUseStatus
	}
	return json.Marshal(objectMap)
}

// AutoApprovedPrivateLinkService the information of an AutoApprovedPrivateLinkService.
type AutoApprovedPrivateLinkService struct {
	// PrivateLinkService - The id of the private link service resource.
	PrivateLinkService *string `json:"privateLinkService,omitempty"`
}

// AutoApprovedPrivateLinkServicesResult an array of private link service id that can be linked to a
// private end point with auto approved.
type AutoApprovedPrivateLinkServicesResult struct {
	autorest.Response `json:"-"`
	// Value - An array of auto approved private link service.
	Value *[]AutoApprovedPrivateLinkService `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AutoApprovedPrivateLinkServicesResult.
func (aaplsr AutoApprovedPrivateLinkServicesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aaplsr.Value != nil {
		objectMap["value"] = aaplsr.Value
	}
	return json.Marshal(objectMap)
}

// AutoApprovedPrivateLinkServicesResultIterator provides access to a complete listing of
// AutoApprovedPrivateLinkService values.
type AutoApprovedPrivateLinkServicesResultIterator struct {
	i    int
	page AutoApprovedPrivateLinkServicesResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AutoApprovedPrivateLinkServicesResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AutoApprovedPrivateLinkServicesResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AutoApprovedPrivateLinkServicesResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AutoApprovedPrivateLinkServicesResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AutoApprovedPrivateLinkServicesResultIterator) Response() AutoApprovedPrivateLinkServicesResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AutoApprovedPrivateLinkServicesResultIterator) Value() AutoApprovedPrivateLinkService {
	if !iter.page.NotDone() {
		return AutoApprovedPrivateLinkService{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AutoApprovedPrivateLinkServicesResultIterator type.
func NewAutoApprovedPrivateLinkServicesResultIterator(page AutoApprovedPrivateLinkServicesResultPage) AutoApprovedPrivateLinkServicesResultIterator {
	return AutoApprovedPrivateLinkServicesResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aaplsr AutoApprovedPrivateLinkServicesResult) IsEmpty() bool {
	return aaplsr.Value == nil || len(*aaplsr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aaplsr AutoApprovedPrivateLinkServicesResult) hasNextLink() bool {
	return aaplsr.NextLink != nil && len(*aaplsr.NextLink) != 0
}

// autoApprovedPrivateLinkServicesResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aaplsr AutoApprovedPrivateLinkServicesResult) autoApprovedPrivateLinkServicesResultPreparer(ctx context.Context) (*http.Request, error) {
	if !aaplsr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aaplsr.NextLink)))
}

// AutoApprovedPrivateLinkServicesResultPage contains a page of AutoApprovedPrivateLinkService values.
type AutoApprovedPrivateLinkServicesResultPage struct {
	fn     func(context.Context, AutoApprovedPrivateLinkServicesResult) (AutoApprovedPrivateLinkServicesResult, error)
	aaplsr AutoApprovedPrivateLinkServicesResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AutoApprovedPrivateLinkServicesResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AutoApprovedPrivateLinkServicesResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aaplsr)
		if err != nil {
			return err
		}
		page.aaplsr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AutoApprovedPrivateLinkServicesResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AutoApprovedPrivateLinkServicesResultPage) NotDone() bool {
	return !page.aaplsr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AutoApprovedPrivateLinkServicesResultPage) Response() AutoApprovedPrivateLinkServicesResult {
	return page.aaplsr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AutoApprovedPrivateLinkServicesResultPage) Values() []AutoApprovedPrivateLinkService {
	if page.aaplsr.IsEmpty() {
		return nil
	}
	return *page.aaplsr.Value
}

// Creates a new instance of the AutoApprovedPrivateLinkServicesResultPage type.
func NewAutoApprovedPrivateLinkServicesResultPage(cur AutoApprovedPrivateLinkServicesResult, getNextPage func(context.Context, AutoApprovedPrivateLinkServicesResult) (AutoApprovedPrivateLinkServicesResult, error)) AutoApprovedPrivateLinkServicesResultPage {
	return AutoApprovedPrivateLinkServicesResultPage{
		fn:     getNextPage,
		aaplsr: cur,
	}
}

// Availability availability of the metric.
type Availability struct {
	// TimeGrain - The time grain of the availability.
	TimeGrain *string `json:"timeGrain,omitempty"`
	// Retention - The retention of the availability.
	Retention *string `json:"retention,omitempty"`
	// BlobDuration - Duration of the availability blob.
	BlobDuration *string `json:"blobDuration,omitempty"`
}

// AvailableDelegation the serviceName of an AvailableDelegation indicates a possible delegation for a
// subnet.
type AvailableDelegation struct {
	// Name - The name of the AvailableDelegation resource.
	Name *string `json:"name,omitempty"`
	// ID - A unique identifier of the AvailableDelegation resource.
	ID *string `json:"id,omitempty"`
	// Type - Resource type.
	Type *string `json:"type,omitempty"`
	// ServiceName - The name of the service and resource.
	ServiceName *string `json:"serviceName,omitempty"`
	// Actions - The actions permitted to the service upon delegation.
	Actions *[]string `json:"actions,omitempty"`
}

// AvailableDelegationsResult an array of available delegations.
type AvailableDelegationsResult struct {
	autorest.Response `json:"-"`
	// Value - An array of available delegations.
	Value *[]AvailableDelegation `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AvailableDelegationsResult.
func (adr AvailableDelegationsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if adr.Value != nil {
		objectMap["value"] = adr.Value
	}
	return json.Marshal(objectMap)
}

// AvailableDelegationsResultIterator provides access to a complete listing of AvailableDelegation values.
type AvailableDelegationsResultIterator struct {
	i    int
	page AvailableDelegationsResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AvailableDelegationsResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AvailableDelegationsResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AvailableDelegationsResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AvailableDelegationsResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AvailableDelegationsResultIterator) Response() AvailableDelegationsResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AvailableDelegationsResultIterator) Value() AvailableDelegation {
	if !iter.page.NotDone() {
		return AvailableDelegation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AvailableDelegationsResultIterator type.
func NewAvailableDelegationsResultIterator(page AvailableDelegationsResultPage) AvailableDelegationsResultIterator {
	return AvailableDelegationsResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (adr AvailableDelegationsResult) IsEmpty() bool {
	return adr.Value == nil || len(*adr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (adr AvailableDelegationsResult) hasNextLink() bool {
	return adr.NextLink != nil && len(*adr.NextLink) != 0
}

// availableDelegationsResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (adr AvailableDelegationsResult) availableDelegationsResultPreparer(ctx context.Context) (*http.Request, error) {
	if !adr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(adr.NextLink)))
}

// AvailableDelegationsResultPage contains a page of AvailableDelegation values.
type AvailableDelegationsResultPage struct {
	fn  func(context.Context, AvailableDelegationsResult) (AvailableDelegationsResult, error)
	adr AvailableDelegationsResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AvailableDelegationsResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AvailableDelegationsResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.adr)
		if err != nil {
			return err
		}
		page.adr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AvailableDelegationsResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AvailableDelegationsResultPage) NotDone() bool {
	return !page.adr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AvailableDelegationsResultPage) Response() AvailableDelegationsResult {
	return page.adr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AvailableDelegationsResultPage) Values() []AvailableDelegation {
	if page.adr.IsEmpty() {
		return nil
	}
	return *page.adr.Value
}

// Creates a new instance of the AvailableDelegationsResultPage type.
func NewAvailableDelegationsResultPage(cur AvailableDelegationsResult, getNextPage func(context.Context, AvailableDelegationsResult) (AvailableDelegationsResult, error)) AvailableDelegationsResultPage {
	return AvailableDelegationsResultPage{
		fn:  getNextPage,
		adr: cur,
	}
}

// AvailablePrivateEndpointType the information of an AvailablePrivateEndpointType.
type AvailablePrivateEndpointType struct {
	// Name - The name of the service and resource.
	Name *string `json:"name,omitempty"`
	// ID - A unique identifier of the AvailablePrivateEndpoint Type resource.
	ID *string `json:"id,omitempty"`
	// Type - Resource type.
	Type *string `json:"type,omitempty"`
	// ResourceName - The name of the service and resource.
	ResourceName *string `json:"resourceName,omitempty"`
	// DisplayName - Display name of the resource.
	DisplayName *string `json:"displayName,omitempty"`
}

// AvailablePrivateEndpointTypesResult an array of available PrivateEndpoint types.
type AvailablePrivateEndpointTypesResult struct {
	autorest.Response `json:"-"`
	// Value - An array of available privateEndpoint type.
	Value *[]AvailablePrivateEndpointType `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AvailablePrivateEndpointTypesResult.
func (apetr AvailablePrivateEndpointTypesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if apetr.Value != nil {
		objectMap["value"] = apetr.Value
	}
	return json.Marshal(objectMap)
}

// AvailablePrivateEndpointTypesResultIterator provides access to a complete listing of
// AvailablePrivateEndpointType values.
type AvailablePrivateEndpointTypesResultIterator struct {
	i    int
	page AvailablePrivateEndpointTypesResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AvailablePrivateEndpointTypesResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AvailablePrivateEndpointTypesResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AvailablePrivateEndpointTypesResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AvailablePrivateEndpointTypesResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AvailablePrivateEndpointTypesResultIterator) Response() AvailablePrivateEndpointTypesResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AvailablePrivateEndpointTypesResultIterator) Value() AvailablePrivateEndpointType {
	if !iter.page.NotDone() {
		return AvailablePrivateEndpointType{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AvailablePrivateEndpointTypesResultIterator type.
func NewAvailablePrivateEndpointTypesResultIterator(page AvailablePrivateEndpointTypesResultPage) AvailablePrivateEndpointTypesResultIterator {
	return AvailablePrivateEndpointTypesResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (apetr AvailablePrivateEndpointTypesResult) IsEmpty() bool {
	return apetr.Value == nil || len(*apetr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (apetr AvailablePrivateEndpointTypesResult) hasNextLink() bool {
	return apetr.NextLink != nil && len(*apetr.NextLink) != 0
}

// availablePrivateEndpointTypesResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (apetr AvailablePrivateEndpointTypesResult) availablePrivateEndpointTypesResultPreparer(ctx context.Context) (*http.Request, error) {
	if !apetr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(apetr.NextLink)))
}

// AvailablePrivateEndpointTypesResultPage contains a page of AvailablePrivateEndpointType values.
type AvailablePrivateEndpointTypesResultPage struct {
	fn    func(context.Context, AvailablePrivateEndpointTypesResult) (AvailablePrivateEndpointTypesResult, error)
	apetr AvailablePrivateEndpointTypesResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AvailablePrivateEndpointTypesResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AvailablePrivateEndpointTypesResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.apetr)
		if err != nil {
			return err
		}
		page.apetr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AvailablePrivateEndpointTypesResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AvailablePrivateEndpointTypesResultPage) NotDone() bool {
	return !page.apetr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AvailablePrivateEndpointTypesResultPage) Response() AvailablePrivateEndpointTypesResult {
	return page.apetr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AvailablePrivateEndpointTypesResultPage) Values() []AvailablePrivateEndpointType {
	if page.apetr.IsEmpty() {
		return nil
	}
	return *page.apetr.Value
}

// Creates a new instance of the AvailablePrivateEndpointTypesResultPage type.
func NewAvailablePrivateEndpointTypesResultPage(cur AvailablePrivateEndpointTypesResult, getNextPage func(context.Context, AvailablePrivateEndpointTypesResult) (AvailablePrivateEndpointTypesResult, error)) AvailablePrivateEndpointTypesResultPage {
	return AvailablePrivateEndpointTypesResultPage{
		fn:    getNextPage,
		apetr: cur,
	}
}

// AvailableProvidersList list of available countries with details.
type AvailableProvidersList struct {
	autorest.Response `json:"-"`
	// Countries - List of available countries.
	Countries *[]AvailableProvidersListCountry `json:"countries,omitempty"`
}

// AvailableProvidersListCity city or town details.
type AvailableProvidersListCity struct {
	// CityName - The city or town name.
	CityName *string `json:"cityName,omitempty"`
	// Providers - A list of Internet service providers.
	Providers *[]string `json:"providers,omitempty"`
}

// AvailableProvidersListCountry country details.
type AvailableProvidersListCountry struct {
	// CountryName - The country name.
	CountryName *string `json:"countryName,omitempty"`
	// Providers - A list of Internet service providers.
	Providers *[]string `json:"providers,omitempty"`
	// States - List of available states in the country.
	States *[]AvailableProvidersListState `json:"states,omitempty"`
}

// AvailableProvidersListParameters constraints that determine the list of available Internet service
// providers.
type AvailableProvidersListParameters struct {
	// AzureLocations - A list of Azure regions.
	AzureLocations *[]string `json:"azureLocations,omitempty"`
	// Country - The country for available providers list.
	Country *string `json:"country,omitempty"`
	// State - The state for available providers list.
	State *string `json:"state,omitempty"`
	// City - The city or town for available providers list.
	City *string `json:"city,omitempty"`
}

// AvailableProvidersListState state details.
type AvailableProvidersListState struct {
	// StateName - The state name.
	StateName *string `json:"stateName,omitempty"`
	// Providers - A list of Internet service providers.
	Providers *[]string `json:"providers,omitempty"`
	// Cities - List of available cities or towns in the state.
	Cities *[]AvailableProvidersListCity `json:"cities,omitempty"`
}

// AvailableServiceAlias the available service alias.
type AvailableServiceAlias struct {
	// Name - The name of the service alias.
	Name *string `json:"name,omitempty"`
	// ID - The ID of the service alias.
	ID *string `json:"id,omitempty"`
	// Type - The type of the resource.
	Type *string `json:"type,omitempty"`
	// ResourceName - The resource name of the service alias.
	ResourceName *string `json:"resourceName,omitempty"`
}

// AvailableServiceAliasesResult an array of available service aliases.
type AvailableServiceAliasesResult struct {
	autorest.Response `json:"-"`
	// Value - An array of available service aliases.
	Value *[]AvailableServiceAlias `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AvailableServiceAliasesResult.
func (asar AvailableServiceAliasesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if asar.Value != nil {
		objectMap["value"] = asar.Value
	}
	return json.Marshal(objectMap)
}

// AvailableServiceAliasesResultIterator provides access to a complete listing of AvailableServiceAlias
// values.
type AvailableServiceAliasesResultIterator struct {
	i    int
	page AvailableServiceAliasesResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AvailableServiceAliasesResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AvailableServiceAliasesResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AvailableServiceAliasesResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AvailableServiceAliasesResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AvailableServiceAliasesResultIterator) Response() AvailableServiceAliasesResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AvailableServiceAliasesResultIterator) Value() AvailableServiceAlias {
	if !iter.page.NotDone() {
		return AvailableServiceAlias{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AvailableServiceAliasesResultIterator type.
func NewAvailableServiceAliasesResultIterator(page AvailableServiceAliasesResultPage) AvailableServiceAliasesResultIterator {
	return AvailableServiceAliasesResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (asar AvailableServiceAliasesResult) IsEmpty() bool {
	return asar.Value == nil || len(*asar.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (asar AvailableServiceAliasesResult) hasNextLink() bool {
	return asar.NextLink != nil && len(*asar.NextLink) != 0
}

// availableServiceAliasesResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (asar AvailableServiceAliasesResult) availableServiceAliasesResultPreparer(ctx context.Context) (*http.Request, error) {
	if !asar.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(asar.NextLink)))
}

// AvailableServiceAliasesResultPage contains a page of AvailableServiceAlias values.
type AvailableServiceAliasesResultPage struct {
	fn   func(context.Context, AvailableServiceAliasesResult) (AvailableServiceAliasesResult, error)
	asar AvailableServiceAliasesResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AvailableServiceAliasesResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AvailableServiceAliasesResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.asar)
		if err != nil {
			return err
		}
		page.asar = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AvailableServiceAliasesResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AvailableServiceAliasesResultPage) NotDone() bool {
	return !page.asar.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AvailableServiceAliasesResultPage) Response() AvailableServiceAliasesResult {
	return page.asar
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AvailableServiceAliasesResultPage) Values() []AvailableServiceAlias {
	if page.asar.IsEmpty() {
		return nil
	}
	return *page.asar.Value
}

// Creates a new instance of the AvailableServiceAliasesResultPage type.
func NewAvailableServiceAliasesResultPage(cur AvailableServiceAliasesResult, getNextPage func(context.Context, AvailableServiceAliasesResult) (AvailableServiceAliasesResult, error)) AvailableServiceAliasesResultPage {
	return AvailableServiceAliasesResultPage{
		fn:   getNextPage,
		asar: cur,
	}
}

// AzureAsyncOperationResult the response body contains the status of the specified asynchronous operation,
// indicating whether it has succeeded, is in progress, or has failed. Note that this status is distinct
// from the HTTP status code returned for the Get Operation Status operation itself. If the asynchronous
// operation succeeded, the response body includes the HTTP status code for the successful request. If the
// asynchronous operation failed, the response body includes the HTTP status code for the failed request
// and error information regarding the failure.
type AzureAsyncOperationResult struct {
	// Status - Status of the Azure async operation. Possible values include: 'OperationStatusInProgress', 'OperationStatusSucceeded', 'OperationStatusFailed'
	Status OperationStatus `json:"status,omitempty"`
	// Error - Details of the error occurred during specified asynchronous operation.
	Error *Error `json:"error,omitempty"`
}

// AzureFirewall azure Firewall resource.
type AzureFirewall struct {
	autorest.Response `json:"-"`
	// AzureFirewallPropertiesFormat - Properties of the azure firewall.
	*AzureFirewallPropertiesFormat `json:"properties,omitempty"`
	// Zones - A list of availability zones denoting where the resource needs to come from.
	Zones *[]string `json:"zones,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AzureFirewall.
func (af AzureFirewall) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if af.AzureFirewallPropertiesFormat != nil {
		objectMap["properties"] = af.AzureFirewallPropertiesFormat
	}
	if af.Zones != nil {
		objectMap["zones"] = af.Zones
	}
	if af.ID != nil {
		objectMap["id"] = af.ID
	}
	if af.Location != nil {
		objectMap["location"] = af.Location
	}
	if af.Tags != nil {
		objectMap["tags"] = af.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AzureFirewall struct.
func (af *AzureFirewall) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var azureFirewallPropertiesFormat AzureFirewallPropertiesFormat
				err = json.Unmarshal(*v, &azureFirewallPropertiesFormat)
				if err != nil {
					return err
				}
				af.AzureFirewallPropertiesFormat = &azureFirewallPropertiesFormat
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				af.Zones = &zones
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				af.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				af.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				af.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				af.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				af.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				af.Tags = tags
			}
		}
	}

	return nil
}

// AzureFirewallApplicationRule properties of an application rule.
type AzureFirewallApplicationRule struct {
	// Name - Name of the application rule.
	Name *string `json:"name,omitempty"`
	// Description - Description of the rule.
	Description *string `json:"description,omitempty"`
	// SourceAddresses - List of source IP addresses for this rule.
	SourceAddresses *[]string `json:"sourceAddresses,omitempty"`
	// Protocols - Array of ApplicationRuleProtocols.
	Protocols *[]AzureFirewallApplicationRuleProtocol `json:"protocols,omitempty"`
	// TargetFqdns - List of FQDNs for this rule.
	TargetFqdns *[]string `json:"targetFqdns,omitempty"`
	// FqdnTags - List of FQDN Tags for this rule.
	FqdnTags *[]string `json:"fqdnTags,omitempty"`
	// SourceIPGroups - List of source IpGroups for this rule.
	SourceIPGroups *[]string `json:"sourceIpGroups,omitempty"`
}

// AzureFirewallApplicationRuleCollection application rule collection resource.
type AzureFirewallApplicationRuleCollection struct {
	// AzureFirewallApplicationRuleCollectionPropertiesFormat - Properties of the azure firewall application rule collection.
	*AzureFirewallApplicationRuleCollectionPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallApplicationRuleCollection.
func (afarc AzureFirewallApplicationRuleCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afarc.AzureFirewallApplicationRuleCollectionPropertiesFormat != nil {
		objectMap["properties"] = afarc.AzureFirewallApplicationRuleCollectionPropertiesFormat
	}
	if afarc.Name != nil {
		objectMap["name"] = afarc.Name
	}
	if afarc.ID != nil {
		objectMap["id"] = afarc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AzureFirewallApplicationRuleCollection struct.
func (afarc *AzureFirewallApplicationRuleCollection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var azureFirewallApplicationRuleCollectionPropertiesFormat AzureFirewallApplicationRuleCollectionPropertiesFormat
				err = json.Unmarshal(*v, &azureFirewallApplicationRuleCollectionPropertiesFormat)
				if err != nil {
					return err
				}
				afarc.AzureFirewallApplicationRuleCollectionPropertiesFormat = &azureFirewallApplicationRuleCollectionPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				afarc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				afarc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				afarc.ID = &ID
			}
		}
	}

	return nil
}

// AzureFirewallApplicationRuleCollectionPropertiesFormat properties of the application rule collection.
type AzureFirewallApplicationRuleCollectionPropertiesFormat struct {
	// Priority - Priority of the application rule collection resource.
	Priority *int32 `json:"priority,omitempty"`
	// Action - The action type of a rule collection.
	Action *AzureFirewallRCAction `json:"action,omitempty"`
	// Rules - Collection of rules used by a application rule collection.
	Rules *[]AzureFirewallApplicationRule `json:"rules,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the application rule collection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallApplicationRuleCollectionPropertiesFormat.
func (afarcpf AzureFirewallApplicationRuleCollectionPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afarcpf.Priority != nil {
		objectMap["priority"] = afarcpf.Priority
	}
	if afarcpf.Action != nil {
		objectMap["action"] = afarcpf.Action
	}
	if afarcpf.Rules != nil {
		objectMap["rules"] = afarcpf.Rules
	}
	return json.Marshal(objectMap)
}

// AzureFirewallApplicationRuleProtocol properties of the application rule protocol.
type AzureFirewallApplicationRuleProtocol struct {
	// ProtocolType - Protocol type. Possible values include: 'AzureFirewallApplicationRuleProtocolTypeHTTP', 'AzureFirewallApplicationRuleProtocolTypeHTTPS', 'AzureFirewallApplicationRuleProtocolTypeMssql'
	ProtocolType AzureFirewallApplicationRuleProtocolType `json:"protocolType,omitempty"`
	// Port - Port number for the protocol, cannot be greater than 64000. This field is optional.
	Port *int32 `json:"port,omitempty"`
}

// AzureFirewallFqdnTag azure Firewall FQDN Tag Resource.
type AzureFirewallFqdnTag struct {
	// AzureFirewallFqdnTagPropertiesFormat - Properties of the azure firewall FQDN tag.
	*AzureFirewallFqdnTagPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AzureFirewallFqdnTag.
func (afft AzureFirewallFqdnTag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afft.AzureFirewallFqdnTagPropertiesFormat != nil {
		objectMap["properties"] = afft.AzureFirewallFqdnTagPropertiesFormat
	}
	if afft.ID != nil {
		objectMap["id"] = afft.ID
	}
	if afft.Location != nil {
		objectMap["location"] = afft.Location
	}
	if afft.Tags != nil {
		objectMap["tags"] = afft.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AzureFirewallFqdnTag struct.
func (afft *AzureFirewallFqdnTag) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var azureFirewallFqdnTagPropertiesFormat AzureFirewallFqdnTagPropertiesFormat
				err = json.Unmarshal(*v, &azureFirewallFqdnTagPropertiesFormat)
				if err != nil {
					return err
				}
				afft.AzureFirewallFqdnTagPropertiesFormat = &azureFirewallFqdnTagPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				afft.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				afft.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				afft.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				afft.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				afft.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				afft.Tags = tags
			}
		}
	}

	return nil
}

// AzureFirewallFqdnTagListResult response for ListAzureFirewallFqdnTags API service call.
type AzureFirewallFqdnTagListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Azure Firewall FQDN Tags in a resource group.
	Value *[]AzureFirewallFqdnTag `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AzureFirewallFqdnTagListResultIterator provides access to a complete listing of AzureFirewallFqdnTag
// values.
type AzureFirewallFqdnTagListResultIterator struct {
	i    int
	page AzureFirewallFqdnTagListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AzureFirewallFqdnTagListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AzureFirewallFqdnTagListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AzureFirewallFqdnTagListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AzureFirewallFqdnTagListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AzureFirewallFqdnTagListResultIterator) Response() AzureFirewallFqdnTagListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AzureFirewallFqdnTagListResultIterator) Value() AzureFirewallFqdnTag {
	if !iter.page.NotDone() {
		return AzureFirewallFqdnTag{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AzureFirewallFqdnTagListResultIterator type.
func NewAzureFirewallFqdnTagListResultIterator(page AzureFirewallFqdnTagListResultPage) AzureFirewallFqdnTagListResultIterator {
	return AzureFirewallFqdnTagListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (afftlr AzureFirewallFqdnTagListResult) IsEmpty() bool {
	return afftlr.Value == nil || len(*afftlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (afftlr AzureFirewallFqdnTagListResult) hasNextLink() bool {
	return afftlr.NextLink != nil && len(*afftlr.NextLink) != 0
}

// azureFirewallFqdnTagListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (afftlr AzureFirewallFqdnTagListResult) azureFirewallFqdnTagListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !afftlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(afftlr.NextLink)))
}

// AzureFirewallFqdnTagListResultPage contains a page of AzureFirewallFqdnTag values.
type AzureFirewallFqdnTagListResultPage struct {
	fn     func(context.Context, AzureFirewallFqdnTagListResult) (AzureFirewallFqdnTagListResult, error)
	afftlr AzureFirewallFqdnTagListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AzureFirewallFqdnTagListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AzureFirewallFqdnTagListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.afftlr)
		if err != nil {
			return err
		}
		page.afftlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AzureFirewallFqdnTagListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AzureFirewallFqdnTagListResultPage) NotDone() bool {
	return !page.afftlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AzureFirewallFqdnTagListResultPage) Response() AzureFirewallFqdnTagListResult {
	return page.afftlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AzureFirewallFqdnTagListResultPage) Values() []AzureFirewallFqdnTag {
	if page.afftlr.IsEmpty() {
		return nil
	}
	return *page.afftlr.Value
}

// Creates a new instance of the AzureFirewallFqdnTagListResultPage type.
func NewAzureFirewallFqdnTagListResultPage(cur AzureFirewallFqdnTagListResult, getNextPage func(context.Context, AzureFirewallFqdnTagListResult) (AzureFirewallFqdnTagListResult, error)) AzureFirewallFqdnTagListResultPage {
	return AzureFirewallFqdnTagListResultPage{
		fn:     getNextPage,
		afftlr: cur,
	}
}

// AzureFirewallFqdnTagPropertiesFormat azure Firewall FQDN Tag Properties.
type AzureFirewallFqdnTagPropertiesFormat struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the Azure firewall FQDN tag resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// FqdnTagName - READ-ONLY; The name of this FQDN Tag.
	FqdnTagName *string `json:"fqdnTagName,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallFqdnTagPropertiesFormat.
func (afftpf AzureFirewallFqdnTagPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AzureFirewallIPConfiguration IP configuration of an Azure Firewall.
type AzureFirewallIPConfiguration struct {
	// AzureFirewallIPConfigurationPropertiesFormat - Properties of the azure firewall IP configuration.
	*AzureFirewallIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallIPConfiguration.
func (afic AzureFirewallIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afic.AzureFirewallIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = afic.AzureFirewallIPConfigurationPropertiesFormat
	}
	if afic.Name != nil {
		objectMap["name"] = afic.Name
	}
	if afic.ID != nil {
		objectMap["id"] = afic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AzureFirewallIPConfiguration struct.
func (afic *AzureFirewallIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var azureFirewallIPConfigurationPropertiesFormat AzureFirewallIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &azureFirewallIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				afic.AzureFirewallIPConfigurationPropertiesFormat = &azureFirewallIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				afic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				afic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				afic.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				afic.ID = &ID
			}
		}
	}

	return nil
}

// AzureFirewallIPConfigurationPropertiesFormat properties of IP configuration of an Azure Firewall.
type AzureFirewallIPConfigurationPropertiesFormat struct {
	// PrivateIPAddress - READ-ONLY; The Firewall Internal Load Balancer IP to be used as the next hop in User Defined Routes.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// Subnet - Reference to the subnet resource. This resource must be named 'AzureFirewallSubnet' or 'AzureFirewallManagementSubnet'.
	Subnet *SubResource `json:"subnet,omitempty"`
	// PublicIPAddress - Reference to the PublicIP resource. This field is a mandatory input if subnet is not null.
	PublicIPAddress *SubResource `json:"publicIPAddress,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the Azure firewall IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallIPConfigurationPropertiesFormat.
func (aficpf AzureFirewallIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aficpf.Subnet != nil {
		objectMap["subnet"] = aficpf.Subnet
	}
	if aficpf.PublicIPAddress != nil {
		objectMap["publicIPAddress"] = aficpf.PublicIPAddress
	}
	return json.Marshal(objectMap)
}

// AzureFirewallIPGroups ipGroups associated with azure firewall.
type AzureFirewallIPGroups struct {
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// ChangeNumber - READ-ONLY; The iteration number.
	ChangeNumber *string `json:"changeNumber,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallIPGroups.
func (afig AzureFirewallIPGroups) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AzureFirewallListResult response for ListAzureFirewalls API service call.
type AzureFirewallListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Azure Firewalls in a resource group.
	Value *[]AzureFirewall `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AzureFirewallListResultIterator provides access to a complete listing of AzureFirewall values.
type AzureFirewallListResultIterator struct {
	i    int
	page AzureFirewallListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AzureFirewallListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AzureFirewallListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AzureFirewallListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AzureFirewallListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AzureFirewallListResultIterator) Response() AzureFirewallListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AzureFirewallListResultIterator) Value() AzureFirewall {
	if !iter.page.NotDone() {
		return AzureFirewall{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AzureFirewallListResultIterator type.
func NewAzureFirewallListResultIterator(page AzureFirewallListResultPage) AzureFirewallListResultIterator {
	return AzureFirewallListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aflr AzureFirewallListResult) IsEmpty() bool {
	return aflr.Value == nil || len(*aflr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aflr AzureFirewallListResult) hasNextLink() bool {
	return aflr.NextLink != nil && len(*aflr.NextLink) != 0
}

// azureFirewallListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aflr AzureFirewallListResult) azureFirewallListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !aflr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aflr.NextLink)))
}

// AzureFirewallListResultPage contains a page of AzureFirewall values.
type AzureFirewallListResultPage struct {
	fn   func(context.Context, AzureFirewallListResult) (AzureFirewallListResult, error)
	aflr AzureFirewallListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AzureFirewallListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AzureFirewallListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aflr)
		if err != nil {
			return err
		}
		page.aflr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AzureFirewallListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AzureFirewallListResultPage) NotDone() bool {
	return !page.aflr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AzureFirewallListResultPage) Response() AzureFirewallListResult {
	return page.aflr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AzureFirewallListResultPage) Values() []AzureFirewall {
	if page.aflr.IsEmpty() {
		return nil
	}
	return *page.aflr.Value
}

// Creates a new instance of the AzureFirewallListResultPage type.
func NewAzureFirewallListResultPage(cur AzureFirewallListResult, getNextPage func(context.Context, AzureFirewallListResult) (AzureFirewallListResult, error)) AzureFirewallListResultPage {
	return AzureFirewallListResultPage{
		fn:   getNextPage,
		aflr: cur,
	}
}

// AzureFirewallNatRCAction azureFirewall NAT Rule Collection Action.
type AzureFirewallNatRCAction struct {
	// Type - The type of action. Possible values include: 'AzureFirewallNatRCActionTypeSnat', 'AzureFirewallNatRCActionTypeDnat'
	Type AzureFirewallNatRCActionType `json:"type,omitempty"`
}

// AzureFirewallNatRule properties of a NAT rule.
type AzureFirewallNatRule struct {
	// Name - Name of the NAT rule.
	Name *string `json:"name,omitempty"`
	// Description - Description of the rule.
	Description *string `json:"description,omitempty"`
	// SourceAddresses - List of source IP addresses for this rule.
	SourceAddresses *[]string `json:"sourceAddresses,omitempty"`
	// DestinationAddresses - List of destination IP addresses for this rule. Supports IP ranges, prefixes, and service tags.
	DestinationAddresses *[]string `json:"destinationAddresses,omitempty"`
	// DestinationPorts - List of destination ports.
	DestinationPorts *[]string `json:"destinationPorts,omitempty"`
	// Protocols - Array of AzureFirewallNetworkRuleProtocols applicable to this NAT rule.
	Protocols *[]AzureFirewallNetworkRuleProtocol `json:"protocols,omitempty"`
	// TranslatedAddress - The translated address for this NAT rule.
	TranslatedAddress *string `json:"translatedAddress,omitempty"`
	// TranslatedPort - The translated port for this NAT rule.
	TranslatedPort *string `json:"translatedPort,omitempty"`
	// TranslatedFqdn - The translated FQDN for this NAT rule.
	TranslatedFqdn *string `json:"translatedFqdn,omitempty"`
	// SourceIPGroups - List of source IpGroups for this rule.
	SourceIPGroups *[]string `json:"sourceIpGroups,omitempty"`
}

// AzureFirewallNatRuleCollection NAT rule collection resource.
type AzureFirewallNatRuleCollection struct {
	// AzureFirewallNatRuleCollectionProperties - Properties of the azure firewall NAT rule collection.
	*AzureFirewallNatRuleCollectionProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallNatRuleCollection.
func (afnrc AzureFirewallNatRuleCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afnrc.AzureFirewallNatRuleCollectionProperties != nil {
		objectMap["properties"] = afnrc.AzureFirewallNatRuleCollectionProperties
	}
	if afnrc.Name != nil {
		objectMap["name"] = afnrc.Name
	}
	if afnrc.ID != nil {
		objectMap["id"] = afnrc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AzureFirewallNatRuleCollection struct.
func (afnrc *AzureFirewallNatRuleCollection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var azureFirewallNatRuleCollectionProperties AzureFirewallNatRuleCollectionProperties
				err = json.Unmarshal(*v, &azureFirewallNatRuleCollectionProperties)
				if err != nil {
					return err
				}
				afnrc.AzureFirewallNatRuleCollectionProperties = &azureFirewallNatRuleCollectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				afnrc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				afnrc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				afnrc.ID = &ID
			}
		}
	}

	return nil
}

// AzureFirewallNatRuleCollectionProperties properties of the NAT rule collection.
type AzureFirewallNatRuleCollectionProperties struct {
	// Priority - Priority of the NAT rule collection resource.
	Priority *int32 `json:"priority,omitempty"`
	// Action - The action type of a NAT rule collection.
	Action *AzureFirewallNatRCAction `json:"action,omitempty"`
	// Rules - Collection of rules used by a NAT rule collection.
	Rules *[]AzureFirewallNatRule `json:"rules,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the NAT rule collection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallNatRuleCollectionProperties.
func (afnrcp AzureFirewallNatRuleCollectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afnrcp.Priority != nil {
		objectMap["priority"] = afnrcp.Priority
	}
	if afnrcp.Action != nil {
		objectMap["action"] = afnrcp.Action
	}
	if afnrcp.Rules != nil {
		objectMap["rules"] = afnrcp.Rules
	}
	return json.Marshal(objectMap)
}

// AzureFirewallNetworkRule properties of the network rule.
type AzureFirewallNetworkRule struct {
	// Name - Name of the network rule.
	Name *string `json:"name,omitempty"`
	// Description - Description of the rule.
	Description *string `json:"description,omitempty"`
	// Protocols - Array of AzureFirewallNetworkRuleProtocols.
	Protocols *[]AzureFirewallNetworkRuleProtocol `json:"protocols,omitempty"`
	// SourceAddresses - List of source IP addresses for this rule.
	SourceAddresses *[]string `json:"sourceAddresses,omitempty"`
	// DestinationAddresses - List of destination IP addresses.
	DestinationAddresses *[]string `json:"destinationAddresses,omitempty"`
	// DestinationPorts - List of destination ports.
	DestinationPorts *[]string `json:"destinationPorts,omitempty"`
	// DestinationFqdns - List of destination FQDNs.
	DestinationFqdns *[]string `json:"destinationFqdns,omitempty"`
	// SourceIPGroups - List of source IpGroups for this rule.
	SourceIPGroups *[]string `json:"sourceIpGroups,omitempty"`
	// DestinationIPGroups - List of destination IpGroups for this rule.
	DestinationIPGroups *[]string `json:"destinationIpGroups,omitempty"`
}

// AzureFirewallNetworkRuleCollection network rule collection resource.
type AzureFirewallNetworkRuleCollection struct {
	// AzureFirewallNetworkRuleCollectionPropertiesFormat - Properties of the azure firewall network rule collection.
	*AzureFirewallNetworkRuleCollectionPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallNetworkRuleCollection.
func (afnrc AzureFirewallNetworkRuleCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afnrc.AzureFirewallNetworkRuleCollectionPropertiesFormat != nil {
		objectMap["properties"] = afnrc.AzureFirewallNetworkRuleCollectionPropertiesFormat
	}
	if afnrc.Name != nil {
		objectMap["name"] = afnrc.Name
	}
	if afnrc.ID != nil {
		objectMap["id"] = afnrc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AzureFirewallNetworkRuleCollection struct.
func (afnrc *AzureFirewallNetworkRuleCollection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var azureFirewallNetworkRuleCollectionPropertiesFormat AzureFirewallNetworkRuleCollectionPropertiesFormat
				err = json.Unmarshal(*v, &azureFirewallNetworkRuleCollectionPropertiesFormat)
				if err != nil {
					return err
				}
				afnrc.AzureFirewallNetworkRuleCollectionPropertiesFormat = &azureFirewallNetworkRuleCollectionPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				afnrc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				afnrc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				afnrc.ID = &ID
			}
		}
	}

	return nil
}

// AzureFirewallNetworkRuleCollectionPropertiesFormat properties of the network rule collection.
type AzureFirewallNetworkRuleCollectionPropertiesFormat struct {
	// Priority - Priority of the network rule collection resource.
	Priority *int32 `json:"priority,omitempty"`
	// Action - The action type of a rule collection.
	Action *AzureFirewallRCAction `json:"action,omitempty"`
	// Rules - Collection of rules used by a network rule collection.
	Rules *[]AzureFirewallNetworkRule `json:"rules,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the network rule collection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureFirewallNetworkRuleCollectionPropertiesFormat.
func (afnrcpf AzureFirewallNetworkRuleCollectionPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afnrcpf.Priority != nil {
		objectMap["priority"] = afnrcpf.Priority
	}
	if afnrcpf.Action != nil {
		objectMap["action"] = afnrcpf.Action
	}
	if afnrcpf.Rules != nil {
		objectMap["rules"] = afnrcpf.Rules
	}
	return json.Marshal(objectMap)
}

// AzureFirewallPropertiesFormat properties of the Azure Firewall.
type AzureFirewallPropertiesFormat struct {
	// ApplicationRuleCollections - Collection of application rule collections used by Azure Firewall.
	ApplicationRuleCollections *[]AzureFirewallApplicationRuleCollection `json:"applicationRuleCollections,omitempty"`
	// NatRuleCollections - Collection of NAT rule collections used by Azure Firewall.
	NatRuleCollections *[]AzureFirewallNatRuleCollection `json:"natRuleCollections,omitempty"`
	// NetworkRuleCollections - Collection of network rule collections used by Azure Firewall.
	NetworkRuleCollections *[]AzureFirewallNetworkRuleCollection `json:"networkRuleCollections,omitempty"`
	// IPConfigurations - IP configuration of the Azure Firewall resource.
	IPConfigurations *[]AzureFirewallIPConfiguration `json:"ipConfigurations,omitempty"`
	// ManagementIPConfiguration - IP configuration of the Azure Firewall used for management traffic.
	ManagementIPConfiguration *AzureFirewallIPConfiguration `json:"managementIpConfiguration,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the Azure firewall resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ThreatIntelMode - The operation mode for Threat Intelligence. Possible values include: 'AzureFirewallThreatIntelModeAlert', 'AzureFirewallThreatIntelModeDeny', 'AzureFirewallThreatIntelModeOff'
	ThreatIntelMode AzureFirewallThreatIntelMode `json:"threatIntelMode,omitempty"`
	// VirtualHub - The virtualHub to which the firewall belongs.
	VirtualHub *SubResource `json:"virtualHub,omitempty"`
	// FirewallPolicy - The firewallPolicy associated with this azure firewall.
	FirewallPolicy *SubResource `json:"firewallPolicy,omitempty"`
	// HubIPAddresses - IP addresses associated with AzureFirewall.
	HubIPAddresses *HubIPAddresses `json:"hubIPAddresses,omitempty"`
	// IPGroups - READ-ONLY; IpGroups associated with AzureFirewall.
	IPGroups *[]AzureFirewallIPGroups `json:"ipGroups,omitempty"`
	// Sku - The Azure Firewall Resource SKU.
	Sku *AzureFirewallSku `json:"sku,omitempty"`
	// AdditionalProperties - The additional properties used to further config this azure firewall.
	AdditionalProperties map[string]*string `json:"additionalProperties"`
}

// MarshalJSON is the custom marshaler for AzureFirewallPropertiesFormat.
func (afpf AzureFirewallPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if afpf.ApplicationRuleCollections != nil {
		objectMap["applicationRuleCollections"] = afpf.ApplicationRuleCollections
	}
	if afpf.NatRuleCollections != nil {
		objectMap["natRuleCollections"] = afpf.NatRuleCollections
	}
	if afpf.NetworkRuleCollections != nil {
		objectMap["networkRuleCollections"] = afpf.NetworkRuleCollections
	}
	if afpf.IPConfigurations != nil {
		objectMap["ipConfigurations"] = afpf.IPConfigurations
	}
	if afpf.ManagementIPConfiguration != nil {
		objectMap["managementIpConfiguration"] = afpf.ManagementIPConfiguration
	}
	if afpf.ThreatIntelMode != "" {
		objectMap["threatIntelMode"] = afpf.ThreatIntelMode
	}
	if afpf.VirtualHub != nil {
		objectMap["virtualHub"] = afpf.VirtualHub
	}
	if afpf.FirewallPolicy != nil {
		objectMap["firewallPolicy"] = afpf.FirewallPolicy
	}
	if afpf.HubIPAddresses != nil {
		objectMap["hubIPAddresses"] = afpf.HubIPAddresses
	}
	if afpf.Sku != nil {
		objectMap["sku"] = afpf.Sku
	}
	if afpf.AdditionalProperties != nil {
		objectMap["additionalProperties"] = afpf.AdditionalProperties
	}
	return json.Marshal(objectMap)
}

// AzureFirewallPublicIPAddress public IP Address associated with azure firewall.
type AzureFirewallPublicIPAddress struct {
	// Address - Public IP Address value.
	Address *string `json:"address,omitempty"`
}

// AzureFirewallRCAction properties of the AzureFirewallRCAction.
type AzureFirewallRCAction struct {
	// Type - The type of action. Possible values include: 'AzureFirewallRCActionTypeAllow', 'AzureFirewallRCActionTypeDeny'
	Type AzureFirewallRCActionType `json:"type,omitempty"`
}

// AzureFirewallsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AzureFirewallsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AzureFirewallsClient) (AzureFirewall, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AzureFirewallsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AzureFirewallsCreateOrUpdateFuture.Result.
func (future *AzureFirewallsCreateOrUpdateFuture) result(client AzureFirewallsClient) (af AzureFirewall, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.AzureFirewallsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		af.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.AzureFirewallsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if af.Response.Response, err = future.GetResult(sender); err == nil && af.Response.Response.StatusCode != http.StatusNoContent {
		af, err = client.CreateOrUpdateResponder(af.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.AzureFirewallsCreateOrUpdateFuture", "Result", af.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AzureFirewallsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AzureFirewallsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AzureFirewallsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AzureFirewallsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AzureFirewallsDeleteFuture.Result.
func (future *AzureFirewallsDeleteFuture) result(client AzureFirewallsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.AzureFirewallsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.AzureFirewallsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AzureFirewallSku SKU of an Azure Firewall.
type AzureFirewallSku struct {
	// Name - Name of an Azure Firewall SKU. Possible values include: 'AzureFirewallSkuNameAZFWVNet', 'AzureFirewallSkuNameAZFWHub'
	Name AzureFirewallSkuName `json:"name,omitempty"`
	// Tier - Tier of an Azure Firewall. Possible values include: 'AzureFirewallSkuTierStandard', 'AzureFirewallSkuTierPremium'
	Tier AzureFirewallSkuTier `json:"tier,omitempty"`
}

// AzureFirewallsUpdateTagsFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type AzureFirewallsUpdateTagsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AzureFirewallsClient) (AzureFirewall, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AzureFirewallsUpdateTagsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AzureFirewallsUpdateTagsFuture.Result.
func (future *AzureFirewallsUpdateTagsFuture) result(client AzureFirewallsClient) (af AzureFirewall, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.AzureFirewallsUpdateTagsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		af.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.AzureFirewallsUpdateTagsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if af.Response.Response, err = future.GetResult(sender); err == nil && af.Response.Response.StatusCode != http.StatusNoContent {
		af, err = client.UpdateTagsResponder(af.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.AzureFirewallsUpdateTagsFuture", "Result", af.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AzureReachabilityReport azure reachability report details.
type AzureReachabilityReport struct {
	autorest.Response `json:"-"`
	// AggregationLevel - The aggregation level of Azure reachability report. Can be Country, State or City.
	AggregationLevel *string `json:"aggregationLevel,omitempty"`
	// ProviderLocation - Parameters that define a geographic location.
	ProviderLocation *AzureReachabilityReportLocation `json:"providerLocation,omitempty"`
	// ReachabilityReport - List of Azure reachability report items.
	ReachabilityReport *[]AzureReachabilityReportItem `json:"reachabilityReport,omitempty"`
}

// AzureReachabilityReportItem azure reachability report details for a given provider location.
type AzureReachabilityReportItem struct {
	// Provider - The Internet service provider.
	Provider *string `json:"provider,omitempty"`
	// AzureLocation - The Azure region.
	AzureLocation *string `json:"azureLocation,omitempty"`
	// Latencies - List of latency details for each of the time series.
	Latencies *[]AzureReachabilityReportLatencyInfo `json:"latencies,omitempty"`
}

// AzureReachabilityReportLatencyInfo details on latency for a time series.
type AzureReachabilityReportLatencyInfo struct {
	// TimeStamp - The time stamp.
	TimeStamp *date.Time `json:"timeStamp,omitempty"`
	// Score - The relative latency score between 1 and 100, higher values indicating a faster connection.
	Score *int32 `json:"score,omitempty"`
}

// AzureReachabilityReportLocation parameters that define a geographic location.
type AzureReachabilityReportLocation struct {
	// Country - The name of the country.
	Country *string `json:"country,omitempty"`
	// State - The name of the state.
	State *string `json:"state,omitempty"`
	// City - The name of the city or town.
	City *string `json:"city,omitempty"`
}

// AzureReachabilityReportParameters geographic and time constraints for Azure reachability report.
type AzureReachabilityReportParameters struct {
	// ProviderLocation - Parameters that define a geographic location.
	ProviderLocation *AzureReachabilityReportLocation `json:"providerLocation,omitempty"`
	// Providers - List of Internet service providers.
	Providers *[]string `json:"providers,omitempty"`
	// AzureLocations - Optional Azure regions to scope the query to.
	AzureLocations *[]string `json:"azureLocations,omitempty"`
	// StartTime - The start time for the Azure reachability report.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time for the Azure reachability report.
	EndTime *date.Time `json:"endTime,omitempty"`
}

// AzureWebCategory azure Web Category Resource.
type AzureWebCategory struct {
	autorest.Response `json:"-"`
	// AzureWebCategoryPropertiesFormat - Properties of the Azure Web Category.
	*AzureWebCategoryPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureWebCategory.
func (awc AzureWebCategory) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if awc.AzureWebCategoryPropertiesFormat != nil {
		objectMap["properties"] = awc.AzureWebCategoryPropertiesFormat
	}
	if awc.ID != nil {
		objectMap["id"] = awc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AzureWebCategory struct.
func (awc *AzureWebCategory) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var azureWebCategoryPropertiesFormat AzureWebCategoryPropertiesFormat
				err = json.Unmarshal(*v, &azureWebCategoryPropertiesFormat)
				if err != nil {
					return err
				}
				awc.AzureWebCategoryPropertiesFormat = &azureWebCategoryPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				awc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				awc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				awc.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				awc.Etag = &etag
			}
		}
	}

	return nil
}

// AzureWebCategoryListResult response for ListAzureWebCategories API service call.
type AzureWebCategoryListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Azure Web Categories for a given Subscription.
	Value *[]AzureWebCategory `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AzureWebCategoryListResultIterator provides access to a complete listing of AzureWebCategory values.
type AzureWebCategoryListResultIterator struct {
	i    int
	page AzureWebCategoryListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AzureWebCategoryListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AzureWebCategoryListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AzureWebCategoryListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AzureWebCategoryListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AzureWebCategoryListResultIterator) Response() AzureWebCategoryListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AzureWebCategoryListResultIterator) Value() AzureWebCategory {
	if !iter.page.NotDone() {
		return AzureWebCategory{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AzureWebCategoryListResultIterator type.
func NewAzureWebCategoryListResultIterator(page AzureWebCategoryListResultPage) AzureWebCategoryListResultIterator {
	return AzureWebCategoryListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (awclr AzureWebCategoryListResult) IsEmpty() bool {
	return awclr.Value == nil || len(*awclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (awclr AzureWebCategoryListResult) hasNextLink() bool {
	return awclr.NextLink != nil && len(*awclr.NextLink) != 0
}

// azureWebCategoryListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (awclr AzureWebCategoryListResult) azureWebCategoryListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !awclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(awclr.NextLink)))
}

// AzureWebCategoryListResultPage contains a page of AzureWebCategory values.
type AzureWebCategoryListResultPage struct {
	fn    func(context.Context, AzureWebCategoryListResult) (AzureWebCategoryListResult, error)
	awclr AzureWebCategoryListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AzureWebCategoryListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AzureWebCategoryListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.awclr)
		if err != nil {
			return err
		}
		page.awclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AzureWebCategoryListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AzureWebCategoryListResultPage) NotDone() bool {
	return !page.awclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AzureWebCategoryListResultPage) Response() AzureWebCategoryListResult {
	return page.awclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AzureWebCategoryListResultPage) Values() []AzureWebCategory {
	if page.awclr.IsEmpty() {
		return nil
	}
	return *page.awclr.Value
}

// Creates a new instance of the AzureWebCategoryListResultPage type.
func NewAzureWebCategoryListResultPage(cur AzureWebCategoryListResult, getNextPage func(context.Context, AzureWebCategoryListResult) (AzureWebCategoryListResult, error)) AzureWebCategoryListResultPage {
	return AzureWebCategoryListResultPage{
		fn:    getNextPage,
		awclr: cur,
	}
}

// AzureWebCategoryPropertiesFormat azure Web Category Properties.
type AzureWebCategoryPropertiesFormat struct {
	// Group - READ-ONLY; The name of the group that the category belongs to.
	Group *string `json:"group,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureWebCategoryPropertiesFormat.
func (awcpf AzureWebCategoryPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// BackendAddressPool pool of backend IP addresses.
type BackendAddressPool struct {
	autorest.Response `json:"-"`
	// BackendAddressPoolPropertiesFormat - Properties of load balancer backend address pool.
	*BackendAddressPoolPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the set of backend address pools used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for BackendAddressPool.
func (bap BackendAddressPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bap.BackendAddressPoolPropertiesFormat != nil {
		objectMap["properties"] = bap.BackendAddressPoolPropertiesFormat
	}
	if bap.Name != nil {
		objectMap["name"] = bap.Name
	}
	if bap.ID != nil {
		objectMap["id"] = bap.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BackendAddressPool struct.
func (bap *BackendAddressPool) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var backendAddressPoolPropertiesFormat BackendAddressPoolPropertiesFormat
				err = json.Unmarshal(*v, &backendAddressPoolPropertiesFormat)
				if err != nil {
					return err
				}
				bap.BackendAddressPoolPropertiesFormat = &backendAddressPoolPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bap.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				bap.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bap.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bap.ID = &ID
			}
		}
	}

	return nil
}

// BackendAddressPoolPropertiesFormat properties of the backend address pool.
type BackendAddressPoolPropertiesFormat struct {
	// Location - The location of the backend address pool.
	Location *string `json:"location,omitempty"`
	// LoadBalancerBackendAddresses - An array of backend addresses.
	LoadBalancerBackendAddresses *[]LoadBalancerBackendAddress `json:"loadBalancerBackendAddresses,omitempty"`
	// BackendIPConfigurations - READ-ONLY; An array of references to IP addresses defined in network interfaces.
	BackendIPConfigurations *[]InterfaceIPConfiguration `json:"backendIPConfigurations,omitempty"`
	// LoadBalancingRules - READ-ONLY; An array of references to load balancing rules that use this backend address pool.
	LoadBalancingRules *[]SubResource `json:"loadBalancingRules,omitempty"`
	// OutboundRule - READ-ONLY; A reference to an outbound rule that uses this backend address pool.
	OutboundRule *SubResource `json:"outboundRule,omitempty"`
	// OutboundRules - READ-ONLY; An array of references to outbound rules that use this backend address pool.
	OutboundRules *[]SubResource `json:"outboundRules,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the backend address pool resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for BackendAddressPoolPropertiesFormat.
func (bappf BackendAddressPoolPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bappf.Location != nil {
		objectMap["location"] = bappf.Location
	}
	if bappf.LoadBalancerBackendAddresses != nil {
		objectMap["loadBalancerBackendAddresses"] = bappf.LoadBalancerBackendAddresses
	}
	return json.Marshal(objectMap)
}

// BastionActiveSession the session detail for a target.
type BastionActiveSession struct {
	// SessionID - READ-ONLY; A unique id for the session.
	SessionID *string `json:"sessionId,omitempty"`
	// StartTime - READ-ONLY; The time when the session started.
	StartTime interface{} `json:"startTime,omitempty"`
	// TargetSubscriptionID - READ-ONLY; The subscription id for the target virtual machine.
	TargetSubscriptionID *string `json:"targetSubscriptionId,omitempty"`
	// ResourceType - READ-ONLY; The type of the resource.
	ResourceType *string `json:"resourceType,omitempty"`
	// TargetHostName - READ-ONLY; The host name of the target.
	TargetHostName *string `json:"targetHostName,omitempty"`
	// TargetResourceGroup - READ-ONLY; The resource group of the target.
	TargetResourceGroup *string `json:"targetResourceGroup,omitempty"`
	// UserName - READ-ONLY; The user name who is active on this session.
	UserName *string `json:"userName,omitempty"`
	// TargetIPAddress - READ-ONLY; The IP Address of the target.
	TargetIPAddress *string `json:"targetIpAddress,omitempty"`
	// Protocol - READ-ONLY; The protocol used to connect to the target. Possible values include: 'BastionConnectProtocolSSH', 'BastionConnectProtocolRDP'
	Protocol BastionConnectProtocol `json:"protocol,omitempty"`
	// TargetResourceID - READ-ONLY; The resource id of the target.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
	// SessionDurationInMins - READ-ONLY; Duration in mins the session has been active.
	SessionDurationInMins *float64 `json:"sessionDurationInMins,omitempty"`
}

// MarshalJSON is the custom marshaler for BastionActiveSession.
func (bas BastionActiveSession) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// BastionActiveSessionListResult response for GetActiveSessions.
type BastionActiveSessionListResult struct {
	autorest.Response `json:"-"`
	// Value - List of active sessions on the bastion.
	Value *[]BastionActiveSession `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// BastionActiveSessionListResultIterator provides access to a complete listing of BastionActiveSession
// values.
type BastionActiveSessionListResultIterator struct {
	i    int
	page BastionActiveSessionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BastionActiveSessionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BastionActiveSessionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BastionActiveSessionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BastionActiveSessionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BastionActiveSessionListResultIterator) Response() BastionActiveSessionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BastionActiveSessionListResultIterator) Value() BastionActiveSession {
	if !iter.page.NotDone() {
		return BastionActiveSession{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BastionActiveSessionListResultIterator type.
func NewBastionActiveSessionListResultIterator(page BastionActiveSessionListResultPage) BastionActiveSessionListResultIterator {
	return BastionActiveSessionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (baslr BastionActiveSessionListResult) IsEmpty() bool {
	return baslr.Value == nil || len(*baslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (baslr BastionActiveSessionListResult) hasNextLink() bool {
	return baslr.NextLink != nil && len(*baslr.NextLink) != 0
}

// bastionActiveSessionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (baslr BastionActiveSessionListResult) bastionActiveSessionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !baslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(baslr.NextLink)))
}

// BastionActiveSessionListResultPage contains a page of BastionActiveSession values.
type BastionActiveSessionListResultPage struct {
	fn    func(context.Context, BastionActiveSessionListResult) (BastionActiveSessionListResult, error)
	baslr BastionActiveSessionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BastionActiveSessionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BastionActiveSessionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.baslr)
		if err != nil {
			return err
		}
		page.baslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BastionActiveSessionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BastionActiveSessionListResultPage) NotDone() bool {
	return !page.baslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BastionActiveSessionListResultPage) Response() BastionActiveSessionListResult {
	return page.baslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BastionActiveSessionListResultPage) Values() []BastionActiveSession {
	if page.baslr.IsEmpty() {
		return nil
	}
	return *page.baslr.Value
}

// Creates a new instance of the BastionActiveSessionListResultPage type.
func NewBastionActiveSessionListResultPage(cur BastionActiveSessionListResult, getNextPage func(context.Context, BastionActiveSessionListResult) (BastionActiveSessionListResult, error)) BastionActiveSessionListResultPage {
	return BastionActiveSessionListResultPage{
		fn:    getNextPage,
		baslr: cur,
	}
}

// BastionHost bastion Host resource.
type BastionHost struct {
	autorest.Response `json:"-"`
	// BastionHostPropertiesFormat - Represents the bastion host resource.
	*BastionHostPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for BastionHost.
func (bh BastionHost) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bh.BastionHostPropertiesFormat != nil {
		objectMap["properties"] = bh.BastionHostPropertiesFormat
	}
	if bh.ID != nil {
		objectMap["id"] = bh.ID
	}
	if bh.Location != nil {
		objectMap["location"] = bh.Location
	}
	if bh.Tags != nil {
		objectMap["tags"] = bh.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BastionHost struct.
func (bh *BastionHost) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var bastionHostPropertiesFormat BastionHostPropertiesFormat
				err = json.Unmarshal(*v, &bastionHostPropertiesFormat)
				if err != nil {
					return err
				}
				bh.BastionHostPropertiesFormat = &bastionHostPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				bh.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bh.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bh.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bh.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				bh.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				bh.Tags = tags
			}
		}
	}

	return nil
}

// BastionHostIPConfiguration IP configuration of an Bastion Host.
type BastionHostIPConfiguration struct {
	// BastionHostIPConfigurationPropertiesFormat - Represents the ip configuration associated with the resource.
	*BastionHostIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Ip configuration type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for BastionHostIPConfiguration.
func (bhic BastionHostIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bhic.BastionHostIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = bhic.BastionHostIPConfigurationPropertiesFormat
	}
	if bhic.Name != nil {
		objectMap["name"] = bhic.Name
	}
	if bhic.ID != nil {
		objectMap["id"] = bhic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BastionHostIPConfiguration struct.
func (bhic *BastionHostIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var bastionHostIPConfigurationPropertiesFormat BastionHostIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &bastionHostIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				bhic.BastionHostIPConfigurationPropertiesFormat = &bastionHostIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bhic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				bhic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bhic.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bhic.ID = &ID
			}
		}
	}

	return nil
}

// BastionHostIPConfigurationPropertiesFormat properties of IP configuration of an Bastion Host.
type BastionHostIPConfigurationPropertiesFormat struct {
	// Subnet - Reference of the subnet resource.
	Subnet *SubResource `json:"subnet,omitempty"`
	// PublicIPAddress - Reference of the PublicIP resource.
	PublicIPAddress *SubResource `json:"publicIPAddress,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the bastion host IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PrivateIPAllocationMethod - Private IP allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
}

// MarshalJSON is the custom marshaler for BastionHostIPConfigurationPropertiesFormat.
func (bhicpf BastionHostIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bhicpf.Subnet != nil {
		objectMap["subnet"] = bhicpf.Subnet
	}
	if bhicpf.PublicIPAddress != nil {
		objectMap["publicIPAddress"] = bhicpf.PublicIPAddress
	}
	if bhicpf.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = bhicpf.PrivateIPAllocationMethod
	}
	return json.Marshal(objectMap)
}

// BastionHostListResult response for ListBastionHosts API service call.
type BastionHostListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Bastion Hosts in a resource group.
	Value *[]BastionHost `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// BastionHostListResultIterator provides access to a complete listing of BastionHost values.
type BastionHostListResultIterator struct {
	i    int
	page BastionHostListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BastionHostListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BastionHostListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BastionHostListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BastionHostListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BastionHostListResultIterator) Response() BastionHostListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BastionHostListResultIterator) Value() BastionHost {
	if !iter.page.NotDone() {
		return BastionHost{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BastionHostListResultIterator type.
func NewBastionHostListResultIterator(page BastionHostListResultPage) BastionHostListResultIterator {
	return BastionHostListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (bhlr BastionHostListResult) IsEmpty() bool {
	return bhlr.Value == nil || len(*bhlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (bhlr BastionHostListResult) hasNextLink() bool {
	return bhlr.NextLink != nil && len(*bhlr.NextLink) != 0
}

// bastionHostListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (bhlr BastionHostListResult) bastionHostListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !bhlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(bhlr.NextLink)))
}

// BastionHostListResultPage contains a page of BastionHost values.
type BastionHostListResultPage struct {
	fn   func(context.Context, BastionHostListResult) (BastionHostListResult, error)
	bhlr BastionHostListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BastionHostListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BastionHostListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.bhlr)
		if err != nil {
			return err
		}
		page.bhlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BastionHostListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BastionHostListResultPage) NotDone() bool {
	return !page.bhlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BastionHostListResultPage) Response() BastionHostListResult {
	return page.bhlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BastionHostListResultPage) Values() []BastionHost {
	if page.bhlr.IsEmpty() {
		return nil
	}
	return *page.bhlr.Value
}

// Creates a new instance of the BastionHostListResultPage type.
func NewBastionHostListResultPage(cur BastionHostListResult, getNextPage func(context.Context, BastionHostListResult) (BastionHostListResult, error)) BastionHostListResultPage {
	return BastionHostListResultPage{
		fn:   getNextPage,
		bhlr: cur,
	}
}

// BastionHostPropertiesFormat properties of the Bastion Host.
type BastionHostPropertiesFormat struct {
	// IPConfigurations - IP configuration of the Bastion Host resource.
	IPConfigurations *[]BastionHostIPConfiguration `json:"ipConfigurations,omitempty"`
	// DNSName - FQDN for the endpoint on which bastion host is accessible.
	DNSName *string `json:"dnsName,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the bastion host resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for BastionHostPropertiesFormat.
func (bhpf BastionHostPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bhpf.IPConfigurations != nil {
		objectMap["ipConfigurations"] = bhpf.IPConfigurations
	}
	if bhpf.DNSName != nil {
		objectMap["dnsName"] = bhpf.DNSName
	}
	return json.Marshal(objectMap)
}

// BastionHostsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type BastionHostsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BastionHostsClient) (BastionHost, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BastionHostsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BastionHostsCreateOrUpdateFuture.Result.
func (future *BastionHostsCreateOrUpdateFuture) result(client BastionHostsClient) (bh BastionHost, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.BastionHostsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bh.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.BastionHostsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bh.Response.Response, err = future.GetResult(sender); err == nil && bh.Response.Response.StatusCode != http.StatusNoContent {
		bh, err = client.CreateOrUpdateResponder(bh.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.BastionHostsCreateOrUpdateFuture", "Result", bh.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BastionHostsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BastionHostsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BastionHostsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BastionHostsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BastionHostsDeleteFuture.Result.
func (future *BastionHostsDeleteFuture) result(client BastionHostsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.BastionHostsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.BastionHostsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// BastionSessionDeleteResult response for DisconnectActiveSessions.
type BastionSessionDeleteResult struct {
	autorest.Response `json:"-"`
	// Value - List of sessions with their corresponding state.
	Value *[]BastionSessionState `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// BastionSessionDeleteResultIterator provides access to a complete listing of BastionSessionState values.
type BastionSessionDeleteResultIterator struct {
	i    int
	page BastionSessionDeleteResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BastionSessionDeleteResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BastionSessionDeleteResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BastionSessionDeleteResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BastionSessionDeleteResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BastionSessionDeleteResultIterator) Response() BastionSessionDeleteResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BastionSessionDeleteResultIterator) Value() BastionSessionState {
	if !iter.page.NotDone() {
		return BastionSessionState{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BastionSessionDeleteResultIterator type.
func NewBastionSessionDeleteResultIterator(page BastionSessionDeleteResultPage) BastionSessionDeleteResultIterator {
	return BastionSessionDeleteResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (bsdr BastionSessionDeleteResult) IsEmpty() bool {
	return bsdr.Value == nil || len(*bsdr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (bsdr BastionSessionDeleteResult) hasNextLink() bool {
	return bsdr.NextLink != nil && len(*bsdr.NextLink) != 0
}

// bastionSessionDeleteResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (bsdr BastionSessionDeleteResult) bastionSessionDeleteResultPreparer(ctx context.Context) (*http.Request, error) {
	if !bsdr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(bsdr.NextLink)))
}

// BastionSessionDeleteResultPage contains a page of BastionSessionState values.
type BastionSessionDeleteResultPage struct {
	fn   func(context.Context, BastionSessionDeleteResult) (BastionSessionDeleteResult, error)
	bsdr BastionSessionDeleteResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BastionSessionDeleteResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BastionSessionDeleteResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.bsdr)
		if err != nil {
			return err
		}
		page.bsdr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BastionSessionDeleteResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BastionSessionDeleteResultPage) NotDone() bool {
	return !page.bsdr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BastionSessionDeleteResultPage) Response() BastionSessionDeleteResult {
	return page.bsdr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BastionSessionDeleteResultPage) Values() []BastionSessionState {
	if page.bsdr.IsEmpty() {
		return nil
	}
	return *page.bsdr.Value
}

// Creates a new instance of the BastionSessionDeleteResultPage type.
func NewBastionSessionDeleteResultPage(cur BastionSessionDeleteResult, getNextPage func(context.Context, BastionSessionDeleteResult) (BastionSessionDeleteResult, error)) BastionSessionDeleteResultPage {
	return BastionSessionDeleteResultPage{
		fn:   getNextPage,
		bsdr: cur,
	}
}

// BastionSessionState the session state detail for a target.
type BastionSessionState struct {
	// SessionID - READ-ONLY; A unique id for the session.
	SessionID *string `json:"sessionId,omitempty"`
	// Message - READ-ONLY; Used for extra information.
	Message *string `json:"message,omitempty"`
	// State - READ-ONLY; The state of the session. Disconnected/Failed/NotFound.
	State *string `json:"state,omitempty"`
}

// MarshalJSON is the custom marshaler for BastionSessionState.
func (bss BastionSessionState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// BastionShareableLink bastion Shareable Link.
type BastionShareableLink struct {
	// VM - Reference of the virtual machine resource.
	VM *VM `json:"vm,omitempty"`
	// Bsl - READ-ONLY; The unique Bastion Shareable Link to the virtual machine.
	Bsl *string `json:"bsl,omitempty"`
	// CreatedAt - READ-ONLY; The time when the link was created.
	CreatedAt *string `json:"createdAt,omitempty"`
	// Message - READ-ONLY; Optional field indicating the warning or error message related to the vm in case of partial failure.
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for BastionShareableLink.
func (bsl BastionShareableLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bsl.VM != nil {
		objectMap["vm"] = bsl.VM
	}
	return json.Marshal(objectMap)
}

// BastionShareableLinkListRequest post request for all the Bastion Shareable Link endpoints.
type BastionShareableLinkListRequest struct {
	// Vms - List of VM references.
	Vms *[]BastionShareableLink `json:"vms,omitempty"`
}

// BastionShareableLinkListResult response for all the Bastion Shareable Link endpoints.
type BastionShareableLinkListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Bastion Shareable Links for the request.
	Value *[]BastionShareableLink `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// BastionShareableLinkListResultIterator provides access to a complete listing of BastionShareableLink
// values.
type BastionShareableLinkListResultIterator struct {
	i    int
	page BastionShareableLinkListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BastionShareableLinkListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BastionShareableLinkListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BastionShareableLinkListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BastionShareableLinkListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BastionShareableLinkListResultIterator) Response() BastionShareableLinkListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BastionShareableLinkListResultIterator) Value() BastionShareableLink {
	if !iter.page.NotDone() {
		return BastionShareableLink{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BastionShareableLinkListResultIterator type.
func NewBastionShareableLinkListResultIterator(page BastionShareableLinkListResultPage) BastionShareableLinkListResultIterator {
	return BastionShareableLinkListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (bsllr BastionShareableLinkListResult) IsEmpty() bool {
	return bsllr.Value == nil || len(*bsllr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (bsllr BastionShareableLinkListResult) hasNextLink() bool {
	return bsllr.NextLink != nil && len(*bsllr.NextLink) != 0
}

// bastionShareableLinkListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (bsllr BastionShareableLinkListResult) bastionShareableLinkListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !bsllr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(bsllr.NextLink)))
}

// BastionShareableLinkListResultPage contains a page of BastionShareableLink values.
type BastionShareableLinkListResultPage struct {
	fn    func(context.Context, BastionShareableLinkListResult) (BastionShareableLinkListResult, error)
	bsllr BastionShareableLinkListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BastionShareableLinkListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BastionShareableLinkListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.bsllr)
		if err != nil {
			return err
		}
		page.bsllr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BastionShareableLinkListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BastionShareableLinkListResultPage) NotDone() bool {
	return !page.bsllr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BastionShareableLinkListResultPage) Response() BastionShareableLinkListResult {
	return page.bsllr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BastionShareableLinkListResultPage) Values() []BastionShareableLink {
	if page.bsllr.IsEmpty() {
		return nil
	}
	return *page.bsllr.Value
}

// Creates a new instance of the BastionShareableLinkListResultPage type.
func NewBastionShareableLinkListResultPage(cur BastionShareableLinkListResult, getNextPage func(context.Context, BastionShareableLinkListResult) (BastionShareableLinkListResult, error)) BastionShareableLinkListResultPage {
	return BastionShareableLinkListResultPage{
		fn:    getNextPage,
		bsllr: cur,
	}
}

// BGPCommunity contains bgp community information offered in Service Community resources.
type BGPCommunity struct {
	// ServiceSupportedRegion - The region which the service support. e.g. For O365, region is Global.
	ServiceSupportedRegion *string `json:"serviceSupportedRegion,omitempty"`
	// CommunityName - The name of the bgp community. e.g. Skype.
	CommunityName *string `json:"communityName,omitempty"`
	// CommunityValue - The value of the bgp community. For more information: https://docs.microsoft.com/en-us/azure/expressroute/expressroute-routing.
	CommunityValue *string `json:"communityValue,omitempty"`
	// CommunityPrefixes - The prefixes that the bgp community contains.
	CommunityPrefixes *[]string `json:"communityPrefixes,omitempty"`
	// IsAuthorizedToUse - Customer is authorized to use bgp community or not.
	IsAuthorizedToUse *bool `json:"isAuthorizedToUse,omitempty"`
	// ServiceGroup - The service group of the bgp community contains.
	ServiceGroup *string `json:"serviceGroup,omitempty"`
}

// BgpConnection virtual Appliance Site resource.
type BgpConnection struct {
	autorest.Response `json:"-"`
	// BgpConnectionProperties - The properties of the Bgp connections.
	*BgpConnectionProperties `json:"properties,omitempty"`
	// Name - Name of the connection.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Connection type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for BgpConnection.
func (bc BgpConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bc.BgpConnectionProperties != nil {
		objectMap["properties"] = bc.BgpConnectionProperties
	}
	if bc.Name != nil {
		objectMap["name"] = bc.Name
	}
	if bc.ID != nil {
		objectMap["id"] = bc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BgpConnection struct.
func (bc *BgpConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var bgpConnectionProperties BgpConnectionProperties
				err = json.Unmarshal(*v, &bgpConnectionProperties)
				if err != nil {
					return err
				}
				bc.BgpConnectionProperties = &bgpConnectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				bc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bc.ID = &ID
			}
		}
	}

	return nil
}

// BgpConnectionProperties properties of the bgp connection.
type BgpConnectionProperties struct {
	// PeerAsn - Peer ASN.
	PeerAsn *int64 `json:"peerAsn,omitempty"`
	// PeerIP - Peer IP.
	PeerIP *string `json:"peerIp,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ConnectionState - READ-ONLY; The current state of the VirtualHub to Peer. Possible values include: 'HubBgpConnectionStatusUnknown', 'HubBgpConnectionStatusConnecting', 'HubBgpConnectionStatusConnected', 'HubBgpConnectionStatusNotConnected'
	ConnectionState HubBgpConnectionStatus `json:"connectionState,omitempty"`
}

// MarshalJSON is the custom marshaler for BgpConnectionProperties.
func (bcp BgpConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bcp.PeerAsn != nil {
		objectMap["peerAsn"] = bcp.PeerAsn
	}
	if bcp.PeerIP != nil {
		objectMap["peerIp"] = bcp.PeerIP
	}
	return json.Marshal(objectMap)
}

// BgpPeerStatus BGP peer status details.
type BgpPeerStatus struct {
	// LocalAddress - READ-ONLY; The virtual network gateway's local address.
	LocalAddress *string `json:"localAddress,omitempty"`
	// Neighbor - READ-ONLY; The remote BGP peer.
	Neighbor *string `json:"neighbor,omitempty"`
	// Asn - READ-ONLY; The autonomous system number of the remote BGP peer.
	Asn *int64 `json:"asn,omitempty"`
	// State - READ-ONLY; The BGP peer state. Possible values include: 'BgpPeerStateUnknown', 'BgpPeerStateStopped', 'BgpPeerStateIdle', 'BgpPeerStateConnecting', 'BgpPeerStateConnected'
	State BgpPeerState `json:"state,omitempty"`
	// ConnectedDuration - READ-ONLY; For how long the peering has been up.
	ConnectedDuration *string `json:"connectedDuration,omitempty"`
	// RoutesReceived - READ-ONLY; The number of routes learned from this peer.
	RoutesReceived *int64 `json:"routesReceived,omitempty"`
	// MessagesSent - READ-ONLY; The number of BGP messages sent.
	MessagesSent *int64 `json:"messagesSent,omitempty"`
	// MessagesReceived - READ-ONLY; The number of BGP messages received.
	MessagesReceived *int64 `json:"messagesReceived,omitempty"`
}

// MarshalJSON is the custom marshaler for BgpPeerStatus.
func (bps BgpPeerStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// BgpPeerStatusListResult response for list BGP peer status API service call.
type BgpPeerStatusListResult struct {
	autorest.Response `json:"-"`
	// Value - List of BGP peers.
	Value *[]BgpPeerStatus `json:"value,omitempty"`
}

// BgpServiceCommunity service Community Properties.
type BgpServiceCommunity struct {
	// BgpServiceCommunityPropertiesFormat - Properties of the BGP service community.
	*BgpServiceCommunityPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for BgpServiceCommunity.
func (bsc BgpServiceCommunity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bsc.BgpServiceCommunityPropertiesFormat != nil {
		objectMap["properties"] = bsc.BgpServiceCommunityPropertiesFormat
	}
	if bsc.ID != nil {
		objectMap["id"] = bsc.ID
	}
	if bsc.Location != nil {
		objectMap["location"] = bsc.Location
	}
	if bsc.Tags != nil {
		objectMap["tags"] = bsc.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BgpServiceCommunity struct.
func (bsc *BgpServiceCommunity) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var bgpServiceCommunityPropertiesFormat BgpServiceCommunityPropertiesFormat
				err = json.Unmarshal(*v, &bgpServiceCommunityPropertiesFormat)
				if err != nil {
					return err
				}
				bsc.BgpServiceCommunityPropertiesFormat = &bgpServiceCommunityPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bsc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bsc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bsc.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				bsc.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				bsc.Tags = tags
			}
		}
	}

	return nil
}

// BgpServiceCommunityListResult response for the ListServiceCommunity API service call.
type BgpServiceCommunityListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of service community resources.
	Value *[]BgpServiceCommunity `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// BgpServiceCommunityListResultIterator provides access to a complete listing of BgpServiceCommunity
// values.
type BgpServiceCommunityListResultIterator struct {
	i    int
	page BgpServiceCommunityListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BgpServiceCommunityListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BgpServiceCommunityListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BgpServiceCommunityListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BgpServiceCommunityListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BgpServiceCommunityListResultIterator) Response() BgpServiceCommunityListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BgpServiceCommunityListResultIterator) Value() BgpServiceCommunity {
	if !iter.page.NotDone() {
		return BgpServiceCommunity{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BgpServiceCommunityListResultIterator type.
func NewBgpServiceCommunityListResultIterator(page BgpServiceCommunityListResultPage) BgpServiceCommunityListResultIterator {
	return BgpServiceCommunityListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (bsclr BgpServiceCommunityListResult) IsEmpty() bool {
	return bsclr.Value == nil || len(*bsclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (bsclr BgpServiceCommunityListResult) hasNextLink() bool {
	return bsclr.NextLink != nil && len(*bsclr.NextLink) != 0
}

// bgpServiceCommunityListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (bsclr BgpServiceCommunityListResult) bgpServiceCommunityListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !bsclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(bsclr.NextLink)))
}

// BgpServiceCommunityListResultPage contains a page of BgpServiceCommunity values.
type BgpServiceCommunityListResultPage struct {
	fn    func(context.Context, BgpServiceCommunityListResult) (BgpServiceCommunityListResult, error)
	bsclr BgpServiceCommunityListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BgpServiceCommunityListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BgpServiceCommunityListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.bsclr)
		if err != nil {
			return err
		}
		page.bsclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BgpServiceCommunityListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BgpServiceCommunityListResultPage) NotDone() bool {
	return !page.bsclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BgpServiceCommunityListResultPage) Response() BgpServiceCommunityListResult {
	return page.bsclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BgpServiceCommunityListResultPage) Values() []BgpServiceCommunity {
	if page.bsclr.IsEmpty() {
		return nil
	}
	return *page.bsclr.Value
}

// Creates a new instance of the BgpServiceCommunityListResultPage type.
func NewBgpServiceCommunityListResultPage(cur BgpServiceCommunityListResult, getNextPage func(context.Context, BgpServiceCommunityListResult) (BgpServiceCommunityListResult, error)) BgpServiceCommunityListResultPage {
	return BgpServiceCommunityListResultPage{
		fn:    getNextPage,
		bsclr: cur,
	}
}

// BgpServiceCommunityPropertiesFormat properties of Service Community.
type BgpServiceCommunityPropertiesFormat struct {
	// ServiceName - The name of the bgp community. e.g. Skype.
	ServiceName *string `json:"serviceName,omitempty"`
	// BgpCommunities - A list of bgp communities.
	BgpCommunities *[]BGPCommunity `json:"bgpCommunities,omitempty"`
}

// BgpSettings BGP settings details.
type BgpSettings struct {
	// Asn - The BGP speaker's ASN.
	Asn *int64 `json:"asn,omitempty"`
	// BgpPeeringAddress - The BGP peering address and BGP identifier of this BGP speaker.
	BgpPeeringAddress *string `json:"bgpPeeringAddress,omitempty"`
	// PeerWeight - The weight added to routes learned from this BGP speaker.
	PeerWeight *int32 `json:"peerWeight,omitempty"`
	// BgpPeeringAddresses - BGP peering address with IP configuration ID for virtual network gateway.
	BgpPeeringAddresses *[]IPConfigurationBgpPeeringAddress `json:"bgpPeeringAddresses,omitempty"`
}

// BreakOutCategoryPolicies network Virtual Appliance Sku Properties.
type BreakOutCategoryPolicies struct {
	// Allow - Flag to control breakout of o365 allow category.
	Allow *bool `json:"allow,omitempty"`
	// Optimize - Flag to control breakout of o365 optimize category.
	Optimize *bool `json:"optimize,omitempty"`
	// Default - Flag to control breakout of o365 default category.
	Default *bool `json:"default,omitempty"`
}

// CheckPrivateLinkServiceVisibilityRequest request body of the CheckPrivateLinkServiceVisibility API
// service call.
type CheckPrivateLinkServiceVisibilityRequest struct {
	// PrivateLinkServiceAlias - The alias of the private link service.
	PrivateLinkServiceAlias *string `json:"privateLinkServiceAlias,omitempty"`
}

// CloudError an error response from the service.
type CloudError struct {
	// Error - Cloud error body.
	Error *CloudErrorBody `json:"error,omitempty"`
}

// CloudErrorBody an error response from the service.
type CloudErrorBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
	// Details - A list of additional details about the error.
	Details *[]CloudErrorBody `json:"details,omitempty"`
}

// ConfigurationDiagnosticParameters parameters to get network configuration diagnostic.
type ConfigurationDiagnosticParameters struct {
	// TargetResourceID - The ID of the target resource to perform network configuration diagnostic. Valid options are VM, NetworkInterface, VMSS/NetworkInterface and Application Gateway.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
	// VerbosityLevel - Verbosity level. Possible values include: 'VerbosityLevelNormal', 'VerbosityLevelMinimum', 'VerbosityLevelFull'
	VerbosityLevel VerbosityLevel `json:"verbosityLevel,omitempty"`
	// Profiles - List of network configuration diagnostic profiles.
	Profiles *[]ConfigurationDiagnosticProfile `json:"profiles,omitempty"`
}

// ConfigurationDiagnosticProfile parameters to compare with network configuration.
type ConfigurationDiagnosticProfile struct {
	// Direction - The direction of the traffic. Possible values include: 'DirectionInbound', 'DirectionOutbound'
	Direction Direction `json:"direction,omitempty"`
	// Protocol - Protocol to be verified on. Accepted values are '*', TCP, UDP.
	Protocol *string `json:"protocol,omitempty"`
	// Source - Traffic source. Accepted values are '*', IP Address/CIDR, Service Tag.
	Source *string `json:"source,omitempty"`
	// Destination - Traffic destination. Accepted values are: '*', IP Address/CIDR, Service Tag.
	Destination *string `json:"destination,omitempty"`
	// DestinationPort - Traffic destination port. Accepted values are '*' and a single port in the range (0 - 65535).
	DestinationPort *string `json:"destinationPort,omitempty"`
}

// ConfigurationDiagnosticResponse results of network configuration diagnostic on the target resource.
type ConfigurationDiagnosticResponse struct {
	autorest.Response `json:"-"`
	// Results - READ-ONLY; List of network configuration diagnostic results.
	Results *[]ConfigurationDiagnosticResult `json:"results,omitempty"`
}

// MarshalJSON is the custom marshaler for ConfigurationDiagnosticResponse.
func (cdr ConfigurationDiagnosticResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ConfigurationDiagnosticResult network configuration diagnostic result corresponded to provided traffic
// query.
type ConfigurationDiagnosticResult struct {
	// Profile - Network configuration diagnostic profile.
	Profile *ConfigurationDiagnosticProfile `json:"profile,omitempty"`
	// NetworkSecurityGroupResult - Network security group result.
	NetworkSecurityGroupResult *SecurityGroupResult `json:"networkSecurityGroupResult,omitempty"`
}

// ConnectionMonitor parameters that define the operation to create a connection monitor.
type ConnectionMonitor struct {
	// Location - Connection monitor location.
	Location *string `json:"location,omitempty"`
	// Tags - Connection monitor tags.
	Tags map[string]*string `json:"tags"`
	// ConnectionMonitorParameters - Properties of the connection monitor.
	*ConnectionMonitorParameters `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectionMonitor.
func (cm ConnectionMonitor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cm.Location != nil {
		objectMap["location"] = cm.Location
	}
	if cm.Tags != nil {
		objectMap["tags"] = cm.Tags
	}
	if cm.ConnectionMonitorParameters != nil {
		objectMap["properties"] = cm.ConnectionMonitorParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ConnectionMonitor struct.
func (cm *ConnectionMonitor) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				cm.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cm.Tags = tags
			}
		case "properties":
			if v != nil {
				var connectionMonitorParameters ConnectionMonitorParameters
				err = json.Unmarshal(*v, &connectionMonitorParameters)
				if err != nil {
					return err
				}
				cm.ConnectionMonitorParameters = &connectionMonitorParameters
			}
		}
	}

	return nil
}

// ConnectionMonitorDestination describes the destination of connection monitor.
type ConnectionMonitorDestination struct {
	// ResourceID - The ID of the resource used as the destination by connection monitor.
	ResourceID *string `json:"resourceId,omitempty"`
	// Address - Address of the connection monitor destination (IP or domain name).
	Address *string `json:"address,omitempty"`
	// Port - The destination port used by connection monitor.
	Port *int32 `json:"port,omitempty"`
}

// ConnectionMonitorEndpoint describes the connection monitor endpoint.
type ConnectionMonitorEndpoint struct {
	// Name - The name of the connection monitor endpoint.
	Name *string `json:"name,omitempty"`
	// Type - The endpoint type. Possible values include: 'EndpointTypeAzureVM', 'EndpointTypeAzureVNet', 'EndpointTypeAzureSubnet', 'EndpointTypeExternalAddress', 'EndpointTypeMMAWorkspaceMachine', 'EndpointTypeMMAWorkspaceNetwork'
	Type EndpointType `json:"type,omitempty"`
	// ResourceID - Resource ID of the connection monitor endpoint.
	ResourceID *string `json:"resourceId,omitempty"`
	// Address - Address of the connection monitor endpoint (IP or domain name).
	Address *string `json:"address,omitempty"`
	// Filter - Filter for sub-items within the endpoint.
	Filter *ConnectionMonitorEndpointFilter `json:"filter,omitempty"`
	// Scope - Endpoint scope.
	Scope *ConnectionMonitorEndpointScope `json:"scope,omitempty"`
	// CoverageLevel - Test coverage for the endpoint. Possible values include: 'CoverageLevelDefault', 'CoverageLevelLow', 'CoverageLevelBelowAverage', 'CoverageLevelAverage', 'CoverageLevelAboveAverage', 'CoverageLevelFull'
	CoverageLevel CoverageLevel `json:"coverageLevel,omitempty"`
}

// ConnectionMonitorEndpointFilter describes the connection monitor endpoint filter.
type ConnectionMonitorEndpointFilter struct {
	// Type - The behavior of the endpoint filter. Currently only 'Include' is supported. Possible values include: 'ConnectionMonitorEndpointFilterTypeInclude'
	Type ConnectionMonitorEndpointFilterType `json:"type,omitempty"`
	// Items - List of items in the filter.
	Items *[]ConnectionMonitorEndpointFilterItem `json:"items,omitempty"`
}

// ConnectionMonitorEndpointFilterItem describes the connection monitor endpoint filter item.
type ConnectionMonitorEndpointFilterItem struct {
	// Type - The type of item included in the filter. Currently only 'AgentAddress' is supported. Possible values include: 'ConnectionMonitorEndpointFilterItemTypeAgentAddress'
	Type ConnectionMonitorEndpointFilterItemType `json:"type,omitempty"`
	// Address - The address of the filter item.
	Address *string `json:"address,omitempty"`
}

// ConnectionMonitorEndpointScope describes the connection monitor endpoint scope.
type ConnectionMonitorEndpointScope struct {
	// Include - List of items which needs to be included to the endpoint scope.
	Include *[]ConnectionMonitorEndpointScopeItem `json:"include,omitempty"`
	// Exclude - List of items which needs to be excluded from the endpoint scope.
	Exclude *[]ConnectionMonitorEndpointScopeItem `json:"exclude,omitempty"`
}

// ConnectionMonitorEndpointScopeItem describes the connection monitor endpoint scope item.
type ConnectionMonitorEndpointScopeItem struct {
	// Address - The address of the endpoint item. Supported types are IPv4/IPv6 subnet mask or IPv4/IPv6 IP address.
	Address *string `json:"address,omitempty"`
}

// ConnectionMonitorHTTPConfiguration describes the HTTP configuration.
type ConnectionMonitorHTTPConfiguration struct {
	// Port - The port to connect to.
	Port *int32 `json:"port,omitempty"`
	// Method - The HTTP method to use. Possible values include: 'HTTPConfigurationMethodGet', 'HTTPConfigurationMethodPost'
	Method HTTPConfigurationMethod `json:"method,omitempty"`
	// Path - The path component of the URI. For instance, "/dir1/dir2".
	Path *string `json:"path,omitempty"`
	// RequestHeaders - The HTTP headers to transmit with the request.
	RequestHeaders *[]HTTPHeader `json:"requestHeaders,omitempty"`
	// ValidStatusCodeRanges - HTTP status codes to consider successful. For instance, "2xx,301-304,418".
	ValidStatusCodeRanges *[]string `json:"validStatusCodeRanges,omitempty"`
	// PreferHTTPS - Value indicating whether HTTPS is preferred over HTTP in cases where the choice is not explicit.
	PreferHTTPS *bool `json:"preferHTTPS,omitempty"`
}

// ConnectionMonitorIcmpConfiguration describes the ICMP configuration.
type ConnectionMonitorIcmpConfiguration struct {
	// DisableTraceRoute - Value indicating whether path evaluation with trace route should be disabled.
	DisableTraceRoute *bool `json:"disableTraceRoute,omitempty"`
}

// ConnectionMonitorListResult list of connection monitors.
type ConnectionMonitorListResult struct {
	autorest.Response `json:"-"`
	// Value - Information about connection monitors.
	Value *[]ConnectionMonitorResult `json:"value,omitempty"`
}

// ConnectionMonitorOutput describes a connection monitor output destination.
type ConnectionMonitorOutput struct {
	// Type - Connection monitor output destination type. Currently, only "Workspace" is supported. Possible values include: 'OutputTypeWorkspace'
	Type OutputType `json:"type,omitempty"`
	// WorkspaceSettings - Describes the settings for producing output into a log analytics workspace.
	WorkspaceSettings *ConnectionMonitorWorkspaceSettings `json:"workspaceSettings,omitempty"`
}

// ConnectionMonitorParameters parameters that define the operation to create a connection monitor.
type ConnectionMonitorParameters struct {
	// Source - Describes the source of connection monitor.
	Source *ConnectionMonitorSource `json:"source,omitempty"`
	// Destination - Describes the destination of connection monitor.
	Destination *ConnectionMonitorDestination `json:"destination,omitempty"`
	// AutoStart - Determines if the connection monitor will start automatically once created.
	AutoStart *bool `json:"autoStart,omitempty"`
	// MonitoringIntervalInSeconds - Monitoring interval in seconds.
	MonitoringIntervalInSeconds *int32 `json:"monitoringIntervalInSeconds,omitempty"`
	// Endpoints - List of connection monitor endpoints.
	Endpoints *[]ConnectionMonitorEndpoint `json:"endpoints,omitempty"`
	// TestConfigurations - List of connection monitor test configurations.
	TestConfigurations *[]ConnectionMonitorTestConfiguration `json:"testConfigurations,omitempty"`
	// TestGroups - List of connection monitor test groups.
	TestGroups *[]ConnectionMonitorTestGroup `json:"testGroups,omitempty"`
	// Outputs - List of connection monitor outputs.
	Outputs *[]ConnectionMonitorOutput `json:"outputs,omitempty"`
	// Notes - Optional notes to be associated with the connection monitor.
	Notes *string `json:"notes,omitempty"`
}

// ConnectionMonitorQueryResult list of connection states snapshots.
type ConnectionMonitorQueryResult struct {
	autorest.Response `json:"-"`
	// SourceStatus - Status of connection monitor source. Possible values include: 'ConnectionMonitorSourceStatusUnknown', 'ConnectionMonitorSourceStatusActive', 'ConnectionMonitorSourceStatusInactive'
	SourceStatus ConnectionMonitorSourceStatus `json:"sourceStatus,omitempty"`
	// States - Information about connection states.
	States *[]ConnectionStateSnapshot `json:"states,omitempty"`
}

// ConnectionMonitorResult information about the connection monitor.
type ConnectionMonitorResult struct {
	autorest.Response `json:"-"`
	// Name - READ-ONLY; Name of the connection monitor.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; ID of the connection monitor.
	ID *string `json:"id,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Connection monitor type.
	Type *string `json:"type,omitempty"`
	// Location - Connection monitor location.
	Location *string `json:"location,omitempty"`
	// Tags - Connection monitor tags.
	Tags map[string]*string `json:"tags"`
	// ConnectionMonitorResultProperties - Properties of the connection monitor result.
	*ConnectionMonitorResultProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectionMonitorResult.
func (cmr ConnectionMonitorResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cmr.Location != nil {
		objectMap["location"] = cmr.Location
	}
	if cmr.Tags != nil {
		objectMap["tags"] = cmr.Tags
	}
	if cmr.ConnectionMonitorResultProperties != nil {
		objectMap["properties"] = cmr.ConnectionMonitorResultProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ConnectionMonitorResult struct.
func (cmr *ConnectionMonitorResult) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cmr.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cmr.ID = &ID
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				cmr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cmr.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				cmr.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cmr.Tags = tags
			}
		case "properties":
			if v != nil {
				var connectionMonitorResultProperties ConnectionMonitorResultProperties
				err = json.Unmarshal(*v, &connectionMonitorResultProperties)
				if err != nil {
					return err
				}
				cmr.ConnectionMonitorResultProperties = &connectionMonitorResultProperties
			}
		}
	}

	return nil
}

// ConnectionMonitorResultProperties describes the properties of a connection monitor.
type ConnectionMonitorResultProperties struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the connection monitor. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// StartTime - READ-ONLY; The date and time when the connection monitor was started.
	StartTime *date.Time `json:"startTime,omitempty"`
	// MonitoringStatus - READ-ONLY; The monitoring status of the connection monitor.
	MonitoringStatus *string `json:"monitoringStatus,omitempty"`
	// ConnectionMonitorType - READ-ONLY; Type of connection monitor. Possible values include: 'ConnectionMonitorTypeMultiEndpoint', 'ConnectionMonitorTypeSingleSourceDestination'
	ConnectionMonitorType ConnectionMonitorType `json:"connectionMonitorType,omitempty"`
	// Source - Describes the source of connection monitor.
	Source *ConnectionMonitorSource `json:"source,omitempty"`
	// Destination - Describes the destination of connection monitor.
	Destination *ConnectionMonitorDestination `json:"destination,omitempty"`
	// AutoStart - Determines if the connection monitor will start automatically once created.
	AutoStart *bool `json:"autoStart,omitempty"`
	// MonitoringIntervalInSeconds - Monitoring interval in seconds.
	MonitoringIntervalInSeconds *int32 `json:"monitoringIntervalInSeconds,omitempty"`
	// Endpoints - List of connection monitor endpoints.
	Endpoints *[]ConnectionMonitorEndpoint `json:"endpoints,omitempty"`
	// TestConfigurations - List of connection monitor test configurations.
	TestConfigurations *[]ConnectionMonitorTestConfiguration `json:"testConfigurations,omitempty"`
	// TestGroups - List of connection monitor test groups.
	TestGroups *[]ConnectionMonitorTestGroup `json:"testGroups,omitempty"`
	// Outputs - List of connection monitor outputs.
	Outputs *[]ConnectionMonitorOutput `json:"outputs,omitempty"`
	// Notes - Optional notes to be associated with the connection monitor.
	Notes *string `json:"notes,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectionMonitorResultProperties.
func (cmrp ConnectionMonitorResultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cmrp.Source != nil {
		objectMap["source"] = cmrp.Source
	}
	if cmrp.Destination != nil {
		objectMap["destination"] = cmrp.Destination
	}
	if cmrp.AutoStart != nil {
		objectMap["autoStart"] = cmrp.AutoStart
	}
	if cmrp.MonitoringIntervalInSeconds != nil {
		objectMap["monitoringIntervalInSeconds"] = cmrp.MonitoringIntervalInSeconds
	}
	if cmrp.Endpoints != nil {
		objectMap["endpoints"] = cmrp.Endpoints
	}
	if cmrp.TestConfigurations != nil {
		objectMap["testConfigurations"] = cmrp.TestConfigurations
	}
	if cmrp.TestGroups != nil {
		objectMap["testGroups"] = cmrp.TestGroups
	}
	if cmrp.Outputs != nil {
		objectMap["outputs"] = cmrp.Outputs
	}
	if cmrp.Notes != nil {
		objectMap["notes"] = cmrp.Notes
	}
	return json.Marshal(objectMap)
}

// ConnectionMonitorsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ConnectionMonitorsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectionMonitorsClient) (ConnectionMonitorResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectionMonitorsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectionMonitorsCreateOrUpdateFuture.Result.
func (future *ConnectionMonitorsCreateOrUpdateFuture) result(client ConnectionMonitorsClient) (cmr ConnectionMonitorResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ConnectionMonitorsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cmr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ConnectionMonitorsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cmr.Response.Response, err = future.GetResult(sender); err == nil && cmr.Response.Response.StatusCode != http.StatusNoContent {
		cmr, err = client.CreateOrUpdateResponder(cmr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ConnectionMonitorsCreateOrUpdateFuture", "Result", cmr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ConnectionMonitorsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ConnectionMonitorsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectionMonitorsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectionMonitorsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectionMonitorsDeleteFuture.Result.
func (future *ConnectionMonitorsDeleteFuture) result(client ConnectionMonitorsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ConnectionMonitorsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ConnectionMonitorsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ConnectionMonitorSource describes the source of connection monitor.
type ConnectionMonitorSource struct {
	// ResourceID - The ID of the resource used as the source by connection monitor.
	ResourceID *string `json:"resourceId,omitempty"`
	// Port - The source port used by connection monitor.
	Port *int32 `json:"port,omitempty"`
}

// ConnectionMonitorsQueryFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConnectionMonitorsQueryFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectionMonitorsClient) (ConnectionMonitorQueryResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectionMonitorsQueryFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectionMonitorsQueryFuture.Result.
func (future *ConnectionMonitorsQueryFuture) result(client ConnectionMonitorsClient) (cmqr ConnectionMonitorQueryResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ConnectionMonitorsQueryFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cmqr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ConnectionMonitorsQueryFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cmqr.Response.Response, err = future.GetResult(sender); err == nil && cmqr.Response.Response.StatusCode != http.StatusNoContent {
		cmqr, err = client.QueryResponder(cmqr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ConnectionMonitorsQueryFuture", "Result", cmqr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ConnectionMonitorsStartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConnectionMonitorsStartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectionMonitorsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectionMonitorsStartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectionMonitorsStartFuture.Result.
func (future *ConnectionMonitorsStartFuture) result(client ConnectionMonitorsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ConnectionMonitorsStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ConnectionMonitorsStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ConnectionMonitorsStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConnectionMonitorsStopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConnectionMonitorsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConnectionMonitorsStopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConnectionMonitorsStopFuture.Result.
func (future *ConnectionMonitorsStopFuture) result(client ConnectionMonitorsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ConnectionMonitorsStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ConnectionMonitorsStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ConnectionMonitorSuccessThreshold describes the threshold for declaring a test successful.
type ConnectionMonitorSuccessThreshold struct {
	// ChecksFailedPercent - The maximum percentage of failed checks permitted for a test to evaluate as successful.
	ChecksFailedPercent *int32 `json:"checksFailedPercent,omitempty"`
	// RoundTripTimeMs - The maximum round-trip time in milliseconds permitted for a test to evaluate as successful.
	RoundTripTimeMs *float64 `json:"roundTripTimeMs,omitempty"`
}

// ConnectionMonitorTCPConfiguration describes the TCP configuration.
type ConnectionMonitorTCPConfiguration struct {
	// Port - The port to connect to.
	Port *int32 `json:"port,omitempty"`
	// DisableTraceRoute - Value indicating whether path evaluation with trace route should be disabled.
	DisableTraceRoute *bool `json:"disableTraceRoute,omitempty"`
	// DestinationPortBehavior - Destination port behavior. Possible values include: 'DestinationPortBehaviorNone', 'DestinationPortBehaviorListenIfAvailable'
	DestinationPortBehavior DestinationPortBehavior `json:"destinationPortBehavior,omitempty"`
}

// ConnectionMonitorTestConfiguration describes a connection monitor test configuration.
type ConnectionMonitorTestConfiguration struct {
	// Name - The name of the connection monitor test configuration.
	Name *string `json:"name,omitempty"`
	// TestFrequencySec - The frequency of test evaluation, in seconds.
	TestFrequencySec *int32 `json:"testFrequencySec,omitempty"`
	// Protocol - The protocol to use in test evaluation. Possible values include: 'ConnectionMonitorTestConfigurationProtocolTCP', 'ConnectionMonitorTestConfigurationProtocolHTTP', 'ConnectionMonitorTestConfigurationProtocolIcmp'
	Protocol ConnectionMonitorTestConfigurationProtocol `json:"protocol,omitempty"`
	// PreferredIPVersion - The preferred IP version to use in test evaluation. The connection monitor may choose to use a different version depending on other parameters. Possible values include: 'PreferredIPVersionIPv4', 'PreferredIPVersionIPv6'
	PreferredIPVersion PreferredIPVersion `json:"preferredIPVersion,omitempty"`
	// HTTPConfiguration - The parameters used to perform test evaluation over HTTP.
	HTTPConfiguration *ConnectionMonitorHTTPConfiguration `json:"httpConfiguration,omitempty"`
	// TCPConfiguration - The parameters used to perform test evaluation over TCP.
	TCPConfiguration *ConnectionMonitorTCPConfiguration `json:"tcpConfiguration,omitempty"`
	// IcmpConfiguration - The parameters used to perform test evaluation over ICMP.
	IcmpConfiguration *ConnectionMonitorIcmpConfiguration `json:"icmpConfiguration,omitempty"`
	// SuccessThreshold - The threshold for declaring a test successful.
	SuccessThreshold *ConnectionMonitorSuccessThreshold `json:"successThreshold,omitempty"`
}

// ConnectionMonitorTestGroup describes the connection monitor test group.
type ConnectionMonitorTestGroup struct {
	// Name - The name of the connection monitor test group.
	Name *string `json:"name,omitempty"`
	// Disable - Value indicating whether test group is disabled.
	Disable *bool `json:"disable,omitempty"`
	// TestConfigurations - List of test configuration names.
	TestConfigurations *[]string `json:"testConfigurations,omitempty"`
	// Sources - List of source endpoint names.
	Sources *[]string `json:"sources,omitempty"`
	// Destinations - List of destination endpoint names.
	Destinations *[]string `json:"destinations,omitempty"`
}

// ConnectionMonitorWorkspaceSettings describes the settings for producing output into a log analytics
// workspace.
type ConnectionMonitorWorkspaceSettings struct {
	// WorkspaceResourceID - Log analytics workspace resource ID.
	WorkspaceResourceID *string `json:"workspaceResourceId,omitempty"`
}

// ConnectionResetSharedKey the virtual network connection reset shared key.
type ConnectionResetSharedKey struct {
	autorest.Response `json:"-"`
	// KeyLength - The virtual network connection reset shared key length, should between 1 and 128.
	KeyLength *int32 `json:"keyLength,omitempty"`
}

// ConnectionSharedKey response for GetConnectionSharedKey API service call.
type ConnectionSharedKey struct {
	autorest.Response `json:"-"`
	// Value - The virtual network connection shared key value.
	Value *string `json:"value,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// ConnectionStateSnapshot connection state snapshot.
type ConnectionStateSnapshot struct {
	// ConnectionState - The connection state. Possible values include: 'ConnectionStateReachable', 'ConnectionStateUnreachable', 'ConnectionStateUnknown'
	ConnectionState ConnectionState `json:"connectionState,omitempty"`
	// StartTime - The start time of the connection snapshot.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time of the connection snapshot.
	EndTime *date.Time `json:"endTime,omitempty"`
	// EvaluationState - Connectivity analysis evaluation state. Possible values include: 'EvaluationStateNotStarted', 'EvaluationStateInProgress', 'EvaluationStateCompleted'
	EvaluationState EvaluationState `json:"evaluationState,omitempty"`
	// AvgLatencyInMs - Average latency in ms.
	AvgLatencyInMs *int64 `json:"avgLatencyInMs,omitempty"`
	// MinLatencyInMs - Minimum latency in ms.
	MinLatencyInMs *int64 `json:"minLatencyInMs,omitempty"`
	// MaxLatencyInMs - Maximum latency in ms.
	MaxLatencyInMs *int64 `json:"maxLatencyInMs,omitempty"`
	// ProbesSent - The number of sent probes.
	ProbesSent *int64 `json:"probesSent,omitempty"`
	// ProbesFailed - The number of failed probes.
	ProbesFailed *int64 `json:"probesFailed,omitempty"`
	// Hops - READ-ONLY; List of hops between the source and the destination.
	Hops *[]ConnectivityHop `json:"hops,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectionStateSnapshot.
func (CSS ConnectionStateSnapshot) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if CSS.ConnectionState != "" {
		objectMap["connectionState"] = CSS.ConnectionState
	}
	if CSS.StartTime != nil {
		objectMap["startTime"] = CSS.StartTime
	}
	if CSS.EndTime != nil {
		objectMap["endTime"] = CSS.EndTime
	}
	if CSS.EvaluationState != "" {
		objectMap["evaluationState"] = CSS.EvaluationState
	}
	if CSS.AvgLatencyInMs != nil {
		objectMap["avgLatencyInMs"] = CSS.AvgLatencyInMs
	}
	if CSS.MinLatencyInMs != nil {
		objectMap["minLatencyInMs"] = CSS.MinLatencyInMs
	}
	if CSS.MaxLatencyInMs != nil {
		objectMap["maxLatencyInMs"] = CSS.MaxLatencyInMs
	}
	if CSS.ProbesSent != nil {
		objectMap["probesSent"] = CSS.ProbesSent
	}
	if CSS.ProbesFailed != nil {
		objectMap["probesFailed"] = CSS.ProbesFailed
	}
	return json.Marshal(objectMap)
}

// ConnectivityDestination parameters that define destination of connection.
type ConnectivityDestination struct {
	// ResourceID - The ID of the resource to which a connection attempt will be made.
	ResourceID *string `json:"resourceId,omitempty"`
	// Address - The IP address or URI the resource to which a connection attempt will be made.
	Address *string `json:"address,omitempty"`
	// Port - Port on which check connectivity will be performed.
	Port *int32 `json:"port,omitempty"`
}

// ConnectivityHop information about a hop between the source and the destination.
type ConnectivityHop struct {
	// Type - READ-ONLY; The type of the hop.
	Type *string `json:"type,omitempty"`
	// ID - READ-ONLY; The ID of the hop.
	ID *string `json:"id,omitempty"`
	// Address - READ-ONLY; The IP address of the hop.
	Address *string `json:"address,omitempty"`
	// ResourceID - READ-ONLY; The ID of the resource corresponding to this hop.
	ResourceID *string `json:"resourceId,omitempty"`
	// NextHopIds - READ-ONLY; List of next hop identifiers.
	NextHopIds *[]string `json:"nextHopIds,omitempty"`
	// PreviousHopIds - READ-ONLY; List of previous hop identifiers.
	PreviousHopIds *[]string `json:"previousHopIds,omitempty"`
	// Links - READ-ONLY; List of hop links.
	Links *[]HopLink `json:"links,omitempty"`
	// PreviousLinks - READ-ONLY; List of previous hop links.
	PreviousLinks *[]HopLink `json:"previousLinks,omitempty"`
	// Issues - READ-ONLY; List of issues.
	Issues *[]ConnectivityIssue `json:"issues,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectivityHop.
func (ch ConnectivityHop) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ConnectivityInformation information on the connectivity status.
type ConnectivityInformation struct {
	autorest.Response `json:"-"`
	// Hops - READ-ONLY; List of hops between the source and the destination.
	Hops *[]ConnectivityHop `json:"hops,omitempty"`
	// ConnectionStatus - READ-ONLY; The connection status. Possible values include: 'ConnectionStatusUnknown', 'ConnectionStatusConnected', 'ConnectionStatusDisconnected', 'ConnectionStatusDegraded'
	ConnectionStatus ConnectionStatus `json:"connectionStatus,omitempty"`
	// AvgLatencyInMs - READ-ONLY; Average latency in milliseconds.
	AvgLatencyInMs *int32 `json:"avgLatencyInMs,omitempty"`
	// MinLatencyInMs - READ-ONLY; Minimum latency in milliseconds.
	MinLatencyInMs *int32 `json:"minLatencyInMs,omitempty"`
	// MaxLatencyInMs - READ-ONLY; Maximum latency in milliseconds.
	MaxLatencyInMs *int32 `json:"maxLatencyInMs,omitempty"`
	// ProbesSent - READ-ONLY; Total number of probes sent.
	ProbesSent *int32 `json:"probesSent,omitempty"`
	// ProbesFailed - READ-ONLY; Number of failed probes.
	ProbesFailed *int32 `json:"probesFailed,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectivityInformation.
func (ci ConnectivityInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ConnectivityIssue information about an issue encountered in the process of checking for connectivity.
type ConnectivityIssue struct {
	// Origin - READ-ONLY; The origin of the issue. Possible values include: 'OriginLocal', 'OriginInbound', 'OriginOutbound'
	Origin Origin `json:"origin,omitempty"`
	// Severity - READ-ONLY; The severity of the issue. Possible values include: 'SeverityError', 'SeverityWarning'
	Severity Severity `json:"severity,omitempty"`
	// Type - READ-ONLY; The type of issue. Possible values include: 'IssueTypeUnknown', 'IssueTypeAgentStopped', 'IssueTypeGuestFirewall', 'IssueTypeDNSResolution', 'IssueTypeSocketBind', 'IssueTypeNetworkSecurityRule', 'IssueTypeUserDefinedRoute', 'IssueTypePortThrottled', 'IssueTypePlatform'
	Type IssueType `json:"type,omitempty"`
	// Context - READ-ONLY; Provides additional context on the issue.
	Context *[]map[string]*string `json:"context,omitempty"`
}

// MarshalJSON is the custom marshaler for ConnectivityIssue.
func (ci ConnectivityIssue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ConnectivityParameters parameters that determine how the connectivity check will be performed.
type ConnectivityParameters struct {
	// Source - The source of the connection.
	Source *ConnectivitySource `json:"source,omitempty"`
	// Destination - The destination of connection.
	Destination *ConnectivityDestination `json:"destination,omitempty"`
	// Protocol - Network protocol. Possible values include: 'ProtocolTCP', 'ProtocolHTTP', 'ProtocolHTTPS', 'ProtocolIcmp'
	Protocol Protocol `json:"protocol,omitempty"`
	// ProtocolConfiguration - Configuration of the protocol.
	ProtocolConfiguration *ProtocolConfiguration `json:"protocolConfiguration,omitempty"`
	// PreferredIPVersion - Preferred IP version of the connection. Possible values include: 'IPVersionIPv4', 'IPVersionIPv6'
	PreferredIPVersion IPVersion `json:"preferredIPVersion,omitempty"`
}

// ConnectivitySource parameters that define the source of the connection.
type ConnectivitySource struct {
	// ResourceID - The ID of the resource from which a connectivity check will be initiated.
	ResourceID *string `json:"resourceId,omitempty"`
	// Port - The source port from which a connectivity check will be performed.
	Port *int32 `json:"port,omitempty"`
}

// Container reference to container resource in remote resource provider.
type Container struct {
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// ContainerNetworkInterface container network interface child resource.
type ContainerNetworkInterface struct {
	// ContainerNetworkInterfacePropertiesFormat - Container network interface properties.
	*ContainerNetworkInterfacePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Sub Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerNetworkInterface.
func (cni ContainerNetworkInterface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cni.ContainerNetworkInterfacePropertiesFormat != nil {
		objectMap["properties"] = cni.ContainerNetworkInterfacePropertiesFormat
	}
	if cni.Name != nil {
		objectMap["name"] = cni.Name
	}
	if cni.ID != nil {
		objectMap["id"] = cni.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ContainerNetworkInterface struct.
func (cni *ContainerNetworkInterface) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var containerNetworkInterfacePropertiesFormat ContainerNetworkInterfacePropertiesFormat
				err = json.Unmarshal(*v, &containerNetworkInterfacePropertiesFormat)
				if err != nil {
					return err
				}
				cni.ContainerNetworkInterfacePropertiesFormat = &containerNetworkInterfacePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cni.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cni.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				cni.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cni.ID = &ID
			}
		}
	}

	return nil
}

// ContainerNetworkInterfaceConfiguration container network interface configuration child resource.
type ContainerNetworkInterfaceConfiguration struct {
	// ContainerNetworkInterfaceConfigurationPropertiesFormat - Container network interface configuration properties.
	*ContainerNetworkInterfaceConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Sub Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerNetworkInterfaceConfiguration.
func (cnic ContainerNetworkInterfaceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cnic.ContainerNetworkInterfaceConfigurationPropertiesFormat != nil {
		objectMap["properties"] = cnic.ContainerNetworkInterfaceConfigurationPropertiesFormat
	}
	if cnic.Name != nil {
		objectMap["name"] = cnic.Name
	}
	if cnic.ID != nil {
		objectMap["id"] = cnic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ContainerNetworkInterfaceConfiguration struct.
func (cnic *ContainerNetworkInterfaceConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var containerNetworkInterfaceConfigurationPropertiesFormat ContainerNetworkInterfaceConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &containerNetworkInterfaceConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				cnic.ContainerNetworkInterfaceConfigurationPropertiesFormat = &containerNetworkInterfaceConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cnic.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cnic.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				cnic.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cnic.ID = &ID
			}
		}
	}

	return nil
}

// ContainerNetworkInterfaceConfigurationPropertiesFormat container network interface configuration
// properties.
type ContainerNetworkInterfaceConfigurationPropertiesFormat struct {
	// IPConfigurations - A list of ip configurations of the container network interface configuration.
	IPConfigurations *[]IPConfigurationProfile `json:"ipConfigurations,omitempty"`
	// ContainerNetworkInterfaces - A list of container network interfaces created from this container network interface configuration.
	ContainerNetworkInterfaces *[]SubResource `json:"containerNetworkInterfaces,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the container network interface configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerNetworkInterfaceConfigurationPropertiesFormat.
func (cnicpf ContainerNetworkInterfaceConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cnicpf.IPConfigurations != nil {
		objectMap["ipConfigurations"] = cnicpf.IPConfigurations
	}
	if cnicpf.ContainerNetworkInterfaces != nil {
		objectMap["containerNetworkInterfaces"] = cnicpf.ContainerNetworkInterfaces
	}
	return json.Marshal(objectMap)
}

// ContainerNetworkInterfaceIPConfiguration the ip configuration for a container network interface.
type ContainerNetworkInterfaceIPConfiguration struct {
	// ContainerNetworkInterfaceIPConfigurationPropertiesFormat - Properties of the container network interface IP configuration.
	*ContainerNetworkInterfaceIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Sub Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerNetworkInterfaceIPConfiguration.
func (cniic ContainerNetworkInterfaceIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cniic.ContainerNetworkInterfaceIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = cniic.ContainerNetworkInterfaceIPConfigurationPropertiesFormat
	}
	if cniic.Name != nil {
		objectMap["name"] = cniic.Name
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ContainerNetworkInterfaceIPConfiguration struct.
func (cniic *ContainerNetworkInterfaceIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var containerNetworkInterfaceIPConfigurationPropertiesFormat ContainerNetworkInterfaceIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &containerNetworkInterfaceIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				cniic.ContainerNetworkInterfaceIPConfigurationPropertiesFormat = &containerNetworkInterfaceIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cniic.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cniic.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				cniic.Etag = &etag
			}
		}
	}

	return nil
}

// ContainerNetworkInterfaceIPConfigurationPropertiesFormat properties of the container network interface
// IP configuration.
type ContainerNetworkInterfaceIPConfigurationPropertiesFormat struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the container network interface IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerNetworkInterfaceIPConfigurationPropertiesFormat.
func (cniicpf ContainerNetworkInterfaceIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ContainerNetworkInterfacePropertiesFormat properties of container network interface.
type ContainerNetworkInterfacePropertiesFormat struct {
	// ContainerNetworkInterfaceConfiguration - READ-ONLY; Container network interface configuration from which this container network interface is created.
	ContainerNetworkInterfaceConfiguration *ContainerNetworkInterfaceConfiguration `json:"containerNetworkInterfaceConfiguration,omitempty"`
	// Container - Reference to the container to which this container network interface is attached.
	Container *Container `json:"container,omitempty"`
	// IPConfigurations - READ-ONLY; Reference to the ip configuration on this container nic.
	IPConfigurations *[]ContainerNetworkInterfaceIPConfiguration `json:"ipConfigurations,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the container network interface resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ContainerNetworkInterfacePropertiesFormat.
func (cnipf ContainerNetworkInterfacePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cnipf.Container != nil {
		objectMap["container"] = cnipf.Container
	}
	return json.Marshal(objectMap)
}

// CustomDNSConfigPropertiesFormat contains custom Dns resolution configuration from customer.
type CustomDNSConfigPropertiesFormat struct {
	// Fqdn - Fqdn that resolves to private endpoint ip address.
	Fqdn *string `json:"fqdn,omitempty"`
	// IPAddresses - A list of private ip addresses of the private endpoint.
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
}

// CustomIPPrefix custom IP prefix resource.
type CustomIPPrefix struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of the custom IP prefix.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// CustomIPPrefixPropertiesFormat - Custom IP prefix properties.
	*CustomIPPrefixPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Zones - A list of availability zones denoting the IP allocated for the resource needs to come from.
	Zones *[]string `json:"zones,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for CustomIPPrefix.
func (cip CustomIPPrefix) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cip.ExtendedLocation != nil {
		objectMap["extendedLocation"] = cip.ExtendedLocation
	}
	if cip.CustomIPPrefixPropertiesFormat != nil {
		objectMap["properties"] = cip.CustomIPPrefixPropertiesFormat
	}
	if cip.Zones != nil {
		objectMap["zones"] = cip.Zones
	}
	if cip.ID != nil {
		objectMap["id"] = cip.ID
	}
	if cip.Location != nil {
		objectMap["location"] = cip.Location
	}
	if cip.Tags != nil {
		objectMap["tags"] = cip.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CustomIPPrefix struct.
func (cip *CustomIPPrefix) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				cip.ExtendedLocation = &extendedLocation
			}
		case "properties":
			if v != nil {
				var customIPPrefixPropertiesFormat CustomIPPrefixPropertiesFormat
				err = json.Unmarshal(*v, &customIPPrefixPropertiesFormat)
				if err != nil {
					return err
				}
				cip.CustomIPPrefixPropertiesFormat = &customIPPrefixPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				cip.Etag = &etag
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				cip.Zones = &zones
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cip.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cip.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cip.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				cip.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cip.Tags = tags
			}
		}
	}

	return nil
}

// CustomIPPrefixesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type CustomIPPrefixesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(CustomIPPrefixesClient) (CustomIPPrefix, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *CustomIPPrefixesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for CustomIPPrefixesCreateOrUpdateFuture.Result.
func (future *CustomIPPrefixesCreateOrUpdateFuture) result(client CustomIPPrefixesClient) (cip CustomIPPrefix, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.CustomIPPrefixesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cip.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.CustomIPPrefixesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cip.Response.Response, err = future.GetResult(sender); err == nil && cip.Response.Response.StatusCode != http.StatusNoContent {
		cip, err = client.CreateOrUpdateResponder(cip.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.CustomIPPrefixesCreateOrUpdateFuture", "Result", cip.Response.Response, "Failure responding to request")
		}
	}
	return
}

// CustomIPPrefixesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CustomIPPrefixesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(CustomIPPrefixesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *CustomIPPrefixesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for CustomIPPrefixesDeleteFuture.Result.
func (future *CustomIPPrefixesDeleteFuture) result(client CustomIPPrefixesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.CustomIPPrefixesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.CustomIPPrefixesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// CustomIPPrefixListResult response for ListCustomIpPrefixes API service call.
type CustomIPPrefixListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of Custom IP prefixes that exists in a resource group.
	Value *[]CustomIPPrefix `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// CustomIPPrefixListResultIterator provides access to a complete listing of CustomIPPrefix values.
type CustomIPPrefixListResultIterator struct {
	i    int
	page CustomIPPrefixListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CustomIPPrefixListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomIPPrefixListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CustomIPPrefixListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CustomIPPrefixListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CustomIPPrefixListResultIterator) Response() CustomIPPrefixListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CustomIPPrefixListResultIterator) Value() CustomIPPrefix {
	if !iter.page.NotDone() {
		return CustomIPPrefix{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CustomIPPrefixListResultIterator type.
func NewCustomIPPrefixListResultIterator(page CustomIPPrefixListResultPage) CustomIPPrefixListResultIterator {
	return CustomIPPrefixListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ciplr CustomIPPrefixListResult) IsEmpty() bool {
	return ciplr.Value == nil || len(*ciplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ciplr CustomIPPrefixListResult) hasNextLink() bool {
	return ciplr.NextLink != nil && len(*ciplr.NextLink) != 0
}

// customIPPrefixListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ciplr CustomIPPrefixListResult) customIPPrefixListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ciplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ciplr.NextLink)))
}

// CustomIPPrefixListResultPage contains a page of CustomIPPrefix values.
type CustomIPPrefixListResultPage struct {
	fn    func(context.Context, CustomIPPrefixListResult) (CustomIPPrefixListResult, error)
	ciplr CustomIPPrefixListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CustomIPPrefixListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomIPPrefixListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ciplr)
		if err != nil {
			return err
		}
		page.ciplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CustomIPPrefixListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CustomIPPrefixListResultPage) NotDone() bool {
	return !page.ciplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CustomIPPrefixListResultPage) Response() CustomIPPrefixListResult {
	return page.ciplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CustomIPPrefixListResultPage) Values() []CustomIPPrefix {
	if page.ciplr.IsEmpty() {
		return nil
	}
	return *page.ciplr.Value
}

// Creates a new instance of the CustomIPPrefixListResultPage type.
func NewCustomIPPrefixListResultPage(cur CustomIPPrefixListResult, getNextPage func(context.Context, CustomIPPrefixListResult) (CustomIPPrefixListResult, error)) CustomIPPrefixListResultPage {
	return CustomIPPrefixListResultPage{
		fn:    getNextPage,
		ciplr: cur,
	}
}

// CustomIPPrefixPropertiesFormat custom IP prefix properties.
type CustomIPPrefixPropertiesFormat struct {
	// Cidr - The prefix range in CIDR notation. Should include the start address and the prefix length.
	Cidr *string `json:"cidr,omitempty"`
	// CommissionedState - The commissioned state of the Custom IP Prefix. Possible values include: 'CommissionedStateProvisioning', 'CommissionedStateProvisioned', 'CommissionedStateCommissioning', 'CommissionedStateCommissioned', 'CommissionedStateDecommissioning', 'CommissionedStateDeprovisioning'
	CommissionedState CommissionedState `json:"commissionedState,omitempty"`
	// PublicIPPrefixes - READ-ONLY; The list of all referenced PublicIpPrefixes.
	PublicIPPrefixes *[]SubResource `json:"publicIpPrefixes,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the custom IP prefix resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the custom IP prefix resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomIPPrefixPropertiesFormat.
func (cippf CustomIPPrefixPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cippf.Cidr != nil {
		objectMap["cidr"] = cippf.Cidr
	}
	if cippf.CommissionedState != "" {
		objectMap["commissionedState"] = cippf.CommissionedState
	}
	return json.Marshal(objectMap)
}

// DdosCustomPoliciesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DdosCustomPoliciesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DdosCustomPoliciesClient) (DdosCustomPolicy, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DdosCustomPoliciesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DdosCustomPoliciesCreateOrUpdateFuture.Result.
func (future *DdosCustomPoliciesCreateOrUpdateFuture) result(client DdosCustomPoliciesClient) (dcp DdosCustomPolicy, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.DdosCustomPoliciesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		dcp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.DdosCustomPoliciesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if dcp.Response.Response, err = future.GetResult(sender); err == nil && dcp.Response.Response.StatusCode != http.StatusNoContent {
		dcp, err = client.CreateOrUpdateResponder(dcp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.DdosCustomPoliciesCreateOrUpdateFuture", "Result", dcp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DdosCustomPoliciesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DdosCustomPoliciesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DdosCustomPoliciesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DdosCustomPoliciesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DdosCustomPoliciesDeleteFuture.Result.
func (future *DdosCustomPoliciesDeleteFuture) result(client DdosCustomPoliciesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.DdosCustomPoliciesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.DdosCustomPoliciesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// DdosCustomPolicy a DDoS custom policy in a resource group.
type DdosCustomPolicy struct {
	autorest.Response `json:"-"`
	// DdosCustomPolicyPropertiesFormat - Properties of the DDoS custom policy.
	*DdosCustomPolicyPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for DdosCustomPolicy.
func (dcp DdosCustomPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcp.DdosCustomPolicyPropertiesFormat != nil {
		objectMap["properties"] = dcp.DdosCustomPolicyPropertiesFormat
	}
	if dcp.ID != nil {
		objectMap["id"] = dcp.ID
	}
	if dcp.Location != nil {
		objectMap["location"] = dcp.Location
	}
	if dcp.Tags != nil {
		objectMap["tags"] = dcp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DdosCustomPolicy struct.
func (dcp *DdosCustomPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var ddosCustomPolicyPropertiesFormat DdosCustomPolicyPropertiesFormat
				err = json.Unmarshal(*v, &ddosCustomPolicyPropertiesFormat)
				if err != nil {
					return err
				}
				dcp.DdosCustomPolicyPropertiesFormat = &ddosCustomPolicyPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				dcp.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dcp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dcp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dcp.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				dcp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				dcp.Tags = tags
			}
		}
	}

	return nil
}

// DdosCustomPolicyPropertiesFormat dDoS custom policy properties.
type DdosCustomPolicyPropertiesFormat struct {
	// ResourceGUID - READ-ONLY; The resource GUID property of the DDoS custom policy resource. It uniquely identifies the resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the DDoS custom policy resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PublicIPAddresses - READ-ONLY; The list of public IPs associated with the DDoS custom policy resource. This list is read-only.
	PublicIPAddresses *[]SubResource `json:"publicIPAddresses,omitempty"`
	// ProtocolCustomSettings - The protocol-specific DDoS policy customization parameters.
	ProtocolCustomSettings *[]ProtocolCustomSettingsFormat `json:"protocolCustomSettings,omitempty"`
}

// MarshalJSON is the custom marshaler for DdosCustomPolicyPropertiesFormat.
func (dcppf DdosCustomPolicyPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcppf.ProtocolCustomSettings != nil {
		objectMap["protocolCustomSettings"] = dcppf.ProtocolCustomSettings
	}
	return json.Marshal(objectMap)
}

// DdosProtectionPlan a DDoS protection plan in a resource group.
type DdosProtectionPlan struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// DdosProtectionPlanPropertiesFormat - Properties of the DDoS protection plan.
	*DdosProtectionPlanPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for DdosProtectionPlan.
func (dpp DdosProtectionPlan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dpp.Location != nil {
		objectMap["location"] = dpp.Location
	}
	if dpp.Tags != nil {
		objectMap["tags"] = dpp.Tags
	}
	if dpp.DdosProtectionPlanPropertiesFormat != nil {
		objectMap["properties"] = dpp.DdosProtectionPlanPropertiesFormat
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DdosProtectionPlan struct.
func (dpp *DdosProtectionPlan) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dpp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dpp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dpp.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				dpp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				dpp.Tags = tags
			}
		case "properties":
			if v != nil {
				var ddosProtectionPlanPropertiesFormat DdosProtectionPlanPropertiesFormat
				err = json.Unmarshal(*v, &ddosProtectionPlanPropertiesFormat)
				if err != nil {
					return err
				}
				dpp.DdosProtectionPlanPropertiesFormat = &ddosProtectionPlanPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				dpp.Etag = &etag
			}
		}
	}

	return nil
}

// DdosProtectionPlanListResult a list of DDoS protection plans.
type DdosProtectionPlanListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of DDoS protection plans.
	Value *[]DdosProtectionPlan `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DdosProtectionPlanListResult.
func (dpplr DdosProtectionPlanListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dpplr.Value != nil {
		objectMap["value"] = dpplr.Value
	}
	return json.Marshal(objectMap)
}

// DdosProtectionPlanListResultIterator provides access to a complete listing of DdosProtectionPlan values.
type DdosProtectionPlanListResultIterator struct {
	i    int
	page DdosProtectionPlanListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DdosProtectionPlanListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DdosProtectionPlanListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DdosProtectionPlanListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DdosProtectionPlanListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DdosProtectionPlanListResultIterator) Response() DdosProtectionPlanListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DdosProtectionPlanListResultIterator) Value() DdosProtectionPlan {
	if !iter.page.NotDone() {
		return DdosProtectionPlan{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DdosProtectionPlanListResultIterator type.
func NewDdosProtectionPlanListResultIterator(page DdosProtectionPlanListResultPage) DdosProtectionPlanListResultIterator {
	return DdosProtectionPlanListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dpplr DdosProtectionPlanListResult) IsEmpty() bool {
	return dpplr.Value == nil || len(*dpplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dpplr DdosProtectionPlanListResult) hasNextLink() bool {
	return dpplr.NextLink != nil && len(*dpplr.NextLink) != 0
}

// ddosProtectionPlanListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dpplr DdosProtectionPlanListResult) ddosProtectionPlanListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !dpplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dpplr.NextLink)))
}

// DdosProtectionPlanListResultPage contains a page of DdosProtectionPlan values.
type DdosProtectionPlanListResultPage struct {
	fn    func(context.Context, DdosProtectionPlanListResult) (DdosProtectionPlanListResult, error)
	dpplr DdosProtectionPlanListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DdosProtectionPlanListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DdosProtectionPlanListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dpplr)
		if err != nil {
			return err
		}
		page.dpplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DdosProtectionPlanListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DdosProtectionPlanListResultPage) NotDone() bool {
	return !page.dpplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DdosProtectionPlanListResultPage) Response() DdosProtectionPlanListResult {
	return page.dpplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DdosProtectionPlanListResultPage) Values() []DdosProtectionPlan {
	if page.dpplr.IsEmpty() {
		return nil
	}
	return *page.dpplr.Value
}

// Creates a new instance of the DdosProtectionPlanListResultPage type.
func NewDdosProtectionPlanListResultPage(cur DdosProtectionPlanListResult, getNextPage func(context.Context, DdosProtectionPlanListResult) (DdosProtectionPlanListResult, error)) DdosProtectionPlanListResultPage {
	return DdosProtectionPlanListResultPage{
		fn:    getNextPage,
		dpplr: cur,
	}
}

// DdosProtectionPlanPropertiesFormat dDoS protection plan properties.
type DdosProtectionPlanPropertiesFormat struct {
	// ResourceGUID - READ-ONLY; The resource GUID property of the DDoS protection plan resource. It uniquely identifies the resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the DDoS protection plan resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// VirtualNetworks - READ-ONLY; The list of virtual networks associated with the DDoS protection plan resource. This list is read-only.
	VirtualNetworks *[]SubResource `json:"virtualNetworks,omitempty"`
}

// MarshalJSON is the custom marshaler for DdosProtectionPlanPropertiesFormat.
func (dpppf DdosProtectionPlanPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DdosProtectionPlansCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DdosProtectionPlansCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DdosProtectionPlansClient) (DdosProtectionPlan, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DdosProtectionPlansCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DdosProtectionPlansCreateOrUpdateFuture.Result.
func (future *DdosProtectionPlansCreateOrUpdateFuture) result(client DdosProtectionPlansClient) (dpp DdosProtectionPlan, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.DdosProtectionPlansCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		dpp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.DdosProtectionPlansCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if dpp.Response.Response, err = future.GetResult(sender); err == nil && dpp.Response.Response.StatusCode != http.StatusNoContent {
		dpp, err = client.CreateOrUpdateResponder(dpp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.DdosProtectionPlansCreateOrUpdateFuture", "Result", dpp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DdosProtectionPlansDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DdosProtectionPlansDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DdosProtectionPlansClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DdosProtectionPlansDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DdosProtectionPlansDeleteFuture.Result.
func (future *DdosProtectionPlansDeleteFuture) result(client DdosProtectionPlansClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.DdosProtectionPlansDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.DdosProtectionPlansDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// DdosSettings contains the DDoS protection settings of the public IP.
type DdosSettings struct {
	// DdosCustomPolicy - The DDoS custom policy associated with the public IP.
	DdosCustomPolicy *SubResource `json:"ddosCustomPolicy,omitempty"`
	// ProtectionCoverage - The DDoS protection policy customizability of the public IP. Only standard coverage will have the ability to be customized. Possible values include: 'DdosSettingsProtectionCoverageBasic', 'DdosSettingsProtectionCoverageStandard'
	ProtectionCoverage DdosSettingsProtectionCoverage `json:"protectionCoverage,omitempty"`
	// ProtectedIP - Enables DDoS protection on the public IP.
	ProtectedIP *bool `json:"protectedIP,omitempty"`
}

// Delegation details the service to which the subnet is delegated.
type Delegation struct {
	// ServiceDelegationPropertiesFormat - Properties of the subnet.
	*ServiceDelegationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a subnet. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for Delegation.
func (d Delegation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.ServiceDelegationPropertiesFormat != nil {
		objectMap["properties"] = d.ServiceDelegationPropertiesFormat
	}
	if d.Name != nil {
		objectMap["name"] = d.Name
	}
	if d.Type != nil {
		objectMap["type"] = d.Type
	}
	if d.ID != nil {
		objectMap["id"] = d.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Delegation struct.
func (d *Delegation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serviceDelegationPropertiesFormat ServiceDelegationPropertiesFormat
				err = json.Unmarshal(*v, &serviceDelegationPropertiesFormat)
				if err != nil {
					return err
				}
				d.ServiceDelegationPropertiesFormat = &serviceDelegationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				d.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				d.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				d.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				d.ID = &ID
			}
		}
	}

	return nil
}

// DeleteBastionShareableLinkFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DeleteBastionShareableLinkFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BaseClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DeleteBastionShareableLinkFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DeleteBastionShareableLinkFuture.Result.
func (future *DeleteBastionShareableLinkFuture) result(client BaseClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.DeleteBastionShareableLinkFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.DeleteBastionShareableLinkFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// DeviceProperties list of properties of the device.
type DeviceProperties struct {
	// DeviceVendor - Name of the device Vendor.
	DeviceVendor *string `json:"deviceVendor,omitempty"`
	// DeviceModel - Model of the device.
	DeviceModel *string `json:"deviceModel,omitempty"`
	// LinkSpeedInMbps - Link speed.
	LinkSpeedInMbps *int32 `json:"linkSpeedInMbps,omitempty"`
}

// DhcpOptions dhcpOptions contains an array of DNS servers available to VMs deployed in the virtual
// network. Standard DHCP option for a subnet overrides VNET DHCP options.
type DhcpOptions struct {
	// DNSServers - The list of DNS servers IP addresses.
	DNSServers *[]string `json:"dnsServers,omitempty"`
}

// Dimension dimension of the metric.
type Dimension struct {
	// Name - The name of the dimension.
	Name *string `json:"name,omitempty"`
	// DisplayName - The display name of the dimension.
	DisplayName *string `json:"displayName,omitempty"`
	// InternalName - The internal name of the dimension.
	InternalName *string `json:"internalName,omitempty"`
}

// DNSNameAvailabilityResult response for the CheckDnsNameAvailability API service call.
type DNSNameAvailabilityResult struct {
	autorest.Response `json:"-"`
	// Available - Domain availability (True/False).
	Available *bool `json:"available,omitempty"`
}

// DNSSettings DNS Proxy Settings in Firewall Policy.
type DNSSettings struct {
	// Servers - List of Custom DNS Servers.
	Servers *[]string `json:"servers,omitempty"`
	// EnableProxy - Enable DNS Proxy on Firewalls attached to the Firewall Policy.
	EnableProxy *bool `json:"enableProxy,omitempty"`
	// RequireProxyForNetworkRules - FQDNs in Network Rules are supported when set to true.
	RequireProxyForNetworkRules *bool `json:"requireProxyForNetworkRules,omitempty"`
}

// DscpConfiguration DSCP Configuration in a resource group.
type DscpConfiguration struct {
	autorest.Response `json:"-"`
	// DscpConfigurationPropertiesFormat - Properties of the network interface.
	*DscpConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for DscpConfiguration.
func (dc DscpConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dc.DscpConfigurationPropertiesFormat != nil {
		objectMap["properties"] = dc.DscpConfigurationPropertiesFormat
	}
	if dc.ID != nil {
		objectMap["id"] = dc.ID
	}
	if dc.Location != nil {
		objectMap["location"] = dc.Location
	}
	if dc.Tags != nil {
		objectMap["tags"] = dc.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DscpConfiguration struct.
func (dc *DscpConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dscpConfigurationPropertiesFormat DscpConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &dscpConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				dc.DscpConfigurationPropertiesFormat = &dscpConfigurationPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				dc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dc.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				dc.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				dc.Tags = tags
			}
		}
	}

	return nil
}

// DscpConfigurationCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DscpConfigurationCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DscpConfigurationClient) (DscpConfiguration, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DscpConfigurationCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DscpConfigurationCreateOrUpdateFuture.Result.
func (future *DscpConfigurationCreateOrUpdateFuture) result(client DscpConfigurationClient) (dc DscpConfiguration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.DscpConfigurationCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		dc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.DscpConfigurationCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if dc.Response.Response, err = future.GetResult(sender); err == nil && dc.Response.Response.StatusCode != http.StatusNoContent {
		dc, err = client.CreateOrUpdateResponder(dc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.DscpConfigurationCreateOrUpdateFuture", "Result", dc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DscpConfigurationDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type DscpConfigurationDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DscpConfigurationClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DscpConfigurationDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DscpConfigurationDeleteFuture.Result.
func (future *DscpConfigurationDeleteFuture) result(client DscpConfigurationClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.DscpConfigurationDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.DscpConfigurationDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// DscpConfigurationListResult response for the DscpConfigurationList API service call.
type DscpConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of dscp configurations in a resource group.
	Value *[]DscpConfiguration `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for DscpConfigurationListResult.
func (dclr DscpConfigurationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dclr.Value != nil {
		objectMap["value"] = dclr.Value
	}
	return json.Marshal(objectMap)
}

// DscpConfigurationListResultIterator provides access to a complete listing of DscpConfiguration values.
type DscpConfigurationListResultIterator struct {
	i    int
	page DscpConfigurationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DscpConfigurationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DscpConfigurationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DscpConfigurationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DscpConfigurationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DscpConfigurationListResultIterator) Response() DscpConfigurationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DscpConfigurationListResultIterator) Value() DscpConfiguration {
	if !iter.page.NotDone() {
		return DscpConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DscpConfigurationListResultIterator type.
func NewDscpConfigurationListResultIterator(page DscpConfigurationListResultPage) DscpConfigurationListResultIterator {
	return DscpConfigurationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dclr DscpConfigurationListResult) IsEmpty() bool {
	return dclr.Value == nil || len(*dclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dclr DscpConfigurationListResult) hasNextLink() bool {
	return dclr.NextLink != nil && len(*dclr.NextLink) != 0
}

// dscpConfigurationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dclr DscpConfigurationListResult) dscpConfigurationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !dclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dclr.NextLink)))
}

// DscpConfigurationListResultPage contains a page of DscpConfiguration values.
type DscpConfigurationListResultPage struct {
	fn   func(context.Context, DscpConfigurationListResult) (DscpConfigurationListResult, error)
	dclr DscpConfigurationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DscpConfigurationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DscpConfigurationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dclr)
		if err != nil {
			return err
		}
		page.dclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DscpConfigurationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DscpConfigurationListResultPage) NotDone() bool {
	return !page.dclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DscpConfigurationListResultPage) Response() DscpConfigurationListResult {
	return page.dclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DscpConfigurationListResultPage) Values() []DscpConfiguration {
	if page.dclr.IsEmpty() {
		return nil
	}
	return *page.dclr.Value
}

// Creates a new instance of the DscpConfigurationListResultPage type.
func NewDscpConfigurationListResultPage(cur DscpConfigurationListResult, getNextPage func(context.Context, DscpConfigurationListResult) (DscpConfigurationListResult, error)) DscpConfigurationListResultPage {
	return DscpConfigurationListResultPage{
		fn:   getNextPage,
		dclr: cur,
	}
}

// DscpConfigurationPropertiesFormat DSCP Configuration properties.
type DscpConfigurationPropertiesFormat struct {
	// Markings - List of markings to be used in the configuration.
	Markings *[]int32 `json:"markings,omitempty"`
	// SourceIPRanges - Source IP ranges.
	SourceIPRanges *[]QosIPRange `json:"sourceIpRanges,omitempty"`
	// DestinationIPRanges - Destination IP ranges.
	DestinationIPRanges *[]QosIPRange `json:"destinationIpRanges,omitempty"`
	// SourcePortRanges - Sources port ranges.
	SourcePortRanges *[]QosPortRange `json:"sourcePortRanges,omitempty"`
	// DestinationPortRanges - Destination port ranges.
	DestinationPortRanges *[]QosPortRange `json:"destinationPortRanges,omitempty"`
	// Protocol - RNM supported protocol types. Possible values include: 'ProtocolTypeDoNotUse', 'ProtocolTypeIcmp', 'ProtocolTypeTCP', 'ProtocolTypeUDP', 'ProtocolTypeGre', 'ProtocolTypeEsp', 'ProtocolTypeAh', 'ProtocolTypeVxlan', 'ProtocolTypeAll'
	Protocol ProtocolType `json:"protocol,omitempty"`
	// QosCollectionID - READ-ONLY; Qos Collection ID generated by RNM.
	QosCollectionID *string `json:"qosCollectionId,omitempty"`
	// AssociatedNetworkInterfaces - READ-ONLY; Associated Network Interfaces to the DSCP Configuration.
	AssociatedNetworkInterfaces *[]Interface `json:"associatedNetworkInterfaces,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the DSCP Configuration resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the DSCP Configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for DscpConfigurationPropertiesFormat.
func (dcpf DscpConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcpf.Markings != nil {
		objectMap["markings"] = dcpf.Markings
	}
	if dcpf.SourceIPRanges != nil {
		objectMap["sourceIpRanges"] = dcpf.SourceIPRanges
	}
	if dcpf.DestinationIPRanges != nil {
		objectMap["destinationIpRanges"] = dcpf.DestinationIPRanges
	}
	if dcpf.SourcePortRanges != nil {
		objectMap["sourcePortRanges"] = dcpf.SourcePortRanges
	}
	if dcpf.DestinationPortRanges != nil {
		objectMap["destinationPortRanges"] = dcpf.DestinationPortRanges
	}
	if dcpf.Protocol != "" {
		objectMap["protocol"] = dcpf.Protocol
	}
	return json.Marshal(objectMap)
}

// EffectiveNetworkSecurityGroup effective network security group.
type EffectiveNetworkSecurityGroup struct {
	// NetworkSecurityGroup - The ID of network security group that is applied.
	NetworkSecurityGroup *SubResource `json:"networkSecurityGroup,omitempty"`
	// Association - Associated resources.
	Association *EffectiveNetworkSecurityGroupAssociation `json:"association,omitempty"`
	// EffectiveSecurityRules - A collection of effective security rules.
	EffectiveSecurityRules *[]EffectiveNetworkSecurityRule `json:"effectiveSecurityRules,omitempty"`
	// TagMap - Mapping of tags to list of IP Addresses included within the tag.
	TagMap map[string][]string `json:"tagMap"`
}

// MarshalJSON is the custom marshaler for EffectiveNetworkSecurityGroup.
func (ensg EffectiveNetworkSecurityGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ensg.NetworkSecurityGroup != nil {
		objectMap["networkSecurityGroup"] = ensg.NetworkSecurityGroup
	}
	if ensg.Association != nil {
		objectMap["association"] = ensg.Association
	}
	if ensg.EffectiveSecurityRules != nil {
		objectMap["effectiveSecurityRules"] = ensg.EffectiveSecurityRules
	}
	if ensg.TagMap != nil {
		objectMap["tagMap"] = ensg.TagMap
	}
	return json.Marshal(objectMap)
}

// EffectiveNetworkSecurityGroupAssociation the effective network security group association.
type EffectiveNetworkSecurityGroupAssociation struct {
	// Subnet - The ID of the subnet if assigned.
	Subnet *SubResource `json:"subnet,omitempty"`
	// NetworkInterface - The ID of the network interface if assigned.
	NetworkInterface *SubResource `json:"networkInterface,omitempty"`
}

// EffectiveNetworkSecurityGroupListResult response for list effective network security groups API service
// call.
type EffectiveNetworkSecurityGroupListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of effective network security groups.
	Value *[]EffectiveNetworkSecurityGroup `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for EffectiveNetworkSecurityGroupListResult.
func (ensglr EffectiveNetworkSecurityGroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ensglr.Value != nil {
		objectMap["value"] = ensglr.Value
	}
	return json.Marshal(objectMap)
}

// EffectiveNetworkSecurityRule effective network security rules.
type EffectiveNetworkSecurityRule struct {
	// Name - The name of the security rule specified by the user (if created by the user).
	Name *string `json:"name,omitempty"`
	// Protocol - The network protocol this rule applies to. Possible values include: 'EffectiveSecurityRuleProtocolTCP', 'EffectiveSecurityRuleProtocolUDP', 'EffectiveSecurityRuleProtocolAll'
	Protocol EffectiveSecurityRuleProtocol `json:"protocol,omitempty"`
	// SourcePortRange - The source port or range.
	SourcePortRange *string `json:"sourcePortRange,omitempty"`
	// DestinationPortRange - The destination port or range.
	DestinationPortRange *string `json:"destinationPortRange,omitempty"`
	// SourcePortRanges - The source port ranges. Expected values include a single integer between 0 and 65535, a range using '-' as separator (e.g. 100-400), or an asterisk (*).
	SourcePortRanges *[]string `json:"sourcePortRanges,omitempty"`
	// DestinationPortRanges - The destination port ranges. Expected values include a single integer between 0 and 65535, a range using '-' as separator (e.g. 100-400), or an asterisk (*).
	DestinationPortRanges *[]string `json:"destinationPortRanges,omitempty"`
	// SourceAddressPrefix - The source address prefix.
	SourceAddressPrefix *string `json:"sourceAddressPrefix,omitempty"`
	// DestinationAddressPrefix - The destination address prefix.
	DestinationAddressPrefix *string `json:"destinationAddressPrefix,omitempty"`
	// SourceAddressPrefixes - The source address prefixes. Expected values include CIDR IP ranges, Default Tags (VirtualNetwork, AzureLoadBalancer, Internet), System Tags, and the asterisk (*).
	SourceAddressPrefixes *[]string `json:"sourceAddressPrefixes,omitempty"`
	// DestinationAddressPrefixes - The destination address prefixes. Expected values include CIDR IP ranges, Default Tags (VirtualNetwork, AzureLoadBalancer, Internet), System Tags, and the asterisk (*).
	DestinationAddressPrefixes *[]string `json:"destinationAddressPrefixes,omitempty"`
	// ExpandedSourceAddressPrefix - The expanded source address prefix.
	ExpandedSourceAddressPrefix *[]string `json:"expandedSourceAddressPrefix,omitempty"`
	// ExpandedDestinationAddressPrefix - Expanded destination address prefix.
	ExpandedDestinationAddressPrefix *[]string `json:"expandedDestinationAddressPrefix,omitempty"`
	// Access - Whether network traffic is allowed or denied. Possible values include: 'SecurityRuleAccessAllow', 'SecurityRuleAccessDeny'
	Access SecurityRuleAccess `json:"access,omitempty"`
	// Priority - The priority of the rule.
	Priority *int32 `json:"priority,omitempty"`
	// Direction - The direction of the rule. Possible values include: 'SecurityRuleDirectionInbound', 'SecurityRuleDirectionOutbound'
	Direction SecurityRuleDirection `json:"direction,omitempty"`
}

// EffectiveRoute effective Route.
type EffectiveRoute struct {
	// Name - The name of the user defined route. This is optional.
	Name *string `json:"name,omitempty"`
	// DisableBgpRoutePropagation - If true, on-premises routes are not propagated to the network interfaces in the subnet.
	DisableBgpRoutePropagation *bool `json:"disableBgpRoutePropagation,omitempty"`
	// Source - Who created the route. Possible values include: 'EffectiveRouteSourceUnknown', 'EffectiveRouteSourceUser', 'EffectiveRouteSourceVirtualNetworkGateway', 'EffectiveRouteSourceDefault'
	Source EffectiveRouteSource `json:"source,omitempty"`
	// State - The value of effective route. Possible values include: 'EffectiveRouteStateActive', 'EffectiveRouteStateInvalid'
	State EffectiveRouteState `json:"state,omitempty"`
	// AddressPrefix - The address prefixes of the effective routes in CIDR notation.
	AddressPrefix *[]string `json:"addressPrefix,omitempty"`
	// NextHopIPAddress - The IP address of the next hop of the effective route.
	NextHopIPAddress *[]string `json:"nextHopIpAddress,omitempty"`
	// NextHopType - The type of Azure hop the packet should be sent to. Possible values include: 'RouteNextHopTypeVirtualNetworkGateway', 'RouteNextHopTypeVnetLocal', 'RouteNextHopTypeInternet', 'RouteNextHopTypeVirtualAppliance', 'RouteNextHopTypeNone'
	NextHopType RouteNextHopType `json:"nextHopType,omitempty"`
}

// EffectiveRouteListResult response for list effective route API service call.
type EffectiveRouteListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of effective routes.
	Value *[]EffectiveRoute `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for EffectiveRouteListResult.
func (erlr EffectiveRouteListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erlr.Value != nil {
		objectMap["value"] = erlr.Value
	}
	return json.Marshal(objectMap)
}

// EffectiveRoutesParameters the parameters specifying the resource whose effective routes are being
// requested.
type EffectiveRoutesParameters struct {
	// ResourceID - The resource whose effective routes are being requested.
	ResourceID *string `json:"resourceId,omitempty"`
	// VirtualWanResourceType - The type of the specified resource like RouteTable, ExpressRouteConnection, HubVirtualNetworkConnection, VpnConnection and P2SConnection.
	VirtualWanResourceType *string `json:"virtualWanResourceType,omitempty"`
}

// EndpointServiceResult endpoint service.
type EndpointServiceResult struct {
	// Name - READ-ONLY; Name of the endpoint service.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the endpoint service.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for EndpointServiceResult.
func (esr EndpointServiceResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if esr.ID != nil {
		objectMap["id"] = esr.ID
	}
	return json.Marshal(objectMap)
}

// EndpointServicesListResult response for the ListAvailableEndpointServices API service call.
type EndpointServicesListResult struct {
	autorest.Response `json:"-"`
	// Value - List of available endpoint services in a region.
	Value *[]EndpointServiceResult `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// EndpointServicesListResultIterator provides access to a complete listing of EndpointServiceResult
// values.
type EndpointServicesListResultIterator struct {
	i    int
	page EndpointServicesListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EndpointServicesListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EndpointServicesListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EndpointServicesListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EndpointServicesListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EndpointServicesListResultIterator) Response() EndpointServicesListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EndpointServicesListResultIterator) Value() EndpointServiceResult {
	if !iter.page.NotDone() {
		return EndpointServiceResult{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EndpointServicesListResultIterator type.
func NewEndpointServicesListResultIterator(page EndpointServicesListResultPage) EndpointServicesListResultIterator {
	return EndpointServicesListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (eslr EndpointServicesListResult) IsEmpty() bool {
	return eslr.Value == nil || len(*eslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (eslr EndpointServicesListResult) hasNextLink() bool {
	return eslr.NextLink != nil && len(*eslr.NextLink) != 0
}

// endpointServicesListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (eslr EndpointServicesListResult) endpointServicesListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !eslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(eslr.NextLink)))
}

// EndpointServicesListResultPage contains a page of EndpointServiceResult values.
type EndpointServicesListResultPage struct {
	fn   func(context.Context, EndpointServicesListResult) (EndpointServicesListResult, error)
	eslr EndpointServicesListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EndpointServicesListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EndpointServicesListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.eslr)
		if err != nil {
			return err
		}
		page.eslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EndpointServicesListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EndpointServicesListResultPage) NotDone() bool {
	return !page.eslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EndpointServicesListResultPage) Response() EndpointServicesListResult {
	return page.eslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EndpointServicesListResultPage) Values() []EndpointServiceResult {
	if page.eslr.IsEmpty() {
		return nil
	}
	return *page.eslr.Value
}

// Creates a new instance of the EndpointServicesListResultPage type.
func NewEndpointServicesListResultPage(cur EndpointServicesListResult, getNextPage func(context.Context, EndpointServicesListResult) (EndpointServicesListResult, error)) EndpointServicesListResultPage {
	return EndpointServicesListResultPage{
		fn:   getNextPage,
		eslr: cur,
	}
}

// Error common error representation.
type Error struct {
	// Code - Error code.
	Code *string `json:"code,omitempty"`
	// Message - Error message.
	Message *string `json:"message,omitempty"`
	// Target - Error target.
	Target *string `json:"target,omitempty"`
	// Details - Error details.
	Details *[]ErrorDetails `json:"details,omitempty"`
	// InnerError - Inner error message.
	InnerError *string `json:"innerError,omitempty"`
}

// ErrorDetails common error details representation.
type ErrorDetails struct {
	// Code - Error code.
	Code *string `json:"code,omitempty"`
	// Target - Error target.
	Target *string `json:"target,omitempty"`
	// Message - Error message.
	Message *string `json:"message,omitempty"`
}

// ErrorResponse the error object.
type ErrorResponse struct {
	// Error - The error details object.
	Error *ErrorDetails `json:"error,omitempty"`
}

// EvaluatedNetworkSecurityGroup results of network security group evaluation.
type EvaluatedNetworkSecurityGroup struct {
	// NetworkSecurityGroupID - Network security group ID.
	NetworkSecurityGroupID *string `json:"networkSecurityGroupId,omitempty"`
	// AppliedTo - Resource ID of nic or subnet to which network security group is applied.
	AppliedTo *string `json:"appliedTo,omitempty"`
	// MatchedRule - Matched network security rule.
	MatchedRule *MatchedRule `json:"matchedRule,omitempty"`
	// RulesEvaluationResult - READ-ONLY; List of network security rules evaluation results.
	RulesEvaluationResult *[]SecurityRulesEvaluationResult `json:"rulesEvaluationResult,omitempty"`
}

// MarshalJSON is the custom marshaler for EvaluatedNetworkSecurityGroup.
func (ensg EvaluatedNetworkSecurityGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ensg.NetworkSecurityGroupID != nil {
		objectMap["networkSecurityGroupId"] = ensg.NetworkSecurityGroupID
	}
	if ensg.AppliedTo != nil {
		objectMap["appliedTo"] = ensg.AppliedTo
	}
	if ensg.MatchedRule != nil {
		objectMap["matchedRule"] = ensg.MatchedRule
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCircuit expressRouteCircuit resource.
type ExpressRouteCircuit struct {
	autorest.Response `json:"-"`
	// Sku - The SKU.
	Sku *ExpressRouteCircuitSku `json:"sku,omitempty"`
	// ExpressRouteCircuitPropertiesFormat - Properties of the express route circuit.
	*ExpressRouteCircuitPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCircuit.
func (erc ExpressRouteCircuit) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erc.Sku != nil {
		objectMap["sku"] = erc.Sku
	}
	if erc.ExpressRouteCircuitPropertiesFormat != nil {
		objectMap["properties"] = erc.ExpressRouteCircuitPropertiesFormat
	}
	if erc.ID != nil {
		objectMap["id"] = erc.ID
	}
	if erc.Location != nil {
		objectMap["location"] = erc.Location
	}
	if erc.Tags != nil {
		objectMap["tags"] = erc.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteCircuit struct.
func (erc *ExpressRouteCircuit) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "sku":
			if v != nil {
				var sku ExpressRouteCircuitSku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				erc.Sku = &sku
			}
		case "properties":
			if v != nil {
				var expressRouteCircuitPropertiesFormat ExpressRouteCircuitPropertiesFormat
				err = json.Unmarshal(*v, &expressRouteCircuitPropertiesFormat)
				if err != nil {
					return err
				}
				erc.ExpressRouteCircuitPropertiesFormat = &expressRouteCircuitPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				erc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				erc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				erc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				erc.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				erc.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				erc.Tags = tags
			}
		}
	}

	return nil
}

// ExpressRouteCircuitArpTable the ARP table associated with the ExpressRouteCircuit.
type ExpressRouteCircuitArpTable struct {
	// Age - Entry age in minutes.
	Age *int32 `json:"age,omitempty"`
	// Interface - Interface address.
	Interface *string `json:"interface,omitempty"`
	// IPAddress - The IP address.
	IPAddress *string `json:"ipAddress,omitempty"`
	// MacAddress - The MAC address.
	MacAddress *string `json:"macAddress,omitempty"`
}

// ExpressRouteCircuitAuthorization authorization in an ExpressRouteCircuit resource.
type ExpressRouteCircuitAuthorization struct {
	autorest.Response `json:"-"`
	// AuthorizationPropertiesFormat - Properties of the express route circuit authorization.
	*AuthorizationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCircuitAuthorization.
func (erca ExpressRouteCircuitAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erca.AuthorizationPropertiesFormat != nil {
		objectMap["properties"] = erca.AuthorizationPropertiesFormat
	}
	if erca.Name != nil {
		objectMap["name"] = erca.Name
	}
	if erca.ID != nil {
		objectMap["id"] = erca.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteCircuitAuthorization struct.
func (erca *ExpressRouteCircuitAuthorization) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var authorizationPropertiesFormat AuthorizationPropertiesFormat
				err = json.Unmarshal(*v, &authorizationPropertiesFormat)
				if err != nil {
					return err
				}
				erca.AuthorizationPropertiesFormat = &authorizationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				erca.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				erca.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				erca.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				erca.ID = &ID
			}
		}
	}

	return nil
}

// ExpressRouteCircuitAuthorizationsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type ExpressRouteCircuitAuthorizationsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitAuthorizationsClient) (ExpressRouteCircuitAuthorization, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitAuthorizationsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitAuthorizationsCreateOrUpdateFuture.Result.
func (future *ExpressRouteCircuitAuthorizationsCreateOrUpdateFuture) result(client ExpressRouteCircuitAuthorizationsClient) (erca ExpressRouteCircuitAuthorization, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitAuthorizationsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erca.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitAuthorizationsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erca.Response.Response, err = future.GetResult(sender); err == nil && erca.Response.Response.StatusCode != http.StatusNoContent {
		erca, err = client.CreateOrUpdateResponder(erca.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitAuthorizationsCreateOrUpdateFuture", "Result", erca.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCircuitAuthorizationsDeleteFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type ExpressRouteCircuitAuthorizationsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitAuthorizationsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitAuthorizationsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitAuthorizationsDeleteFuture.Result.
func (future *ExpressRouteCircuitAuthorizationsDeleteFuture) result(client ExpressRouteCircuitAuthorizationsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitAuthorizationsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitAuthorizationsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExpressRouteCircuitConnection express Route Circuit Connection in an ExpressRouteCircuitPeering
// resource.
type ExpressRouteCircuitConnection struct {
	autorest.Response `json:"-"`
	// ExpressRouteCircuitConnectionPropertiesFormat - Properties of the express route circuit connection.
	*ExpressRouteCircuitConnectionPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCircuitConnection.
func (ercc ExpressRouteCircuitConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ercc.ExpressRouteCircuitConnectionPropertiesFormat != nil {
		objectMap["properties"] = ercc.ExpressRouteCircuitConnectionPropertiesFormat
	}
	if ercc.Name != nil {
		objectMap["name"] = ercc.Name
	}
	if ercc.ID != nil {
		objectMap["id"] = ercc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteCircuitConnection struct.
func (ercc *ExpressRouteCircuitConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRouteCircuitConnectionPropertiesFormat ExpressRouteCircuitConnectionPropertiesFormat
				err = json.Unmarshal(*v, &expressRouteCircuitConnectionPropertiesFormat)
				if err != nil {
					return err
				}
				ercc.ExpressRouteCircuitConnectionPropertiesFormat = &expressRouteCircuitConnectionPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ercc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ercc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ercc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ercc.ID = &ID
			}
		}
	}

	return nil
}

// ExpressRouteCircuitConnectionListResult response for ListConnections API service call retrieves all
// global reach connections that belongs to a Private Peering for an ExpressRouteCircuit.
type ExpressRouteCircuitConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - The global reach connection associated with Private Peering in an ExpressRoute Circuit.
	Value *[]ExpressRouteCircuitConnection `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRouteCircuitConnectionListResultIterator provides access to a complete listing of
// ExpressRouteCircuitConnection values.
type ExpressRouteCircuitConnectionListResultIterator struct {
	i    int
	page ExpressRouteCircuitConnectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRouteCircuitConnectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCircuitConnectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRouteCircuitConnectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRouteCircuitConnectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRouteCircuitConnectionListResultIterator) Response() ExpressRouteCircuitConnectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRouteCircuitConnectionListResultIterator) Value() ExpressRouteCircuitConnection {
	if !iter.page.NotDone() {
		return ExpressRouteCircuitConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRouteCircuitConnectionListResultIterator type.
func NewExpressRouteCircuitConnectionListResultIterator(page ExpressRouteCircuitConnectionListResultPage) ExpressRouteCircuitConnectionListResultIterator {
	return ExpressRouteCircuitConnectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ercclr ExpressRouteCircuitConnectionListResult) IsEmpty() bool {
	return ercclr.Value == nil || len(*ercclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ercclr ExpressRouteCircuitConnectionListResult) hasNextLink() bool {
	return ercclr.NextLink != nil && len(*ercclr.NextLink) != 0
}

// expressRouteCircuitConnectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ercclr ExpressRouteCircuitConnectionListResult) expressRouteCircuitConnectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ercclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ercclr.NextLink)))
}

// ExpressRouteCircuitConnectionListResultPage contains a page of ExpressRouteCircuitConnection values.
type ExpressRouteCircuitConnectionListResultPage struct {
	fn     func(context.Context, ExpressRouteCircuitConnectionListResult) (ExpressRouteCircuitConnectionListResult, error)
	ercclr ExpressRouteCircuitConnectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRouteCircuitConnectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCircuitConnectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ercclr)
		if err != nil {
			return err
		}
		page.ercclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRouteCircuitConnectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRouteCircuitConnectionListResultPage) NotDone() bool {
	return !page.ercclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRouteCircuitConnectionListResultPage) Response() ExpressRouteCircuitConnectionListResult {
	return page.ercclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRouteCircuitConnectionListResultPage) Values() []ExpressRouteCircuitConnection {
	if page.ercclr.IsEmpty() {
		return nil
	}
	return *page.ercclr.Value
}

// Creates a new instance of the ExpressRouteCircuitConnectionListResultPage type.
func NewExpressRouteCircuitConnectionListResultPage(cur ExpressRouteCircuitConnectionListResult, getNextPage func(context.Context, ExpressRouteCircuitConnectionListResult) (ExpressRouteCircuitConnectionListResult, error)) ExpressRouteCircuitConnectionListResultPage {
	return ExpressRouteCircuitConnectionListResultPage{
		fn:     getNextPage,
		ercclr: cur,
	}
}

// ExpressRouteCircuitConnectionPropertiesFormat properties of the express route circuit connection.
type ExpressRouteCircuitConnectionPropertiesFormat struct {
	// ExpressRouteCircuitPeering - Reference to Express Route Circuit Private Peering Resource of the circuit initiating connection.
	ExpressRouteCircuitPeering *SubResource `json:"expressRouteCircuitPeering,omitempty"`
	// PeerExpressRouteCircuitPeering - Reference to Express Route Circuit Private Peering Resource of the peered circuit.
	PeerExpressRouteCircuitPeering *SubResource `json:"peerExpressRouteCircuitPeering,omitempty"`
	// AddressPrefix - /29 IP address space to carve out Customer addresses for tunnels.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// AuthorizationKey - The authorization key.
	AuthorizationKey *string `json:"authorizationKey,omitempty"`
	// Ipv6CircuitConnectionConfig - IPv6 Address PrefixProperties of the express route circuit connection.
	Ipv6CircuitConnectionConfig *Ipv6CircuitConnectionConfig `json:"ipv6CircuitConnectionConfig,omitempty"`
	// CircuitConnectionStatus - Express Route Circuit connection state. Possible values include: 'CircuitConnectionStatusConnected', 'CircuitConnectionStatusConnecting', 'CircuitConnectionStatusDisconnected'
	CircuitConnectionStatus CircuitConnectionStatus `json:"circuitConnectionStatus,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route circuit connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCircuitConnectionPropertiesFormat.
func (erccpf ExpressRouteCircuitConnectionPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erccpf.ExpressRouteCircuitPeering != nil {
		objectMap["expressRouteCircuitPeering"] = erccpf.ExpressRouteCircuitPeering
	}
	if erccpf.PeerExpressRouteCircuitPeering != nil {
		objectMap["peerExpressRouteCircuitPeering"] = erccpf.PeerExpressRouteCircuitPeering
	}
	if erccpf.AddressPrefix != nil {
		objectMap["addressPrefix"] = erccpf.AddressPrefix
	}
	if erccpf.AuthorizationKey != nil {
		objectMap["authorizationKey"] = erccpf.AuthorizationKey
	}
	if erccpf.Ipv6CircuitConnectionConfig != nil {
		objectMap["ipv6CircuitConnectionConfig"] = erccpf.Ipv6CircuitConnectionConfig
	}
	if erccpf.CircuitConnectionStatus != "" {
		objectMap["circuitConnectionStatus"] = erccpf.CircuitConnectionStatus
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCircuitConnectionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type ExpressRouteCircuitConnectionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitConnectionsClient) (ExpressRouteCircuitConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitConnectionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitConnectionsCreateOrUpdateFuture.Result.
func (future *ExpressRouteCircuitConnectionsCreateOrUpdateFuture) result(client ExpressRouteCircuitConnectionsClient) (ercc ExpressRouteCircuitConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitConnectionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ercc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitConnectionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ercc.Response.Response, err = future.GetResult(sender); err == nil && ercc.Response.Response.StatusCode != http.StatusNoContent {
		ercc, err = client.CreateOrUpdateResponder(ercc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitConnectionsCreateOrUpdateFuture", "Result", ercc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCircuitConnectionsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteCircuitConnectionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitConnectionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitConnectionsDeleteFuture.Result.
func (future *ExpressRouteCircuitConnectionsDeleteFuture) result(client ExpressRouteCircuitConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitConnectionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitConnectionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExpressRouteCircuitListResult response for ListExpressRouteCircuit API service call.
type ExpressRouteCircuitListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of ExpressRouteCircuits in a resource group.
	Value *[]ExpressRouteCircuit `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRouteCircuitListResultIterator provides access to a complete listing of ExpressRouteCircuit
// values.
type ExpressRouteCircuitListResultIterator struct {
	i    int
	page ExpressRouteCircuitListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRouteCircuitListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCircuitListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRouteCircuitListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRouteCircuitListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRouteCircuitListResultIterator) Response() ExpressRouteCircuitListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRouteCircuitListResultIterator) Value() ExpressRouteCircuit {
	if !iter.page.NotDone() {
		return ExpressRouteCircuit{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRouteCircuitListResultIterator type.
func NewExpressRouteCircuitListResultIterator(page ExpressRouteCircuitListResultPage) ExpressRouteCircuitListResultIterator {
	return ExpressRouteCircuitListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (erclr ExpressRouteCircuitListResult) IsEmpty() bool {
	return erclr.Value == nil || len(*erclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (erclr ExpressRouteCircuitListResult) hasNextLink() bool {
	return erclr.NextLink != nil && len(*erclr.NextLink) != 0
}

// expressRouteCircuitListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (erclr ExpressRouteCircuitListResult) expressRouteCircuitListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !erclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(erclr.NextLink)))
}

// ExpressRouteCircuitListResultPage contains a page of ExpressRouteCircuit values.
type ExpressRouteCircuitListResultPage struct {
	fn    func(context.Context, ExpressRouteCircuitListResult) (ExpressRouteCircuitListResult, error)
	erclr ExpressRouteCircuitListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRouteCircuitListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCircuitListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.erclr)
		if err != nil {
			return err
		}
		page.erclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRouteCircuitListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRouteCircuitListResultPage) NotDone() bool {
	return !page.erclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRouteCircuitListResultPage) Response() ExpressRouteCircuitListResult {
	return page.erclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRouteCircuitListResultPage) Values() []ExpressRouteCircuit {
	if page.erclr.IsEmpty() {
		return nil
	}
	return *page.erclr.Value
}

// Creates a new instance of the ExpressRouteCircuitListResultPage type.
func NewExpressRouteCircuitListResultPage(cur ExpressRouteCircuitListResult, getNextPage func(context.Context, ExpressRouteCircuitListResult) (ExpressRouteCircuitListResult, error)) ExpressRouteCircuitListResultPage {
	return ExpressRouteCircuitListResultPage{
		fn:    getNextPage,
		erclr: cur,
	}
}

// ExpressRouteCircuitPeering peering in an ExpressRouteCircuit resource.
type ExpressRouteCircuitPeering struct {
	autorest.Response `json:"-"`
	// ExpressRouteCircuitPeeringPropertiesFormat - Properties of the express route circuit peering.
	*ExpressRouteCircuitPeeringPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCircuitPeering.
func (ercp ExpressRouteCircuitPeering) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ercp.ExpressRouteCircuitPeeringPropertiesFormat != nil {
		objectMap["properties"] = ercp.ExpressRouteCircuitPeeringPropertiesFormat
	}
	if ercp.Name != nil {
		objectMap["name"] = ercp.Name
	}
	if ercp.ID != nil {
		objectMap["id"] = ercp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteCircuitPeering struct.
func (ercp *ExpressRouteCircuitPeering) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRouteCircuitPeeringPropertiesFormat ExpressRouteCircuitPeeringPropertiesFormat
				err = json.Unmarshal(*v, &expressRouteCircuitPeeringPropertiesFormat)
				if err != nil {
					return err
				}
				ercp.ExpressRouteCircuitPeeringPropertiesFormat = &expressRouteCircuitPeeringPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ercp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ercp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ercp.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ercp.ID = &ID
			}
		}
	}

	return nil
}

// ExpressRouteCircuitPeeringConfig specifies the peering configuration.
type ExpressRouteCircuitPeeringConfig struct {
	// AdvertisedPublicPrefixes - The reference to AdvertisedPublicPrefixes.
	AdvertisedPublicPrefixes *[]string `json:"advertisedPublicPrefixes,omitempty"`
	// AdvertisedCommunities - The communities of bgp peering. Specified for microsoft peering.
	AdvertisedCommunities *[]string `json:"advertisedCommunities,omitempty"`
	// AdvertisedPublicPrefixesState - READ-ONLY; The advertised public prefix state of the Peering resource. Possible values include: 'ExpressRouteCircuitPeeringAdvertisedPublicPrefixStateNotConfigured', 'ExpressRouteCircuitPeeringAdvertisedPublicPrefixStateConfiguring', 'ExpressRouteCircuitPeeringAdvertisedPublicPrefixStateConfigured', 'ExpressRouteCircuitPeeringAdvertisedPublicPrefixStateValidationNeeded'
	AdvertisedPublicPrefixesState ExpressRouteCircuitPeeringAdvertisedPublicPrefixState `json:"advertisedPublicPrefixesState,omitempty"`
	// LegacyMode - The legacy mode of the peering.
	LegacyMode *int32 `json:"legacyMode,omitempty"`
	// CustomerASN - The CustomerASN of the peering.
	CustomerASN *int32 `json:"customerASN,omitempty"`
	// RoutingRegistryName - The RoutingRegistryName of the configuration.
	RoutingRegistryName *string `json:"routingRegistryName,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCircuitPeeringConfig.
func (ercpc ExpressRouteCircuitPeeringConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ercpc.AdvertisedPublicPrefixes != nil {
		objectMap["advertisedPublicPrefixes"] = ercpc.AdvertisedPublicPrefixes
	}
	if ercpc.AdvertisedCommunities != nil {
		objectMap["advertisedCommunities"] = ercpc.AdvertisedCommunities
	}
	if ercpc.LegacyMode != nil {
		objectMap["legacyMode"] = ercpc.LegacyMode
	}
	if ercpc.CustomerASN != nil {
		objectMap["customerASN"] = ercpc.CustomerASN
	}
	if ercpc.RoutingRegistryName != nil {
		objectMap["routingRegistryName"] = ercpc.RoutingRegistryName
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCircuitPeeringID expressRoute circuit peering identifier.
type ExpressRouteCircuitPeeringID struct {
	// ID - The ID of the ExpressRoute circuit peering.
	ID *string `json:"id,omitempty"`
}

// ExpressRouteCircuitPeeringListResult response for ListPeering API service call retrieves all peerings
// that belong to an ExpressRouteCircuit.
type ExpressRouteCircuitPeeringListResult struct {
	autorest.Response `json:"-"`
	// Value - The peerings in an express route circuit.
	Value *[]ExpressRouteCircuitPeering `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRouteCircuitPeeringListResultIterator provides access to a complete listing of
// ExpressRouteCircuitPeering values.
type ExpressRouteCircuitPeeringListResultIterator struct {
	i    int
	page ExpressRouteCircuitPeeringListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRouteCircuitPeeringListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCircuitPeeringListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRouteCircuitPeeringListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRouteCircuitPeeringListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRouteCircuitPeeringListResultIterator) Response() ExpressRouteCircuitPeeringListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRouteCircuitPeeringListResultIterator) Value() ExpressRouteCircuitPeering {
	if !iter.page.NotDone() {
		return ExpressRouteCircuitPeering{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRouteCircuitPeeringListResultIterator type.
func NewExpressRouteCircuitPeeringListResultIterator(page ExpressRouteCircuitPeeringListResultPage) ExpressRouteCircuitPeeringListResultIterator {
	return ExpressRouteCircuitPeeringListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ercplr ExpressRouteCircuitPeeringListResult) IsEmpty() bool {
	return ercplr.Value == nil || len(*ercplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ercplr ExpressRouteCircuitPeeringListResult) hasNextLink() bool {
	return ercplr.NextLink != nil && len(*ercplr.NextLink) != 0
}

// expressRouteCircuitPeeringListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ercplr ExpressRouteCircuitPeeringListResult) expressRouteCircuitPeeringListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ercplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ercplr.NextLink)))
}

// ExpressRouteCircuitPeeringListResultPage contains a page of ExpressRouteCircuitPeering values.
type ExpressRouteCircuitPeeringListResultPage struct {
	fn     func(context.Context, ExpressRouteCircuitPeeringListResult) (ExpressRouteCircuitPeeringListResult, error)
	ercplr ExpressRouteCircuitPeeringListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRouteCircuitPeeringListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCircuitPeeringListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ercplr)
		if err != nil {
			return err
		}
		page.ercplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRouteCircuitPeeringListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRouteCircuitPeeringListResultPage) NotDone() bool {
	return !page.ercplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRouteCircuitPeeringListResultPage) Response() ExpressRouteCircuitPeeringListResult {
	return page.ercplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRouteCircuitPeeringListResultPage) Values() []ExpressRouteCircuitPeering {
	if page.ercplr.IsEmpty() {
		return nil
	}
	return *page.ercplr.Value
}

// Creates a new instance of the ExpressRouteCircuitPeeringListResultPage type.
func NewExpressRouteCircuitPeeringListResultPage(cur ExpressRouteCircuitPeeringListResult, getNextPage func(context.Context, ExpressRouteCircuitPeeringListResult) (ExpressRouteCircuitPeeringListResult, error)) ExpressRouteCircuitPeeringListResultPage {
	return ExpressRouteCircuitPeeringListResultPage{
		fn:     getNextPage,
		ercplr: cur,
	}
}

// ExpressRouteCircuitPeeringPropertiesFormat properties of the express route circuit peering.
type ExpressRouteCircuitPeeringPropertiesFormat struct {
	// PeeringType - The peering type. Possible values include: 'ExpressRoutePeeringTypeAzurePublicPeering', 'ExpressRoutePeeringTypeAzurePrivatePeering', 'ExpressRoutePeeringTypeMicrosoftPeering'
	PeeringType ExpressRoutePeeringType `json:"peeringType,omitempty"`
	// State - The peering state. Possible values include: 'ExpressRoutePeeringStateDisabled', 'ExpressRoutePeeringStateEnabled'
	State ExpressRoutePeeringState `json:"state,omitempty"`
	// AzureASN - The Azure ASN.
	AzureASN *int32 `json:"azureASN,omitempty"`
	// PeerASN - The peer ASN.
	PeerASN *int64 `json:"peerASN,omitempty"`
	// PrimaryPeerAddressPrefix - The primary address prefix.
	PrimaryPeerAddressPrefix *string `json:"primaryPeerAddressPrefix,omitempty"`
	// SecondaryPeerAddressPrefix - The secondary address prefix.
	SecondaryPeerAddressPrefix *string `json:"secondaryPeerAddressPrefix,omitempty"`
	// PrimaryAzurePort - The primary port.
	PrimaryAzurePort *string `json:"primaryAzurePort,omitempty"`
	// SecondaryAzurePort - The secondary port.
	SecondaryAzurePort *string `json:"secondaryAzurePort,omitempty"`
	// SharedKey - The shared key.
	SharedKey *string `json:"sharedKey,omitempty"`
	// VlanID - The VLAN ID.
	VlanID *int32 `json:"vlanId,omitempty"`
	// MicrosoftPeeringConfig - The Microsoft peering configuration.
	MicrosoftPeeringConfig *ExpressRouteCircuitPeeringConfig `json:"microsoftPeeringConfig,omitempty"`
	// Stats - The peering stats of express route circuit.
	Stats *ExpressRouteCircuitStats `json:"stats,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route circuit peering resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// GatewayManagerEtag - The GatewayManager Etag.
	GatewayManagerEtag *string `json:"gatewayManagerEtag,omitempty"`
	// LastModifiedBy - READ-ONLY; Who was the last to modify the peering.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// RouteFilter - The reference to the RouteFilter resource.
	RouteFilter *SubResource `json:"routeFilter,omitempty"`
	// Ipv6PeeringConfig - The IPv6 peering configuration.
	Ipv6PeeringConfig *Ipv6ExpressRouteCircuitPeeringConfig `json:"ipv6PeeringConfig,omitempty"`
	// ExpressRouteConnection - The ExpressRoute connection.
	ExpressRouteConnection *ExpressRouteConnectionID `json:"expressRouteConnection,omitempty"`
	// Connections - The list of circuit connections associated with Azure Private Peering for this circuit.
	Connections *[]ExpressRouteCircuitConnection `json:"connections,omitempty"`
	// PeeredConnections - READ-ONLY; The list of peered circuit connections associated with Azure Private Peering for this circuit.
	PeeredConnections *[]PeerExpressRouteCircuitConnection `json:"peeredConnections,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCircuitPeeringPropertiesFormat.
func (ercppf ExpressRouteCircuitPeeringPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ercppf.PeeringType != "" {
		objectMap["peeringType"] = ercppf.PeeringType
	}
	if ercppf.State != "" {
		objectMap["state"] = ercppf.State
	}
	if ercppf.AzureASN != nil {
		objectMap["azureASN"] = ercppf.AzureASN
	}
	if ercppf.PeerASN != nil {
		objectMap["peerASN"] = ercppf.PeerASN
	}
	if ercppf.PrimaryPeerAddressPrefix != nil {
		objectMap["primaryPeerAddressPrefix"] = ercppf.PrimaryPeerAddressPrefix
	}
	if ercppf.SecondaryPeerAddressPrefix != nil {
		objectMap["secondaryPeerAddressPrefix"] = ercppf.SecondaryPeerAddressPrefix
	}
	if ercppf.PrimaryAzurePort != nil {
		objectMap["primaryAzurePort"] = ercppf.PrimaryAzurePort
	}
	if ercppf.SecondaryAzurePort != nil {
		objectMap["secondaryAzurePort"] = ercppf.SecondaryAzurePort
	}
	if ercppf.SharedKey != nil {
		objectMap["sharedKey"] = ercppf.SharedKey
	}
	if ercppf.VlanID != nil {
		objectMap["vlanId"] = ercppf.VlanID
	}
	if ercppf.MicrosoftPeeringConfig != nil {
		objectMap["microsoftPeeringConfig"] = ercppf.MicrosoftPeeringConfig
	}
	if ercppf.Stats != nil {
		objectMap["stats"] = ercppf.Stats
	}
	if ercppf.GatewayManagerEtag != nil {
		objectMap["gatewayManagerEtag"] = ercppf.GatewayManagerEtag
	}
	if ercppf.RouteFilter != nil {
		objectMap["routeFilter"] = ercppf.RouteFilter
	}
	if ercppf.Ipv6PeeringConfig != nil {
		objectMap["ipv6PeeringConfig"] = ercppf.Ipv6PeeringConfig
	}
	if ercppf.ExpressRouteConnection != nil {
		objectMap["expressRouteConnection"] = ercppf.ExpressRouteConnection
	}
	if ercppf.Connections != nil {
		objectMap["connections"] = ercppf.Connections
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCircuitPeeringsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type ExpressRouteCircuitPeeringsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitPeeringsClient) (ExpressRouteCircuitPeering, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitPeeringsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitPeeringsCreateOrUpdateFuture.Result.
func (future *ExpressRouteCircuitPeeringsCreateOrUpdateFuture) result(client ExpressRouteCircuitPeeringsClient) (ercp ExpressRouteCircuitPeering, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitPeeringsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ercp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitPeeringsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ercp.Response.Response, err = future.GetResult(sender); err == nil && ercp.Response.Response.StatusCode != http.StatusNoContent {
		ercp, err = client.CreateOrUpdateResponder(ercp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitPeeringsCreateOrUpdateFuture", "Result", ercp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCircuitPeeringsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteCircuitPeeringsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitPeeringsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitPeeringsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitPeeringsDeleteFuture.Result.
func (future *ExpressRouteCircuitPeeringsDeleteFuture) result(client ExpressRouteCircuitPeeringsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitPeeringsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitPeeringsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExpressRouteCircuitPropertiesFormat properties of ExpressRouteCircuit.
type ExpressRouteCircuitPropertiesFormat struct {
	// AllowClassicOperations - Allow classic operations.
	AllowClassicOperations *bool `json:"allowClassicOperations,omitempty"`
	// CircuitProvisioningState - The CircuitProvisioningState state of the resource.
	CircuitProvisioningState *string `json:"circuitProvisioningState,omitempty"`
	// ServiceProviderProvisioningState - The ServiceProviderProvisioningState state of the resource. Possible values include: 'ServiceProviderProvisioningStateNotProvisioned', 'ServiceProviderProvisioningStateProvisioning', 'ServiceProviderProvisioningStateProvisioned', 'ServiceProviderProvisioningStateDeprovisioning'
	ServiceProviderProvisioningState ServiceProviderProvisioningState `json:"serviceProviderProvisioningState,omitempty"`
	// Authorizations - The list of authorizations.
	Authorizations *[]ExpressRouteCircuitAuthorization `json:"authorizations,omitempty"`
	// Peerings - The list of peerings.
	Peerings *[]ExpressRouteCircuitPeering `json:"peerings,omitempty"`
	// ServiceKey - The ServiceKey.
	ServiceKey *string `json:"serviceKey,omitempty"`
	// ServiceProviderNotes - The ServiceProviderNotes.
	ServiceProviderNotes *string `json:"serviceProviderNotes,omitempty"`
	// ServiceProviderProperties - The ServiceProviderProperties.
	ServiceProviderProperties *ExpressRouteCircuitServiceProviderProperties `json:"serviceProviderProperties,omitempty"`
	// ExpressRoutePort - The reference to the ExpressRoutePort resource when the circuit is provisioned on an ExpressRoutePort resource.
	ExpressRoutePort *SubResource `json:"expressRoutePort,omitempty"`
	// BandwidthInGbps - The bandwidth of the circuit when the circuit is provisioned on an ExpressRoutePort resource.
	BandwidthInGbps *float64 `json:"bandwidthInGbps,omitempty"`
	// Stag - READ-ONLY; The identifier of the circuit traffic. Outer tag for QinQ encapsulation.
	Stag *int32 `json:"stag,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route circuit resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// GatewayManagerEtag - The GatewayManager Etag.
	GatewayManagerEtag *string `json:"gatewayManagerEtag,omitempty"`
	// GlobalReachEnabled - Flag denoting global reach status.
	GlobalReachEnabled *bool `json:"globalReachEnabled,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCircuitPropertiesFormat.
func (ercpf ExpressRouteCircuitPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ercpf.AllowClassicOperations != nil {
		objectMap["allowClassicOperations"] = ercpf.AllowClassicOperations
	}
	if ercpf.CircuitProvisioningState != nil {
		objectMap["circuitProvisioningState"] = ercpf.CircuitProvisioningState
	}
	if ercpf.ServiceProviderProvisioningState != "" {
		objectMap["serviceProviderProvisioningState"] = ercpf.ServiceProviderProvisioningState
	}
	if ercpf.Authorizations != nil {
		objectMap["authorizations"] = ercpf.Authorizations
	}
	if ercpf.Peerings != nil {
		objectMap["peerings"] = ercpf.Peerings
	}
	if ercpf.ServiceKey != nil {
		objectMap["serviceKey"] = ercpf.ServiceKey
	}
	if ercpf.ServiceProviderNotes != nil {
		objectMap["serviceProviderNotes"] = ercpf.ServiceProviderNotes
	}
	if ercpf.ServiceProviderProperties != nil {
		objectMap["serviceProviderProperties"] = ercpf.ServiceProviderProperties
	}
	if ercpf.ExpressRoutePort != nil {
		objectMap["expressRoutePort"] = ercpf.ExpressRoutePort
	}
	if ercpf.BandwidthInGbps != nil {
		objectMap["bandwidthInGbps"] = ercpf.BandwidthInGbps
	}
	if ercpf.GatewayManagerEtag != nil {
		objectMap["gatewayManagerEtag"] = ercpf.GatewayManagerEtag
	}
	if ercpf.GlobalReachEnabled != nil {
		objectMap["globalReachEnabled"] = ercpf.GlobalReachEnabled
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCircuitReference reference to an express route circuit.
type ExpressRouteCircuitReference struct {
	// ID - Corresponding Express Route Circuit Id.
	ID *string `json:"id,omitempty"`
}

// ExpressRouteCircuitRoutesTable the routes table associated with the ExpressRouteCircuit.
type ExpressRouteCircuitRoutesTable struct {
	// NetworkProperty - IP address of a network entity.
	NetworkProperty *string `json:"network,omitempty"`
	// NextHop - NextHop address.
	NextHop *string `json:"nextHop,omitempty"`
	// LocPrf - Local preference value as set with the set local-preference route-map configuration command.
	LocPrf *string `json:"locPrf,omitempty"`
	// Weight - Route Weight.
	Weight *int32 `json:"weight,omitempty"`
	// Path - Autonomous system paths to the destination network.
	Path *string `json:"path,omitempty"`
}

// ExpressRouteCircuitRoutesTableSummary the routes table associated with the ExpressRouteCircuit.
type ExpressRouteCircuitRoutesTableSummary struct {
	// Neighbor - IP address of the neighbor.
	Neighbor *string `json:"neighbor,omitempty"`
	// V - BGP version number spoken to the neighbor.
	V *int32 `json:"v,omitempty"`
	// As - Autonomous system number.
	As *int32 `json:"as,omitempty"`
	// UpDown - The length of time that the BGP session has been in the Established state, or the current status if not in the Established state.
	UpDown *string `json:"upDown,omitempty"`
	// StatePfxRcd - Current state of the BGP session, and the number of prefixes that have been received from a neighbor or peer group.
	StatePfxRcd *string `json:"statePfxRcd,omitempty"`
}

// ExpressRouteCircuitsArpTableListResult response for ListArpTable associated with the Express Route
// Circuits API.
type ExpressRouteCircuitsArpTableListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of the ARP tables.
	Value *[]ExpressRouteCircuitArpTable `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRouteCircuitsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteCircuitsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitsClient) (ExpressRouteCircuit, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitsCreateOrUpdateFuture.Result.
func (future *ExpressRouteCircuitsCreateOrUpdateFuture) result(client ExpressRouteCircuitsClient) (erc ExpressRouteCircuit, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erc.Response.Response, err = future.GetResult(sender); err == nil && erc.Response.Response.StatusCode != http.StatusNoContent {
		erc, err = client.CreateOrUpdateResponder(erc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsCreateOrUpdateFuture", "Result", erc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCircuitsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteCircuitsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitsDeleteFuture.Result.
func (future *ExpressRouteCircuitsDeleteFuture) result(client ExpressRouteCircuitsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExpressRouteCircuitServiceProviderProperties contains ServiceProviderProperties in an
// ExpressRouteCircuit.
type ExpressRouteCircuitServiceProviderProperties struct {
	// ServiceProviderName - The serviceProviderName.
	ServiceProviderName *string `json:"serviceProviderName,omitempty"`
	// PeeringLocation - The peering location.
	PeeringLocation *string `json:"peeringLocation,omitempty"`
	// BandwidthInMbps - The BandwidthInMbps.
	BandwidthInMbps *int32 `json:"bandwidthInMbps,omitempty"`
}

// ExpressRouteCircuitSku contains SKU in an ExpressRouteCircuit.
type ExpressRouteCircuitSku struct {
	// Name - The name of the SKU.
	Name *string `json:"name,omitempty"`
	// Tier - The tier of the SKU. Possible values include: 'ExpressRouteCircuitSkuTierStandard', 'ExpressRouteCircuitSkuTierPremium', 'ExpressRouteCircuitSkuTierBasic', 'ExpressRouteCircuitSkuTierLocal'
	Tier ExpressRouteCircuitSkuTier `json:"tier,omitempty"`
	// Family - The family of the SKU. Possible values include: 'ExpressRouteCircuitSkuFamilyUnlimitedData', 'ExpressRouteCircuitSkuFamilyMeteredData'
	Family ExpressRouteCircuitSkuFamily `json:"family,omitempty"`
}

// ExpressRouteCircuitsListArpTableFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteCircuitsListArpTableFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitsClient) (ExpressRouteCircuitsArpTableListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitsListArpTableFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitsListArpTableFuture.Result.
func (future *ExpressRouteCircuitsListArpTableFuture) result(client ExpressRouteCircuitsClient) (ercatlr ExpressRouteCircuitsArpTableListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsListArpTableFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ercatlr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitsListArpTableFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ercatlr.Response.Response, err = future.GetResult(sender); err == nil && ercatlr.Response.Response.StatusCode != http.StatusNoContent {
		ercatlr, err = client.ListArpTableResponder(ercatlr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsListArpTableFuture", "Result", ercatlr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCircuitsListRoutesTableFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteCircuitsListRoutesTableFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitsClient) (ExpressRouteCircuitsRoutesTableListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitsListRoutesTableFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitsListRoutesTableFuture.Result.
func (future *ExpressRouteCircuitsListRoutesTableFuture) result(client ExpressRouteCircuitsClient) (ercrtlr ExpressRouteCircuitsRoutesTableListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsListRoutesTableFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ercrtlr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitsListRoutesTableFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ercrtlr.Response.Response, err = future.GetResult(sender); err == nil && ercrtlr.Response.Response.StatusCode != http.StatusNoContent {
		ercrtlr, err = client.ListRoutesTableResponder(ercrtlr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsListRoutesTableFuture", "Result", ercrtlr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCircuitsListRoutesTableSummaryFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type ExpressRouteCircuitsListRoutesTableSummaryFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCircuitsClient) (ExpressRouteCircuitsRoutesTableSummaryListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCircuitsListRoutesTableSummaryFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCircuitsListRoutesTableSummaryFuture.Result.
func (future *ExpressRouteCircuitsListRoutesTableSummaryFuture) result(client ExpressRouteCircuitsClient) (ercrtslr ExpressRouteCircuitsRoutesTableSummaryListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsListRoutesTableSummaryFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ercrtslr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCircuitsListRoutesTableSummaryFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ercrtslr.Response.Response, err = future.GetResult(sender); err == nil && ercrtslr.Response.Response.StatusCode != http.StatusNoContent {
		ercrtslr, err = client.ListRoutesTableSummaryResponder(ercrtslr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCircuitsListRoutesTableSummaryFuture", "Result", ercrtslr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCircuitsRoutesTableListResult response for ListRoutesTable associated with the Express Route
// Circuits API.
type ExpressRouteCircuitsRoutesTableListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of routes table.
	Value *[]ExpressRouteCircuitRoutesTable `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRouteCircuitsRoutesTableSummaryListResult response for ListRoutesTable associated with the
// Express Route Circuits API.
type ExpressRouteCircuitsRoutesTableSummaryListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of the routes table.
	Value *[]ExpressRouteCircuitRoutesTableSummary `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRouteCircuitStats contains stats associated with the peering.
type ExpressRouteCircuitStats struct {
	autorest.Response `json:"-"`
	// PrimarybytesIn - The Primary BytesIn of the peering.
	PrimarybytesIn *int64 `json:"primarybytesIn,omitempty"`
	// PrimarybytesOut - The primary BytesOut of the peering.
	PrimarybytesOut *int64 `json:"primarybytesOut,omitempty"`
	// SecondarybytesIn - The secondary BytesIn of the peering.
	SecondarybytesIn *int64 `json:"secondarybytesIn,omitempty"`
	// SecondarybytesOut - The secondary BytesOut of the peering.
	SecondarybytesOut *int64 `json:"secondarybytesOut,omitempty"`
}

// ExpressRouteConnection expressRouteConnection resource.
type ExpressRouteConnection struct {
	autorest.Response `json:"-"`
	// ExpressRouteConnectionProperties - Properties of the express route connection.
	*ExpressRouteConnectionProperties `json:"properties,omitempty"`
	// Name - The name of the resource.
	Name *string `json:"name,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteConnection.
func (erc ExpressRouteConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erc.ExpressRouteConnectionProperties != nil {
		objectMap["properties"] = erc.ExpressRouteConnectionProperties
	}
	if erc.Name != nil {
		objectMap["name"] = erc.Name
	}
	if erc.ID != nil {
		objectMap["id"] = erc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteConnection struct.
func (erc *ExpressRouteConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRouteConnectionProperties ExpressRouteConnectionProperties
				err = json.Unmarshal(*v, &expressRouteConnectionProperties)
				if err != nil {
					return err
				}
				erc.ExpressRouteConnectionProperties = &expressRouteConnectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				erc.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				erc.ID = &ID
			}
		}
	}

	return nil
}

// ExpressRouteConnectionID the ID of the ExpressRouteConnection.
type ExpressRouteConnectionID struct {
	// ID - READ-ONLY; The ID of the ExpressRouteConnection.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteConnectionID.
func (erci ExpressRouteConnectionID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ExpressRouteConnectionList expressRouteConnection list.
type ExpressRouteConnectionList struct {
	autorest.Response `json:"-"`
	// Value - The list of ExpressRoute connections.
	Value *[]ExpressRouteConnection `json:"value,omitempty"`
}

// ExpressRouteConnectionProperties properties of the ExpressRouteConnection subresource.
type ExpressRouteConnectionProperties struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the express route connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ExpressRouteCircuitPeering - The ExpressRoute circuit peering.
	ExpressRouteCircuitPeering *ExpressRouteCircuitPeeringID `json:"expressRouteCircuitPeering,omitempty"`
	// AuthorizationKey - Authorization key to establish the connection.
	AuthorizationKey *string `json:"authorizationKey,omitempty"`
	// RoutingWeight - The routing weight associated to the connection.
	RoutingWeight *int32 `json:"routingWeight,omitempty"`
	// EnableInternetSecurity - Enable internet security.
	EnableInternetSecurity *bool `json:"enableInternetSecurity,omitempty"`
	// ExpressRouteGatewayBypass - Enable FastPath to vWan Firewall hub.
	ExpressRouteGatewayBypass *bool `json:"expressRouteGatewayBypass,omitempty"`
	// RoutingConfiguration - The Routing Configuration indicating the associated and propagated route tables on this connection.
	RoutingConfiguration *RoutingConfiguration `json:"routingConfiguration,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteConnectionProperties.
func (ercp ExpressRouteConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ercp.ExpressRouteCircuitPeering != nil {
		objectMap["expressRouteCircuitPeering"] = ercp.ExpressRouteCircuitPeering
	}
	if ercp.AuthorizationKey != nil {
		objectMap["authorizationKey"] = ercp.AuthorizationKey
	}
	if ercp.RoutingWeight != nil {
		objectMap["routingWeight"] = ercp.RoutingWeight
	}
	if ercp.EnableInternetSecurity != nil {
		objectMap["enableInternetSecurity"] = ercp.EnableInternetSecurity
	}
	if ercp.ExpressRouteGatewayBypass != nil {
		objectMap["expressRouteGatewayBypass"] = ercp.ExpressRouteGatewayBypass
	}
	if ercp.RoutingConfiguration != nil {
		objectMap["routingConfiguration"] = ercp.RoutingConfiguration
	}
	return json.Marshal(objectMap)
}

// ExpressRouteConnectionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type ExpressRouteConnectionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteConnectionsClient) (ExpressRouteConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteConnectionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteConnectionsCreateOrUpdateFuture.Result.
func (future *ExpressRouteConnectionsCreateOrUpdateFuture) result(client ExpressRouteConnectionsClient) (erc ExpressRouteConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteConnectionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteConnectionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erc.Response.Response, err = future.GetResult(sender); err == nil && erc.Response.Response.StatusCode != http.StatusNoContent {
		erc, err = client.CreateOrUpdateResponder(erc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteConnectionsCreateOrUpdateFuture", "Result", erc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteConnectionsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteConnectionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteConnectionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteConnectionsDeleteFuture.Result.
func (future *ExpressRouteConnectionsDeleteFuture) result(client ExpressRouteConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteConnectionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteConnectionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExpressRouteCrossConnection expressRouteCrossConnection resource.
type ExpressRouteCrossConnection struct {
	autorest.Response `json:"-"`
	// ExpressRouteCrossConnectionProperties - Properties of the express route cross connection.
	*ExpressRouteCrossConnectionProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCrossConnection.
func (ercc ExpressRouteCrossConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ercc.ExpressRouteCrossConnectionProperties != nil {
		objectMap["properties"] = ercc.ExpressRouteCrossConnectionProperties
	}
	if ercc.ID != nil {
		objectMap["id"] = ercc.ID
	}
	if ercc.Location != nil {
		objectMap["location"] = ercc.Location
	}
	if ercc.Tags != nil {
		objectMap["tags"] = ercc.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteCrossConnection struct.
func (ercc *ExpressRouteCrossConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRouteCrossConnectionProperties ExpressRouteCrossConnectionProperties
				err = json.Unmarshal(*v, &expressRouteCrossConnectionProperties)
				if err != nil {
					return err
				}
				ercc.ExpressRouteCrossConnectionProperties = &expressRouteCrossConnectionProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ercc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ercc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ercc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ercc.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ercc.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ercc.Tags = tags
			}
		}
	}

	return nil
}

// ExpressRouteCrossConnectionListResult response for ListExpressRouteCrossConnection API service call.
type ExpressRouteCrossConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of ExpressRouteCrossConnection resources.
	Value *[]ExpressRouteCrossConnection `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCrossConnectionListResult.
func (ercclr ExpressRouteCrossConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ercclr.Value != nil {
		objectMap["value"] = ercclr.Value
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCrossConnectionListResultIterator provides access to a complete listing of
// ExpressRouteCrossConnection values.
type ExpressRouteCrossConnectionListResultIterator struct {
	i    int
	page ExpressRouteCrossConnectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRouteCrossConnectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCrossConnectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRouteCrossConnectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRouteCrossConnectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRouteCrossConnectionListResultIterator) Response() ExpressRouteCrossConnectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRouteCrossConnectionListResultIterator) Value() ExpressRouteCrossConnection {
	if !iter.page.NotDone() {
		return ExpressRouteCrossConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRouteCrossConnectionListResultIterator type.
func NewExpressRouteCrossConnectionListResultIterator(page ExpressRouteCrossConnectionListResultPage) ExpressRouteCrossConnectionListResultIterator {
	return ExpressRouteCrossConnectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ercclr ExpressRouteCrossConnectionListResult) IsEmpty() bool {
	return ercclr.Value == nil || len(*ercclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ercclr ExpressRouteCrossConnectionListResult) hasNextLink() bool {
	return ercclr.NextLink != nil && len(*ercclr.NextLink) != 0
}

// expressRouteCrossConnectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ercclr ExpressRouteCrossConnectionListResult) expressRouteCrossConnectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ercclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ercclr.NextLink)))
}

// ExpressRouteCrossConnectionListResultPage contains a page of ExpressRouteCrossConnection values.
type ExpressRouteCrossConnectionListResultPage struct {
	fn     func(context.Context, ExpressRouteCrossConnectionListResult) (ExpressRouteCrossConnectionListResult, error)
	ercclr ExpressRouteCrossConnectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRouteCrossConnectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCrossConnectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ercclr)
		if err != nil {
			return err
		}
		page.ercclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRouteCrossConnectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRouteCrossConnectionListResultPage) NotDone() bool {
	return !page.ercclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRouteCrossConnectionListResultPage) Response() ExpressRouteCrossConnectionListResult {
	return page.ercclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRouteCrossConnectionListResultPage) Values() []ExpressRouteCrossConnection {
	if page.ercclr.IsEmpty() {
		return nil
	}
	return *page.ercclr.Value
}

// Creates a new instance of the ExpressRouteCrossConnectionListResultPage type.
func NewExpressRouteCrossConnectionListResultPage(cur ExpressRouteCrossConnectionListResult, getNextPage func(context.Context, ExpressRouteCrossConnectionListResult) (ExpressRouteCrossConnectionListResult, error)) ExpressRouteCrossConnectionListResultPage {
	return ExpressRouteCrossConnectionListResultPage{
		fn:     getNextPage,
		ercclr: cur,
	}
}

// ExpressRouteCrossConnectionPeering peering in an ExpressRoute Cross Connection resource.
type ExpressRouteCrossConnectionPeering struct {
	autorest.Response `json:"-"`
	// ExpressRouteCrossConnectionPeeringProperties - Properties of the express route cross connection peering.
	*ExpressRouteCrossConnectionPeeringProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCrossConnectionPeering.
func (erccp ExpressRouteCrossConnectionPeering) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erccp.ExpressRouteCrossConnectionPeeringProperties != nil {
		objectMap["properties"] = erccp.ExpressRouteCrossConnectionPeeringProperties
	}
	if erccp.Name != nil {
		objectMap["name"] = erccp.Name
	}
	if erccp.ID != nil {
		objectMap["id"] = erccp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteCrossConnectionPeering struct.
func (erccp *ExpressRouteCrossConnectionPeering) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRouteCrossConnectionPeeringProperties ExpressRouteCrossConnectionPeeringProperties
				err = json.Unmarshal(*v, &expressRouteCrossConnectionPeeringProperties)
				if err != nil {
					return err
				}
				erccp.ExpressRouteCrossConnectionPeeringProperties = &expressRouteCrossConnectionPeeringProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				erccp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				erccp.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				erccp.ID = &ID
			}
		}
	}

	return nil
}

// ExpressRouteCrossConnectionPeeringList response for ListPeering API service call retrieves all peerings
// that belong to an ExpressRouteCrossConnection.
type ExpressRouteCrossConnectionPeeringList struct {
	autorest.Response `json:"-"`
	// Value - The peerings in an express route cross connection.
	Value *[]ExpressRouteCrossConnectionPeering `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCrossConnectionPeeringList.
func (erccpl ExpressRouteCrossConnectionPeeringList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erccpl.Value != nil {
		objectMap["value"] = erccpl.Value
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCrossConnectionPeeringListIterator provides access to a complete listing of
// ExpressRouteCrossConnectionPeering values.
type ExpressRouteCrossConnectionPeeringListIterator struct {
	i    int
	page ExpressRouteCrossConnectionPeeringListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRouteCrossConnectionPeeringListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCrossConnectionPeeringListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRouteCrossConnectionPeeringListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRouteCrossConnectionPeeringListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRouteCrossConnectionPeeringListIterator) Response() ExpressRouteCrossConnectionPeeringList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRouteCrossConnectionPeeringListIterator) Value() ExpressRouteCrossConnectionPeering {
	if !iter.page.NotDone() {
		return ExpressRouteCrossConnectionPeering{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRouteCrossConnectionPeeringListIterator type.
func NewExpressRouteCrossConnectionPeeringListIterator(page ExpressRouteCrossConnectionPeeringListPage) ExpressRouteCrossConnectionPeeringListIterator {
	return ExpressRouteCrossConnectionPeeringListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (erccpl ExpressRouteCrossConnectionPeeringList) IsEmpty() bool {
	return erccpl.Value == nil || len(*erccpl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (erccpl ExpressRouteCrossConnectionPeeringList) hasNextLink() bool {
	return erccpl.NextLink != nil && len(*erccpl.NextLink) != 0
}

// expressRouteCrossConnectionPeeringListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (erccpl ExpressRouteCrossConnectionPeeringList) expressRouteCrossConnectionPeeringListPreparer(ctx context.Context) (*http.Request, error) {
	if !erccpl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(erccpl.NextLink)))
}

// ExpressRouteCrossConnectionPeeringListPage contains a page of ExpressRouteCrossConnectionPeering values.
type ExpressRouteCrossConnectionPeeringListPage struct {
	fn     func(context.Context, ExpressRouteCrossConnectionPeeringList) (ExpressRouteCrossConnectionPeeringList, error)
	erccpl ExpressRouteCrossConnectionPeeringList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRouteCrossConnectionPeeringListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteCrossConnectionPeeringListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.erccpl)
		if err != nil {
			return err
		}
		page.erccpl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRouteCrossConnectionPeeringListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRouteCrossConnectionPeeringListPage) NotDone() bool {
	return !page.erccpl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRouteCrossConnectionPeeringListPage) Response() ExpressRouteCrossConnectionPeeringList {
	return page.erccpl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRouteCrossConnectionPeeringListPage) Values() []ExpressRouteCrossConnectionPeering {
	if page.erccpl.IsEmpty() {
		return nil
	}
	return *page.erccpl.Value
}

// Creates a new instance of the ExpressRouteCrossConnectionPeeringListPage type.
func NewExpressRouteCrossConnectionPeeringListPage(cur ExpressRouteCrossConnectionPeeringList, getNextPage func(context.Context, ExpressRouteCrossConnectionPeeringList) (ExpressRouteCrossConnectionPeeringList, error)) ExpressRouteCrossConnectionPeeringListPage {
	return ExpressRouteCrossConnectionPeeringListPage{
		fn:     getNextPage,
		erccpl: cur,
	}
}

// ExpressRouteCrossConnectionPeeringProperties properties of express route cross connection peering.
type ExpressRouteCrossConnectionPeeringProperties struct {
	// PeeringType - The peering type. Possible values include: 'ExpressRoutePeeringTypeAzurePublicPeering', 'ExpressRoutePeeringTypeAzurePrivatePeering', 'ExpressRoutePeeringTypeMicrosoftPeering'
	PeeringType ExpressRoutePeeringType `json:"peeringType,omitempty"`
	// State - The peering state. Possible values include: 'ExpressRoutePeeringStateDisabled', 'ExpressRoutePeeringStateEnabled'
	State ExpressRoutePeeringState `json:"state,omitempty"`
	// AzureASN - READ-ONLY; The Azure ASN.
	AzureASN *int32 `json:"azureASN,omitempty"`
	// PeerASN - The peer ASN.
	PeerASN *int64 `json:"peerASN,omitempty"`
	// PrimaryPeerAddressPrefix - The primary address prefix.
	PrimaryPeerAddressPrefix *string `json:"primaryPeerAddressPrefix,omitempty"`
	// SecondaryPeerAddressPrefix - The secondary address prefix.
	SecondaryPeerAddressPrefix *string `json:"secondaryPeerAddressPrefix,omitempty"`
	// PrimaryAzurePort - READ-ONLY; The primary port.
	PrimaryAzurePort *string `json:"primaryAzurePort,omitempty"`
	// SecondaryAzurePort - READ-ONLY; The secondary port.
	SecondaryAzurePort *string `json:"secondaryAzurePort,omitempty"`
	// SharedKey - The shared key.
	SharedKey *string `json:"sharedKey,omitempty"`
	// VlanID - The VLAN ID.
	VlanID *int32 `json:"vlanId,omitempty"`
	// MicrosoftPeeringConfig - The Microsoft peering configuration.
	MicrosoftPeeringConfig *ExpressRouteCircuitPeeringConfig `json:"microsoftPeeringConfig,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route cross connection peering resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// GatewayManagerEtag - The GatewayManager Etag.
	GatewayManagerEtag *string `json:"gatewayManagerEtag,omitempty"`
	// LastModifiedBy - READ-ONLY; Who was the last to modify the peering.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// Ipv6PeeringConfig - The IPv6 peering configuration.
	Ipv6PeeringConfig *Ipv6ExpressRouteCircuitPeeringConfig `json:"ipv6PeeringConfig,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCrossConnectionPeeringProperties.
func (erccpp ExpressRouteCrossConnectionPeeringProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erccpp.PeeringType != "" {
		objectMap["peeringType"] = erccpp.PeeringType
	}
	if erccpp.State != "" {
		objectMap["state"] = erccpp.State
	}
	if erccpp.PeerASN != nil {
		objectMap["peerASN"] = erccpp.PeerASN
	}
	if erccpp.PrimaryPeerAddressPrefix != nil {
		objectMap["primaryPeerAddressPrefix"] = erccpp.PrimaryPeerAddressPrefix
	}
	if erccpp.SecondaryPeerAddressPrefix != nil {
		objectMap["secondaryPeerAddressPrefix"] = erccpp.SecondaryPeerAddressPrefix
	}
	if erccpp.SharedKey != nil {
		objectMap["sharedKey"] = erccpp.SharedKey
	}
	if erccpp.VlanID != nil {
		objectMap["vlanId"] = erccpp.VlanID
	}
	if erccpp.MicrosoftPeeringConfig != nil {
		objectMap["microsoftPeeringConfig"] = erccpp.MicrosoftPeeringConfig
	}
	if erccpp.GatewayManagerEtag != nil {
		objectMap["gatewayManagerEtag"] = erccpp.GatewayManagerEtag
	}
	if erccpp.Ipv6PeeringConfig != nil {
		objectMap["ipv6PeeringConfig"] = erccpp.Ipv6PeeringConfig
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCrossConnectionPeeringsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type ExpressRouteCrossConnectionPeeringsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCrossConnectionPeeringsClient) (ExpressRouteCrossConnectionPeering, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCrossConnectionPeeringsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCrossConnectionPeeringsCreateOrUpdateFuture.Result.
func (future *ExpressRouteCrossConnectionPeeringsCreateOrUpdateFuture) result(client ExpressRouteCrossConnectionPeeringsClient) (erccp ExpressRouteCrossConnectionPeering, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionPeeringsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erccp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCrossConnectionPeeringsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erccp.Response.Response, err = future.GetResult(sender); err == nil && erccp.Response.Response.StatusCode != http.StatusNoContent {
		erccp, err = client.CreateOrUpdateResponder(erccp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionPeeringsCreateOrUpdateFuture", "Result", erccp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCrossConnectionPeeringsDeleteFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type ExpressRouteCrossConnectionPeeringsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCrossConnectionPeeringsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCrossConnectionPeeringsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCrossConnectionPeeringsDeleteFuture.Result.
func (future *ExpressRouteCrossConnectionPeeringsDeleteFuture) result(client ExpressRouteCrossConnectionPeeringsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionPeeringsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCrossConnectionPeeringsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExpressRouteCrossConnectionProperties properties of ExpressRouteCrossConnection.
type ExpressRouteCrossConnectionProperties struct {
	// PrimaryAzurePort - READ-ONLY; The name of the primary port.
	PrimaryAzurePort *string `json:"primaryAzurePort,omitempty"`
	// SecondaryAzurePort - READ-ONLY; The name of the secondary port.
	SecondaryAzurePort *string `json:"secondaryAzurePort,omitempty"`
	// STag - READ-ONLY; The identifier of the circuit traffic.
	STag *int32 `json:"sTag,omitempty"`
	// PeeringLocation - READ-ONLY; The peering location of the ExpressRoute circuit.
	PeeringLocation *string `json:"peeringLocation,omitempty"`
	// BandwidthInMbps - READ-ONLY; The circuit bandwidth In Mbps.
	BandwidthInMbps *int32 `json:"bandwidthInMbps,omitempty"`
	// ExpressRouteCircuit - The ExpressRouteCircuit.
	ExpressRouteCircuit *ExpressRouteCircuitReference `json:"expressRouteCircuit,omitempty"`
	// ServiceProviderProvisioningState - The provisioning state of the circuit in the connectivity provider system. Possible values include: 'ServiceProviderProvisioningStateNotProvisioned', 'ServiceProviderProvisioningStateProvisioning', 'ServiceProviderProvisioningStateProvisioned', 'ServiceProviderProvisioningStateDeprovisioning'
	ServiceProviderProvisioningState ServiceProviderProvisioningState `json:"serviceProviderProvisioningState,omitempty"`
	// ServiceProviderNotes - Additional read only notes set by the connectivity provider.
	ServiceProviderNotes *string `json:"serviceProviderNotes,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route cross connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Peerings - The list of peerings.
	Peerings *[]ExpressRouteCrossConnectionPeering `json:"peerings,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCrossConnectionProperties.
func (erccp ExpressRouteCrossConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erccp.ExpressRouteCircuit != nil {
		objectMap["expressRouteCircuit"] = erccp.ExpressRouteCircuit
	}
	if erccp.ServiceProviderProvisioningState != "" {
		objectMap["serviceProviderProvisioningState"] = erccp.ServiceProviderProvisioningState
	}
	if erccp.ServiceProviderNotes != nil {
		objectMap["serviceProviderNotes"] = erccp.ServiceProviderNotes
	}
	if erccp.Peerings != nil {
		objectMap["peerings"] = erccp.Peerings
	}
	return json.Marshal(objectMap)
}

// ExpressRouteCrossConnectionRoutesTableSummary the routes table associated with the ExpressRouteCircuit.
type ExpressRouteCrossConnectionRoutesTableSummary struct {
	// Neighbor - IP address of Neighbor router.
	Neighbor *string `json:"neighbor,omitempty"`
	// Asn - Autonomous system number.
	Asn *int32 `json:"asn,omitempty"`
	// UpDown - The length of time that the BGP session has been in the Established state, or the current status if not in the Established state.
	UpDown *string `json:"upDown,omitempty"`
	// StateOrPrefixesReceived - Current state of the BGP session, and the number of prefixes that have been received from a neighbor or peer group.
	StateOrPrefixesReceived *string `json:"stateOrPrefixesReceived,omitempty"`
}

// ExpressRouteCrossConnectionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type ExpressRouteCrossConnectionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCrossConnectionsClient) (ExpressRouteCrossConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCrossConnectionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCrossConnectionsCreateOrUpdateFuture.Result.
func (future *ExpressRouteCrossConnectionsCreateOrUpdateFuture) result(client ExpressRouteCrossConnectionsClient) (ercc ExpressRouteCrossConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ercc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCrossConnectionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ercc.Response.Response, err = future.GetResult(sender); err == nil && ercc.Response.Response.StatusCode != http.StatusNoContent {
		ercc, err = client.CreateOrUpdateResponder(ercc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionsCreateOrUpdateFuture", "Result", ercc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCrossConnectionsListArpTableFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type ExpressRouteCrossConnectionsListArpTableFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCrossConnectionsClient) (ExpressRouteCircuitsArpTableListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCrossConnectionsListArpTableFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCrossConnectionsListArpTableFuture.Result.
func (future *ExpressRouteCrossConnectionsListArpTableFuture) result(client ExpressRouteCrossConnectionsClient) (ercatlr ExpressRouteCircuitsArpTableListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionsListArpTableFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ercatlr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCrossConnectionsListArpTableFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ercatlr.Response.Response, err = future.GetResult(sender); err == nil && ercatlr.Response.Response.StatusCode != http.StatusNoContent {
		ercatlr, err = client.ListArpTableResponder(ercatlr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionsListArpTableFuture", "Result", ercatlr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCrossConnectionsListRoutesTableFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type ExpressRouteCrossConnectionsListRoutesTableFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCrossConnectionsClient) (ExpressRouteCircuitsRoutesTableListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCrossConnectionsListRoutesTableFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCrossConnectionsListRoutesTableFuture.Result.
func (future *ExpressRouteCrossConnectionsListRoutesTableFuture) result(client ExpressRouteCrossConnectionsClient) (ercrtlr ExpressRouteCircuitsRoutesTableListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionsListRoutesTableFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ercrtlr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCrossConnectionsListRoutesTableFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ercrtlr.Response.Response, err = future.GetResult(sender); err == nil && ercrtlr.Response.Response.StatusCode != http.StatusNoContent {
		ercrtlr, err = client.ListRoutesTableResponder(ercrtlr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionsListRoutesTableFuture", "Result", ercrtlr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCrossConnectionsListRoutesTableSummaryFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type ExpressRouteCrossConnectionsListRoutesTableSummaryFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteCrossConnectionsClient) (ExpressRouteCrossConnectionsRoutesTableSummaryListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteCrossConnectionsListRoutesTableSummaryFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteCrossConnectionsListRoutesTableSummaryFuture.Result.
func (future *ExpressRouteCrossConnectionsListRoutesTableSummaryFuture) result(client ExpressRouteCrossConnectionsClient) (erccrtslr ExpressRouteCrossConnectionsRoutesTableSummaryListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionsListRoutesTableSummaryFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erccrtslr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteCrossConnectionsListRoutesTableSummaryFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erccrtslr.Response.Response, err = future.GetResult(sender); err == nil && erccrtslr.Response.Response.StatusCode != http.StatusNoContent {
		erccrtslr, err = client.ListRoutesTableSummaryResponder(erccrtslr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteCrossConnectionsListRoutesTableSummaryFuture", "Result", erccrtslr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteCrossConnectionsRoutesTableSummaryListResult response for ListRoutesTable associated with
// the Express Route Cross Connections.
type ExpressRouteCrossConnectionsRoutesTableSummaryListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of the routes table.
	Value *[]ExpressRouteCrossConnectionRoutesTableSummary `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteCrossConnectionsRoutesTableSummaryListResult.
func (erccrtslr ExpressRouteCrossConnectionsRoutesTableSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erccrtslr.Value != nil {
		objectMap["value"] = erccrtslr.Value
	}
	return json.Marshal(objectMap)
}

// ExpressRouteGateway expressRoute gateway resource.
type ExpressRouteGateway struct {
	autorest.Response `json:"-"`
	// ExpressRouteGatewayProperties - Properties of the express route gateway.
	*ExpressRouteGatewayProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ExpressRouteGateway.
func (erg ExpressRouteGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erg.ExpressRouteGatewayProperties != nil {
		objectMap["properties"] = erg.ExpressRouteGatewayProperties
	}
	if erg.ID != nil {
		objectMap["id"] = erg.ID
	}
	if erg.Location != nil {
		objectMap["location"] = erg.Location
	}
	if erg.Tags != nil {
		objectMap["tags"] = erg.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteGateway struct.
func (erg *ExpressRouteGateway) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRouteGatewayProperties ExpressRouteGatewayProperties
				err = json.Unmarshal(*v, &expressRouteGatewayProperties)
				if err != nil {
					return err
				}
				erg.ExpressRouteGatewayProperties = &expressRouteGatewayProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				erg.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				erg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				erg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				erg.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				erg.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				erg.Tags = tags
			}
		}
	}

	return nil
}

// ExpressRouteGatewayList list of ExpressRoute gateways.
type ExpressRouteGatewayList struct {
	autorest.Response `json:"-"`
	// Value - List of ExpressRoute gateways.
	Value *[]ExpressRouteGateway `json:"value,omitempty"`
}

// ExpressRouteGatewayProperties expressRoute gateway resource properties.
type ExpressRouteGatewayProperties struct {
	// AutoScaleConfiguration - Configuration for auto scaling.
	AutoScaleConfiguration *ExpressRouteGatewayPropertiesAutoScaleConfiguration `json:"autoScaleConfiguration,omitempty"`
	// ExpressRouteConnections - READ-ONLY; List of ExpressRoute connections to the ExpressRoute gateway.
	ExpressRouteConnections *[]ExpressRouteConnection `json:"expressRouteConnections,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route gateway resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// VirtualHub - The Virtual Hub where the ExpressRoute gateway is or will be deployed.
	VirtualHub *VirtualHubID `json:"virtualHub,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteGatewayProperties.
func (ergp ExpressRouteGatewayProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ergp.AutoScaleConfiguration != nil {
		objectMap["autoScaleConfiguration"] = ergp.AutoScaleConfiguration
	}
	if ergp.VirtualHub != nil {
		objectMap["virtualHub"] = ergp.VirtualHub
	}
	return json.Marshal(objectMap)
}

// ExpressRouteGatewayPropertiesAutoScaleConfiguration configuration for auto scaling.
type ExpressRouteGatewayPropertiesAutoScaleConfiguration struct {
	// Bounds - Minimum and maximum number of scale units to deploy.
	Bounds *ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds `json:"bounds,omitempty"`
}

// ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds minimum and maximum number of scale units to
// deploy.
type ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds struct {
	// Min - Minimum number of scale units deployed for ExpressRoute gateway.
	Min *int32 `json:"min,omitempty"`
	// Max - Maximum number of scale units deployed for ExpressRoute gateway.
	Max *int32 `json:"max,omitempty"`
}

// ExpressRouteGatewaysCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteGatewaysCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteGatewaysClient) (ExpressRouteGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteGatewaysCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteGatewaysCreateOrUpdateFuture.Result.
func (future *ExpressRouteGatewaysCreateOrUpdateFuture) result(client ExpressRouteGatewaysClient) (erg ExpressRouteGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteGatewaysCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteGatewaysCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erg.Response.Response, err = future.GetResult(sender); err == nil && erg.Response.Response.StatusCode != http.StatusNoContent {
		erg, err = client.CreateOrUpdateResponder(erg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteGatewaysCreateOrUpdateFuture", "Result", erg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteGatewaysDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteGatewaysDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteGatewaysDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteGatewaysDeleteFuture.Result.
func (future *ExpressRouteGatewaysDeleteFuture) result(client ExpressRouteGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteGatewaysDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteGatewaysDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExpressRouteGatewaysUpdateTagsFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRouteGatewaysUpdateTagsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRouteGatewaysClient) (ExpressRouteGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRouteGatewaysUpdateTagsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRouteGatewaysUpdateTagsFuture.Result.
func (future *ExpressRouteGatewaysUpdateTagsFuture) result(client ExpressRouteGatewaysClient) (erg ExpressRouteGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRouteGatewaysUpdateTagsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRouteGatewaysUpdateTagsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erg.Response.Response, err = future.GetResult(sender); err == nil && erg.Response.Response.StatusCode != http.StatusNoContent {
		erg, err = client.UpdateTagsResponder(erg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRouteGatewaysUpdateTagsFuture", "Result", erg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRouteLink expressRouteLink child resource definition.
type ExpressRouteLink struct {
	autorest.Response `json:"-"`
	// ExpressRouteLinkPropertiesFormat - ExpressRouteLink properties.
	*ExpressRouteLinkPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of child port resource that is unique among child port resources of the parent.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteLink.
func (erl ExpressRouteLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erl.ExpressRouteLinkPropertiesFormat != nil {
		objectMap["properties"] = erl.ExpressRouteLinkPropertiesFormat
	}
	if erl.Name != nil {
		objectMap["name"] = erl.Name
	}
	if erl.ID != nil {
		objectMap["id"] = erl.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteLink struct.
func (erl *ExpressRouteLink) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRouteLinkPropertiesFormat ExpressRouteLinkPropertiesFormat
				err = json.Unmarshal(*v, &expressRouteLinkPropertiesFormat)
				if err != nil {
					return err
				}
				erl.ExpressRouteLinkPropertiesFormat = &expressRouteLinkPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				erl.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				erl.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				erl.ID = &ID
			}
		}
	}

	return nil
}

// ExpressRouteLinkListResult response for ListExpressRouteLinks API service call.
type ExpressRouteLinkListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of ExpressRouteLink sub-resources.
	Value *[]ExpressRouteLink `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRouteLinkListResultIterator provides access to a complete listing of ExpressRouteLink values.
type ExpressRouteLinkListResultIterator struct {
	i    int
	page ExpressRouteLinkListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRouteLinkListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteLinkListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRouteLinkListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRouteLinkListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRouteLinkListResultIterator) Response() ExpressRouteLinkListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRouteLinkListResultIterator) Value() ExpressRouteLink {
	if !iter.page.NotDone() {
		return ExpressRouteLink{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRouteLinkListResultIterator type.
func NewExpressRouteLinkListResultIterator(page ExpressRouteLinkListResultPage) ExpressRouteLinkListResultIterator {
	return ExpressRouteLinkListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (erllr ExpressRouteLinkListResult) IsEmpty() bool {
	return erllr.Value == nil || len(*erllr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (erllr ExpressRouteLinkListResult) hasNextLink() bool {
	return erllr.NextLink != nil && len(*erllr.NextLink) != 0
}

// expressRouteLinkListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (erllr ExpressRouteLinkListResult) expressRouteLinkListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !erllr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(erllr.NextLink)))
}

// ExpressRouteLinkListResultPage contains a page of ExpressRouteLink values.
type ExpressRouteLinkListResultPage struct {
	fn    func(context.Context, ExpressRouteLinkListResult) (ExpressRouteLinkListResult, error)
	erllr ExpressRouteLinkListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRouteLinkListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteLinkListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.erllr)
		if err != nil {
			return err
		}
		page.erllr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRouteLinkListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRouteLinkListResultPage) NotDone() bool {
	return !page.erllr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRouteLinkListResultPage) Response() ExpressRouteLinkListResult {
	return page.erllr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRouteLinkListResultPage) Values() []ExpressRouteLink {
	if page.erllr.IsEmpty() {
		return nil
	}
	return *page.erllr.Value
}

// Creates a new instance of the ExpressRouteLinkListResultPage type.
func NewExpressRouteLinkListResultPage(cur ExpressRouteLinkListResult, getNextPage func(context.Context, ExpressRouteLinkListResult) (ExpressRouteLinkListResult, error)) ExpressRouteLinkListResultPage {
	return ExpressRouteLinkListResultPage{
		fn:    getNextPage,
		erllr: cur,
	}
}

// ExpressRouteLinkMacSecConfig expressRouteLink Mac Security Configuration.
type ExpressRouteLinkMacSecConfig struct {
	// CknSecretIdentifier - Keyvault Secret Identifier URL containing Mac security CKN key.
	CknSecretIdentifier *string `json:"cknSecretIdentifier,omitempty"`
	// CakSecretIdentifier - Keyvault Secret Identifier URL containing Mac security CAK key.
	CakSecretIdentifier *string `json:"cakSecretIdentifier,omitempty"`
	// Cipher - Mac security cipher. Possible values include: 'ExpressRouteLinkMacSecCipherGcmAes256', 'ExpressRouteLinkMacSecCipherGcmAes128', 'ExpressRouteLinkMacSecCipherGcmAesXpn128', 'ExpressRouteLinkMacSecCipherGcmAesXpn256'
	Cipher ExpressRouteLinkMacSecCipher `json:"cipher,omitempty"`
	// SciState - Sci mode enabled/disabled. Possible values include: 'ExpressRouteLinkMacSecSciStateDisabled', 'ExpressRouteLinkMacSecSciStateEnabled'
	SciState ExpressRouteLinkMacSecSciState `json:"sciState,omitempty"`
}

// ExpressRouteLinkPropertiesFormat properties specific to ExpressRouteLink resources.
type ExpressRouteLinkPropertiesFormat struct {
	// RouterName - READ-ONLY; Name of Azure router associated with physical port.
	RouterName *string `json:"routerName,omitempty"`
	// InterfaceName - READ-ONLY; Name of Azure router interface.
	InterfaceName *string `json:"interfaceName,omitempty"`
	// PatchPanelID - READ-ONLY; Mapping between physical port to patch panel port.
	PatchPanelID *string `json:"patchPanelId,omitempty"`
	// RackID - READ-ONLY; Mapping of physical patch panel to rack.
	RackID *string `json:"rackId,omitempty"`
	// ConnectorType - READ-ONLY; Physical fiber port type. Possible values include: 'ExpressRouteLinkConnectorTypeLC', 'ExpressRouteLinkConnectorTypeSC'
	ConnectorType ExpressRouteLinkConnectorType `json:"connectorType,omitempty"`
	// AdminState - Administrative state of the physical port. Possible values include: 'ExpressRouteLinkAdminStateEnabled', 'ExpressRouteLinkAdminStateDisabled'
	AdminState ExpressRouteLinkAdminState `json:"adminState,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route link resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// MacSecConfig - MacSec configuration.
	MacSecConfig *ExpressRouteLinkMacSecConfig `json:"macSecConfig,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteLinkPropertiesFormat.
func (erlpf ExpressRouteLinkPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erlpf.AdminState != "" {
		objectMap["adminState"] = erlpf.AdminState
	}
	if erlpf.MacSecConfig != nil {
		objectMap["macSecConfig"] = erlpf.MacSecConfig
	}
	return json.Marshal(objectMap)
}

// ExpressRoutePort expressRoutePort resource definition.
type ExpressRoutePort struct {
	autorest.Response `json:"-"`
	// ExpressRoutePortPropertiesFormat - ExpressRoutePort properties.
	*ExpressRoutePortPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Identity - The identity of ExpressRoutePort, if configured.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ExpressRoutePort.
func (erp ExpressRoutePort) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erp.ExpressRoutePortPropertiesFormat != nil {
		objectMap["properties"] = erp.ExpressRoutePortPropertiesFormat
	}
	if erp.Identity != nil {
		objectMap["identity"] = erp.Identity
	}
	if erp.ID != nil {
		objectMap["id"] = erp.ID
	}
	if erp.Location != nil {
		objectMap["location"] = erp.Location
	}
	if erp.Tags != nil {
		objectMap["tags"] = erp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRoutePort struct.
func (erp *ExpressRoutePort) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRoutePortPropertiesFormat ExpressRoutePortPropertiesFormat
				err = json.Unmarshal(*v, &expressRoutePortPropertiesFormat)
				if err != nil {
					return err
				}
				erp.ExpressRoutePortPropertiesFormat = &expressRoutePortPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				erp.Etag = &etag
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				erp.Identity = &identity
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				erp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				erp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				erp.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				erp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				erp.Tags = tags
			}
		}
	}

	return nil
}

// ExpressRoutePortListResult response for ListExpressRoutePorts API service call.
type ExpressRoutePortListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of ExpressRoutePort resources.
	Value *[]ExpressRoutePort `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRoutePortListResultIterator provides access to a complete listing of ExpressRoutePort values.
type ExpressRoutePortListResultIterator struct {
	i    int
	page ExpressRoutePortListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRoutePortListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRoutePortListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRoutePortListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRoutePortListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRoutePortListResultIterator) Response() ExpressRoutePortListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRoutePortListResultIterator) Value() ExpressRoutePort {
	if !iter.page.NotDone() {
		return ExpressRoutePort{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRoutePortListResultIterator type.
func NewExpressRoutePortListResultIterator(page ExpressRoutePortListResultPage) ExpressRoutePortListResultIterator {
	return ExpressRoutePortListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (erplr ExpressRoutePortListResult) IsEmpty() bool {
	return erplr.Value == nil || len(*erplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (erplr ExpressRoutePortListResult) hasNextLink() bool {
	return erplr.NextLink != nil && len(*erplr.NextLink) != 0
}

// expressRoutePortListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (erplr ExpressRoutePortListResult) expressRoutePortListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !erplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(erplr.NextLink)))
}

// ExpressRoutePortListResultPage contains a page of ExpressRoutePort values.
type ExpressRoutePortListResultPage struct {
	fn    func(context.Context, ExpressRoutePortListResult) (ExpressRoutePortListResult, error)
	erplr ExpressRoutePortListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRoutePortListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRoutePortListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.erplr)
		if err != nil {
			return err
		}
		page.erplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRoutePortListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRoutePortListResultPage) NotDone() bool {
	return !page.erplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRoutePortListResultPage) Response() ExpressRoutePortListResult {
	return page.erplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRoutePortListResultPage) Values() []ExpressRoutePort {
	if page.erplr.IsEmpty() {
		return nil
	}
	return *page.erplr.Value
}

// Creates a new instance of the ExpressRoutePortListResultPage type.
func NewExpressRoutePortListResultPage(cur ExpressRoutePortListResult, getNextPage func(context.Context, ExpressRoutePortListResult) (ExpressRoutePortListResult, error)) ExpressRoutePortListResultPage {
	return ExpressRoutePortListResultPage{
		fn:    getNextPage,
		erplr: cur,
	}
}

// ExpressRoutePortPropertiesFormat properties specific to ExpressRoutePort resources.
type ExpressRoutePortPropertiesFormat struct {
	// PeeringLocation - The name of the peering location that the ExpressRoutePort is mapped to physically.
	PeeringLocation *string `json:"peeringLocation,omitempty"`
	// BandwidthInGbps - Bandwidth of procured ports in Gbps.
	BandwidthInGbps *int32 `json:"bandwidthInGbps,omitempty"`
	// ProvisionedBandwidthInGbps - READ-ONLY; Aggregate Gbps of associated circuit bandwidths.
	ProvisionedBandwidthInGbps *float64 `json:"provisionedBandwidthInGbps,omitempty"`
	// Mtu - READ-ONLY; Maximum transmission unit of the physical port pair(s).
	Mtu *string `json:"mtu,omitempty"`
	// Encapsulation - Encapsulation method on physical ports. Possible values include: 'ExpressRoutePortsEncapsulationDot1Q', 'ExpressRoutePortsEncapsulationQinQ'
	Encapsulation ExpressRoutePortsEncapsulation `json:"encapsulation,omitempty"`
	// EtherType - READ-ONLY; Ether type of the physical port.
	EtherType *string `json:"etherType,omitempty"`
	// AllocationDate - READ-ONLY; Date of the physical port allocation to be used in Letter of Authorization.
	AllocationDate *string `json:"allocationDate,omitempty"`
	// Links - The set of physical links of the ExpressRoutePort resource.
	Links *[]ExpressRouteLink `json:"links,omitempty"`
	// Circuits - READ-ONLY; Reference the ExpressRoute circuit(s) that are provisioned on this ExpressRoutePort resource.
	Circuits *[]SubResource `json:"circuits,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route port resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the express route port resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRoutePortPropertiesFormat.
func (erppf ExpressRoutePortPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erppf.PeeringLocation != nil {
		objectMap["peeringLocation"] = erppf.PeeringLocation
	}
	if erppf.BandwidthInGbps != nil {
		objectMap["bandwidthInGbps"] = erppf.BandwidthInGbps
	}
	if erppf.Encapsulation != "" {
		objectMap["encapsulation"] = erppf.Encapsulation
	}
	if erppf.Links != nil {
		objectMap["links"] = erppf.Links
	}
	return json.Marshal(objectMap)
}

// ExpressRoutePortsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ExpressRoutePortsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRoutePortsClient) (ExpressRoutePort, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRoutePortsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRoutePortsCreateOrUpdateFuture.Result.
func (future *ExpressRoutePortsCreateOrUpdateFuture) result(client ExpressRoutePortsClient) (erp ExpressRoutePort, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRoutePortsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRoutePortsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erp.Response.Response, err = future.GetResult(sender); err == nil && erp.Response.Response.StatusCode != http.StatusNoContent {
		erp, err = client.CreateOrUpdateResponder(erp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ExpressRoutePortsCreateOrUpdateFuture", "Result", erp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExpressRoutePortsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ExpressRoutePortsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExpressRoutePortsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExpressRoutePortsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExpressRoutePortsDeleteFuture.Result.
func (future *ExpressRoutePortsDeleteFuture) result(client ExpressRoutePortsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ExpressRoutePortsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ExpressRoutePortsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExpressRoutePortsLocation definition of the ExpressRoutePorts peering location resource.
type ExpressRoutePortsLocation struct {
	autorest.Response `json:"-"`
	// ExpressRoutePortsLocationPropertiesFormat - ExpressRoutePort peering location properties.
	*ExpressRoutePortsLocationPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ExpressRoutePortsLocation.
func (erpl ExpressRoutePortsLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erpl.ExpressRoutePortsLocationPropertiesFormat != nil {
		objectMap["properties"] = erpl.ExpressRoutePortsLocationPropertiesFormat
	}
	if erpl.ID != nil {
		objectMap["id"] = erpl.ID
	}
	if erpl.Location != nil {
		objectMap["location"] = erpl.Location
	}
	if erpl.Tags != nil {
		objectMap["tags"] = erpl.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRoutePortsLocation struct.
func (erpl *ExpressRoutePortsLocation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRoutePortsLocationPropertiesFormat ExpressRoutePortsLocationPropertiesFormat
				err = json.Unmarshal(*v, &expressRoutePortsLocationPropertiesFormat)
				if err != nil {
					return err
				}
				erpl.ExpressRoutePortsLocationPropertiesFormat = &expressRoutePortsLocationPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				erpl.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				erpl.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				erpl.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				erpl.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				erpl.Tags = tags
			}
		}
	}

	return nil
}

// ExpressRoutePortsLocationBandwidths real-time inventory of available ExpressRoute port bandwidths.
type ExpressRoutePortsLocationBandwidths struct {
	// OfferName - READ-ONLY; Bandwidth descriptive name.
	OfferName *string `json:"offerName,omitempty"`
	// ValueInGbps - READ-ONLY; Bandwidth value in Gbps.
	ValueInGbps *int32 `json:"valueInGbps,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRoutePortsLocationBandwidths.
func (erplb ExpressRoutePortsLocationBandwidths) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ExpressRoutePortsLocationListResult response for ListExpressRoutePortsLocations API service call.
type ExpressRoutePortsLocationListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of all ExpressRoutePort peering locations.
	Value *[]ExpressRoutePortsLocation `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRoutePortsLocationListResultIterator provides access to a complete listing of
// ExpressRoutePortsLocation values.
type ExpressRoutePortsLocationListResultIterator struct {
	i    int
	page ExpressRoutePortsLocationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRoutePortsLocationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRoutePortsLocationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRoutePortsLocationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRoutePortsLocationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRoutePortsLocationListResultIterator) Response() ExpressRoutePortsLocationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRoutePortsLocationListResultIterator) Value() ExpressRoutePortsLocation {
	if !iter.page.NotDone() {
		return ExpressRoutePortsLocation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRoutePortsLocationListResultIterator type.
func NewExpressRoutePortsLocationListResultIterator(page ExpressRoutePortsLocationListResultPage) ExpressRoutePortsLocationListResultIterator {
	return ExpressRoutePortsLocationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (erpllr ExpressRoutePortsLocationListResult) IsEmpty() bool {
	return erpllr.Value == nil || len(*erpllr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (erpllr ExpressRoutePortsLocationListResult) hasNextLink() bool {
	return erpllr.NextLink != nil && len(*erpllr.NextLink) != 0
}

// expressRoutePortsLocationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (erpllr ExpressRoutePortsLocationListResult) expressRoutePortsLocationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !erpllr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(erpllr.NextLink)))
}

// ExpressRoutePortsLocationListResultPage contains a page of ExpressRoutePortsLocation values.
type ExpressRoutePortsLocationListResultPage struct {
	fn     func(context.Context, ExpressRoutePortsLocationListResult) (ExpressRoutePortsLocationListResult, error)
	erpllr ExpressRoutePortsLocationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRoutePortsLocationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRoutePortsLocationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.erpllr)
		if err != nil {
			return err
		}
		page.erpllr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRoutePortsLocationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRoutePortsLocationListResultPage) NotDone() bool {
	return !page.erpllr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRoutePortsLocationListResultPage) Response() ExpressRoutePortsLocationListResult {
	return page.erpllr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRoutePortsLocationListResultPage) Values() []ExpressRoutePortsLocation {
	if page.erpllr.IsEmpty() {
		return nil
	}
	return *page.erpllr.Value
}

// Creates a new instance of the ExpressRoutePortsLocationListResultPage type.
func NewExpressRoutePortsLocationListResultPage(cur ExpressRoutePortsLocationListResult, getNextPage func(context.Context, ExpressRoutePortsLocationListResult) (ExpressRoutePortsLocationListResult, error)) ExpressRoutePortsLocationListResultPage {
	return ExpressRoutePortsLocationListResultPage{
		fn:     getNextPage,
		erpllr: cur,
	}
}

// ExpressRoutePortsLocationPropertiesFormat properties specific to ExpressRoutePorts peering location
// resources.
type ExpressRoutePortsLocationPropertiesFormat struct {
	// Address - READ-ONLY; Address of peering location.
	Address *string `json:"address,omitempty"`
	// Contact - READ-ONLY; Contact details of peering locations.
	Contact *string `json:"contact,omitempty"`
	// AvailableBandwidths - The inventory of available ExpressRoutePort bandwidths.
	AvailableBandwidths *[]ExpressRoutePortsLocationBandwidths `json:"availableBandwidths,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route port location resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRoutePortsLocationPropertiesFormat.
func (erplpf ExpressRoutePortsLocationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if erplpf.AvailableBandwidths != nil {
		objectMap["availableBandwidths"] = erplpf.AvailableBandwidths
	}
	return json.Marshal(objectMap)
}

// ExpressRouteServiceProvider a ExpressRouteResourceProvider object.
type ExpressRouteServiceProvider struct {
	// ExpressRouteServiceProviderPropertiesFormat - Properties of the express route service provider.
	*ExpressRouteServiceProviderPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ExpressRouteServiceProvider.
func (ersp ExpressRouteServiceProvider) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ersp.ExpressRouteServiceProviderPropertiesFormat != nil {
		objectMap["properties"] = ersp.ExpressRouteServiceProviderPropertiesFormat
	}
	if ersp.ID != nil {
		objectMap["id"] = ersp.ID
	}
	if ersp.Location != nil {
		objectMap["location"] = ersp.Location
	}
	if ersp.Tags != nil {
		objectMap["tags"] = ersp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ExpressRouteServiceProvider struct.
func (ersp *ExpressRouteServiceProvider) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var expressRouteServiceProviderPropertiesFormat ExpressRouteServiceProviderPropertiesFormat
				err = json.Unmarshal(*v, &expressRouteServiceProviderPropertiesFormat)
				if err != nil {
					return err
				}
				ersp.ExpressRouteServiceProviderPropertiesFormat = &expressRouteServiceProviderPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ersp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ersp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ersp.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ersp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ersp.Tags = tags
			}
		}
	}

	return nil
}

// ExpressRouteServiceProviderBandwidthsOffered contains bandwidths offered in ExpressRouteServiceProvider
// resources.
type ExpressRouteServiceProviderBandwidthsOffered struct {
	// OfferName - The OfferName.
	OfferName *string `json:"offerName,omitempty"`
	// ValueInMbps - The ValueInMbps.
	ValueInMbps *int32 `json:"valueInMbps,omitempty"`
}

// ExpressRouteServiceProviderListResult response for the ListExpressRouteServiceProvider API service call.
type ExpressRouteServiceProviderListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of ExpressRouteResourceProvider resources.
	Value *[]ExpressRouteServiceProvider `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ExpressRouteServiceProviderListResultIterator provides access to a complete listing of
// ExpressRouteServiceProvider values.
type ExpressRouteServiceProviderListResultIterator struct {
	i    int
	page ExpressRouteServiceProviderListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ExpressRouteServiceProviderListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteServiceProviderListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ExpressRouteServiceProviderListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ExpressRouteServiceProviderListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ExpressRouteServiceProviderListResultIterator) Response() ExpressRouteServiceProviderListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ExpressRouteServiceProviderListResultIterator) Value() ExpressRouteServiceProvider {
	if !iter.page.NotDone() {
		return ExpressRouteServiceProvider{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ExpressRouteServiceProviderListResultIterator type.
func NewExpressRouteServiceProviderListResultIterator(page ExpressRouteServiceProviderListResultPage) ExpressRouteServiceProviderListResultIterator {
	return ExpressRouteServiceProviderListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ersplr ExpressRouteServiceProviderListResult) IsEmpty() bool {
	return ersplr.Value == nil || len(*ersplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ersplr ExpressRouteServiceProviderListResult) hasNextLink() bool {
	return ersplr.NextLink != nil && len(*ersplr.NextLink) != 0
}

// expressRouteServiceProviderListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ersplr ExpressRouteServiceProviderListResult) expressRouteServiceProviderListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ersplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ersplr.NextLink)))
}

// ExpressRouteServiceProviderListResultPage contains a page of ExpressRouteServiceProvider values.
type ExpressRouteServiceProviderListResultPage struct {
	fn     func(context.Context, ExpressRouteServiceProviderListResult) (ExpressRouteServiceProviderListResult, error)
	ersplr ExpressRouteServiceProviderListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ExpressRouteServiceProviderListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ExpressRouteServiceProviderListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ersplr)
		if err != nil {
			return err
		}
		page.ersplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ExpressRouteServiceProviderListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ExpressRouteServiceProviderListResultPage) NotDone() bool {
	return !page.ersplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ExpressRouteServiceProviderListResultPage) Response() ExpressRouteServiceProviderListResult {
	return page.ersplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ExpressRouteServiceProviderListResultPage) Values() []ExpressRouteServiceProvider {
	if page.ersplr.IsEmpty() {
		return nil
	}
	return *page.ersplr.Value
}

// Creates a new instance of the ExpressRouteServiceProviderListResultPage type.
func NewExpressRouteServiceProviderListResultPage(cur ExpressRouteServiceProviderListResult, getNextPage func(context.Context, ExpressRouteServiceProviderListResult) (ExpressRouteServiceProviderListResult, error)) ExpressRouteServiceProviderListResultPage {
	return ExpressRouteServiceProviderListResultPage{
		fn:     getNextPage,
		ersplr: cur,
	}
}

// ExpressRouteServiceProviderPropertiesFormat properties of ExpressRouteServiceProvider.
type ExpressRouteServiceProviderPropertiesFormat struct {
	// PeeringLocations - A list of peering locations.
	PeeringLocations *[]string `json:"peeringLocations,omitempty"`
	// BandwidthsOffered - A list of bandwidths offered.
	BandwidthsOffered *[]ExpressRouteServiceProviderBandwidthsOffered `json:"bandwidthsOffered,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the express route service provider resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ExpressRouteServiceProviderPropertiesFormat.
func (ersppf ExpressRouteServiceProviderPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ersppf.PeeringLocations != nil {
		objectMap["peeringLocations"] = ersppf.PeeringLocations
	}
	if ersppf.BandwidthsOffered != nil {
		objectMap["bandwidthsOffered"] = ersppf.BandwidthsOffered
	}
	return json.Marshal(objectMap)
}

// ExtendedLocation extendedLocation complex type.
type ExtendedLocation struct {
	// Name - The name of the extended location.
	Name *string `json:"name,omitempty"`
	// Type - The type of the extended location.
	Type *string `json:"type,omitempty"`
}

// FirewallPoliciesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type FirewallPoliciesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FirewallPoliciesClient) (FirewallPolicy, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FirewallPoliciesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FirewallPoliciesCreateOrUpdateFuture.Result.
func (future *FirewallPoliciesCreateOrUpdateFuture) result(client FirewallPoliciesClient) (fp FirewallPolicy, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.FirewallPoliciesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		fp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.FirewallPoliciesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fp.Response.Response, err = future.GetResult(sender); err == nil && fp.Response.Response.StatusCode != http.StatusNoContent {
		fp, err = client.CreateOrUpdateResponder(fp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.FirewallPoliciesCreateOrUpdateFuture", "Result", fp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FirewallPoliciesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type FirewallPoliciesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FirewallPoliciesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FirewallPoliciesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FirewallPoliciesDeleteFuture.Result.
func (future *FirewallPoliciesDeleteFuture) result(client FirewallPoliciesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.FirewallPoliciesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.FirewallPoliciesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// FirewallPolicy firewallPolicy Resource.
type FirewallPolicy struct {
	autorest.Response `json:"-"`
	// FirewallPolicyPropertiesFormat - Properties of the firewall policy.
	*FirewallPolicyPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Identity - The identity of the firewall policy.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for FirewallPolicy.
func (fp FirewallPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fp.FirewallPolicyPropertiesFormat != nil {
		objectMap["properties"] = fp.FirewallPolicyPropertiesFormat
	}
	if fp.Identity != nil {
		objectMap["identity"] = fp.Identity
	}
	if fp.ID != nil {
		objectMap["id"] = fp.ID
	}
	if fp.Location != nil {
		objectMap["location"] = fp.Location
	}
	if fp.Tags != nil {
		objectMap["tags"] = fp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FirewallPolicy struct.
func (fp *FirewallPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var firewallPolicyPropertiesFormat FirewallPolicyPropertiesFormat
				err = json.Unmarshal(*v, &firewallPolicyPropertiesFormat)
				if err != nil {
					return err
				}
				fp.FirewallPolicyPropertiesFormat = &firewallPolicyPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				fp.Etag = &etag
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				fp.Identity = &identity
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fp.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				fp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				fp.Tags = tags
			}
		}
	}

	return nil
}

// FirewallPolicyCertificateAuthority trusted Root certificates properties for tls.
type FirewallPolicyCertificateAuthority struct {
	// KeyVaultSecretID - Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
	KeyVaultSecretID *string `json:"keyVaultSecretId,omitempty"`
	// Name - Name of the CA certificate.
	Name *string `json:"name,omitempty"`
}

// FirewallPolicyFilterRuleCollection firewall Policy Filter Rule Collection.
type FirewallPolicyFilterRuleCollection struct {
	// Action - The action type of a Filter rule collection.
	Action *FirewallPolicyFilterRuleCollectionAction `json:"action,omitempty"`
	// Rules - List of rules included in a rule collection.
	Rules *[]BasicFirewallPolicyRule `json:"rules,omitempty"`
	// Name - The name of the rule collection.
	Name *string `json:"name,omitempty"`
	// Priority - Priority of the Firewall Policy Rule Collection resource.
	Priority *int32 `json:"priority,omitempty"`
	// RuleCollectionType - Possible values include: 'RuleCollectionTypeFirewallPolicyRuleCollection', 'RuleCollectionTypeFirewallPolicyNatRuleCollection', 'RuleCollectionTypeFirewallPolicyFilterRuleCollection'
	RuleCollectionType RuleCollectionType `json:"ruleCollectionType,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallPolicyFilterRuleCollection.
func (fpfrc FirewallPolicyFilterRuleCollection) MarshalJSON() ([]byte, error) {
	fpfrc.RuleCollectionType = RuleCollectionTypeFirewallPolicyFilterRuleCollection
	objectMap := make(map[string]interface{})
	if fpfrc.Action != nil {
		objectMap["action"] = fpfrc.Action
	}
	if fpfrc.Rules != nil {
		objectMap["rules"] = fpfrc.Rules
	}
	if fpfrc.Name != nil {
		objectMap["name"] = fpfrc.Name
	}
	if fpfrc.Priority != nil {
		objectMap["priority"] = fpfrc.Priority
	}
	if fpfrc.RuleCollectionType != "" {
		objectMap["ruleCollectionType"] = fpfrc.RuleCollectionType
	}
	return json.Marshal(objectMap)
}

// AsFirewallPolicyNatRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyFilterRuleCollection.
func (fpfrc FirewallPolicyFilterRuleCollection) AsFirewallPolicyNatRuleCollection() (*FirewallPolicyNatRuleCollection, bool) {
	return nil, false
}

// AsFirewallPolicyFilterRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyFilterRuleCollection.
func (fpfrc FirewallPolicyFilterRuleCollection) AsFirewallPolicyFilterRuleCollection() (*FirewallPolicyFilterRuleCollection, bool) {
	return &fpfrc, true
}

// AsFirewallPolicyRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyFilterRuleCollection.
func (fpfrc FirewallPolicyFilterRuleCollection) AsFirewallPolicyRuleCollection() (*FirewallPolicyRuleCollection, bool) {
	return nil, false
}

// AsBasicFirewallPolicyRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyFilterRuleCollection.
func (fpfrc FirewallPolicyFilterRuleCollection) AsBasicFirewallPolicyRuleCollection() (BasicFirewallPolicyRuleCollection, bool) {
	return &fpfrc, true
}

// UnmarshalJSON is the custom unmarshaler for FirewallPolicyFilterRuleCollection struct.
func (fpfrc *FirewallPolicyFilterRuleCollection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "action":
			if v != nil {
				var action FirewallPolicyFilterRuleCollectionAction
				err = json.Unmarshal(*v, &action)
				if err != nil {
					return err
				}
				fpfrc.Action = &action
			}
		case "rules":
			if v != nil {
				rules, err := unmarshalBasicFirewallPolicyRuleArray(*v)
				if err != nil {
					return err
				}
				fpfrc.Rules = &rules
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fpfrc.Name = &name
			}
		case "priority":
			if v != nil {
				var priority int32
				err = json.Unmarshal(*v, &priority)
				if err != nil {
					return err
				}
				fpfrc.Priority = &priority
			}
		case "ruleCollectionType":
			if v != nil {
				var ruleCollectionType RuleCollectionType
				err = json.Unmarshal(*v, &ruleCollectionType)
				if err != nil {
					return err
				}
				fpfrc.RuleCollectionType = ruleCollectionType
			}
		}
	}

	return nil
}

// FirewallPolicyFilterRuleCollectionAction properties of the FirewallPolicyFilterRuleCollectionAction.
type FirewallPolicyFilterRuleCollectionAction struct {
	// Type - The type of action. Possible values include: 'FirewallPolicyFilterRuleCollectionActionTypeAllow', 'FirewallPolicyFilterRuleCollectionActionTypeDeny'
	Type FirewallPolicyFilterRuleCollectionActionType `json:"type,omitempty"`
}

// FirewallPolicyInsights firewall Policy Insights.
type FirewallPolicyInsights struct {
	// IsEnabled - A flag to indicate if the insights are enabled on the policy.
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// RetentionDays - Number of days the insights should be enabled on the policy.
	RetentionDays *int32 `json:"retentionDays,omitempty"`
	// LogAnalyticsResources - Workspaces needed to configure the Firewall Policy Insights.
	LogAnalyticsResources *FirewallPolicyLogAnalyticsResources `json:"logAnalyticsResources,omitempty"`
}

// FirewallPolicyIntrusionDetection configuration for intrusion detection mode and rules.
type FirewallPolicyIntrusionDetection struct {
	// Mode - Intrusion detection general state. Possible values include: 'FirewallPolicyIntrusionDetectionStateTypeOff', 'FirewallPolicyIntrusionDetectionStateTypeAlert', 'FirewallPolicyIntrusionDetectionStateTypeDeny'
	Mode FirewallPolicyIntrusionDetectionStateType `json:"mode,omitempty"`
	// Configuration - Intrusion detection configuration properties.
	Configuration *FirewallPolicyIntrusionDetectionConfiguration `json:"configuration,omitempty"`
}

// FirewallPolicyIntrusionDetectionBypassTrafficSpecifications intrusion detection bypass traffic
// specification.
type FirewallPolicyIntrusionDetectionBypassTrafficSpecifications struct {
	// Name - Name of the bypass traffic rule.
	Name *string `json:"name,omitempty"`
	// Description - Description of the bypass traffic rule.
	Description *string `json:"description,omitempty"`
	// Protocol - The rule bypass protocol. Possible values include: 'FirewallPolicyIntrusionDetectionProtocolTCP', 'FirewallPolicyIntrusionDetectionProtocolUDP', 'FirewallPolicyIntrusionDetectionProtocolICMP', 'FirewallPolicyIntrusionDetectionProtocolANY'
	Protocol FirewallPolicyIntrusionDetectionProtocol `json:"protocol,omitempty"`
	// SourceAddresses - List of source IP addresses or ranges for this rule.
	SourceAddresses *[]string `json:"sourceAddresses,omitempty"`
	// DestinationAddresses - List of destination IP addresses or ranges for this rule.
	DestinationAddresses *[]string `json:"destinationAddresses,omitempty"`
	// DestinationPorts - List of destination ports or ranges.
	DestinationPorts *[]string `json:"destinationPorts,omitempty"`
	// SourceIPGroups - List of source IpGroups for this rule.
	SourceIPGroups *[]string `json:"sourceIpGroups,omitempty"`
	// DestinationIPGroups - List of destination IpGroups for this rule.
	DestinationIPGroups *[]string `json:"destinationIpGroups,omitempty"`
}

// FirewallPolicyIntrusionDetectionConfiguration the operation for configuring intrusion detection.
type FirewallPolicyIntrusionDetectionConfiguration struct {
	// SignatureOverrides - List of specific signatures states.
	SignatureOverrides *[]FirewallPolicyIntrusionDetectionSignatureSpecification `json:"signatureOverrides,omitempty"`
	// BypassTrafficSettings - List of rules for traffic to bypass.
	BypassTrafficSettings *[]FirewallPolicyIntrusionDetectionBypassTrafficSpecifications `json:"bypassTrafficSettings,omitempty"`
}

// FirewallPolicyIntrusionDetectionSignatureSpecification intrusion detection signatures specification
// states.
type FirewallPolicyIntrusionDetectionSignatureSpecification struct {
	// ID - Signature id.
	ID *string `json:"id,omitempty"`
	// Mode - The signature state. Possible values include: 'FirewallPolicyIntrusionDetectionStateTypeOff', 'FirewallPolicyIntrusionDetectionStateTypeAlert', 'FirewallPolicyIntrusionDetectionStateTypeDeny'
	Mode FirewallPolicyIntrusionDetectionStateType `json:"mode,omitempty"`
}

// FirewallPolicyListResult response for ListFirewallPolicies API service call.
type FirewallPolicyListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Firewall Policies in a resource group.
	Value *[]FirewallPolicy `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// FirewallPolicyListResultIterator provides access to a complete listing of FirewallPolicy values.
type FirewallPolicyListResultIterator struct {
	i    int
	page FirewallPolicyListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FirewallPolicyListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FirewallPolicyListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FirewallPolicyListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FirewallPolicyListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FirewallPolicyListResultIterator) Response() FirewallPolicyListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FirewallPolicyListResultIterator) Value() FirewallPolicy {
	if !iter.page.NotDone() {
		return FirewallPolicy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FirewallPolicyListResultIterator type.
func NewFirewallPolicyListResultIterator(page FirewallPolicyListResultPage) FirewallPolicyListResultIterator {
	return FirewallPolicyListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (fplr FirewallPolicyListResult) IsEmpty() bool {
	return fplr.Value == nil || len(*fplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (fplr FirewallPolicyListResult) hasNextLink() bool {
	return fplr.NextLink != nil && len(*fplr.NextLink) != 0
}

// firewallPolicyListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (fplr FirewallPolicyListResult) firewallPolicyListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !fplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(fplr.NextLink)))
}

// FirewallPolicyListResultPage contains a page of FirewallPolicy values.
type FirewallPolicyListResultPage struct {
	fn   func(context.Context, FirewallPolicyListResult) (FirewallPolicyListResult, error)
	fplr FirewallPolicyListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FirewallPolicyListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FirewallPolicyListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.fplr)
		if err != nil {
			return err
		}
		page.fplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FirewallPolicyListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FirewallPolicyListResultPage) NotDone() bool {
	return !page.fplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FirewallPolicyListResultPage) Response() FirewallPolicyListResult {
	return page.fplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FirewallPolicyListResultPage) Values() []FirewallPolicy {
	if page.fplr.IsEmpty() {
		return nil
	}
	return *page.fplr.Value
}

// Creates a new instance of the FirewallPolicyListResultPage type.
func NewFirewallPolicyListResultPage(cur FirewallPolicyListResult, getNextPage func(context.Context, FirewallPolicyListResult) (FirewallPolicyListResult, error)) FirewallPolicyListResultPage {
	return FirewallPolicyListResultPage{
		fn:   getNextPage,
		fplr: cur,
	}
}

// FirewallPolicyLogAnalyticsResources log Analytics Resources for Firewall Policy Insights.
type FirewallPolicyLogAnalyticsResources struct {
	// Workspaces - List of workspaces for Firewall Policy Insights.
	Workspaces *[]FirewallPolicyLogAnalyticsWorkspace `json:"workspaces,omitempty"`
	// DefaultWorkspaceID - The default workspace Id for Firewall Policy Insights.
	DefaultWorkspaceID *SubResource `json:"defaultWorkspaceId,omitempty"`
}

// FirewallPolicyLogAnalyticsWorkspace log Analytics Workspace for Firewall Policy Insights.
type FirewallPolicyLogAnalyticsWorkspace struct {
	// Region - Region to configure the Workspace.
	Region *string `json:"region,omitempty"`
	// WorkspaceID - The workspace Id for Firewall Policy Insights.
	WorkspaceID *SubResource `json:"workspaceId,omitempty"`
}

// FirewallPolicyNatRuleCollection firewall Policy NAT Rule Collection.
type FirewallPolicyNatRuleCollection struct {
	// Action - The action type of a Nat rule collection.
	Action *FirewallPolicyNatRuleCollectionAction `json:"action,omitempty"`
	// Rules - List of rules included in a rule collection.
	Rules *[]BasicFirewallPolicyRule `json:"rules,omitempty"`
	// Name - The name of the rule collection.
	Name *string `json:"name,omitempty"`
	// Priority - Priority of the Firewall Policy Rule Collection resource.
	Priority *int32 `json:"priority,omitempty"`
	// RuleCollectionType - Possible values include: 'RuleCollectionTypeFirewallPolicyRuleCollection', 'RuleCollectionTypeFirewallPolicyNatRuleCollection', 'RuleCollectionTypeFirewallPolicyFilterRuleCollection'
	RuleCollectionType RuleCollectionType `json:"ruleCollectionType,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallPolicyNatRuleCollection.
func (fpnrc FirewallPolicyNatRuleCollection) MarshalJSON() ([]byte, error) {
	fpnrc.RuleCollectionType = RuleCollectionTypeFirewallPolicyNatRuleCollection
	objectMap := make(map[string]interface{})
	if fpnrc.Action != nil {
		objectMap["action"] = fpnrc.Action
	}
	if fpnrc.Rules != nil {
		objectMap["rules"] = fpnrc.Rules
	}
	if fpnrc.Name != nil {
		objectMap["name"] = fpnrc.Name
	}
	if fpnrc.Priority != nil {
		objectMap["priority"] = fpnrc.Priority
	}
	if fpnrc.RuleCollectionType != "" {
		objectMap["ruleCollectionType"] = fpnrc.RuleCollectionType
	}
	return json.Marshal(objectMap)
}

// AsFirewallPolicyNatRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyNatRuleCollection.
func (fpnrc FirewallPolicyNatRuleCollection) AsFirewallPolicyNatRuleCollection() (*FirewallPolicyNatRuleCollection, bool) {
	return &fpnrc, true
}

// AsFirewallPolicyFilterRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyNatRuleCollection.
func (fpnrc FirewallPolicyNatRuleCollection) AsFirewallPolicyFilterRuleCollection() (*FirewallPolicyFilterRuleCollection, bool) {
	return nil, false
}

// AsFirewallPolicyRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyNatRuleCollection.
func (fpnrc FirewallPolicyNatRuleCollection) AsFirewallPolicyRuleCollection() (*FirewallPolicyRuleCollection, bool) {
	return nil, false
}

// AsBasicFirewallPolicyRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyNatRuleCollection.
func (fpnrc FirewallPolicyNatRuleCollection) AsBasicFirewallPolicyRuleCollection() (BasicFirewallPolicyRuleCollection, bool) {
	return &fpnrc, true
}

// UnmarshalJSON is the custom unmarshaler for FirewallPolicyNatRuleCollection struct.
func (fpnrc *FirewallPolicyNatRuleCollection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "action":
			if v != nil {
				var action FirewallPolicyNatRuleCollectionAction
				err = json.Unmarshal(*v, &action)
				if err != nil {
					return err
				}
				fpnrc.Action = &action
			}
		case "rules":
			if v != nil {
				rules, err := unmarshalBasicFirewallPolicyRuleArray(*v)
				if err != nil {
					return err
				}
				fpnrc.Rules = &rules
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fpnrc.Name = &name
			}
		case "priority":
			if v != nil {
				var priority int32
				err = json.Unmarshal(*v, &priority)
				if err != nil {
					return err
				}
				fpnrc.Priority = &priority
			}
		case "ruleCollectionType":
			if v != nil {
				var ruleCollectionType RuleCollectionType
				err = json.Unmarshal(*v, &ruleCollectionType)
				if err != nil {
					return err
				}
				fpnrc.RuleCollectionType = ruleCollectionType
			}
		}
	}

	return nil
}

// FirewallPolicyNatRuleCollectionAction properties of the FirewallPolicyNatRuleCollectionAction.
type FirewallPolicyNatRuleCollectionAction struct {
	// Type - The type of action. Possible values include: 'FirewallPolicyNatRuleCollectionActionTypeDNAT'
	Type FirewallPolicyNatRuleCollectionActionType `json:"type,omitempty"`
}

// FirewallPolicyPropertiesFormat firewall Policy definition.
type FirewallPolicyPropertiesFormat struct {
	// RuleCollectionGroups - READ-ONLY; List of references to FirewallPolicyRuleCollectionGroups.
	RuleCollectionGroups *[]SubResource `json:"ruleCollectionGroups,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the firewall policy resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// BasePolicy - The parent firewall policy from which rules are inherited.
	BasePolicy *SubResource `json:"basePolicy,omitempty"`
	// Firewalls - READ-ONLY; List of references to Azure Firewalls that this Firewall Policy is associated with.
	Firewalls *[]SubResource `json:"firewalls,omitempty"`
	// ChildPolicies - READ-ONLY; List of references to Child Firewall Policies.
	ChildPolicies *[]SubResource `json:"childPolicies,omitempty"`
	// ThreatIntelMode - The operation mode for Threat Intelligence. Possible values include: 'AzureFirewallThreatIntelModeAlert', 'AzureFirewallThreatIntelModeDeny', 'AzureFirewallThreatIntelModeOff'
	ThreatIntelMode AzureFirewallThreatIntelMode `json:"threatIntelMode,omitempty"`
	// ThreatIntelWhitelist - ThreatIntel Whitelist for Firewall Policy.
	ThreatIntelWhitelist *FirewallPolicyThreatIntelWhitelist `json:"threatIntelWhitelist,omitempty"`
	// Insights - Insights on Firewall Policy.
	Insights *FirewallPolicyInsights `json:"insights,omitempty"`
	// Snat - The private IP addresses/IP ranges to which traffic will not be SNAT.
	Snat *FirewallPolicySNAT `json:"snat,omitempty"`
	// DNSSettings - DNS Proxy Settings definition.
	DNSSettings *DNSSettings `json:"dnsSettings,omitempty"`
	// IntrusionDetection - The configuration for Intrusion detection.
	IntrusionDetection *FirewallPolicyIntrusionDetection `json:"intrusionDetection,omitempty"`
	// TransportSecurity - TLS Configuration definition.
	TransportSecurity *FirewallPolicyTransportSecurity `json:"transportSecurity,omitempty"`
	// Sku - The Firewall Policy SKU.
	Sku *FirewallPolicySku `json:"sku,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallPolicyPropertiesFormat.
func (fppf FirewallPolicyPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fppf.BasePolicy != nil {
		objectMap["basePolicy"] = fppf.BasePolicy
	}
	if fppf.ThreatIntelMode != "" {
		objectMap["threatIntelMode"] = fppf.ThreatIntelMode
	}
	if fppf.ThreatIntelWhitelist != nil {
		objectMap["threatIntelWhitelist"] = fppf.ThreatIntelWhitelist
	}
	if fppf.Insights != nil {
		objectMap["insights"] = fppf.Insights
	}
	if fppf.Snat != nil {
		objectMap["snat"] = fppf.Snat
	}
	if fppf.DNSSettings != nil {
		objectMap["dnsSettings"] = fppf.DNSSettings
	}
	if fppf.IntrusionDetection != nil {
		objectMap["intrusionDetection"] = fppf.IntrusionDetection
	}
	if fppf.TransportSecurity != nil {
		objectMap["transportSecurity"] = fppf.TransportSecurity
	}
	if fppf.Sku != nil {
		objectMap["sku"] = fppf.Sku
	}
	return json.Marshal(objectMap)
}

// BasicFirewallPolicyRule properties of a rule.
type BasicFirewallPolicyRule interface {
	AsApplicationRule() (*ApplicationRule, bool)
	AsNatRule() (*NatRule, bool)
	AsRule() (*Rule, bool)
	AsFirewallPolicyRule() (*FirewallPolicyRule, bool)
}

// FirewallPolicyRule properties of a rule.
type FirewallPolicyRule struct {
	// Name - Name of the rule.
	Name *string `json:"name,omitempty"`
	// Description - Description of the rule.
	Description *string `json:"description,omitempty"`
	// RuleType - Possible values include: 'RuleTypeFirewallPolicyRule', 'RuleTypeApplicationRule', 'RuleTypeNatRule', 'RuleTypeNetworkRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

func unmarshalBasicFirewallPolicyRule(body []byte) (BasicFirewallPolicyRule, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["ruleType"] {
	case string(RuleTypeApplicationRule):
		var ar ApplicationRule
		err := json.Unmarshal(body, &ar)
		return ar, err
	case string(RuleTypeNatRule):
		var nr NatRule
		err := json.Unmarshal(body, &nr)
		return nr, err
	case string(RuleTypeNetworkRule):
		var r Rule
		err := json.Unmarshal(body, &r)
		return r, err
	default:
		var fpr FirewallPolicyRule
		err := json.Unmarshal(body, &fpr)
		return fpr, err
	}
}
func unmarshalBasicFirewallPolicyRuleArray(body []byte) ([]BasicFirewallPolicyRule, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	fprArray := make([]BasicFirewallPolicyRule, len(rawMessages))

	for index, rawMessage := range rawMessages {
		fpr, err := unmarshalBasicFirewallPolicyRule(*rawMessage)
		if err != nil {
			return nil, err
		}
		fprArray[index] = fpr
	}
	return fprArray, nil
}

// MarshalJSON is the custom marshaler for FirewallPolicyRule.
func (fpr FirewallPolicyRule) MarshalJSON() ([]byte, error) {
	fpr.RuleType = RuleTypeFirewallPolicyRule
	objectMap := make(map[string]interface{})
	if fpr.Name != nil {
		objectMap["name"] = fpr.Name
	}
	if fpr.Description != nil {
		objectMap["description"] = fpr.Description
	}
	if fpr.RuleType != "" {
		objectMap["ruleType"] = fpr.RuleType
	}
	return json.Marshal(objectMap)
}

// AsApplicationRule is the BasicFirewallPolicyRule implementation for FirewallPolicyRule.
func (fpr FirewallPolicyRule) AsApplicationRule() (*ApplicationRule, bool) {
	return nil, false
}

// AsNatRule is the BasicFirewallPolicyRule implementation for FirewallPolicyRule.
func (fpr FirewallPolicyRule) AsNatRule() (*NatRule, bool) {
	return nil, false
}

// AsRule is the BasicFirewallPolicyRule implementation for FirewallPolicyRule.
func (fpr FirewallPolicyRule) AsRule() (*Rule, bool) {
	return nil, false
}

// AsFirewallPolicyRule is the BasicFirewallPolicyRule implementation for FirewallPolicyRule.
func (fpr FirewallPolicyRule) AsFirewallPolicyRule() (*FirewallPolicyRule, bool) {
	return &fpr, true
}

// AsBasicFirewallPolicyRule is the BasicFirewallPolicyRule implementation for FirewallPolicyRule.
func (fpr FirewallPolicyRule) AsBasicFirewallPolicyRule() (BasicFirewallPolicyRule, bool) {
	return &fpr, true
}

// FirewallPolicyRuleApplicationProtocol properties of the application rule protocol.
type FirewallPolicyRuleApplicationProtocol struct {
	// ProtocolType - Protocol type. Possible values include: 'FirewallPolicyRuleApplicationProtocolTypeHTTP', 'FirewallPolicyRuleApplicationProtocolTypeHTTPS'
	ProtocolType FirewallPolicyRuleApplicationProtocolType `json:"protocolType,omitempty"`
	// Port - Port number for the protocol, cannot be greater than 64000.
	Port *int32 `json:"port,omitempty"`
}

// BasicFirewallPolicyRuleCollection properties of the rule collection.
type BasicFirewallPolicyRuleCollection interface {
	AsFirewallPolicyNatRuleCollection() (*FirewallPolicyNatRuleCollection, bool)
	AsFirewallPolicyFilterRuleCollection() (*FirewallPolicyFilterRuleCollection, bool)
	AsFirewallPolicyRuleCollection() (*FirewallPolicyRuleCollection, bool)
}

// FirewallPolicyRuleCollection properties of the rule collection.
type FirewallPolicyRuleCollection struct {
	// Name - The name of the rule collection.
	Name *string `json:"name,omitempty"`
	// Priority - Priority of the Firewall Policy Rule Collection resource.
	Priority *int32 `json:"priority,omitempty"`
	// RuleCollectionType - Possible values include: 'RuleCollectionTypeFirewallPolicyRuleCollection', 'RuleCollectionTypeFirewallPolicyNatRuleCollection', 'RuleCollectionTypeFirewallPolicyFilterRuleCollection'
	RuleCollectionType RuleCollectionType `json:"ruleCollectionType,omitempty"`
}

func unmarshalBasicFirewallPolicyRuleCollection(body []byte) (BasicFirewallPolicyRuleCollection, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["ruleCollectionType"] {
	case string(RuleCollectionTypeFirewallPolicyNatRuleCollection):
		var fpnrc FirewallPolicyNatRuleCollection
		err := json.Unmarshal(body, &fpnrc)
		return fpnrc, err
	case string(RuleCollectionTypeFirewallPolicyFilterRuleCollection):
		var fpfrc FirewallPolicyFilterRuleCollection
		err := json.Unmarshal(body, &fpfrc)
		return fpfrc, err
	default:
		var fprc FirewallPolicyRuleCollection
		err := json.Unmarshal(body, &fprc)
		return fprc, err
	}
}
func unmarshalBasicFirewallPolicyRuleCollectionArray(body []byte) ([]BasicFirewallPolicyRuleCollection, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	fprcArray := make([]BasicFirewallPolicyRuleCollection, len(rawMessages))

	for index, rawMessage := range rawMessages {
		fprc, err := unmarshalBasicFirewallPolicyRuleCollection(*rawMessage)
		if err != nil {
			return nil, err
		}
		fprcArray[index] = fprc
	}
	return fprcArray, nil
}

// MarshalJSON is the custom marshaler for FirewallPolicyRuleCollection.
func (fprc FirewallPolicyRuleCollection) MarshalJSON() ([]byte, error) {
	fprc.RuleCollectionType = RuleCollectionTypeFirewallPolicyRuleCollection
	objectMap := make(map[string]interface{})
	if fprc.Name != nil {
		objectMap["name"] = fprc.Name
	}
	if fprc.Priority != nil {
		objectMap["priority"] = fprc.Priority
	}
	if fprc.RuleCollectionType != "" {
		objectMap["ruleCollectionType"] = fprc.RuleCollectionType
	}
	return json.Marshal(objectMap)
}

// AsFirewallPolicyNatRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyRuleCollection.
func (fprc FirewallPolicyRuleCollection) AsFirewallPolicyNatRuleCollection() (*FirewallPolicyNatRuleCollection, bool) {
	return nil, false
}

// AsFirewallPolicyFilterRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyRuleCollection.
func (fprc FirewallPolicyRuleCollection) AsFirewallPolicyFilterRuleCollection() (*FirewallPolicyFilterRuleCollection, bool) {
	return nil, false
}

// AsFirewallPolicyRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyRuleCollection.
func (fprc FirewallPolicyRuleCollection) AsFirewallPolicyRuleCollection() (*FirewallPolicyRuleCollection, bool) {
	return &fprc, true
}

// AsBasicFirewallPolicyRuleCollection is the BasicFirewallPolicyRuleCollection implementation for FirewallPolicyRuleCollection.
func (fprc FirewallPolicyRuleCollection) AsBasicFirewallPolicyRuleCollection() (BasicFirewallPolicyRuleCollection, bool) {
	return &fprc, true
}

// FirewallPolicyRuleCollectionGroup rule Collection Group resource.
type FirewallPolicyRuleCollectionGroup struct {
	autorest.Response `json:"-"`
	// FirewallPolicyRuleCollectionGroupProperties - The properties of the firewall policy rule collection group.
	*FirewallPolicyRuleCollectionGroupProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Rule Group type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallPolicyRuleCollectionGroup.
func (fprcg FirewallPolicyRuleCollectionGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fprcg.FirewallPolicyRuleCollectionGroupProperties != nil {
		objectMap["properties"] = fprcg.FirewallPolicyRuleCollectionGroupProperties
	}
	if fprcg.Name != nil {
		objectMap["name"] = fprcg.Name
	}
	if fprcg.ID != nil {
		objectMap["id"] = fprcg.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FirewallPolicyRuleCollectionGroup struct.
func (fprcg *FirewallPolicyRuleCollectionGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var firewallPolicyRuleCollectionGroupProperties FirewallPolicyRuleCollectionGroupProperties
				err = json.Unmarshal(*v, &firewallPolicyRuleCollectionGroupProperties)
				if err != nil {
					return err
				}
				fprcg.FirewallPolicyRuleCollectionGroupProperties = &firewallPolicyRuleCollectionGroupProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fprcg.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				fprcg.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fprcg.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fprcg.ID = &ID
			}
		}
	}

	return nil
}

// FirewallPolicyRuleCollectionGroupListResult response for ListFirewallPolicyRuleCollectionGroups API
// service call.
type FirewallPolicyRuleCollectionGroupListResult struct {
	autorest.Response `json:"-"`
	// Value - List of FirewallPolicyRuleCollectionGroups in a FirewallPolicy.
	Value *[]FirewallPolicyRuleCollectionGroup `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// FirewallPolicyRuleCollectionGroupListResultIterator provides access to a complete listing of
// FirewallPolicyRuleCollectionGroup values.
type FirewallPolicyRuleCollectionGroupListResultIterator struct {
	i    int
	page FirewallPolicyRuleCollectionGroupListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FirewallPolicyRuleCollectionGroupListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FirewallPolicyRuleCollectionGroupListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FirewallPolicyRuleCollectionGroupListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FirewallPolicyRuleCollectionGroupListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FirewallPolicyRuleCollectionGroupListResultIterator) Response() FirewallPolicyRuleCollectionGroupListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FirewallPolicyRuleCollectionGroupListResultIterator) Value() FirewallPolicyRuleCollectionGroup {
	if !iter.page.NotDone() {
		return FirewallPolicyRuleCollectionGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FirewallPolicyRuleCollectionGroupListResultIterator type.
func NewFirewallPolicyRuleCollectionGroupListResultIterator(page FirewallPolicyRuleCollectionGroupListResultPage) FirewallPolicyRuleCollectionGroupListResultIterator {
	return FirewallPolicyRuleCollectionGroupListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (fprcglr FirewallPolicyRuleCollectionGroupListResult) IsEmpty() bool {
	return fprcglr.Value == nil || len(*fprcglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (fprcglr FirewallPolicyRuleCollectionGroupListResult) hasNextLink() bool {
	return fprcglr.NextLink != nil && len(*fprcglr.NextLink) != 0
}

// firewallPolicyRuleCollectionGroupListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (fprcglr FirewallPolicyRuleCollectionGroupListResult) firewallPolicyRuleCollectionGroupListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !fprcglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(fprcglr.NextLink)))
}

// FirewallPolicyRuleCollectionGroupListResultPage contains a page of FirewallPolicyRuleCollectionGroup
// values.
type FirewallPolicyRuleCollectionGroupListResultPage struct {
	fn      func(context.Context, FirewallPolicyRuleCollectionGroupListResult) (FirewallPolicyRuleCollectionGroupListResult, error)
	fprcglr FirewallPolicyRuleCollectionGroupListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FirewallPolicyRuleCollectionGroupListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FirewallPolicyRuleCollectionGroupListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.fprcglr)
		if err != nil {
			return err
		}
		page.fprcglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FirewallPolicyRuleCollectionGroupListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FirewallPolicyRuleCollectionGroupListResultPage) NotDone() bool {
	return !page.fprcglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FirewallPolicyRuleCollectionGroupListResultPage) Response() FirewallPolicyRuleCollectionGroupListResult {
	return page.fprcglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FirewallPolicyRuleCollectionGroupListResultPage) Values() []FirewallPolicyRuleCollectionGroup {
	if page.fprcglr.IsEmpty() {
		return nil
	}
	return *page.fprcglr.Value
}

// Creates a new instance of the FirewallPolicyRuleCollectionGroupListResultPage type.
func NewFirewallPolicyRuleCollectionGroupListResultPage(cur FirewallPolicyRuleCollectionGroupListResult, getNextPage func(context.Context, FirewallPolicyRuleCollectionGroupListResult) (FirewallPolicyRuleCollectionGroupListResult, error)) FirewallPolicyRuleCollectionGroupListResultPage {
	return FirewallPolicyRuleCollectionGroupListResultPage{
		fn:      getNextPage,
		fprcglr: cur,
	}
}

// FirewallPolicyRuleCollectionGroupProperties properties of the rule collection group.
type FirewallPolicyRuleCollectionGroupProperties struct {
	// Priority - Priority of the Firewall Policy Rule Collection Group resource.
	Priority *int32 `json:"priority,omitempty"`
	// RuleCollections - Group of Firewall Policy rule collections.
	RuleCollections *[]BasicFirewallPolicyRuleCollection `json:"ruleCollections,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the firewall policy rule collection group resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallPolicyRuleCollectionGroupProperties.
func (fprcgp FirewallPolicyRuleCollectionGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fprcgp.Priority != nil {
		objectMap["priority"] = fprcgp.Priority
	}
	if fprcgp.RuleCollections != nil {
		objectMap["ruleCollections"] = fprcgp.RuleCollections
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FirewallPolicyRuleCollectionGroupProperties struct.
func (fprcgp *FirewallPolicyRuleCollectionGroupProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "priority":
			if v != nil {
				var priority int32
				err = json.Unmarshal(*v, &priority)
				if err != nil {
					return err
				}
				fprcgp.Priority = &priority
			}
		case "ruleCollections":
			if v != nil {
				ruleCollections, err := unmarshalBasicFirewallPolicyRuleCollectionArray(*v)
				if err != nil {
					return err
				}
				fprcgp.RuleCollections = &ruleCollections
			}
		case "provisioningState":
			if v != nil {
				var provisioningState ProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				fprcgp.ProvisioningState = provisioningState
			}
		}
	}

	return nil
}

// FirewallPolicyRuleCollectionGroupsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type FirewallPolicyRuleCollectionGroupsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FirewallPolicyRuleCollectionGroupsClient) (FirewallPolicyRuleCollectionGroup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FirewallPolicyRuleCollectionGroupsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FirewallPolicyRuleCollectionGroupsCreateOrUpdateFuture.Result.
func (future *FirewallPolicyRuleCollectionGroupsCreateOrUpdateFuture) result(client FirewallPolicyRuleCollectionGroupsClient) (fprcg FirewallPolicyRuleCollectionGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.FirewallPolicyRuleCollectionGroupsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		fprcg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.FirewallPolicyRuleCollectionGroupsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fprcg.Response.Response, err = future.GetResult(sender); err == nil && fprcg.Response.Response.StatusCode != http.StatusNoContent {
		fprcg, err = client.CreateOrUpdateResponder(fprcg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.FirewallPolicyRuleCollectionGroupsCreateOrUpdateFuture", "Result", fprcg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FirewallPolicyRuleCollectionGroupsDeleteFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type FirewallPolicyRuleCollectionGroupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FirewallPolicyRuleCollectionGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FirewallPolicyRuleCollectionGroupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FirewallPolicyRuleCollectionGroupsDeleteFuture.Result.
func (future *FirewallPolicyRuleCollectionGroupsDeleteFuture) result(client FirewallPolicyRuleCollectionGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.FirewallPolicyRuleCollectionGroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.FirewallPolicyRuleCollectionGroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// FirewallPolicySku SKU of Firewall policy.
type FirewallPolicySku struct {
	// Tier - Tier of Firewall Policy. Possible values include: 'FirewallPolicySkuTierStandard', 'FirewallPolicySkuTierPremium'
	Tier FirewallPolicySkuTier `json:"tier,omitempty"`
}

// FirewallPolicySNAT the private IP addresses/IP ranges to which traffic will not be SNAT.
type FirewallPolicySNAT struct {
	// PrivateRanges - List of private IP addresses/IP address ranges to not be SNAT.
	PrivateRanges *[]string `json:"privateRanges,omitempty"`
}

// FirewallPolicyThreatIntelWhitelist threatIntel Whitelist for Firewall Policy.
type FirewallPolicyThreatIntelWhitelist struct {
	// IPAddresses - List of IP addresses for the ThreatIntel Whitelist.
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
	// Fqdns - List of FQDNs for the ThreatIntel Whitelist.
	Fqdns *[]string `json:"fqdns,omitempty"`
}

// FirewallPolicyTransportSecurity configuration needed to perform TLS termination & initiation.
type FirewallPolicyTransportSecurity struct {
	// CertificateAuthority - The CA used for intermediate CA generation.
	CertificateAuthority *FirewallPolicyCertificateAuthority `json:"certificateAuthority,omitempty"`
}

// FlowLog a flow log resource.
type FlowLog struct {
	autorest.Response `json:"-"`
	// FlowLogPropertiesFormat - Properties of the flow log.
	*FlowLogPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for FlowLog.
func (fl FlowLog) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fl.FlowLogPropertiesFormat != nil {
		objectMap["properties"] = fl.FlowLogPropertiesFormat
	}
	if fl.ID != nil {
		objectMap["id"] = fl.ID
	}
	if fl.Location != nil {
		objectMap["location"] = fl.Location
	}
	if fl.Tags != nil {
		objectMap["tags"] = fl.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FlowLog struct.
func (fl *FlowLog) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var flowLogPropertiesFormat FlowLogPropertiesFormat
				err = json.Unmarshal(*v, &flowLogPropertiesFormat)
				if err != nil {
					return err
				}
				fl.FlowLogPropertiesFormat = &flowLogPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				fl.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fl.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fl.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fl.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				fl.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				fl.Tags = tags
			}
		}
	}

	return nil
}

// FlowLogFormatParameters parameters that define the flow log format.
type FlowLogFormatParameters struct {
	// Type - The file type of flow log. Possible values include: 'FlowLogFormatTypeJSON'
	Type FlowLogFormatType `json:"type,omitempty"`
	// Version - The version (revision) of the flow log.
	Version *int32 `json:"version,omitempty"`
}

// FlowLogInformation information on the configuration of flow log and traffic analytics (optional) .
type FlowLogInformation struct {
	autorest.Response `json:"-"`
	// TargetResourceID - The ID of the resource to configure for flow log and traffic analytics (optional) .
	TargetResourceID *string `json:"targetResourceId,omitempty"`
	// FlowLogProperties - Properties of the flow log.
	*FlowLogProperties `json:"properties,omitempty"`
	// FlowAnalyticsConfiguration - Parameters that define the configuration of traffic analytics.
	FlowAnalyticsConfiguration *TrafficAnalyticsProperties `json:"flowAnalyticsConfiguration,omitempty"`
}

// MarshalJSON is the custom marshaler for FlowLogInformation.
func (fli FlowLogInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fli.TargetResourceID != nil {
		objectMap["targetResourceId"] = fli.TargetResourceID
	}
	if fli.FlowLogProperties != nil {
		objectMap["properties"] = fli.FlowLogProperties
	}
	if fli.FlowAnalyticsConfiguration != nil {
		objectMap["flowAnalyticsConfiguration"] = fli.FlowAnalyticsConfiguration
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FlowLogInformation struct.
func (fli *FlowLogInformation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "targetResourceId":
			if v != nil {
				var targetResourceID string
				err = json.Unmarshal(*v, &targetResourceID)
				if err != nil {
					return err
				}
				fli.TargetResourceID = &targetResourceID
			}
		case "properties":
			if v != nil {
				var flowLogProperties FlowLogProperties
				err = json.Unmarshal(*v, &flowLogProperties)
				if err != nil {
					return err
				}
				fli.FlowLogProperties = &flowLogProperties
			}
		case "flowAnalyticsConfiguration":
			if v != nil {
				var flowAnalyticsConfiguration TrafficAnalyticsProperties
				err = json.Unmarshal(*v, &flowAnalyticsConfiguration)
				if err != nil {
					return err
				}
				fli.FlowAnalyticsConfiguration = &flowAnalyticsConfiguration
			}
		}
	}

	return nil
}

// FlowLogListResult list of flow logs.
type FlowLogListResult struct {
	autorest.Response `json:"-"`
	// Value - Information about flow log resource.
	Value *[]FlowLog `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for FlowLogListResult.
func (fllr FlowLogListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fllr.Value != nil {
		objectMap["value"] = fllr.Value
	}
	return json.Marshal(objectMap)
}

// FlowLogListResultIterator provides access to a complete listing of FlowLog values.
type FlowLogListResultIterator struct {
	i    int
	page FlowLogListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FlowLogListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FlowLogListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FlowLogListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FlowLogListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FlowLogListResultIterator) Response() FlowLogListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FlowLogListResultIterator) Value() FlowLog {
	if !iter.page.NotDone() {
		return FlowLog{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FlowLogListResultIterator type.
func NewFlowLogListResultIterator(page FlowLogListResultPage) FlowLogListResultIterator {
	return FlowLogListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (fllr FlowLogListResult) IsEmpty() bool {
	return fllr.Value == nil || len(*fllr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (fllr FlowLogListResult) hasNextLink() bool {
	return fllr.NextLink != nil && len(*fllr.NextLink) != 0
}

// flowLogListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (fllr FlowLogListResult) flowLogListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !fllr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(fllr.NextLink)))
}

// FlowLogListResultPage contains a page of FlowLog values.
type FlowLogListResultPage struct {
	fn   func(context.Context, FlowLogListResult) (FlowLogListResult, error)
	fllr FlowLogListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FlowLogListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FlowLogListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.fllr)
		if err != nil {
			return err
		}
		page.fllr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FlowLogListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FlowLogListResultPage) NotDone() bool {
	return !page.fllr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FlowLogListResultPage) Response() FlowLogListResult {
	return page.fllr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FlowLogListResultPage) Values() []FlowLog {
	if page.fllr.IsEmpty() {
		return nil
	}
	return *page.fllr.Value
}

// Creates a new instance of the FlowLogListResultPage type.
func NewFlowLogListResultPage(cur FlowLogListResult, getNextPage func(context.Context, FlowLogListResult) (FlowLogListResult, error)) FlowLogListResultPage {
	return FlowLogListResultPage{
		fn:   getNextPage,
		fllr: cur,
	}
}

// FlowLogProperties parameters that define the configuration of flow log.
type FlowLogProperties struct {
	// StorageID - ID of the storage account which is used to store the flow log.
	StorageID *string `json:"storageId,omitempty"`
	// Enabled - Flag to enable/disable flow logging.
	Enabled *bool `json:"enabled,omitempty"`
	// RetentionPolicy - Parameters that define the retention policy for flow log.
	RetentionPolicy *RetentionPolicyParameters `json:"retentionPolicy,omitempty"`
	// Format - Parameters that define the flow log format.
	Format *FlowLogFormatParameters `json:"format,omitempty"`
}

// FlowLogPropertiesFormat parameters that define the configuration of flow log.
type FlowLogPropertiesFormat struct {
	// TargetResourceID - ID of network security group to which flow log will be applied.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
	// TargetResourceGUID - READ-ONLY; Guid of network security group to which flow log will be applied.
	TargetResourceGUID *string `json:"targetResourceGuid,omitempty"`
	// StorageID - ID of the storage account which is used to store the flow log.
	StorageID *string `json:"storageId,omitempty"`
	// Enabled - Flag to enable/disable flow logging.
	Enabled *bool `json:"enabled,omitempty"`
	// RetentionPolicy - Parameters that define the retention policy for flow log.
	RetentionPolicy *RetentionPolicyParameters `json:"retentionPolicy,omitempty"`
	// Format - Parameters that define the flow log format.
	Format *FlowLogFormatParameters `json:"format,omitempty"`
	// FlowAnalyticsConfiguration - Parameters that define the configuration of traffic analytics.
	FlowAnalyticsConfiguration *TrafficAnalyticsProperties `json:"flowAnalyticsConfiguration,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the flow log. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for FlowLogPropertiesFormat.
func (flpf FlowLogPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if flpf.TargetResourceID != nil {
		objectMap["targetResourceId"] = flpf.TargetResourceID
	}
	if flpf.StorageID != nil {
		objectMap["storageId"] = flpf.StorageID
	}
	if flpf.Enabled != nil {
		objectMap["enabled"] = flpf.Enabled
	}
	if flpf.RetentionPolicy != nil {
		objectMap["retentionPolicy"] = flpf.RetentionPolicy
	}
	if flpf.Format != nil {
		objectMap["format"] = flpf.Format
	}
	if flpf.FlowAnalyticsConfiguration != nil {
		objectMap["flowAnalyticsConfiguration"] = flpf.FlowAnalyticsConfiguration
	}
	return json.Marshal(objectMap)
}

// FlowLogsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type FlowLogsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FlowLogsClient) (FlowLog, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FlowLogsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FlowLogsCreateOrUpdateFuture.Result.
func (future *FlowLogsCreateOrUpdateFuture) result(client FlowLogsClient) (fl FlowLog, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.FlowLogsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		fl.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.FlowLogsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fl.Response.Response, err = future.GetResult(sender); err == nil && fl.Response.Response.StatusCode != http.StatusNoContent {
		fl, err = client.CreateOrUpdateResponder(fl.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.FlowLogsCreateOrUpdateFuture", "Result", fl.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FlowLogsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type FlowLogsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FlowLogsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FlowLogsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FlowLogsDeleteFuture.Result.
func (future *FlowLogsDeleteFuture) result(client FlowLogsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.FlowLogsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.FlowLogsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// FlowLogStatusParameters parameters that define a resource to query flow log and traffic analytics
// (optional) status.
type FlowLogStatusParameters struct {
	// TargetResourceID - The target resource where getting the flow log and traffic analytics (optional) status.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
}

// FrontendIPConfiguration frontend IP address of the load balancer.
type FrontendIPConfiguration struct {
	autorest.Response `json:"-"`
	// FrontendIPConfigurationPropertiesFormat - Properties of the load balancer probe.
	*FrontendIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the set of frontend IP configurations used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// Zones - A list of availability zones denoting the IP allocated for the resource needs to come from.
	Zones *[]string `json:"zones,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for FrontendIPConfiguration.
func (fic FrontendIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fic.FrontendIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = fic.FrontendIPConfigurationPropertiesFormat
	}
	if fic.Name != nil {
		objectMap["name"] = fic.Name
	}
	if fic.Zones != nil {
		objectMap["zones"] = fic.Zones
	}
	if fic.ID != nil {
		objectMap["id"] = fic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FrontendIPConfiguration struct.
func (fic *FrontendIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var frontendIPConfigurationPropertiesFormat FrontendIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &frontendIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				fic.FrontendIPConfigurationPropertiesFormat = &frontendIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				fic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fic.Type = &typeVar
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				fic.Zones = &zones
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fic.ID = &ID
			}
		}
	}

	return nil
}

// FrontendIPConfigurationPropertiesFormat properties of Frontend IP Configuration of the load balancer.
type FrontendIPConfigurationPropertiesFormat struct {
	// InboundNatRules - READ-ONLY; An array of references to inbound rules that use this frontend IP.
	InboundNatRules *[]SubResource `json:"inboundNatRules,omitempty"`
	// InboundNatPools - READ-ONLY; An array of references to inbound pools that use this frontend IP.
	InboundNatPools *[]SubResource `json:"inboundNatPools,omitempty"`
	// OutboundRules - READ-ONLY; An array of references to outbound rules that use this frontend IP.
	OutboundRules *[]SubResource `json:"outboundRules,omitempty"`
	// LoadBalancingRules - READ-ONLY; An array of references to load balancing rules that use this frontend IP.
	LoadBalancingRules *[]SubResource `json:"loadBalancingRules,omitempty"`
	// PrivateIPAddress - The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// PrivateIPAllocationMethod - The Private IP allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	// PrivateIPAddressVersion - Whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values include: 'IPVersionIPv4', 'IPVersionIPv6'
	PrivateIPAddressVersion IPVersion `json:"privateIPAddressVersion,omitempty"`
	// Subnet - The reference to the subnet resource.
	Subnet *Subnet `json:"subnet,omitempty"`
	// PublicIPAddress - The reference to the Public IP resource.
	PublicIPAddress *PublicIPAddress `json:"publicIPAddress,omitempty"`
	// PublicIPPrefix - The reference to the Public IP Prefix resource.
	PublicIPPrefix *SubResource `json:"publicIPPrefix,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the frontend IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for FrontendIPConfigurationPropertiesFormat.
func (ficpf FrontendIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ficpf.PrivateIPAddress != nil {
		objectMap["privateIPAddress"] = ficpf.PrivateIPAddress
	}
	if ficpf.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = ficpf.PrivateIPAllocationMethod
	}
	if ficpf.PrivateIPAddressVersion != "" {
		objectMap["privateIPAddressVersion"] = ficpf.PrivateIPAddressVersion
	}
	if ficpf.Subnet != nil {
		objectMap["subnet"] = ficpf.Subnet
	}
	if ficpf.PublicIPAddress != nil {
		objectMap["publicIPAddress"] = ficpf.PublicIPAddress
	}
	if ficpf.PublicIPPrefix != nil {
		objectMap["publicIPPrefix"] = ficpf.PublicIPPrefix
	}
	return json.Marshal(objectMap)
}

// GatewayRoute gateway routing details.
type GatewayRoute struct {
	// LocalAddress - READ-ONLY; The gateway's local address.
	LocalAddress *string `json:"localAddress,omitempty"`
	// NetworkProperty - READ-ONLY; The route's network prefix.
	NetworkProperty *string `json:"network,omitempty"`
	// NextHop - READ-ONLY; The route's next hop.
	NextHop *string `json:"nextHop,omitempty"`
	// SourcePeer - READ-ONLY; The peer this route was learned from.
	SourcePeer *string `json:"sourcePeer,omitempty"`
	// Origin - READ-ONLY; The source this route was learned from.
	Origin *string `json:"origin,omitempty"`
	// AsPath - READ-ONLY; The route's AS path sequence.
	AsPath *string `json:"asPath,omitempty"`
	// Weight - READ-ONLY; The route's weight.
	Weight *int32 `json:"weight,omitempty"`
}

// MarshalJSON is the custom marshaler for GatewayRoute.
func (gr GatewayRoute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// GatewayRouteListResult list of virtual network gateway routes.
type GatewayRouteListResult struct {
	autorest.Response `json:"-"`
	// Value - List of gateway routes.
	Value *[]GatewayRoute `json:"value,omitempty"`
}

// GenerateExpressRoutePortsLOARequest the customer name to be printed on a letter of authorization.
type GenerateExpressRoutePortsLOARequest struct {
	// CustomerName - The customer name.
	CustomerName *string `json:"customerName,omitempty"`
}

// GenerateExpressRoutePortsLOAResult response for GenerateExpressRoutePortsLOA API service call.
type GenerateExpressRoutePortsLOAResult struct {
	autorest.Response `json:"-"`
	// EncodedContent - The content as a base64 encoded string.
	EncodedContent *string `json:"encodedContent,omitempty"`
}

// GeneratevirtualwanvpnserverconfigurationvpnprofileFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type GeneratevirtualwanvpnserverconfigurationvpnprofileFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BaseClient) (VpnProfileResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *GeneratevirtualwanvpnserverconfigurationvpnprofileFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for GeneratevirtualwanvpnserverconfigurationvpnprofileFuture.Result.
func (future *GeneratevirtualwanvpnserverconfigurationvpnprofileFuture) result(client BaseClient) (vpr VpnProfileResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.GeneratevirtualwanvpnserverconfigurationvpnprofileFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vpr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.GeneratevirtualwanvpnserverconfigurationvpnprofileFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vpr.Response.Response, err = future.GetResult(sender); err == nil && vpr.Response.Response.StatusCode != http.StatusNoContent {
		vpr, err = client.GeneratevirtualwanvpnserverconfigurationvpnprofileResponder(vpr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.GeneratevirtualwanvpnserverconfigurationvpnprofileFuture", "Result", vpr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// GetActiveSessionsAllFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type GetActiveSessionsAllFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BaseClient) (BastionActiveSessionListResultPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *GetActiveSessionsAllFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for GetActiveSessionsAllFuture.Result.
func (future *GetActiveSessionsAllFuture) result(client BaseClient) (baslrp BastionActiveSessionListResultPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.GetActiveSessionsAllFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		baslrp.baslr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.GetActiveSessionsAllFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if baslrp.baslr.Response.Response, err = future.GetResult(sender); err == nil && baslrp.baslr.Response.Response.StatusCode != http.StatusNoContent {
		baslrp, err = client.GetActiveSessionsResponder(baslrp.baslr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.GetActiveSessionsAllFuture", "Result", baslrp.baslr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// GetActiveSessionsFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type GetActiveSessionsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BaseClient) (BastionActiveSessionListResultPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *GetActiveSessionsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for GetActiveSessionsFuture.Result.
func (future *GetActiveSessionsFuture) result(client BaseClient) (baslrp BastionActiveSessionListResultPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.GetActiveSessionsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		baslrp.baslr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.GetActiveSessionsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if baslrp.baslr.Response.Response, err = future.GetResult(sender); err == nil && baslrp.baslr.Response.Response.StatusCode != http.StatusNoContent {
		baslrp, err = client.GetActiveSessionsResponder(baslrp.baslr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.GetActiveSessionsFuture", "Result", baslrp.baslr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// GetVpnSitesConfigurationRequest list of Vpn-Sites.
type GetVpnSitesConfigurationRequest struct {
	// VpnSites - List of resource-ids of the vpn-sites for which config is to be downloaded.
	VpnSites *[]string `json:"vpnSites,omitempty"`
	// OutputBlobSasURL - The sas-url to download the configurations for vpn-sites.
	OutputBlobSasURL *string `json:"outputBlobSasUrl,omitempty"`
}

// HopLink hop link.
type HopLink struct {
	// NextHopID - READ-ONLY; The ID of the next hop.
	NextHopID *string `json:"nextHopId,omitempty"`
	// LinkType - READ-ONLY; Link type.
	LinkType *string `json:"linkType,omitempty"`
	// HopLinkProperties - Hop link properties.
	*HopLinkProperties `json:"properties,omitempty"`
	// Issues - READ-ONLY; List of issues.
	Issues *[]ConnectivityIssue `json:"issues,omitempty"`
	// Context - READ-ONLY; Provides additional context on links.
	Context map[string]*string `json:"context"`
	// ResourceID - READ-ONLY; Resource ID.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON is the custom marshaler for HopLink.
func (hl HopLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hl.HopLinkProperties != nil {
		objectMap["properties"] = hl.HopLinkProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HopLink struct.
func (hl *HopLink) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextHopId":
			if v != nil {
				var nextHopID string
				err = json.Unmarshal(*v, &nextHopID)
				if err != nil {
					return err
				}
				hl.NextHopID = &nextHopID
			}
		case "linkType":
			if v != nil {
				var linkType string
				err = json.Unmarshal(*v, &linkType)
				if err != nil {
					return err
				}
				hl.LinkType = &linkType
			}
		case "properties":
			if v != nil {
				var hopLinkProperties HopLinkProperties
				err = json.Unmarshal(*v, &hopLinkProperties)
				if err != nil {
					return err
				}
				hl.HopLinkProperties = &hopLinkProperties
			}
		case "issues":
			if v != nil {
				var issues []ConnectivityIssue
				err = json.Unmarshal(*v, &issues)
				if err != nil {
					return err
				}
				hl.Issues = &issues
			}
		case "context":
			if v != nil {
				var context map[string]*string
				err = json.Unmarshal(*v, &context)
				if err != nil {
					return err
				}
				hl.Context = context
			}
		case "resourceId":
			if v != nil {
				var resourceID string
				err = json.Unmarshal(*v, &resourceID)
				if err != nil {
					return err
				}
				hl.ResourceID = &resourceID
			}
		}
	}

	return nil
}

// HopLinkProperties hop link properties.
type HopLinkProperties struct {
	// RoundTripTimeMin - READ-ONLY; Minimum roundtrip time in milliseconds.
	RoundTripTimeMin *int64 `json:"roundTripTimeMin,omitempty"`
	// RoundTripTimeAvg - READ-ONLY; Average roundtrip time in milliseconds.
	RoundTripTimeAvg *int64 `json:"roundTripTimeAvg,omitempty"`
	// RoundTripTimeMax - READ-ONLY; Maximum roundtrip time in milliseconds.
	RoundTripTimeMax *int64 `json:"roundTripTimeMax,omitempty"`
}

// MarshalJSON is the custom marshaler for HopLinkProperties.
func (hlp HopLinkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// HTTPConfiguration HTTP configuration of the connectivity check.
type HTTPConfiguration struct {
	// Method - HTTP method. Possible values include: 'HTTPMethodGet'
	Method HTTPMethod `json:"method,omitempty"`
	// Headers - List of HTTP headers.
	Headers *[]HTTPHeader `json:"headers,omitempty"`
	// ValidStatusCodes - Valid status codes.
	ValidStatusCodes *[]int32 `json:"validStatusCodes,omitempty"`
}

// HTTPHeader the HTTP header.
type HTTPHeader struct {
	// Name - The name in HTTP header.
	Name *string `json:"name,omitempty"`
	// Value - The value in HTTP header.
	Value *string `json:"value,omitempty"`
}

// HubIPAddresses IP addresses associated with azure firewall.
type HubIPAddresses struct {
	// PublicIPs - Public IP addresses associated with azure firewall.
	PublicIPs *HubPublicIPAddresses `json:"publicIPs,omitempty"`
	// PrivateIPAddress - Private IP Address associated with azure firewall.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
}

// HubIPConfiguration ipConfigurations.
type HubIPConfiguration struct {
	autorest.Response `json:"-"`
	// HubIPConfigurationPropertiesFormat - The properties of the Virtual Hub IPConfigurations.
	*HubIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the Ip Configuration.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Ipconfiguration type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for HubIPConfiguration.
func (hic HubIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hic.HubIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = hic.HubIPConfigurationPropertiesFormat
	}
	if hic.Name != nil {
		objectMap["name"] = hic.Name
	}
	if hic.ID != nil {
		objectMap["id"] = hic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HubIPConfiguration struct.
func (hic *HubIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hubIPConfigurationPropertiesFormat HubIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &hubIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				hic.HubIPConfigurationPropertiesFormat = &hubIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				hic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				hic.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				hic.ID = &ID
			}
		}
	}

	return nil
}

// HubIPConfigurationPropertiesFormat properties of IP configuration.
type HubIPConfigurationPropertiesFormat struct {
	// PrivateIPAddress - The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	// Subnet - The reference to the subnet resource.
	Subnet *Subnet `json:"subnet,omitempty"`
	// PublicIPAddress - The reference to the public IP resource.
	PublicIPAddress *PublicIPAddress `json:"publicIPAddress,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for HubIPConfigurationPropertiesFormat.
func (hicpf HubIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hicpf.PrivateIPAddress != nil {
		objectMap["privateIPAddress"] = hicpf.PrivateIPAddress
	}
	if hicpf.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = hicpf.PrivateIPAllocationMethod
	}
	if hicpf.Subnet != nil {
		objectMap["subnet"] = hicpf.Subnet
	}
	if hicpf.PublicIPAddress != nil {
		objectMap["publicIPAddress"] = hicpf.PublicIPAddress
	}
	return json.Marshal(objectMap)
}

// HubPublicIPAddresses public IP addresses associated with azure firewall.
type HubPublicIPAddresses struct {
	// Addresses - The list of Public IP addresses associated with azure firewall or IP addresses to be retained.
	Addresses *[]AzureFirewallPublicIPAddress `json:"addresses,omitempty"`
	// Count - The number of Public IP addresses associated with azure firewall.
	Count *int32 `json:"count,omitempty"`
}

// HubRoute routeTable route.
type HubRoute struct {
	// Name - The name of the Route that is unique within a RouteTable. This name can be used to access this route.
	Name *string `json:"name,omitempty"`
	// DestinationType - The type of destinations (eg: CIDR, ResourceId, Service).
	DestinationType *string `json:"destinationType,omitempty"`
	// Destinations - List of all destinations.
	Destinations *[]string `json:"destinations,omitempty"`
	// NextHopType - The type of next hop (eg: ResourceId).
	NextHopType *string `json:"nextHopType,omitempty"`
	// NextHop - NextHop resource ID.
	NextHop *string `json:"nextHop,omitempty"`
}

// HubRouteTable routeTable resource in a virtual hub.
type HubRouteTable struct {
	autorest.Response `json:"-"`
	// HubRouteTableProperties - Properties of the RouteTable resource.
	*HubRouteTableProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for HubRouteTable.
func (hrt HubRouteTable) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hrt.HubRouteTableProperties != nil {
		objectMap["properties"] = hrt.HubRouteTableProperties
	}
	if hrt.Name != nil {
		objectMap["name"] = hrt.Name
	}
	if hrt.ID != nil {
		objectMap["id"] = hrt.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HubRouteTable struct.
func (hrt *HubRouteTable) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hubRouteTableProperties HubRouteTableProperties
				err = json.Unmarshal(*v, &hubRouteTableProperties)
				if err != nil {
					return err
				}
				hrt.HubRouteTableProperties = &hubRouteTableProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hrt.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				hrt.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				hrt.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				hrt.ID = &ID
			}
		}
	}

	return nil
}

// HubRouteTableProperties parameters for RouteTable.
type HubRouteTableProperties struct {
	// Routes - List of all routes.
	Routes *[]HubRoute `json:"routes,omitempty"`
	// Labels - List of labels associated with this route table.
	Labels *[]string `json:"labels,omitempty"`
	// AssociatedConnections - READ-ONLY; List of all connections associated with this route table.
	AssociatedConnections *[]string `json:"associatedConnections,omitempty"`
	// PropagatingConnections - READ-ONLY; List of all connections that advertise to this route table.
	PropagatingConnections *[]string `json:"propagatingConnections,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the RouteTable resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for HubRouteTableProperties.
func (hrtp HubRouteTableProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hrtp.Routes != nil {
		objectMap["routes"] = hrtp.Routes
	}
	if hrtp.Labels != nil {
		objectMap["labels"] = hrtp.Labels
	}
	return json.Marshal(objectMap)
}

// HubRouteTablesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type HubRouteTablesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(HubRouteTablesClient) (HubRouteTable, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *HubRouteTablesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for HubRouteTablesCreateOrUpdateFuture.Result.
func (future *HubRouteTablesCreateOrUpdateFuture) result(client HubRouteTablesClient) (hrt HubRouteTable, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.HubRouteTablesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		hrt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.HubRouteTablesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if hrt.Response.Response, err = future.GetResult(sender); err == nil && hrt.Response.Response.StatusCode != http.StatusNoContent {
		hrt, err = client.CreateOrUpdateResponder(hrt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.HubRouteTablesCreateOrUpdateFuture", "Result", hrt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// HubRouteTablesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type HubRouteTablesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(HubRouteTablesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *HubRouteTablesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for HubRouteTablesDeleteFuture.Result.
func (future *HubRouteTablesDeleteFuture) result(client HubRouteTablesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.HubRouteTablesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.HubRouteTablesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// HubVirtualNetworkConnection hubVirtualNetworkConnection Resource.
type HubVirtualNetworkConnection struct {
	autorest.Response `json:"-"`
	// HubVirtualNetworkConnectionProperties - Properties of the hub virtual network connection.
	*HubVirtualNetworkConnectionProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for HubVirtualNetworkConnection.
func (hvnc HubVirtualNetworkConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hvnc.HubVirtualNetworkConnectionProperties != nil {
		objectMap["properties"] = hvnc.HubVirtualNetworkConnectionProperties
	}
	if hvnc.Name != nil {
		objectMap["name"] = hvnc.Name
	}
	if hvnc.ID != nil {
		objectMap["id"] = hvnc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HubVirtualNetworkConnection struct.
func (hvnc *HubVirtualNetworkConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hubVirtualNetworkConnectionProperties HubVirtualNetworkConnectionProperties
				err = json.Unmarshal(*v, &hubVirtualNetworkConnectionProperties)
				if err != nil {
					return err
				}
				hvnc.HubVirtualNetworkConnectionProperties = &hubVirtualNetworkConnectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				hvnc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				hvnc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				hvnc.ID = &ID
			}
		}
	}

	return nil
}

// HubVirtualNetworkConnectionProperties parameters for HubVirtualNetworkConnection.
type HubVirtualNetworkConnectionProperties struct {
	// RemoteVirtualNetwork - Reference to the remote virtual network.
	RemoteVirtualNetwork *SubResource `json:"remoteVirtualNetwork,omitempty"`
	// AllowHubToRemoteVnetTransit - Deprecated: VirtualHub to RemoteVnet transit to enabled or not.
	AllowHubToRemoteVnetTransit *bool `json:"allowHubToRemoteVnetTransit,omitempty"`
	// AllowRemoteVnetToUseHubVnetGateways - Deprecated: Allow RemoteVnet to use Virtual Hub's gateways.
	AllowRemoteVnetToUseHubVnetGateways *bool `json:"allowRemoteVnetToUseHubVnetGateways,omitempty"`
	// EnableInternetSecurity - Enable internet security.
	EnableInternetSecurity *bool `json:"enableInternetSecurity,omitempty"`
	// RoutingConfiguration - The Routing Configuration indicating the associated and propagated route tables on this connection.
	RoutingConfiguration *RoutingConfiguration `json:"routingConfiguration,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the hub virtual network connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for HubVirtualNetworkConnectionProperties.
func (hvncp HubVirtualNetworkConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hvncp.RemoteVirtualNetwork != nil {
		objectMap["remoteVirtualNetwork"] = hvncp.RemoteVirtualNetwork
	}
	if hvncp.AllowHubToRemoteVnetTransit != nil {
		objectMap["allowHubToRemoteVnetTransit"] = hvncp.AllowHubToRemoteVnetTransit
	}
	if hvncp.AllowRemoteVnetToUseHubVnetGateways != nil {
		objectMap["allowRemoteVnetToUseHubVnetGateways"] = hvncp.AllowRemoteVnetToUseHubVnetGateways
	}
	if hvncp.EnableInternetSecurity != nil {
		objectMap["enableInternetSecurity"] = hvncp.EnableInternetSecurity
	}
	if hvncp.RoutingConfiguration != nil {
		objectMap["routingConfiguration"] = hvncp.RoutingConfiguration
	}
	return json.Marshal(objectMap)
}

// HubVirtualNetworkConnectionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type HubVirtualNetworkConnectionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(HubVirtualNetworkConnectionsClient) (HubVirtualNetworkConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *HubVirtualNetworkConnectionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for HubVirtualNetworkConnectionsCreateOrUpdateFuture.Result.
func (future *HubVirtualNetworkConnectionsCreateOrUpdateFuture) result(client HubVirtualNetworkConnectionsClient) (hvnc HubVirtualNetworkConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.HubVirtualNetworkConnectionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		hvnc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.HubVirtualNetworkConnectionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if hvnc.Response.Response, err = future.GetResult(sender); err == nil && hvnc.Response.Response.StatusCode != http.StatusNoContent {
		hvnc, err = client.CreateOrUpdateResponder(hvnc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.HubVirtualNetworkConnectionsCreateOrUpdateFuture", "Result", hvnc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// HubVirtualNetworkConnectionsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type HubVirtualNetworkConnectionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(HubVirtualNetworkConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *HubVirtualNetworkConnectionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for HubVirtualNetworkConnectionsDeleteFuture.Result.
func (future *HubVirtualNetworkConnectionsDeleteFuture) result(client HubVirtualNetworkConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.HubVirtualNetworkConnectionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.HubVirtualNetworkConnectionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// InboundNatPool inbound NAT pool of the load balancer.
type InboundNatPool struct {
	// InboundNatPoolPropertiesFormat - Properties of load balancer inbound nat pool.
	*InboundNatPoolPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the set of inbound NAT pools used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for InboundNatPool.
func (inp InboundNatPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if inp.InboundNatPoolPropertiesFormat != nil {
		objectMap["properties"] = inp.InboundNatPoolPropertiesFormat
	}
	if inp.Name != nil {
		objectMap["name"] = inp.Name
	}
	if inp.ID != nil {
		objectMap["id"] = inp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InboundNatPool struct.
func (inp *InboundNatPool) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var inboundNatPoolPropertiesFormat InboundNatPoolPropertiesFormat
				err = json.Unmarshal(*v, &inboundNatPoolPropertiesFormat)
				if err != nil {
					return err
				}
				inp.InboundNatPoolPropertiesFormat = &inboundNatPoolPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				inp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				inp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				inp.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				inp.ID = &ID
			}
		}
	}

	return nil
}

// InboundNatPoolPropertiesFormat properties of Inbound NAT pool.
type InboundNatPoolPropertiesFormat struct {
	// FrontendIPConfiguration - A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`
	// Protocol - The reference to the transport protocol used by the inbound NAT pool. Possible values include: 'TransportProtocolUDP', 'TransportProtocolTCP', 'TransportProtocolAll'
	Protocol TransportProtocol `json:"protocol,omitempty"`
	// FrontendPortRangeStart - The first port number in the range of external ports that will be used to provide Inbound Nat to NICs associated with a load balancer. Acceptable values range between 1 and 65534.
	FrontendPortRangeStart *int32 `json:"frontendPortRangeStart,omitempty"`
	// FrontendPortRangeEnd - The last port number in the range of external ports that will be used to provide Inbound Nat to NICs associated with a load balancer. Acceptable values range between 1 and 65535.
	FrontendPortRangeEnd *int32 `json:"frontendPortRangeEnd,omitempty"`
	// BackendPort - The port used for internal connections on the endpoint. Acceptable values are between 1 and 65535.
	BackendPort *int32 `json:"backendPort,omitempty"`
	// IdleTimeoutInMinutes - The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
	// EnableFloatingIP - Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`
	// EnableTCPReset - Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
	EnableTCPReset *bool `json:"enableTcpReset,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the inbound NAT pool resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for InboundNatPoolPropertiesFormat.
func (inppf InboundNatPoolPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if inppf.FrontendIPConfiguration != nil {
		objectMap["frontendIPConfiguration"] = inppf.FrontendIPConfiguration
	}
	if inppf.Protocol != "" {
		objectMap["protocol"] = inppf.Protocol
	}
	if inppf.FrontendPortRangeStart != nil {
		objectMap["frontendPortRangeStart"] = inppf.FrontendPortRangeStart
	}
	if inppf.FrontendPortRangeEnd != nil {
		objectMap["frontendPortRangeEnd"] = inppf.FrontendPortRangeEnd
	}
	if inppf.BackendPort != nil {
		objectMap["backendPort"] = inppf.BackendPort
	}
	if inppf.IdleTimeoutInMinutes != nil {
		objectMap["idleTimeoutInMinutes"] = inppf.IdleTimeoutInMinutes
	}
	if inppf.EnableFloatingIP != nil {
		objectMap["enableFloatingIP"] = inppf.EnableFloatingIP
	}
	if inppf.EnableTCPReset != nil {
		objectMap["enableTcpReset"] = inppf.EnableTCPReset
	}
	return json.Marshal(objectMap)
}

// InboundNatRule inbound NAT rule of the load balancer.
type InboundNatRule struct {
	autorest.Response `json:"-"`
	// InboundNatRulePropertiesFormat - Properties of load balancer inbound nat rule.
	*InboundNatRulePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the set of inbound NAT rules used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for InboundNatRule.
func (inr InboundNatRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if inr.InboundNatRulePropertiesFormat != nil {
		objectMap["properties"] = inr.InboundNatRulePropertiesFormat
	}
	if inr.Name != nil {
		objectMap["name"] = inr.Name
	}
	if inr.ID != nil {
		objectMap["id"] = inr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InboundNatRule struct.
func (inr *InboundNatRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var inboundNatRulePropertiesFormat InboundNatRulePropertiesFormat
				err = json.Unmarshal(*v, &inboundNatRulePropertiesFormat)
				if err != nil {
					return err
				}
				inr.InboundNatRulePropertiesFormat = &inboundNatRulePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				inr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				inr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				inr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				inr.ID = &ID
			}
		}
	}

	return nil
}

// InboundNatRuleListResult response for ListInboundNatRule API service call.
type InboundNatRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of inbound nat rules in a load balancer.
	Value *[]InboundNatRule `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InboundNatRuleListResult.
func (inrlr InboundNatRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if inrlr.Value != nil {
		objectMap["value"] = inrlr.Value
	}
	return json.Marshal(objectMap)
}

// InboundNatRuleListResultIterator provides access to a complete listing of InboundNatRule values.
type InboundNatRuleListResultIterator struct {
	i    int
	page InboundNatRuleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InboundNatRuleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InboundNatRuleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InboundNatRuleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InboundNatRuleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InboundNatRuleListResultIterator) Response() InboundNatRuleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InboundNatRuleListResultIterator) Value() InboundNatRule {
	if !iter.page.NotDone() {
		return InboundNatRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InboundNatRuleListResultIterator type.
func NewInboundNatRuleListResultIterator(page InboundNatRuleListResultPage) InboundNatRuleListResultIterator {
	return InboundNatRuleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (inrlr InboundNatRuleListResult) IsEmpty() bool {
	return inrlr.Value == nil || len(*inrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (inrlr InboundNatRuleListResult) hasNextLink() bool {
	return inrlr.NextLink != nil && len(*inrlr.NextLink) != 0
}

// inboundNatRuleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (inrlr InboundNatRuleListResult) inboundNatRuleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !inrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(inrlr.NextLink)))
}

// InboundNatRuleListResultPage contains a page of InboundNatRule values.
type InboundNatRuleListResultPage struct {
	fn    func(context.Context, InboundNatRuleListResult) (InboundNatRuleListResult, error)
	inrlr InboundNatRuleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InboundNatRuleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InboundNatRuleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.inrlr)
		if err != nil {
			return err
		}
		page.inrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InboundNatRuleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InboundNatRuleListResultPage) NotDone() bool {
	return !page.inrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InboundNatRuleListResultPage) Response() InboundNatRuleListResult {
	return page.inrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InboundNatRuleListResultPage) Values() []InboundNatRule {
	if page.inrlr.IsEmpty() {
		return nil
	}
	return *page.inrlr.Value
}

// Creates a new instance of the InboundNatRuleListResultPage type.
func NewInboundNatRuleListResultPage(cur InboundNatRuleListResult, getNextPage func(context.Context, InboundNatRuleListResult) (InboundNatRuleListResult, error)) InboundNatRuleListResultPage {
	return InboundNatRuleListResultPage{
		fn:    getNextPage,
		inrlr: cur,
	}
}

// InboundNatRulePropertiesFormat properties of the inbound NAT rule.
type InboundNatRulePropertiesFormat struct {
	// FrontendIPConfiguration - A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`
	// BackendIPConfiguration - READ-ONLY; A reference to a private IP address defined on a network interface of a VM. Traffic sent to the frontend port of each of the frontend IP configurations is forwarded to the backend IP.
	BackendIPConfiguration *InterfaceIPConfiguration `json:"backendIPConfiguration,omitempty"`
	// Protocol - The reference to the transport protocol used by the load balancing rule. Possible values include: 'TransportProtocolUDP', 'TransportProtocolTCP', 'TransportProtocolAll'
	Protocol TransportProtocol `json:"protocol,omitempty"`
	// FrontendPort - The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values range from 1 to 65534.
	FrontendPort *int32 `json:"frontendPort,omitempty"`
	// BackendPort - The port used for the internal endpoint. Acceptable values range from 1 to 65535.
	BackendPort *int32 `json:"backendPort,omitempty"`
	// IdleTimeoutInMinutes - The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
	// EnableFloatingIP - Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`
	// EnableTCPReset - Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
	EnableTCPReset *bool `json:"enableTcpReset,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the inbound NAT rule resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for InboundNatRulePropertiesFormat.
func (inrpf InboundNatRulePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if inrpf.FrontendIPConfiguration != nil {
		objectMap["frontendIPConfiguration"] = inrpf.FrontendIPConfiguration
	}
	if inrpf.Protocol != "" {
		objectMap["protocol"] = inrpf.Protocol
	}
	if inrpf.FrontendPort != nil {
		objectMap["frontendPort"] = inrpf.FrontendPort
	}
	if inrpf.BackendPort != nil {
		objectMap["backendPort"] = inrpf.BackendPort
	}
	if inrpf.IdleTimeoutInMinutes != nil {
		objectMap["idleTimeoutInMinutes"] = inrpf.IdleTimeoutInMinutes
	}
	if inrpf.EnableFloatingIP != nil {
		objectMap["enableFloatingIP"] = inrpf.EnableFloatingIP
	}
	if inrpf.EnableTCPReset != nil {
		objectMap["enableTcpReset"] = inrpf.EnableTCPReset
	}
	return json.Marshal(objectMap)
}

// InboundNatRulesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type InboundNatRulesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InboundNatRulesClient) (InboundNatRule, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InboundNatRulesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InboundNatRulesCreateOrUpdateFuture.Result.
func (future *InboundNatRulesCreateOrUpdateFuture) result(client InboundNatRulesClient) (inr InboundNatRule, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InboundNatRulesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		inr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InboundNatRulesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if inr.Response.Response, err = future.GetResult(sender); err == nil && inr.Response.Response.StatusCode != http.StatusNoContent {
		inr, err = client.CreateOrUpdateResponder(inr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.InboundNatRulesCreateOrUpdateFuture", "Result", inr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InboundNatRulesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type InboundNatRulesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InboundNatRulesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InboundNatRulesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InboundNatRulesDeleteFuture.Result.
func (future *InboundNatRulesDeleteFuture) result(client InboundNatRulesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InboundNatRulesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InboundNatRulesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// InboundSecurityRule NVA Inbound Security Rule resource.
type InboundSecurityRule struct {
	autorest.Response `json:"-"`
	// InboundSecurityRuleProperties - The properties of the Inbound Security Rules.
	*InboundSecurityRuleProperties `json:"properties,omitempty"`
	// Name - Name of security rule collection.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; NVA inbound security rule type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for InboundSecurityRule.
func (isr InboundSecurityRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if isr.InboundSecurityRuleProperties != nil {
		objectMap["properties"] = isr.InboundSecurityRuleProperties
	}
	if isr.Name != nil {
		objectMap["name"] = isr.Name
	}
	if isr.ID != nil {
		objectMap["id"] = isr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InboundSecurityRule struct.
func (isr *InboundSecurityRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var inboundSecurityRuleProperties InboundSecurityRuleProperties
				err = json.Unmarshal(*v, &inboundSecurityRuleProperties)
				if err != nil {
					return err
				}
				isr.InboundSecurityRuleProperties = &inboundSecurityRuleProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				isr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				isr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				isr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				isr.ID = &ID
			}
		}
	}

	return nil
}

// InboundSecurityRuleCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type InboundSecurityRuleCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InboundSecurityRuleClient) (InboundSecurityRule, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InboundSecurityRuleCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InboundSecurityRuleCreateOrUpdateFuture.Result.
func (future *InboundSecurityRuleCreateOrUpdateFuture) result(client InboundSecurityRuleClient) (isr InboundSecurityRule, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InboundSecurityRuleCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		isr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InboundSecurityRuleCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if isr.Response.Response, err = future.GetResult(sender); err == nil && isr.Response.Response.StatusCode != http.StatusNoContent {
		isr, err = client.CreateOrUpdateResponder(isr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.InboundSecurityRuleCreateOrUpdateFuture", "Result", isr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InboundSecurityRuleProperties properties of the Inbound Security Rules resource.
type InboundSecurityRuleProperties struct {
	// Rules - List of allowed rules.
	Rules *[]InboundSecurityRules `json:"rules,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for InboundSecurityRuleProperties.
func (isrp InboundSecurityRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if isrp.Rules != nil {
		objectMap["rules"] = isrp.Rules
	}
	return json.Marshal(objectMap)
}

// InboundSecurityRules properties of the Inbound Security Rules resource.
type InboundSecurityRules struct {
	// Protocol - Protocol. This should be either TCP or UDP. Possible values include: 'InboundSecurityRulesProtocolTCP', 'InboundSecurityRulesProtocolUDP'
	Protocol InboundSecurityRulesProtocol `json:"protocol,omitempty"`
	// SourceAddressPrefix - The CIDR or source IP range. Only /30, /31 and /32 Ip ranges are allowed.
	SourceAddressPrefix *string `json:"sourceAddressPrefix,omitempty"`
	// DestinationPortRange - NVA port ranges to be opened up. One needs to provide specific ports.
	DestinationPortRange *int32 `json:"destinationPortRange,omitempty"`
}

// IntentPolicy network Intent Policy resource.
type IntentPolicy struct {
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for IntentPolicy.
func (IP IntentPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if IP.ID != nil {
		objectMap["id"] = IP.ID
	}
	if IP.Location != nil {
		objectMap["location"] = IP.Location
	}
	if IP.Tags != nil {
		objectMap["tags"] = IP.Tags
	}
	return json.Marshal(objectMap)
}

// IntentPolicyConfiguration details of NetworkIntentPolicyConfiguration for PrepareNetworkPoliciesRequest.
type IntentPolicyConfiguration struct {
	// NetworkIntentPolicyName - The name of the Network Intent Policy for storing in target subscription.
	NetworkIntentPolicyName *string `json:"networkIntentPolicyName,omitempty"`
	// SourceNetworkIntentPolicy - Source network intent policy.
	SourceNetworkIntentPolicy *IntentPolicy `json:"sourceNetworkIntentPolicy,omitempty"`
}

// Interface a network interface in a resource group.
type Interface struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of the network interface.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// InterfacePropertiesFormat - Properties of the network interface.
	*InterfacePropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Interface.
func (i Interface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.ExtendedLocation != nil {
		objectMap["extendedLocation"] = i.ExtendedLocation
	}
	if i.InterfacePropertiesFormat != nil {
		objectMap["properties"] = i.InterfacePropertiesFormat
	}
	if i.ID != nil {
		objectMap["id"] = i.ID
	}
	if i.Location != nil {
		objectMap["location"] = i.Location
	}
	if i.Tags != nil {
		objectMap["tags"] = i.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Interface struct.
func (i *Interface) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				i.ExtendedLocation = &extendedLocation
			}
		case "properties":
			if v != nil {
				var interfacePropertiesFormat InterfacePropertiesFormat
				err = json.Unmarshal(*v, &interfacePropertiesFormat)
				if err != nil {
					return err
				}
				i.InterfacePropertiesFormat = &interfacePropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				i.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				i.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				i.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				i.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				i.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				i.Tags = tags
			}
		}
	}

	return nil
}

// InterfaceAssociation network interface and its custom security rules.
type InterfaceAssociation struct {
	// ID - READ-ONLY; Network interface ID.
	ID *string `json:"id,omitempty"`
	// SecurityRules - Collection of custom security rules.
	SecurityRules *[]SecurityRule `json:"securityRules,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceAssociation.
func (ia InterfaceAssociation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ia.SecurityRules != nil {
		objectMap["securityRules"] = ia.SecurityRules
	}
	return json.Marshal(objectMap)
}

// InterfaceDNSSettings DNS settings of a network interface.
type InterfaceDNSSettings struct {
	// DNSServers - List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch to azure provided DNS resolution. 'AzureProvidedDNS' value cannot be combined with other IPs, it must be the only value in dnsServers collection.
	DNSServers *[]string `json:"dnsServers,omitempty"`
	// AppliedDNSServers - READ-ONLY; If the VM that uses this NIC is part of an Availability Set, then this list will have the union of all DNS servers from all NICs that are part of the Availability Set. This property is what is configured on each of those VMs.
	AppliedDNSServers *[]string `json:"appliedDnsServers,omitempty"`
	// InternalDNSNameLabel - Relative DNS name for this NIC used for internal communications between VMs in the same virtual network.
	InternalDNSNameLabel *string `json:"internalDnsNameLabel,omitempty"`
	// InternalFqdn - READ-ONLY; Fully qualified DNS name supporting internal communications between VMs in the same virtual network.
	InternalFqdn *string `json:"internalFqdn,omitempty"`
	// InternalDomainNameSuffix - READ-ONLY; Even if internalDnsNameLabel is not specified, a DNS entry is created for the primary NIC of the VM. This DNS name can be constructed by concatenating the VM name with the value of internalDomainNameSuffix.
	InternalDomainNameSuffix *string `json:"internalDomainNameSuffix,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceDNSSettings.
func (ids InterfaceDNSSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ids.DNSServers != nil {
		objectMap["dnsServers"] = ids.DNSServers
	}
	if ids.InternalDNSNameLabel != nil {
		objectMap["internalDnsNameLabel"] = ids.InternalDNSNameLabel
	}
	return json.Marshal(objectMap)
}

// InterfaceIPConfiguration iPConfiguration in a network interface.
type InterfaceIPConfiguration struct {
	autorest.Response `json:"-"`
	// InterfaceIPConfigurationPropertiesFormat - Network interface IP configuration properties.
	*InterfaceIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceIPConfiguration.
func (iic InterfaceIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if iic.InterfaceIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = iic.InterfaceIPConfigurationPropertiesFormat
	}
	if iic.Name != nil {
		objectMap["name"] = iic.Name
	}
	if iic.Type != nil {
		objectMap["type"] = iic.Type
	}
	if iic.ID != nil {
		objectMap["id"] = iic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InterfaceIPConfiguration struct.
func (iic *InterfaceIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var interfaceIPConfigurationPropertiesFormat InterfaceIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &interfaceIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				iic.InterfaceIPConfigurationPropertiesFormat = &interfaceIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				iic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				iic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				iic.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				iic.ID = &ID
			}
		}
	}

	return nil
}

// InterfaceIPConfigurationListResult response for list ip configurations API service call.
type InterfaceIPConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of ip configurations.
	Value *[]InterfaceIPConfiguration `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceIPConfigurationListResult.
func (iiclr InterfaceIPConfigurationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if iiclr.Value != nil {
		objectMap["value"] = iiclr.Value
	}
	return json.Marshal(objectMap)
}

// InterfaceIPConfigurationListResultIterator provides access to a complete listing of
// InterfaceIPConfiguration values.
type InterfaceIPConfigurationListResultIterator struct {
	i    int
	page InterfaceIPConfigurationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InterfaceIPConfigurationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InterfaceIPConfigurationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InterfaceIPConfigurationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InterfaceIPConfigurationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InterfaceIPConfigurationListResultIterator) Response() InterfaceIPConfigurationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InterfaceIPConfigurationListResultIterator) Value() InterfaceIPConfiguration {
	if !iter.page.NotDone() {
		return InterfaceIPConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InterfaceIPConfigurationListResultIterator type.
func NewInterfaceIPConfigurationListResultIterator(page InterfaceIPConfigurationListResultPage) InterfaceIPConfigurationListResultIterator {
	return InterfaceIPConfigurationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (iiclr InterfaceIPConfigurationListResult) IsEmpty() bool {
	return iiclr.Value == nil || len(*iiclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (iiclr InterfaceIPConfigurationListResult) hasNextLink() bool {
	return iiclr.NextLink != nil && len(*iiclr.NextLink) != 0
}

// interfaceIPConfigurationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (iiclr InterfaceIPConfigurationListResult) interfaceIPConfigurationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !iiclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(iiclr.NextLink)))
}

// InterfaceIPConfigurationListResultPage contains a page of InterfaceIPConfiguration values.
type InterfaceIPConfigurationListResultPage struct {
	fn    func(context.Context, InterfaceIPConfigurationListResult) (InterfaceIPConfigurationListResult, error)
	iiclr InterfaceIPConfigurationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InterfaceIPConfigurationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InterfaceIPConfigurationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.iiclr)
		if err != nil {
			return err
		}
		page.iiclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InterfaceIPConfigurationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InterfaceIPConfigurationListResultPage) NotDone() bool {
	return !page.iiclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InterfaceIPConfigurationListResultPage) Response() InterfaceIPConfigurationListResult {
	return page.iiclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InterfaceIPConfigurationListResultPage) Values() []InterfaceIPConfiguration {
	if page.iiclr.IsEmpty() {
		return nil
	}
	return *page.iiclr.Value
}

// Creates a new instance of the InterfaceIPConfigurationListResultPage type.
func NewInterfaceIPConfigurationListResultPage(cur InterfaceIPConfigurationListResult, getNextPage func(context.Context, InterfaceIPConfigurationListResult) (InterfaceIPConfigurationListResult, error)) InterfaceIPConfigurationListResultPage {
	return InterfaceIPConfigurationListResultPage{
		fn:    getNextPage,
		iiclr: cur,
	}
}

// InterfaceIPConfigurationPrivateLinkConnectionProperties privateLinkConnection properties for the network
// interface.
type InterfaceIPConfigurationPrivateLinkConnectionProperties struct {
	// GroupID - READ-ONLY; The group ID for current private link connection.
	GroupID *string `json:"groupId,omitempty"`
	// RequiredMemberName - READ-ONLY; The required member name for current private link connection.
	RequiredMemberName *string `json:"requiredMemberName,omitempty"`
	// Fqdns - READ-ONLY; List of FQDNs for current private link connection.
	Fqdns *[]string `json:"fqdns,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceIPConfigurationPrivateLinkConnectionProperties.
func (iicplcp InterfaceIPConfigurationPrivateLinkConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
type InterfaceIPConfigurationPropertiesFormat struct {
	// VirtualNetworkTaps - The reference to Virtual Network Taps.
	VirtualNetworkTaps *[]VirtualNetworkTap `json:"virtualNetworkTaps,omitempty"`
	// ApplicationGatewayBackendAddressPools - The reference to ApplicationGatewayBackendAddressPool resource.
	ApplicationGatewayBackendAddressPools *[]ApplicationGatewayBackendAddressPool `json:"applicationGatewayBackendAddressPools,omitempty"`
	// LoadBalancerBackendAddressPools - The reference to LoadBalancerBackendAddressPool resource.
	LoadBalancerBackendAddressPools *[]BackendAddressPool `json:"loadBalancerBackendAddressPools,omitempty"`
	// LoadBalancerInboundNatRules - A list of references of LoadBalancerInboundNatRules.
	LoadBalancerInboundNatRules *[]InboundNatRule `json:"loadBalancerInboundNatRules,omitempty"`
	// PrivateIPAddress - Private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	// PrivateIPAddressVersion - Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4. Possible values include: 'IPVersionIPv4', 'IPVersionIPv6'
	PrivateIPAddressVersion IPVersion `json:"privateIPAddressVersion,omitempty"`
	// Subnet - Subnet bound to the IP configuration.
	Subnet *Subnet `json:"subnet,omitempty"`
	// Primary - Whether this is a primary customer address on the network interface.
	Primary *bool `json:"primary,omitempty"`
	// PublicIPAddress - Public IP address bound to the IP configuration.
	PublicIPAddress *PublicIPAddress `json:"publicIPAddress,omitempty"`
	// ApplicationSecurityGroups - Application security groups in which the IP configuration is included.
	ApplicationSecurityGroups *[]ApplicationSecurityGroup `json:"applicationSecurityGroups,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the network interface IP configuration. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PrivateLinkConnectionProperties - READ-ONLY; PrivateLinkConnection properties for the network interface.
	PrivateLinkConnectionProperties *InterfaceIPConfigurationPrivateLinkConnectionProperties `json:"privateLinkConnectionProperties,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceIPConfigurationPropertiesFormat.
func (iicpf InterfaceIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if iicpf.VirtualNetworkTaps != nil {
		objectMap["virtualNetworkTaps"] = iicpf.VirtualNetworkTaps
	}
	if iicpf.ApplicationGatewayBackendAddressPools != nil {
		objectMap["applicationGatewayBackendAddressPools"] = iicpf.ApplicationGatewayBackendAddressPools
	}
	if iicpf.LoadBalancerBackendAddressPools != nil {
		objectMap["loadBalancerBackendAddressPools"] = iicpf.LoadBalancerBackendAddressPools
	}
	if iicpf.LoadBalancerInboundNatRules != nil {
		objectMap["loadBalancerInboundNatRules"] = iicpf.LoadBalancerInboundNatRules
	}
	if iicpf.PrivateIPAddress != nil {
		objectMap["privateIPAddress"] = iicpf.PrivateIPAddress
	}
	if iicpf.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = iicpf.PrivateIPAllocationMethod
	}
	if iicpf.PrivateIPAddressVersion != "" {
		objectMap["privateIPAddressVersion"] = iicpf.PrivateIPAddressVersion
	}
	if iicpf.Subnet != nil {
		objectMap["subnet"] = iicpf.Subnet
	}
	if iicpf.Primary != nil {
		objectMap["primary"] = iicpf.Primary
	}
	if iicpf.PublicIPAddress != nil {
		objectMap["publicIPAddress"] = iicpf.PublicIPAddress
	}
	if iicpf.ApplicationSecurityGroups != nil {
		objectMap["applicationSecurityGroups"] = iicpf.ApplicationSecurityGroups
	}
	return json.Marshal(objectMap)
}

// InterfaceListResult response for the ListNetworkInterface API service call.
type InterfaceListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of network interfaces in a resource group.
	Value *[]Interface `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceListResult.
func (ilr InterfaceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ilr.Value != nil {
		objectMap["value"] = ilr.Value
	}
	return json.Marshal(objectMap)
}

// InterfaceListResultIterator provides access to a complete listing of Interface values.
type InterfaceListResultIterator struct {
	i    int
	page InterfaceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InterfaceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InterfaceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InterfaceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InterfaceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InterfaceListResultIterator) Response() InterfaceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InterfaceListResultIterator) Value() Interface {
	if !iter.page.NotDone() {
		return Interface{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InterfaceListResultIterator type.
func NewInterfaceListResultIterator(page InterfaceListResultPage) InterfaceListResultIterator {
	return InterfaceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ilr InterfaceListResult) IsEmpty() bool {
	return ilr.Value == nil || len(*ilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ilr InterfaceListResult) hasNextLink() bool {
	return ilr.NextLink != nil && len(*ilr.NextLink) != 0
}

// interfaceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ilr InterfaceListResult) interfaceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ilr.NextLink)))
}

// InterfaceListResultPage contains a page of Interface values.
type InterfaceListResultPage struct {
	fn  func(context.Context, InterfaceListResult) (InterfaceListResult, error)
	ilr InterfaceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InterfaceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InterfaceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ilr)
		if err != nil {
			return err
		}
		page.ilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InterfaceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InterfaceListResultPage) NotDone() bool {
	return !page.ilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InterfaceListResultPage) Response() InterfaceListResult {
	return page.ilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InterfaceListResultPage) Values() []Interface {
	if page.ilr.IsEmpty() {
		return nil
	}
	return *page.ilr.Value
}

// Creates a new instance of the InterfaceListResultPage type.
func NewInterfaceListResultPage(cur InterfaceListResult, getNextPage func(context.Context, InterfaceListResult) (InterfaceListResult, error)) InterfaceListResultPage {
	return InterfaceListResultPage{
		fn:  getNextPage,
		ilr: cur,
	}
}

// InterfaceLoadBalancerListResult response for list ip configurations API service call.
type InterfaceLoadBalancerListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of load balancers.
	Value *[]LoadBalancer `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceLoadBalancerListResult.
func (ilblr InterfaceLoadBalancerListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ilblr.Value != nil {
		objectMap["value"] = ilblr.Value
	}
	return json.Marshal(objectMap)
}

// InterfaceLoadBalancerListResultIterator provides access to a complete listing of LoadBalancer values.
type InterfaceLoadBalancerListResultIterator struct {
	i    int
	page InterfaceLoadBalancerListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InterfaceLoadBalancerListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InterfaceLoadBalancerListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InterfaceLoadBalancerListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InterfaceLoadBalancerListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InterfaceLoadBalancerListResultIterator) Response() InterfaceLoadBalancerListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InterfaceLoadBalancerListResultIterator) Value() LoadBalancer {
	if !iter.page.NotDone() {
		return LoadBalancer{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InterfaceLoadBalancerListResultIterator type.
func NewInterfaceLoadBalancerListResultIterator(page InterfaceLoadBalancerListResultPage) InterfaceLoadBalancerListResultIterator {
	return InterfaceLoadBalancerListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ilblr InterfaceLoadBalancerListResult) IsEmpty() bool {
	return ilblr.Value == nil || len(*ilblr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ilblr InterfaceLoadBalancerListResult) hasNextLink() bool {
	return ilblr.NextLink != nil && len(*ilblr.NextLink) != 0
}

// interfaceLoadBalancerListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ilblr InterfaceLoadBalancerListResult) interfaceLoadBalancerListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ilblr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ilblr.NextLink)))
}

// InterfaceLoadBalancerListResultPage contains a page of LoadBalancer values.
type InterfaceLoadBalancerListResultPage struct {
	fn    func(context.Context, InterfaceLoadBalancerListResult) (InterfaceLoadBalancerListResult, error)
	ilblr InterfaceLoadBalancerListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InterfaceLoadBalancerListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InterfaceLoadBalancerListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ilblr)
		if err != nil {
			return err
		}
		page.ilblr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InterfaceLoadBalancerListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InterfaceLoadBalancerListResultPage) NotDone() bool {
	return !page.ilblr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InterfaceLoadBalancerListResultPage) Response() InterfaceLoadBalancerListResult {
	return page.ilblr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InterfaceLoadBalancerListResultPage) Values() []LoadBalancer {
	if page.ilblr.IsEmpty() {
		return nil
	}
	return *page.ilblr.Value
}

// Creates a new instance of the InterfaceLoadBalancerListResultPage type.
func NewInterfaceLoadBalancerListResultPage(cur InterfaceLoadBalancerListResult, getNextPage func(context.Context, InterfaceLoadBalancerListResult) (InterfaceLoadBalancerListResult, error)) InterfaceLoadBalancerListResultPage {
	return InterfaceLoadBalancerListResultPage{
		fn:    getNextPage,
		ilblr: cur,
	}
}

// InterfacePropertiesFormat networkInterface properties.
type InterfacePropertiesFormat struct {
	// VirtualMachine - READ-ONLY; The reference to a virtual machine.
	VirtualMachine *SubResource `json:"virtualMachine,omitempty"`
	// NetworkSecurityGroup - The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *SecurityGroup `json:"networkSecurityGroup,omitempty"`
	// PrivateEndpoint - READ-ONLY; A reference to the private endpoint to which the network interface is linked.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`
	// IPConfigurations - A list of IPConfigurations of the network interface.
	IPConfigurations *[]InterfaceIPConfiguration `json:"ipConfigurations,omitempty"`
	// TapConfigurations - READ-ONLY; A list of TapConfigurations of the network interface.
	TapConfigurations *[]InterfaceTapConfiguration `json:"tapConfigurations,omitempty"`
	// DNSSettings - The DNS settings in network interface.
	DNSSettings *InterfaceDNSSettings `json:"dnsSettings,omitempty"`
	// MacAddress - READ-ONLY; The MAC address of the network interface.
	MacAddress *string `json:"macAddress,omitempty"`
	// Primary - READ-ONLY; Whether this is a primary network interface on a virtual machine.
	Primary *bool `json:"primary,omitempty"`
	// EnableAcceleratedNetworking - If the network interface is accelerated networking enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`
	// EnableIPForwarding - Indicates whether IP forwarding is enabled on this network interface.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`
	// HostedWorkloads - READ-ONLY; A list of references to linked BareMetal resources.
	HostedWorkloads *[]string `json:"hostedWorkloads,omitempty"`
	// DscpConfiguration - READ-ONLY; A reference to the dscp configuration to which the network interface is linked.
	DscpConfiguration *SubResource `json:"dscpConfiguration,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the network interface resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the network interface resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// NicType - Type of Network Interface resource. Possible values include: 'InterfaceNicTypeStandard', 'InterfaceNicTypeElastic'
	NicType InterfaceNicType `json:"nicType,omitempty"`
	// PrivateLinkService - Privatelinkservice of the network interface resource.
	PrivateLinkService *PrivateLinkService `json:"privateLinkService,omitempty"`
	// MigrationPhase - Migration phase of Network Interface resource. Possible values include: 'InterfaceMigrationPhaseNone', 'InterfaceMigrationPhasePrepare', 'InterfaceMigrationPhaseCommit', 'InterfaceMigrationPhaseAbort', 'InterfaceMigrationPhaseCommitted'
	MigrationPhase InterfaceMigrationPhase `json:"migrationPhase,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfacePropertiesFormat.
func (ipf InterfacePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ipf.NetworkSecurityGroup != nil {
		objectMap["networkSecurityGroup"] = ipf.NetworkSecurityGroup
	}
	if ipf.IPConfigurations != nil {
		objectMap["ipConfigurations"] = ipf.IPConfigurations
	}
	if ipf.DNSSettings != nil {
		objectMap["dnsSettings"] = ipf.DNSSettings
	}
	if ipf.EnableAcceleratedNetworking != nil {
		objectMap["enableAcceleratedNetworking"] = ipf.EnableAcceleratedNetworking
	}
	if ipf.EnableIPForwarding != nil {
		objectMap["enableIPForwarding"] = ipf.EnableIPForwarding
	}
	if ipf.NicType != "" {
		objectMap["nicType"] = ipf.NicType
	}
	if ipf.PrivateLinkService != nil {
		objectMap["privateLinkService"] = ipf.PrivateLinkService
	}
	if ipf.MigrationPhase != "" {
		objectMap["migrationPhase"] = ipf.MigrationPhase
	}
	return json.Marshal(objectMap)
}

// InterfacesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type InterfacesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InterfacesClient) (Interface, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InterfacesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InterfacesCreateOrUpdateFuture.Result.
func (future *InterfacesCreateOrUpdateFuture) result(client InterfacesClient) (i Interface, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InterfacesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		i.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InterfacesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if i.Response.Response, err = future.GetResult(sender); err == nil && i.Response.Response.StatusCode != http.StatusNoContent {
		i, err = client.CreateOrUpdateResponder(i.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.InterfacesCreateOrUpdateFuture", "Result", i.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InterfacesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type InterfacesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InterfacesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InterfacesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InterfacesDeleteFuture.Result.
func (future *InterfacesDeleteFuture) result(client InterfacesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InterfacesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InterfacesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// InterfacesGetEffectiveRouteTableFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type InterfacesGetEffectiveRouteTableFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InterfacesClient) (EffectiveRouteListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InterfacesGetEffectiveRouteTableFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InterfacesGetEffectiveRouteTableFuture.Result.
func (future *InterfacesGetEffectiveRouteTableFuture) result(client InterfacesClient) (erlr EffectiveRouteListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InterfacesGetEffectiveRouteTableFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		erlr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InterfacesGetEffectiveRouteTableFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if erlr.Response.Response, err = future.GetResult(sender); err == nil && erlr.Response.Response.StatusCode != http.StatusNoContent {
		erlr, err = client.GetEffectiveRouteTableResponder(erlr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.InterfacesGetEffectiveRouteTableFuture", "Result", erlr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InterfacesListEffectiveNetworkSecurityGroupsFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type InterfacesListEffectiveNetworkSecurityGroupsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InterfacesClient) (EffectiveNetworkSecurityGroupListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InterfacesListEffectiveNetworkSecurityGroupsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InterfacesListEffectiveNetworkSecurityGroupsFuture.Result.
func (future *InterfacesListEffectiveNetworkSecurityGroupsFuture) result(client InterfacesClient) (ensglr EffectiveNetworkSecurityGroupListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InterfacesListEffectiveNetworkSecurityGroupsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ensglr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InterfacesListEffectiveNetworkSecurityGroupsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ensglr.Response.Response, err = future.GetResult(sender); err == nil && ensglr.Response.Response.StatusCode != http.StatusNoContent {
		ensglr, err = client.ListEffectiveNetworkSecurityGroupsResponder(ensglr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.InterfacesListEffectiveNetworkSecurityGroupsFuture", "Result", ensglr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InterfaceTapConfiguration tap configuration in a Network Interface.
type InterfaceTapConfiguration struct {
	autorest.Response `json:"-"`
	// InterfaceTapConfigurationPropertiesFormat - Properties of the Virtual Network Tap configuration.
	*InterfaceTapConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Sub Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceTapConfiguration.
func (itc InterfaceTapConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if itc.InterfaceTapConfigurationPropertiesFormat != nil {
		objectMap["properties"] = itc.InterfaceTapConfigurationPropertiesFormat
	}
	if itc.Name != nil {
		objectMap["name"] = itc.Name
	}
	if itc.ID != nil {
		objectMap["id"] = itc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InterfaceTapConfiguration struct.
func (itc *InterfaceTapConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var interfaceTapConfigurationPropertiesFormat InterfaceTapConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &interfaceTapConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				itc.InterfaceTapConfigurationPropertiesFormat = &interfaceTapConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				itc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				itc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				itc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				itc.ID = &ID
			}
		}
	}

	return nil
}

// InterfaceTapConfigurationListResult response for list tap configurations API service call.
type InterfaceTapConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of tap configurations.
	Value *[]InterfaceTapConfiguration `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceTapConfigurationListResult.
func (itclr InterfaceTapConfigurationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if itclr.Value != nil {
		objectMap["value"] = itclr.Value
	}
	return json.Marshal(objectMap)
}

// InterfaceTapConfigurationListResultIterator provides access to a complete listing of
// InterfaceTapConfiguration values.
type InterfaceTapConfigurationListResultIterator struct {
	i    int
	page InterfaceTapConfigurationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InterfaceTapConfigurationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InterfaceTapConfigurationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InterfaceTapConfigurationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InterfaceTapConfigurationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InterfaceTapConfigurationListResultIterator) Response() InterfaceTapConfigurationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InterfaceTapConfigurationListResultIterator) Value() InterfaceTapConfiguration {
	if !iter.page.NotDone() {
		return InterfaceTapConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InterfaceTapConfigurationListResultIterator type.
func NewInterfaceTapConfigurationListResultIterator(page InterfaceTapConfigurationListResultPage) InterfaceTapConfigurationListResultIterator {
	return InterfaceTapConfigurationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (itclr InterfaceTapConfigurationListResult) IsEmpty() bool {
	return itclr.Value == nil || len(*itclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (itclr InterfaceTapConfigurationListResult) hasNextLink() bool {
	return itclr.NextLink != nil && len(*itclr.NextLink) != 0
}

// interfaceTapConfigurationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (itclr InterfaceTapConfigurationListResult) interfaceTapConfigurationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !itclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(itclr.NextLink)))
}

// InterfaceTapConfigurationListResultPage contains a page of InterfaceTapConfiguration values.
type InterfaceTapConfigurationListResultPage struct {
	fn    func(context.Context, InterfaceTapConfigurationListResult) (InterfaceTapConfigurationListResult, error)
	itclr InterfaceTapConfigurationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InterfaceTapConfigurationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InterfaceTapConfigurationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.itclr)
		if err != nil {
			return err
		}
		page.itclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InterfaceTapConfigurationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InterfaceTapConfigurationListResultPage) NotDone() bool {
	return !page.itclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InterfaceTapConfigurationListResultPage) Response() InterfaceTapConfigurationListResult {
	return page.itclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InterfaceTapConfigurationListResultPage) Values() []InterfaceTapConfiguration {
	if page.itclr.IsEmpty() {
		return nil
	}
	return *page.itclr.Value
}

// Creates a new instance of the InterfaceTapConfigurationListResultPage type.
func NewInterfaceTapConfigurationListResultPage(cur InterfaceTapConfigurationListResult, getNextPage func(context.Context, InterfaceTapConfigurationListResult) (InterfaceTapConfigurationListResult, error)) InterfaceTapConfigurationListResultPage {
	return InterfaceTapConfigurationListResultPage{
		fn:    getNextPage,
		itclr: cur,
	}
}

// InterfaceTapConfigurationPropertiesFormat properties of Virtual Network Tap configuration.
type InterfaceTapConfigurationPropertiesFormat struct {
	// VirtualNetworkTap - The reference to the Virtual Network Tap resource.
	VirtualNetworkTap *VirtualNetworkTap `json:"virtualNetworkTap,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the network interface tap configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for InterfaceTapConfigurationPropertiesFormat.
func (itcpf InterfaceTapConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if itcpf.VirtualNetworkTap != nil {
		objectMap["virtualNetworkTap"] = itcpf.VirtualNetworkTap
	}
	return json.Marshal(objectMap)
}

// InterfaceTapConfigurationsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type InterfaceTapConfigurationsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InterfaceTapConfigurationsClient) (InterfaceTapConfiguration, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InterfaceTapConfigurationsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InterfaceTapConfigurationsCreateOrUpdateFuture.Result.
func (future *InterfaceTapConfigurationsCreateOrUpdateFuture) result(client InterfaceTapConfigurationsClient) (itc InterfaceTapConfiguration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InterfaceTapConfigurationsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		itc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InterfaceTapConfigurationsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if itc.Response.Response, err = future.GetResult(sender); err == nil && itc.Response.Response.StatusCode != http.StatusNoContent {
		itc, err = client.CreateOrUpdateResponder(itc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.InterfaceTapConfigurationsCreateOrUpdateFuture", "Result", itc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InterfaceTapConfigurationsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type InterfaceTapConfigurationsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InterfaceTapConfigurationsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InterfaceTapConfigurationsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InterfaceTapConfigurationsDeleteFuture.Result.
func (future *InterfaceTapConfigurationsDeleteFuture) result(client InterfaceTapConfigurationsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.InterfaceTapConfigurationsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.InterfaceTapConfigurationsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// IPAddressAvailabilityResult response for CheckIPAddressAvailability API service call.
type IPAddressAvailabilityResult struct {
	autorest.Response `json:"-"`
	// Available - Private IP address availability.
	Available *bool `json:"available,omitempty"`
	// AvailableIPAddresses - Contains other available private IP addresses if the asked for address is taken.
	AvailableIPAddresses *[]string `json:"availableIPAddresses,omitempty"`
	// IsPlatformReserved - Private IP address platform reserved.
	IsPlatformReserved *bool `json:"isPlatformReserved,omitempty"`
}

// IPAllocation ipAllocation resource.
type IPAllocation struct {
	autorest.Response `json:"-"`
	// IPAllocationPropertiesFormat - Properties of the IpAllocation.
	*IPAllocationPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for IPAllocation.
func (ia IPAllocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ia.IPAllocationPropertiesFormat != nil {
		objectMap["properties"] = ia.IPAllocationPropertiesFormat
	}
	if ia.ID != nil {
		objectMap["id"] = ia.ID
	}
	if ia.Location != nil {
		objectMap["location"] = ia.Location
	}
	if ia.Tags != nil {
		objectMap["tags"] = ia.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for IPAllocation struct.
func (ia *IPAllocation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var IPAllocationPropertiesFormat IPAllocationPropertiesFormat
				err = json.Unmarshal(*v, &IPAllocationPropertiesFormat)
				if err != nil {
					return err
				}
				ia.IPAllocationPropertiesFormat = &IPAllocationPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ia.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ia.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ia.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ia.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ia.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ia.Tags = tags
			}
		}
	}

	return nil
}

// IPAllocationListResult response for the ListIpAllocations API service call.
type IPAllocationListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of IpAllocation resources.
	Value *[]IPAllocation `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// IPAllocationListResultIterator provides access to a complete listing of IPAllocation values.
type IPAllocationListResultIterator struct {
	i    int
	page IPAllocationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *IPAllocationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/IPAllocationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *IPAllocationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter IPAllocationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter IPAllocationListResultIterator) Response() IPAllocationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter IPAllocationListResultIterator) Value() IPAllocation {
	if !iter.page.NotDone() {
		return IPAllocation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the IPAllocationListResultIterator type.
func NewIPAllocationListResultIterator(page IPAllocationListResultPage) IPAllocationListResultIterator {
	return IPAllocationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ialr IPAllocationListResult) IsEmpty() bool {
	return ialr.Value == nil || len(*ialr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ialr IPAllocationListResult) hasNextLink() bool {
	return ialr.NextLink != nil && len(*ialr.NextLink) != 0
}

// iPAllocationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ialr IPAllocationListResult) iPAllocationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ialr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ialr.NextLink)))
}

// IPAllocationListResultPage contains a page of IPAllocation values.
type IPAllocationListResultPage struct {
	fn   func(context.Context, IPAllocationListResult) (IPAllocationListResult, error)
	ialr IPAllocationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *IPAllocationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/IPAllocationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ialr)
		if err != nil {
			return err
		}
		page.ialr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *IPAllocationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page IPAllocationListResultPage) NotDone() bool {
	return !page.ialr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page IPAllocationListResultPage) Response() IPAllocationListResult {
	return page.ialr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page IPAllocationListResultPage) Values() []IPAllocation {
	if page.ialr.IsEmpty() {
		return nil
	}
	return *page.ialr.Value
}

// Creates a new instance of the IPAllocationListResultPage type.
func NewIPAllocationListResultPage(cur IPAllocationListResult, getNextPage func(context.Context, IPAllocationListResult) (IPAllocationListResult, error)) IPAllocationListResultPage {
	return IPAllocationListResultPage{
		fn:   getNextPage,
		ialr: cur,
	}
}

// IPAllocationPropertiesFormat properties of the IpAllocation.
type IPAllocationPropertiesFormat struct {
	// Subnet - READ-ONLY; The Subnet that using the prefix of this IpAllocation resource.
	Subnet *SubResource `json:"subnet,omitempty"`
	// VirtualNetwork - READ-ONLY; The VirtualNetwork that using the prefix of this IpAllocation resource.
	VirtualNetwork *SubResource `json:"virtualNetwork,omitempty"`
	// Type - The type for the IpAllocation. Possible values include: 'IPAllocationTypeUndefined', 'IPAllocationTypeHypernet'
	Type IPAllocationType `json:"type,omitempty"`
	// Prefix - The address prefix for the IpAllocation.
	Prefix *string `json:"prefix,omitempty"`
	// PrefixLength - The address prefix length for the IpAllocation.
	PrefixLength *int32 `json:"prefixLength,omitempty"`
	// PrefixType - The address prefix Type for the IpAllocation. Possible values include: 'IPVersionIPv4', 'IPVersionIPv6'
	PrefixType IPVersion `json:"prefixType,omitempty"`
	// IpamAllocationID - The IPAM allocation ID.
	IpamAllocationID *string `json:"ipamAllocationId,omitempty"`
	// AllocationTags - IpAllocation tags.
	AllocationTags map[string]*string `json:"allocationTags"`
}

// MarshalJSON is the custom marshaler for IPAllocationPropertiesFormat.
func (iapf IPAllocationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if iapf.Type != "" {
		objectMap["type"] = iapf.Type
	}
	if iapf.Prefix != nil {
		objectMap["prefix"] = iapf.Prefix
	}
	if iapf.PrefixLength != nil {
		objectMap["prefixLength"] = iapf.PrefixLength
	}
	if iapf.PrefixType != "" {
		objectMap["prefixType"] = iapf.PrefixType
	}
	if iapf.IpamAllocationID != nil {
		objectMap["ipamAllocationId"] = iapf.IpamAllocationID
	}
	if iapf.AllocationTags != nil {
		objectMap["allocationTags"] = iapf.AllocationTags
	}
	return json.Marshal(objectMap)
}

// IPAllocationsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type IPAllocationsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(IPAllocationsClient) (IPAllocation, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *IPAllocationsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for IPAllocationsCreateOrUpdateFuture.Result.
func (future *IPAllocationsCreateOrUpdateFuture) result(client IPAllocationsClient) (ia IPAllocation, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.IPAllocationsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ia.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.IPAllocationsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ia.Response.Response, err = future.GetResult(sender); err == nil && ia.Response.Response.StatusCode != http.StatusNoContent {
		ia, err = client.CreateOrUpdateResponder(ia.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.IPAllocationsCreateOrUpdateFuture", "Result", ia.Response.Response, "Failure responding to request")
		}
	}
	return
}

// IPAllocationsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type IPAllocationsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(IPAllocationsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *IPAllocationsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for IPAllocationsDeleteFuture.Result.
func (future *IPAllocationsDeleteFuture) result(client IPAllocationsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.IPAllocationsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.IPAllocationsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// IPConfiguration IP configuration.
type IPConfiguration struct {
	// IPConfigurationPropertiesFormat - Properties of the IP configuration.
	*IPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for IPConfiguration.
func (ic IPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ic.IPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = ic.IPConfigurationPropertiesFormat
	}
	if ic.Name != nil {
		objectMap["name"] = ic.Name
	}
	if ic.ID != nil {
		objectMap["id"] = ic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for IPConfiguration struct.
func (ic *IPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var IPConfigurationPropertiesFormat IPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &IPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				ic.IPConfigurationPropertiesFormat = &IPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ic.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ic.ID = &ID
			}
		}
	}

	return nil
}

// IPConfigurationBgpPeeringAddress properties of IPConfigurationBgpPeeringAddress.
type IPConfigurationBgpPeeringAddress struct {
	// IpconfigurationID - The ID of IP configuration which belongs to gateway.
	IpconfigurationID *string `json:"ipconfigurationId,omitempty"`
	// DefaultBgpIPAddresses - READ-ONLY; The list of default BGP peering addresses which belong to IP configuration.
	DefaultBgpIPAddresses *[]string `json:"defaultBgpIpAddresses,omitempty"`
	// CustomBgpIPAddresses - The list of custom BGP peering addresses which belong to IP configuration.
	CustomBgpIPAddresses *[]string `json:"customBgpIpAddresses,omitempty"`
	// TunnelIPAddresses - READ-ONLY; The list of tunnel public IP addresses which belong to IP configuration.
	TunnelIPAddresses *[]string `json:"tunnelIpAddresses,omitempty"`
}

// MarshalJSON is the custom marshaler for IPConfigurationBgpPeeringAddress.
func (icbpa IPConfigurationBgpPeeringAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if icbpa.IpconfigurationID != nil {
		objectMap["ipconfigurationId"] = icbpa.IpconfigurationID
	}
	if icbpa.CustomBgpIPAddresses != nil {
		objectMap["customBgpIpAddresses"] = icbpa.CustomBgpIPAddresses
	}
	return json.Marshal(objectMap)
}

// IPConfigurationProfile IP configuration profile child resource.
type IPConfigurationProfile struct {
	// IPConfigurationProfilePropertiesFormat - Properties of the IP configuration profile.
	*IPConfigurationProfilePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Sub Resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for IPConfigurationProfile.
func (icp IPConfigurationProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if icp.IPConfigurationProfilePropertiesFormat != nil {
		objectMap["properties"] = icp.IPConfigurationProfilePropertiesFormat
	}
	if icp.Name != nil {
		objectMap["name"] = icp.Name
	}
	if icp.ID != nil {
		objectMap["id"] = icp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for IPConfigurationProfile struct.
func (icp *IPConfigurationProfile) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var IPConfigurationProfilePropertiesFormat IPConfigurationProfilePropertiesFormat
				err = json.Unmarshal(*v, &IPConfigurationProfilePropertiesFormat)
				if err != nil {
					return err
				}
				icp.IPConfigurationProfilePropertiesFormat = &IPConfigurationProfilePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				icp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				icp.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				icp.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				icp.ID = &ID
			}
		}
	}

	return nil
}

// IPConfigurationProfilePropertiesFormat IP configuration profile properties.
type IPConfigurationProfilePropertiesFormat struct {
	// Subnet - The reference to the subnet resource to create a container network interface ip configuration.
	Subnet *Subnet `json:"subnet,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the IP configuration profile resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for IPConfigurationProfilePropertiesFormat.
func (icppf IPConfigurationProfilePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if icppf.Subnet != nil {
		objectMap["subnet"] = icppf.Subnet
	}
	return json.Marshal(objectMap)
}

// IPConfigurationPropertiesFormat properties of IP configuration.
type IPConfigurationPropertiesFormat struct {
	// PrivateIPAddress - The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	// Subnet - The reference to the subnet resource.
	Subnet *Subnet `json:"subnet,omitempty"`
	// PublicIPAddress - The reference to the public IP resource.
	PublicIPAddress *PublicIPAddress `json:"publicIPAddress,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for IPConfigurationPropertiesFormat.
func (icpf IPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if icpf.PrivateIPAddress != nil {
		objectMap["privateIPAddress"] = icpf.PrivateIPAddress
	}
	if icpf.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = icpf.PrivateIPAllocationMethod
	}
	if icpf.Subnet != nil {
		objectMap["subnet"] = icpf.Subnet
	}
	if icpf.PublicIPAddress != nil {
		objectMap["publicIPAddress"] = icpf.PublicIPAddress
	}
	return json.Marshal(objectMap)
}

// IPGroup the IpGroups resource information.
type IPGroup struct {
	autorest.Response `json:"-"`
	// IPGroupPropertiesFormat - Properties of the IpGroups.
	*IPGroupPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for IPGroup.
func (ig IPGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ig.IPGroupPropertiesFormat != nil {
		objectMap["properties"] = ig.IPGroupPropertiesFormat
	}
	if ig.ID != nil {
		objectMap["id"] = ig.ID
	}
	if ig.Location != nil {
		objectMap["location"] = ig.Location
	}
	if ig.Tags != nil {
		objectMap["tags"] = ig.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for IPGroup struct.
func (ig *IPGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var IPGroupPropertiesFormat IPGroupPropertiesFormat
				err = json.Unmarshal(*v, &IPGroupPropertiesFormat)
				if err != nil {
					return err
				}
				ig.IPGroupPropertiesFormat = &IPGroupPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ig.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ig.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ig.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ig.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ig.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ig.Tags = tags
			}
		}
	}

	return nil
}

// IPGroupListResult response for the ListIpGroups API service call.
type IPGroupListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of IpGroups information resources.
	Value *[]IPGroup `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// IPGroupListResultIterator provides access to a complete listing of IPGroup values.
type IPGroupListResultIterator struct {
	i    int
	page IPGroupListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *IPGroupListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/IPGroupListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *IPGroupListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter IPGroupListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter IPGroupListResultIterator) Response() IPGroupListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter IPGroupListResultIterator) Value() IPGroup {
	if !iter.page.NotDone() {
		return IPGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the IPGroupListResultIterator type.
func NewIPGroupListResultIterator(page IPGroupListResultPage) IPGroupListResultIterator {
	return IPGroupListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (iglr IPGroupListResult) IsEmpty() bool {
	return iglr.Value == nil || len(*iglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (iglr IPGroupListResult) hasNextLink() bool {
	return iglr.NextLink != nil && len(*iglr.NextLink) != 0
}

// iPGroupListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (iglr IPGroupListResult) iPGroupListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !iglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(iglr.NextLink)))
}

// IPGroupListResultPage contains a page of IPGroup values.
type IPGroupListResultPage struct {
	fn   func(context.Context, IPGroupListResult) (IPGroupListResult, error)
	iglr IPGroupListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *IPGroupListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/IPGroupListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.iglr)
		if err != nil {
			return err
		}
		page.iglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *IPGroupListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page IPGroupListResultPage) NotDone() bool {
	return !page.iglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page IPGroupListResultPage) Response() IPGroupListResult {
	return page.iglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page IPGroupListResultPage) Values() []IPGroup {
	if page.iglr.IsEmpty() {
		return nil
	}
	return *page.iglr.Value
}

// Creates a new instance of the IPGroupListResultPage type.
func NewIPGroupListResultPage(cur IPGroupListResult, getNextPage func(context.Context, IPGroupListResult) (IPGroupListResult, error)) IPGroupListResultPage {
	return IPGroupListResultPage{
		fn:   getNextPage,
		iglr: cur,
	}
}

// IPGroupPropertiesFormat the IpGroups property information.
type IPGroupPropertiesFormat struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the IpGroups resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// IPAddresses - IpAddresses/IpAddressPrefixes in the IpGroups resource.
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
	// Firewalls - READ-ONLY; List of references to Firewall resources that this IpGroups is associated with.
	Firewalls *[]SubResource `json:"firewalls,omitempty"`
	// FirewallPolicies - READ-ONLY; List of references to Firewall Policies resources that this IpGroups is associated with.
	FirewallPolicies *[]SubResource `json:"firewallPolicies,omitempty"`
}

// MarshalJSON is the custom marshaler for IPGroupPropertiesFormat.
func (igpf IPGroupPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if igpf.IPAddresses != nil {
		objectMap["ipAddresses"] = igpf.IPAddresses
	}
	return json.Marshal(objectMap)
}

// IPGroupsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type IPGroupsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(IPGroupsClient) (IPGroup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *IPGroupsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for IPGroupsCreateOrUpdateFuture.Result.
func (future *IPGroupsCreateOrUpdateFuture) result(client IPGroupsClient) (ig IPGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.IPGroupsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ig.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.IPGroupsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ig.Response.Response, err = future.GetResult(sender); err == nil && ig.Response.Response.StatusCode != http.StatusNoContent {
		ig, err = client.CreateOrUpdateResponder(ig.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.IPGroupsCreateOrUpdateFuture", "Result", ig.Response.Response, "Failure responding to request")
		}
	}
	return
}

// IPGroupsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type IPGroupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(IPGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *IPGroupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for IPGroupsDeleteFuture.Result.
func (future *IPGroupsDeleteFuture) result(client IPGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.IPGroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.IPGroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// IpsecPolicy an IPSec Policy configuration for a virtual network gateway connection.
type IpsecPolicy struct {
	// SaLifeTimeSeconds - The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for a site to site VPN tunnel.
	SaLifeTimeSeconds *int32 `json:"saLifeTimeSeconds,omitempty"`
	// SaDataSizeKilobytes - The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for a site to site VPN tunnel.
	SaDataSizeKilobytes *int32 `json:"saDataSizeKilobytes,omitempty"`
	// IpsecEncryption - The IPSec encryption algorithm (IKE phase 1). Possible values include: 'IpsecEncryptionNone', 'IpsecEncryptionDES', 'IpsecEncryptionDES3', 'IpsecEncryptionAES128', 'IpsecEncryptionAES192', 'IpsecEncryptionAES256', 'IpsecEncryptionGCMAES128', 'IpsecEncryptionGCMAES192', 'IpsecEncryptionGCMAES256'
	IpsecEncryption IpsecEncryption `json:"ipsecEncryption,omitempty"`
	// IpsecIntegrity - The IPSec integrity algorithm (IKE phase 1). Possible values include: 'IpsecIntegrityMD5', 'IpsecIntegritySHA1', 'IpsecIntegritySHA256', 'IpsecIntegrityGCMAES128', 'IpsecIntegrityGCMAES192', 'IpsecIntegrityGCMAES256'
	IpsecIntegrity IpsecIntegrity `json:"ipsecIntegrity,omitempty"`
	// IkeEncryption - The IKE encryption algorithm (IKE phase 2). Possible values include: 'IkeEncryptionDES', 'IkeEncryptionDES3', 'IkeEncryptionAES128', 'IkeEncryptionAES192', 'IkeEncryptionAES256', 'IkeEncryptionGCMAES256', 'IkeEncryptionGCMAES128'
	IkeEncryption IkeEncryption `json:"ikeEncryption,omitempty"`
	// IkeIntegrity - The IKE integrity algorithm (IKE phase 2). Possible values include: 'IkeIntegrityMD5', 'IkeIntegritySHA1', 'IkeIntegritySHA256', 'IkeIntegritySHA384', 'IkeIntegrityGCMAES256', 'IkeIntegrityGCMAES128'
	IkeIntegrity IkeIntegrity `json:"ikeIntegrity,omitempty"`
	// DhGroup - The DH Group used in IKE Phase 1 for initial SA. Possible values include: 'DhGroupNone', 'DhGroupDHGroup1', 'DhGroupDHGroup2', 'DhGroupDHGroup14', 'DhGroupDHGroup2048', 'DhGroupECP256', 'DhGroupECP384', 'DhGroupDHGroup24'
	DhGroup DhGroup `json:"dhGroup,omitempty"`
	// PfsGroup - The Pfs Group used in IKE Phase 2 for new child SA. Possible values include: 'PfsGroupNone', 'PfsGroupPFS1', 'PfsGroupPFS2', 'PfsGroupPFS2048', 'PfsGroupECP256', 'PfsGroupECP384', 'PfsGroupPFS24', 'PfsGroupPFS14', 'PfsGroupPFSMM'
	PfsGroup PfsGroup `json:"pfsGroup,omitempty"`
}

// IPTag contains the IpTag associated with the object.
type IPTag struct {
	// IPTagType - The IP tag type. Example: FirstPartyUsage.
	IPTagType *string `json:"ipTagType,omitempty"`
	// Tag - The value of the IP tag associated with the public IP. Example: SQL.
	Tag *string `json:"tag,omitempty"`
}

// Ipv6CircuitConnectionConfig iPv6 Circuit Connection properties for global reach.
type Ipv6CircuitConnectionConfig struct {
	// AddressPrefix - /125 IP address space to carve out customer addresses for global reach.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// CircuitConnectionStatus - READ-ONLY; Express Route Circuit connection state. Possible values include: 'CircuitConnectionStatusConnected', 'CircuitConnectionStatusConnecting', 'CircuitConnectionStatusDisconnected'
	CircuitConnectionStatus CircuitConnectionStatus `json:"circuitConnectionStatus,omitempty"`
}

// MarshalJSON is the custom marshaler for Ipv6CircuitConnectionConfig.
func (i6ccc Ipv6CircuitConnectionConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i6ccc.AddressPrefix != nil {
		objectMap["addressPrefix"] = i6ccc.AddressPrefix
	}
	return json.Marshal(objectMap)
}

// Ipv6ExpressRouteCircuitPeeringConfig contains IPv6 peering config.
type Ipv6ExpressRouteCircuitPeeringConfig struct {
	// PrimaryPeerAddressPrefix - The primary address prefix.
	PrimaryPeerAddressPrefix *string `json:"primaryPeerAddressPrefix,omitempty"`
	// SecondaryPeerAddressPrefix - The secondary address prefix.
	SecondaryPeerAddressPrefix *string `json:"secondaryPeerAddressPrefix,omitempty"`
	// MicrosoftPeeringConfig - The Microsoft peering configuration.
	MicrosoftPeeringConfig *ExpressRouteCircuitPeeringConfig `json:"microsoftPeeringConfig,omitempty"`
	// RouteFilter - The reference to the RouteFilter resource.
	RouteFilter *SubResource `json:"routeFilter,omitempty"`
	// State - The state of peering. Possible values include: 'ExpressRouteCircuitPeeringStateDisabled', 'ExpressRouteCircuitPeeringStateEnabled'
	State ExpressRouteCircuitPeeringState `json:"state,omitempty"`
}

// ListHubRouteTablesResult list of RouteTables and a URL nextLink to get the next set of results.
type ListHubRouteTablesResult struct {
	autorest.Response `json:"-"`
	// Value - List of RouteTables.
	Value *[]HubRouteTable `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListHubRouteTablesResultIterator provides access to a complete listing of HubRouteTable values.
type ListHubRouteTablesResultIterator struct {
	i    int
	page ListHubRouteTablesResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListHubRouteTablesResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListHubRouteTablesResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListHubRouteTablesResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListHubRouteTablesResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListHubRouteTablesResultIterator) Response() ListHubRouteTablesResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListHubRouteTablesResultIterator) Value() HubRouteTable {
	if !iter.page.NotDone() {
		return HubRouteTable{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListHubRouteTablesResultIterator type.
func NewListHubRouteTablesResultIterator(page ListHubRouteTablesResultPage) ListHubRouteTablesResultIterator {
	return ListHubRouteTablesResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lhrtr ListHubRouteTablesResult) IsEmpty() bool {
	return lhrtr.Value == nil || len(*lhrtr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lhrtr ListHubRouteTablesResult) hasNextLink() bool {
	return lhrtr.NextLink != nil && len(*lhrtr.NextLink) != 0
}

// listHubRouteTablesResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lhrtr ListHubRouteTablesResult) listHubRouteTablesResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lhrtr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lhrtr.NextLink)))
}

// ListHubRouteTablesResultPage contains a page of HubRouteTable values.
type ListHubRouteTablesResultPage struct {
	fn    func(context.Context, ListHubRouteTablesResult) (ListHubRouteTablesResult, error)
	lhrtr ListHubRouteTablesResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListHubRouteTablesResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListHubRouteTablesResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lhrtr)
		if err != nil {
			return err
		}
		page.lhrtr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListHubRouteTablesResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListHubRouteTablesResultPage) NotDone() bool {
	return !page.lhrtr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListHubRouteTablesResultPage) Response() ListHubRouteTablesResult {
	return page.lhrtr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListHubRouteTablesResultPage) Values() []HubRouteTable {
	if page.lhrtr.IsEmpty() {
		return nil
	}
	return *page.lhrtr.Value
}

// Creates a new instance of the ListHubRouteTablesResultPage type.
func NewListHubRouteTablesResultPage(cur ListHubRouteTablesResult, getNextPage func(context.Context, ListHubRouteTablesResult) (ListHubRouteTablesResult, error)) ListHubRouteTablesResultPage {
	return ListHubRouteTablesResultPage{
		fn:    getNextPage,
		lhrtr: cur,
	}
}

// ListHubVirtualNetworkConnectionsResult list of HubVirtualNetworkConnections and a URL nextLink to get
// the next set of results.
type ListHubVirtualNetworkConnectionsResult struct {
	autorest.Response `json:"-"`
	// Value - List of HubVirtualNetworkConnections.
	Value *[]HubVirtualNetworkConnection `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListHubVirtualNetworkConnectionsResultIterator provides access to a complete listing of
// HubVirtualNetworkConnection values.
type ListHubVirtualNetworkConnectionsResultIterator struct {
	i    int
	page ListHubVirtualNetworkConnectionsResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListHubVirtualNetworkConnectionsResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListHubVirtualNetworkConnectionsResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListHubVirtualNetworkConnectionsResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListHubVirtualNetworkConnectionsResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListHubVirtualNetworkConnectionsResultIterator) Response() ListHubVirtualNetworkConnectionsResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListHubVirtualNetworkConnectionsResultIterator) Value() HubVirtualNetworkConnection {
	if !iter.page.NotDone() {
		return HubVirtualNetworkConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListHubVirtualNetworkConnectionsResultIterator type.
func NewListHubVirtualNetworkConnectionsResultIterator(page ListHubVirtualNetworkConnectionsResultPage) ListHubVirtualNetworkConnectionsResultIterator {
	return ListHubVirtualNetworkConnectionsResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lhvncr ListHubVirtualNetworkConnectionsResult) IsEmpty() bool {
	return lhvncr.Value == nil || len(*lhvncr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lhvncr ListHubVirtualNetworkConnectionsResult) hasNextLink() bool {
	return lhvncr.NextLink != nil && len(*lhvncr.NextLink) != 0
}

// listHubVirtualNetworkConnectionsResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lhvncr ListHubVirtualNetworkConnectionsResult) listHubVirtualNetworkConnectionsResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lhvncr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lhvncr.NextLink)))
}

// ListHubVirtualNetworkConnectionsResultPage contains a page of HubVirtualNetworkConnection values.
type ListHubVirtualNetworkConnectionsResultPage struct {
	fn     func(context.Context, ListHubVirtualNetworkConnectionsResult) (ListHubVirtualNetworkConnectionsResult, error)
	lhvncr ListHubVirtualNetworkConnectionsResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListHubVirtualNetworkConnectionsResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListHubVirtualNetworkConnectionsResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lhvncr)
		if err != nil {
			return err
		}
		page.lhvncr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListHubVirtualNetworkConnectionsResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListHubVirtualNetworkConnectionsResultPage) NotDone() bool {
	return !page.lhvncr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListHubVirtualNetworkConnectionsResultPage) Response() ListHubVirtualNetworkConnectionsResult {
	return page.lhvncr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListHubVirtualNetworkConnectionsResultPage) Values() []HubVirtualNetworkConnection {
	if page.lhvncr.IsEmpty() {
		return nil
	}
	return *page.lhvncr.Value
}

// Creates a new instance of the ListHubVirtualNetworkConnectionsResultPage type.
func NewListHubVirtualNetworkConnectionsResultPage(cur ListHubVirtualNetworkConnectionsResult, getNextPage func(context.Context, ListHubVirtualNetworkConnectionsResult) (ListHubVirtualNetworkConnectionsResult, error)) ListHubVirtualNetworkConnectionsResultPage {
	return ListHubVirtualNetworkConnectionsResultPage{
		fn:     getNextPage,
		lhvncr: cur,
	}
}

// ListP2SVpnGatewaysResult result of the request to list P2SVpnGateways. It contains a list of
// P2SVpnGateways and a URL nextLink to get the next set of results.
type ListP2SVpnGatewaysResult struct {
	autorest.Response `json:"-"`
	// Value - List of P2SVpnGateways.
	Value *[]P2SVpnGateway `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListP2SVpnGatewaysResultIterator provides access to a complete listing of P2SVpnGateway values.
type ListP2SVpnGatewaysResultIterator struct {
	i    int
	page ListP2SVpnGatewaysResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListP2SVpnGatewaysResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListP2SVpnGatewaysResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListP2SVpnGatewaysResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListP2SVpnGatewaysResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListP2SVpnGatewaysResultIterator) Response() ListP2SVpnGatewaysResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListP2SVpnGatewaysResultIterator) Value() P2SVpnGateway {
	if !iter.page.NotDone() {
		return P2SVpnGateway{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListP2SVpnGatewaysResultIterator type.
func NewListP2SVpnGatewaysResultIterator(page ListP2SVpnGatewaysResultPage) ListP2SVpnGatewaysResultIterator {
	return ListP2SVpnGatewaysResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lpvgr ListP2SVpnGatewaysResult) IsEmpty() bool {
	return lpvgr.Value == nil || len(*lpvgr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lpvgr ListP2SVpnGatewaysResult) hasNextLink() bool {
	return lpvgr.NextLink != nil && len(*lpvgr.NextLink) != 0
}

// listP2SVpnGatewaysResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lpvgr ListP2SVpnGatewaysResult) listP2SVpnGatewaysResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lpvgr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lpvgr.NextLink)))
}

// ListP2SVpnGatewaysResultPage contains a page of P2SVpnGateway values.
type ListP2SVpnGatewaysResultPage struct {
	fn    func(context.Context, ListP2SVpnGatewaysResult) (ListP2SVpnGatewaysResult, error)
	lpvgr ListP2SVpnGatewaysResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListP2SVpnGatewaysResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListP2SVpnGatewaysResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lpvgr)
		if err != nil {
			return err
		}
		page.lpvgr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListP2SVpnGatewaysResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListP2SVpnGatewaysResultPage) NotDone() bool {
	return !page.lpvgr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListP2SVpnGatewaysResultPage) Response() ListP2SVpnGatewaysResult {
	return page.lpvgr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListP2SVpnGatewaysResultPage) Values() []P2SVpnGateway {
	if page.lpvgr.IsEmpty() {
		return nil
	}
	return *page.lpvgr.Value
}

// Creates a new instance of the ListP2SVpnGatewaysResultPage type.
func NewListP2SVpnGatewaysResultPage(cur ListP2SVpnGatewaysResult, getNextPage func(context.Context, ListP2SVpnGatewaysResult) (ListP2SVpnGatewaysResult, error)) ListP2SVpnGatewaysResultPage {
	return ListP2SVpnGatewaysResultPage{
		fn:    getNextPage,
		lpvgr: cur,
	}
}

// ListString ...
type ListString struct {
	autorest.Response `json:"-"`
	Value             *[]string `json:"value,omitempty"`
}

// ListVirtualHubBgpConnectionResults virtualHubBgpConnections list.
type ListVirtualHubBgpConnectionResults struct {
	autorest.Response `json:"-"`
	// Value - The list of VirtualHubBgpConnections.
	Value *[]BgpConnection `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVirtualHubBgpConnectionResultsIterator provides access to a complete listing of BgpConnection
// values.
type ListVirtualHubBgpConnectionResultsIterator struct {
	i    int
	page ListVirtualHubBgpConnectionResultsPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVirtualHubBgpConnectionResultsIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualHubBgpConnectionResultsIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVirtualHubBgpConnectionResultsIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVirtualHubBgpConnectionResultsIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVirtualHubBgpConnectionResultsIterator) Response() ListVirtualHubBgpConnectionResults {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVirtualHubBgpConnectionResultsIterator) Value() BgpConnection {
	if !iter.page.NotDone() {
		return BgpConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVirtualHubBgpConnectionResultsIterator type.
func NewListVirtualHubBgpConnectionResultsIterator(page ListVirtualHubBgpConnectionResultsPage) ListVirtualHubBgpConnectionResultsIterator {
	return ListVirtualHubBgpConnectionResultsIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvhbcr ListVirtualHubBgpConnectionResults) IsEmpty() bool {
	return lvhbcr.Value == nil || len(*lvhbcr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvhbcr ListVirtualHubBgpConnectionResults) hasNextLink() bool {
	return lvhbcr.NextLink != nil && len(*lvhbcr.NextLink) != 0
}

// listVirtualHubBgpConnectionResultsPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvhbcr ListVirtualHubBgpConnectionResults) listVirtualHubBgpConnectionResultsPreparer(ctx context.Context) (*http.Request, error) {
	if !lvhbcr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvhbcr.NextLink)))
}

// ListVirtualHubBgpConnectionResultsPage contains a page of BgpConnection values.
type ListVirtualHubBgpConnectionResultsPage struct {
	fn     func(context.Context, ListVirtualHubBgpConnectionResults) (ListVirtualHubBgpConnectionResults, error)
	lvhbcr ListVirtualHubBgpConnectionResults
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVirtualHubBgpConnectionResultsPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualHubBgpConnectionResultsPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvhbcr)
		if err != nil {
			return err
		}
		page.lvhbcr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVirtualHubBgpConnectionResultsPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVirtualHubBgpConnectionResultsPage) NotDone() bool {
	return !page.lvhbcr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVirtualHubBgpConnectionResultsPage) Response() ListVirtualHubBgpConnectionResults {
	return page.lvhbcr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVirtualHubBgpConnectionResultsPage) Values() []BgpConnection {
	if page.lvhbcr.IsEmpty() {
		return nil
	}
	return *page.lvhbcr.Value
}

// Creates a new instance of the ListVirtualHubBgpConnectionResultsPage type.
func NewListVirtualHubBgpConnectionResultsPage(cur ListVirtualHubBgpConnectionResults, getNextPage func(context.Context, ListVirtualHubBgpConnectionResults) (ListVirtualHubBgpConnectionResults, error)) ListVirtualHubBgpConnectionResultsPage {
	return ListVirtualHubBgpConnectionResultsPage{
		fn:     getNextPage,
		lvhbcr: cur,
	}
}

// ListVirtualHubIPConfigurationResults virtualHubIpConfigurations list.
type ListVirtualHubIPConfigurationResults struct {
	autorest.Response `json:"-"`
	// Value - The list of VirtualHubIpConfigurations.
	Value *[]HubIPConfiguration `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVirtualHubIPConfigurationResultsIterator provides access to a complete listing of HubIPConfiguration
// values.
type ListVirtualHubIPConfigurationResultsIterator struct {
	i    int
	page ListVirtualHubIPConfigurationResultsPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVirtualHubIPConfigurationResultsIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualHubIPConfigurationResultsIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVirtualHubIPConfigurationResultsIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVirtualHubIPConfigurationResultsIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVirtualHubIPConfigurationResultsIterator) Response() ListVirtualHubIPConfigurationResults {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVirtualHubIPConfigurationResultsIterator) Value() HubIPConfiguration {
	if !iter.page.NotDone() {
		return HubIPConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVirtualHubIPConfigurationResultsIterator type.
func NewListVirtualHubIPConfigurationResultsIterator(page ListVirtualHubIPConfigurationResultsPage) ListVirtualHubIPConfigurationResultsIterator {
	return ListVirtualHubIPConfigurationResultsIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvhicr ListVirtualHubIPConfigurationResults) IsEmpty() bool {
	return lvhicr.Value == nil || len(*lvhicr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvhicr ListVirtualHubIPConfigurationResults) hasNextLink() bool {
	return lvhicr.NextLink != nil && len(*lvhicr.NextLink) != 0
}

// listVirtualHubIPConfigurationResultsPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvhicr ListVirtualHubIPConfigurationResults) listVirtualHubIPConfigurationResultsPreparer(ctx context.Context) (*http.Request, error) {
	if !lvhicr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvhicr.NextLink)))
}

// ListVirtualHubIPConfigurationResultsPage contains a page of HubIPConfiguration values.
type ListVirtualHubIPConfigurationResultsPage struct {
	fn     func(context.Context, ListVirtualHubIPConfigurationResults) (ListVirtualHubIPConfigurationResults, error)
	lvhicr ListVirtualHubIPConfigurationResults
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVirtualHubIPConfigurationResultsPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualHubIPConfigurationResultsPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvhicr)
		if err != nil {
			return err
		}
		page.lvhicr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVirtualHubIPConfigurationResultsPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVirtualHubIPConfigurationResultsPage) NotDone() bool {
	return !page.lvhicr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVirtualHubIPConfigurationResultsPage) Response() ListVirtualHubIPConfigurationResults {
	return page.lvhicr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVirtualHubIPConfigurationResultsPage) Values() []HubIPConfiguration {
	if page.lvhicr.IsEmpty() {
		return nil
	}
	return *page.lvhicr.Value
}

// Creates a new instance of the ListVirtualHubIPConfigurationResultsPage type.
func NewListVirtualHubIPConfigurationResultsPage(cur ListVirtualHubIPConfigurationResults, getNextPage func(context.Context, ListVirtualHubIPConfigurationResults) (ListVirtualHubIPConfigurationResults, error)) ListVirtualHubIPConfigurationResultsPage {
	return ListVirtualHubIPConfigurationResultsPage{
		fn:     getNextPage,
		lvhicr: cur,
	}
}

// ListVirtualHubRouteTableV2sResult list of VirtualHubRouteTableV2s and a URL nextLink to get the next set
// of results.
type ListVirtualHubRouteTableV2sResult struct {
	autorest.Response `json:"-"`
	// Value - List of VirtualHubRouteTableV2s.
	Value *[]VirtualHubRouteTableV2 `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVirtualHubRouteTableV2sResultIterator provides access to a complete listing of
// VirtualHubRouteTableV2 values.
type ListVirtualHubRouteTableV2sResultIterator struct {
	i    int
	page ListVirtualHubRouteTableV2sResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVirtualHubRouteTableV2sResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualHubRouteTableV2sResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVirtualHubRouteTableV2sResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVirtualHubRouteTableV2sResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVirtualHubRouteTableV2sResultIterator) Response() ListVirtualHubRouteTableV2sResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVirtualHubRouteTableV2sResultIterator) Value() VirtualHubRouteTableV2 {
	if !iter.page.NotDone() {
		return VirtualHubRouteTableV2{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVirtualHubRouteTableV2sResultIterator type.
func NewListVirtualHubRouteTableV2sResultIterator(page ListVirtualHubRouteTableV2sResultPage) ListVirtualHubRouteTableV2sResultIterator {
	return ListVirtualHubRouteTableV2sResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvhrtvr ListVirtualHubRouteTableV2sResult) IsEmpty() bool {
	return lvhrtvr.Value == nil || len(*lvhrtvr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvhrtvr ListVirtualHubRouteTableV2sResult) hasNextLink() bool {
	return lvhrtvr.NextLink != nil && len(*lvhrtvr.NextLink) != 0
}

// listVirtualHubRouteTableV2sResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvhrtvr ListVirtualHubRouteTableV2sResult) listVirtualHubRouteTableV2sResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvhrtvr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvhrtvr.NextLink)))
}

// ListVirtualHubRouteTableV2sResultPage contains a page of VirtualHubRouteTableV2 values.
type ListVirtualHubRouteTableV2sResultPage struct {
	fn      func(context.Context, ListVirtualHubRouteTableV2sResult) (ListVirtualHubRouteTableV2sResult, error)
	lvhrtvr ListVirtualHubRouteTableV2sResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVirtualHubRouteTableV2sResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualHubRouteTableV2sResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvhrtvr)
		if err != nil {
			return err
		}
		page.lvhrtvr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVirtualHubRouteTableV2sResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVirtualHubRouteTableV2sResultPage) NotDone() bool {
	return !page.lvhrtvr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVirtualHubRouteTableV2sResultPage) Response() ListVirtualHubRouteTableV2sResult {
	return page.lvhrtvr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVirtualHubRouteTableV2sResultPage) Values() []VirtualHubRouteTableV2 {
	if page.lvhrtvr.IsEmpty() {
		return nil
	}
	return *page.lvhrtvr.Value
}

// Creates a new instance of the ListVirtualHubRouteTableV2sResultPage type.
func NewListVirtualHubRouteTableV2sResultPage(cur ListVirtualHubRouteTableV2sResult, getNextPage func(context.Context, ListVirtualHubRouteTableV2sResult) (ListVirtualHubRouteTableV2sResult, error)) ListVirtualHubRouteTableV2sResultPage {
	return ListVirtualHubRouteTableV2sResultPage{
		fn:      getNextPage,
		lvhrtvr: cur,
	}
}

// ListVirtualHubsResult result of the request to list VirtualHubs. It contains a list of VirtualHubs and a
// URL nextLink to get the next set of results.
type ListVirtualHubsResult struct {
	autorest.Response `json:"-"`
	// Value - List of VirtualHubs.
	Value *[]VirtualHub `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVirtualHubsResultIterator provides access to a complete listing of VirtualHub values.
type ListVirtualHubsResultIterator struct {
	i    int
	page ListVirtualHubsResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVirtualHubsResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualHubsResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVirtualHubsResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVirtualHubsResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVirtualHubsResultIterator) Response() ListVirtualHubsResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVirtualHubsResultIterator) Value() VirtualHub {
	if !iter.page.NotDone() {
		return VirtualHub{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVirtualHubsResultIterator type.
func NewListVirtualHubsResultIterator(page ListVirtualHubsResultPage) ListVirtualHubsResultIterator {
	return ListVirtualHubsResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvhr ListVirtualHubsResult) IsEmpty() bool {
	return lvhr.Value == nil || len(*lvhr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvhr ListVirtualHubsResult) hasNextLink() bool {
	return lvhr.NextLink != nil && len(*lvhr.NextLink) != 0
}

// listVirtualHubsResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvhr ListVirtualHubsResult) listVirtualHubsResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvhr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvhr.NextLink)))
}

// ListVirtualHubsResultPage contains a page of VirtualHub values.
type ListVirtualHubsResultPage struct {
	fn   func(context.Context, ListVirtualHubsResult) (ListVirtualHubsResult, error)
	lvhr ListVirtualHubsResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVirtualHubsResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualHubsResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvhr)
		if err != nil {
			return err
		}
		page.lvhr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVirtualHubsResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVirtualHubsResultPage) NotDone() bool {
	return !page.lvhr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVirtualHubsResultPage) Response() ListVirtualHubsResult {
	return page.lvhr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVirtualHubsResultPage) Values() []VirtualHub {
	if page.lvhr.IsEmpty() {
		return nil
	}
	return *page.lvhr.Value
}

// Creates a new instance of the ListVirtualHubsResultPage type.
func NewListVirtualHubsResultPage(cur ListVirtualHubsResult, getNextPage func(context.Context, ListVirtualHubsResult) (ListVirtualHubsResult, error)) ListVirtualHubsResultPage {
	return ListVirtualHubsResultPage{
		fn:   getNextPage,
		lvhr: cur,
	}
}

// ListVirtualWANsResult result of the request to list VirtualWANs. It contains a list of VirtualWANs and a
// URL nextLink to get the next set of results.
type ListVirtualWANsResult struct {
	autorest.Response `json:"-"`
	// Value - List of VirtualWANs.
	Value *[]VirtualWAN `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVirtualWANsResultIterator provides access to a complete listing of VirtualWAN values.
type ListVirtualWANsResultIterator struct {
	i    int
	page ListVirtualWANsResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVirtualWANsResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualWANsResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVirtualWANsResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVirtualWANsResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVirtualWANsResultIterator) Response() ListVirtualWANsResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVirtualWANsResultIterator) Value() VirtualWAN {
	if !iter.page.NotDone() {
		return VirtualWAN{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVirtualWANsResultIterator type.
func NewListVirtualWANsResultIterator(page ListVirtualWANsResultPage) ListVirtualWANsResultIterator {
	return ListVirtualWANsResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvwnr ListVirtualWANsResult) IsEmpty() bool {
	return lvwnr.Value == nil || len(*lvwnr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvwnr ListVirtualWANsResult) hasNextLink() bool {
	return lvwnr.NextLink != nil && len(*lvwnr.NextLink) != 0
}

// listVirtualWANsResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvwnr ListVirtualWANsResult) listVirtualWANsResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvwnr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvwnr.NextLink)))
}

// ListVirtualWANsResultPage contains a page of VirtualWAN values.
type ListVirtualWANsResultPage struct {
	fn    func(context.Context, ListVirtualWANsResult) (ListVirtualWANsResult, error)
	lvwnr ListVirtualWANsResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVirtualWANsResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVirtualWANsResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvwnr)
		if err != nil {
			return err
		}
		page.lvwnr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVirtualWANsResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVirtualWANsResultPage) NotDone() bool {
	return !page.lvwnr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVirtualWANsResultPage) Response() ListVirtualWANsResult {
	return page.lvwnr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVirtualWANsResultPage) Values() []VirtualWAN {
	if page.lvwnr.IsEmpty() {
		return nil
	}
	return *page.lvwnr.Value
}

// Creates a new instance of the ListVirtualWANsResultPage type.
func NewListVirtualWANsResultPage(cur ListVirtualWANsResult, getNextPage func(context.Context, ListVirtualWANsResult) (ListVirtualWANsResult, error)) ListVirtualWANsResultPage {
	return ListVirtualWANsResultPage{
		fn:    getNextPage,
		lvwnr: cur,
	}
}

// ListVpnConnectionsResult result of the request to list all vpn connections to a virtual wan vpn gateway.
// It contains a list of Vpn Connections and a URL nextLink to get the next set of results.
type ListVpnConnectionsResult struct {
	autorest.Response `json:"-"`
	// Value - List of Vpn Connections.
	Value *[]VpnConnection `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVpnConnectionsResultIterator provides access to a complete listing of VpnConnection values.
type ListVpnConnectionsResultIterator struct {
	i    int
	page ListVpnConnectionsResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVpnConnectionsResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnConnectionsResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVpnConnectionsResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVpnConnectionsResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVpnConnectionsResultIterator) Response() ListVpnConnectionsResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVpnConnectionsResultIterator) Value() VpnConnection {
	if !iter.page.NotDone() {
		return VpnConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVpnConnectionsResultIterator type.
func NewListVpnConnectionsResultIterator(page ListVpnConnectionsResultPage) ListVpnConnectionsResultIterator {
	return ListVpnConnectionsResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvcr ListVpnConnectionsResult) IsEmpty() bool {
	return lvcr.Value == nil || len(*lvcr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvcr ListVpnConnectionsResult) hasNextLink() bool {
	return lvcr.NextLink != nil && len(*lvcr.NextLink) != 0
}

// listVpnConnectionsResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvcr ListVpnConnectionsResult) listVpnConnectionsResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvcr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvcr.NextLink)))
}

// ListVpnConnectionsResultPage contains a page of VpnConnection values.
type ListVpnConnectionsResultPage struct {
	fn   func(context.Context, ListVpnConnectionsResult) (ListVpnConnectionsResult, error)
	lvcr ListVpnConnectionsResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVpnConnectionsResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnConnectionsResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvcr)
		if err != nil {
			return err
		}
		page.lvcr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVpnConnectionsResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVpnConnectionsResultPage) NotDone() bool {
	return !page.lvcr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVpnConnectionsResultPage) Response() ListVpnConnectionsResult {
	return page.lvcr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVpnConnectionsResultPage) Values() []VpnConnection {
	if page.lvcr.IsEmpty() {
		return nil
	}
	return *page.lvcr.Value
}

// Creates a new instance of the ListVpnConnectionsResultPage type.
func NewListVpnConnectionsResultPage(cur ListVpnConnectionsResult, getNextPage func(context.Context, ListVpnConnectionsResult) (ListVpnConnectionsResult, error)) ListVpnConnectionsResultPage {
	return ListVpnConnectionsResultPage{
		fn:   getNextPage,
		lvcr: cur,
	}
}

// ListVpnGatewayNatRulesResult result of the request to list all nat rules to a virtual wan vpn gateway.
// It contains a list of Nat rules and a URL nextLink to get the next set of results.
type ListVpnGatewayNatRulesResult struct {
	autorest.Response `json:"-"`
	// Value - List of Nat Rules.
	Value *[]VpnGatewayNatRule `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVpnGatewayNatRulesResultIterator provides access to a complete listing of VpnGatewayNatRule values.
type ListVpnGatewayNatRulesResultIterator struct {
	i    int
	page ListVpnGatewayNatRulesResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVpnGatewayNatRulesResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnGatewayNatRulesResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVpnGatewayNatRulesResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVpnGatewayNatRulesResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVpnGatewayNatRulesResultIterator) Response() ListVpnGatewayNatRulesResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVpnGatewayNatRulesResultIterator) Value() VpnGatewayNatRule {
	if !iter.page.NotDone() {
		return VpnGatewayNatRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVpnGatewayNatRulesResultIterator type.
func NewListVpnGatewayNatRulesResultIterator(page ListVpnGatewayNatRulesResultPage) ListVpnGatewayNatRulesResultIterator {
	return ListVpnGatewayNatRulesResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvgnrr ListVpnGatewayNatRulesResult) IsEmpty() bool {
	return lvgnrr.Value == nil || len(*lvgnrr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvgnrr ListVpnGatewayNatRulesResult) hasNextLink() bool {
	return lvgnrr.NextLink != nil && len(*lvgnrr.NextLink) != 0
}

// listVpnGatewayNatRulesResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvgnrr ListVpnGatewayNatRulesResult) listVpnGatewayNatRulesResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvgnrr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvgnrr.NextLink)))
}

// ListVpnGatewayNatRulesResultPage contains a page of VpnGatewayNatRule values.
type ListVpnGatewayNatRulesResultPage struct {
	fn     func(context.Context, ListVpnGatewayNatRulesResult) (ListVpnGatewayNatRulesResult, error)
	lvgnrr ListVpnGatewayNatRulesResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVpnGatewayNatRulesResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnGatewayNatRulesResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvgnrr)
		if err != nil {
			return err
		}
		page.lvgnrr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVpnGatewayNatRulesResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVpnGatewayNatRulesResultPage) NotDone() bool {
	return !page.lvgnrr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVpnGatewayNatRulesResultPage) Response() ListVpnGatewayNatRulesResult {
	return page.lvgnrr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVpnGatewayNatRulesResultPage) Values() []VpnGatewayNatRule {
	if page.lvgnrr.IsEmpty() {
		return nil
	}
	return *page.lvgnrr.Value
}

// Creates a new instance of the ListVpnGatewayNatRulesResultPage type.
func NewListVpnGatewayNatRulesResultPage(cur ListVpnGatewayNatRulesResult, getNextPage func(context.Context, ListVpnGatewayNatRulesResult) (ListVpnGatewayNatRulesResult, error)) ListVpnGatewayNatRulesResultPage {
	return ListVpnGatewayNatRulesResultPage{
		fn:     getNextPage,
		lvgnrr: cur,
	}
}

// ListVpnGatewaysResult result of the request to list VpnGateways. It contains a list of VpnGateways and a
// URL nextLink to get the next set of results.
type ListVpnGatewaysResult struct {
	autorest.Response `json:"-"`
	// Value - List of VpnGateways.
	Value *[]VpnGateway `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVpnGatewaysResultIterator provides access to a complete listing of VpnGateway values.
type ListVpnGatewaysResultIterator struct {
	i    int
	page ListVpnGatewaysResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVpnGatewaysResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnGatewaysResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVpnGatewaysResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVpnGatewaysResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVpnGatewaysResultIterator) Response() ListVpnGatewaysResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVpnGatewaysResultIterator) Value() VpnGateway {
	if !iter.page.NotDone() {
		return VpnGateway{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVpnGatewaysResultIterator type.
func NewListVpnGatewaysResultIterator(page ListVpnGatewaysResultPage) ListVpnGatewaysResultIterator {
	return ListVpnGatewaysResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvgr ListVpnGatewaysResult) IsEmpty() bool {
	return lvgr.Value == nil || len(*lvgr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvgr ListVpnGatewaysResult) hasNextLink() bool {
	return lvgr.NextLink != nil && len(*lvgr.NextLink) != 0
}

// listVpnGatewaysResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvgr ListVpnGatewaysResult) listVpnGatewaysResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvgr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvgr.NextLink)))
}

// ListVpnGatewaysResultPage contains a page of VpnGateway values.
type ListVpnGatewaysResultPage struct {
	fn   func(context.Context, ListVpnGatewaysResult) (ListVpnGatewaysResult, error)
	lvgr ListVpnGatewaysResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVpnGatewaysResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnGatewaysResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvgr)
		if err != nil {
			return err
		}
		page.lvgr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVpnGatewaysResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVpnGatewaysResultPage) NotDone() bool {
	return !page.lvgr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVpnGatewaysResultPage) Response() ListVpnGatewaysResult {
	return page.lvgr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVpnGatewaysResultPage) Values() []VpnGateway {
	if page.lvgr.IsEmpty() {
		return nil
	}
	return *page.lvgr.Value
}

// Creates a new instance of the ListVpnGatewaysResultPage type.
func NewListVpnGatewaysResultPage(cur ListVpnGatewaysResult, getNextPage func(context.Context, ListVpnGatewaysResult) (ListVpnGatewaysResult, error)) ListVpnGatewaysResultPage {
	return ListVpnGatewaysResultPage{
		fn:   getNextPage,
		lvgr: cur,
	}
}

// ListVpnServerConfigurationsResult result of the request to list all VpnServerConfigurations. It contains
// a list of VpnServerConfigurations and a URL nextLink to get the next set of results.
type ListVpnServerConfigurationsResult struct {
	autorest.Response `json:"-"`
	// Value - List of VpnServerConfigurations.
	Value *[]VpnServerConfiguration `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVpnServerConfigurationsResultIterator provides access to a complete listing of
// VpnServerConfiguration values.
type ListVpnServerConfigurationsResultIterator struct {
	i    int
	page ListVpnServerConfigurationsResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVpnServerConfigurationsResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnServerConfigurationsResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVpnServerConfigurationsResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVpnServerConfigurationsResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVpnServerConfigurationsResultIterator) Response() ListVpnServerConfigurationsResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVpnServerConfigurationsResultIterator) Value() VpnServerConfiguration {
	if !iter.page.NotDone() {
		return VpnServerConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVpnServerConfigurationsResultIterator type.
func NewListVpnServerConfigurationsResultIterator(page ListVpnServerConfigurationsResultPage) ListVpnServerConfigurationsResultIterator {
	return ListVpnServerConfigurationsResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvscr ListVpnServerConfigurationsResult) IsEmpty() bool {
	return lvscr.Value == nil || len(*lvscr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvscr ListVpnServerConfigurationsResult) hasNextLink() bool {
	return lvscr.NextLink != nil && len(*lvscr.NextLink) != 0
}

// listVpnServerConfigurationsResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvscr ListVpnServerConfigurationsResult) listVpnServerConfigurationsResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvscr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvscr.NextLink)))
}

// ListVpnServerConfigurationsResultPage contains a page of VpnServerConfiguration values.
type ListVpnServerConfigurationsResultPage struct {
	fn    func(context.Context, ListVpnServerConfigurationsResult) (ListVpnServerConfigurationsResult, error)
	lvscr ListVpnServerConfigurationsResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVpnServerConfigurationsResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnServerConfigurationsResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvscr)
		if err != nil {
			return err
		}
		page.lvscr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVpnServerConfigurationsResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVpnServerConfigurationsResultPage) NotDone() bool {
	return !page.lvscr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVpnServerConfigurationsResultPage) Response() ListVpnServerConfigurationsResult {
	return page.lvscr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVpnServerConfigurationsResultPage) Values() []VpnServerConfiguration {
	if page.lvscr.IsEmpty() {
		return nil
	}
	return *page.lvscr.Value
}

// Creates a new instance of the ListVpnServerConfigurationsResultPage type.
func NewListVpnServerConfigurationsResultPage(cur ListVpnServerConfigurationsResult, getNextPage func(context.Context, ListVpnServerConfigurationsResult) (ListVpnServerConfigurationsResult, error)) ListVpnServerConfigurationsResultPage {
	return ListVpnServerConfigurationsResultPage{
		fn:    getNextPage,
		lvscr: cur,
	}
}

// ListVpnSiteLinkConnectionsResult result of the request to list all vpn connections to a virtual wan vpn
// gateway. It contains a list of Vpn Connections and a URL nextLink to get the next set of results.
type ListVpnSiteLinkConnectionsResult struct {
	autorest.Response `json:"-"`
	// Value - List of VpnSiteLinkConnections.
	Value *[]VpnSiteLinkConnection `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVpnSiteLinkConnectionsResultIterator provides access to a complete listing of VpnSiteLinkConnection
// values.
type ListVpnSiteLinkConnectionsResultIterator struct {
	i    int
	page ListVpnSiteLinkConnectionsResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVpnSiteLinkConnectionsResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnSiteLinkConnectionsResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVpnSiteLinkConnectionsResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVpnSiteLinkConnectionsResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVpnSiteLinkConnectionsResultIterator) Response() ListVpnSiteLinkConnectionsResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVpnSiteLinkConnectionsResultIterator) Value() VpnSiteLinkConnection {
	if !iter.page.NotDone() {
		return VpnSiteLinkConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVpnSiteLinkConnectionsResultIterator type.
func NewListVpnSiteLinkConnectionsResultIterator(page ListVpnSiteLinkConnectionsResultPage) ListVpnSiteLinkConnectionsResultIterator {
	return ListVpnSiteLinkConnectionsResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvslcr ListVpnSiteLinkConnectionsResult) IsEmpty() bool {
	return lvslcr.Value == nil || len(*lvslcr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvslcr ListVpnSiteLinkConnectionsResult) hasNextLink() bool {
	return lvslcr.NextLink != nil && len(*lvslcr.NextLink) != 0
}

// listVpnSiteLinkConnectionsResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvslcr ListVpnSiteLinkConnectionsResult) listVpnSiteLinkConnectionsResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvslcr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvslcr.NextLink)))
}

// ListVpnSiteLinkConnectionsResultPage contains a page of VpnSiteLinkConnection values.
type ListVpnSiteLinkConnectionsResultPage struct {
	fn     func(context.Context, ListVpnSiteLinkConnectionsResult) (ListVpnSiteLinkConnectionsResult, error)
	lvslcr ListVpnSiteLinkConnectionsResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVpnSiteLinkConnectionsResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnSiteLinkConnectionsResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvslcr)
		if err != nil {
			return err
		}
		page.lvslcr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVpnSiteLinkConnectionsResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVpnSiteLinkConnectionsResultPage) NotDone() bool {
	return !page.lvslcr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVpnSiteLinkConnectionsResultPage) Response() ListVpnSiteLinkConnectionsResult {
	return page.lvslcr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVpnSiteLinkConnectionsResultPage) Values() []VpnSiteLinkConnection {
	if page.lvslcr.IsEmpty() {
		return nil
	}
	return *page.lvslcr.Value
}

// Creates a new instance of the ListVpnSiteLinkConnectionsResultPage type.
func NewListVpnSiteLinkConnectionsResultPage(cur ListVpnSiteLinkConnectionsResult, getNextPage func(context.Context, ListVpnSiteLinkConnectionsResult) (ListVpnSiteLinkConnectionsResult, error)) ListVpnSiteLinkConnectionsResultPage {
	return ListVpnSiteLinkConnectionsResultPage{
		fn:     getNextPage,
		lvslcr: cur,
	}
}

// ListVpnSiteLinksResult result of the request to list VpnSiteLinks. It contains a list of VpnSiteLinks
// and a URL nextLink to get the next set of results.
type ListVpnSiteLinksResult struct {
	autorest.Response `json:"-"`
	// Value - List of VpnSitesLinks.
	Value *[]VpnSiteLink `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVpnSiteLinksResultIterator provides access to a complete listing of VpnSiteLink values.
type ListVpnSiteLinksResultIterator struct {
	i    int
	page ListVpnSiteLinksResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVpnSiteLinksResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnSiteLinksResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVpnSiteLinksResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVpnSiteLinksResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVpnSiteLinksResultIterator) Response() ListVpnSiteLinksResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVpnSiteLinksResultIterator) Value() VpnSiteLink {
	if !iter.page.NotDone() {
		return VpnSiteLink{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVpnSiteLinksResultIterator type.
func NewListVpnSiteLinksResultIterator(page ListVpnSiteLinksResultPage) ListVpnSiteLinksResultIterator {
	return ListVpnSiteLinksResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvslr ListVpnSiteLinksResult) IsEmpty() bool {
	return lvslr.Value == nil || len(*lvslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvslr ListVpnSiteLinksResult) hasNextLink() bool {
	return lvslr.NextLink != nil && len(*lvslr.NextLink) != 0
}

// listVpnSiteLinksResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvslr ListVpnSiteLinksResult) listVpnSiteLinksResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvslr.NextLink)))
}

// ListVpnSiteLinksResultPage contains a page of VpnSiteLink values.
type ListVpnSiteLinksResultPage struct {
	fn    func(context.Context, ListVpnSiteLinksResult) (ListVpnSiteLinksResult, error)
	lvslr ListVpnSiteLinksResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVpnSiteLinksResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnSiteLinksResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvslr)
		if err != nil {
			return err
		}
		page.lvslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVpnSiteLinksResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVpnSiteLinksResultPage) NotDone() bool {
	return !page.lvslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVpnSiteLinksResultPage) Response() ListVpnSiteLinksResult {
	return page.lvslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVpnSiteLinksResultPage) Values() []VpnSiteLink {
	if page.lvslr.IsEmpty() {
		return nil
	}
	return *page.lvslr.Value
}

// Creates a new instance of the ListVpnSiteLinksResultPage type.
func NewListVpnSiteLinksResultPage(cur ListVpnSiteLinksResult, getNextPage func(context.Context, ListVpnSiteLinksResult) (ListVpnSiteLinksResult, error)) ListVpnSiteLinksResultPage {
	return ListVpnSiteLinksResultPage{
		fn:    getNextPage,
		lvslr: cur,
	}
}

// ListVpnSitesResult result of the request to list VpnSites. It contains a list of VpnSites and a URL
// nextLink to get the next set of results.
type ListVpnSitesResult struct {
	autorest.Response `json:"-"`
	// Value - List of VpnSites.
	Value *[]VpnSite `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListVpnSitesResultIterator provides access to a complete listing of VpnSite values.
type ListVpnSitesResultIterator struct {
	i    int
	page ListVpnSitesResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListVpnSitesResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnSitesResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListVpnSitesResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListVpnSitesResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListVpnSitesResultIterator) Response() ListVpnSitesResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListVpnSitesResultIterator) Value() VpnSite {
	if !iter.page.NotDone() {
		return VpnSite{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListVpnSitesResultIterator type.
func NewListVpnSitesResultIterator(page ListVpnSitesResultPage) ListVpnSitesResultIterator {
	return ListVpnSitesResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lvsr ListVpnSitesResult) IsEmpty() bool {
	return lvsr.Value == nil || len(*lvsr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lvsr ListVpnSitesResult) hasNextLink() bool {
	return lvsr.NextLink != nil && len(*lvsr.NextLink) != 0
}

// listVpnSitesResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lvsr ListVpnSitesResult) listVpnSitesResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lvsr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lvsr.NextLink)))
}

// ListVpnSitesResultPage contains a page of VpnSite values.
type ListVpnSitesResultPage struct {
	fn   func(context.Context, ListVpnSitesResult) (ListVpnSitesResult, error)
	lvsr ListVpnSitesResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListVpnSitesResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListVpnSitesResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lvsr)
		if err != nil {
			return err
		}
		page.lvsr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListVpnSitesResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListVpnSitesResultPage) NotDone() bool {
	return !page.lvsr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListVpnSitesResultPage) Response() ListVpnSitesResult {
	return page.lvsr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListVpnSitesResultPage) Values() []VpnSite {
	if page.lvsr.IsEmpty() {
		return nil
	}
	return *page.lvsr.Value
}

// Creates a new instance of the ListVpnSitesResultPage type.
func NewListVpnSitesResultPage(cur ListVpnSitesResult, getNextPage func(context.Context, ListVpnSitesResult) (ListVpnSitesResult, error)) ListVpnSitesResultPage {
	return ListVpnSitesResultPage{
		fn:   getNextPage,
		lvsr: cur,
	}
}

// LoadBalancer loadBalancer resource.
type LoadBalancer struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Sku - The load balancer SKU.
	Sku *LoadBalancerSku `json:"sku,omitempty"`
	// LoadBalancerPropertiesFormat - Properties of load balancer.
	*LoadBalancerPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for LoadBalancer.
func (lb LoadBalancer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lb.ExtendedLocation != nil {
		objectMap["extendedLocation"] = lb.ExtendedLocation
	}
	if lb.Sku != nil {
		objectMap["sku"] = lb.Sku
	}
	if lb.LoadBalancerPropertiesFormat != nil {
		objectMap["properties"] = lb.LoadBalancerPropertiesFormat
	}
	if lb.ID != nil {
		objectMap["id"] = lb.ID
	}
	if lb.Location != nil {
		objectMap["location"] = lb.Location
	}
	if lb.Tags != nil {
		objectMap["tags"] = lb.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LoadBalancer struct.
func (lb *LoadBalancer) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				lb.ExtendedLocation = &extendedLocation
			}
		case "sku":
			if v != nil {
				var sku LoadBalancerSku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				lb.Sku = &sku
			}
		case "properties":
			if v != nil {
				var loadBalancerPropertiesFormat LoadBalancerPropertiesFormat
				err = json.Unmarshal(*v, &loadBalancerPropertiesFormat)
				if err != nil {
					return err
				}
				lb.LoadBalancerPropertiesFormat = &loadBalancerPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				lb.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				lb.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lb.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lb.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				lb.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				lb.Tags = tags
			}
		}
	}

	return nil
}

// LoadBalancerBackendAddress load balancer backend addresses.
type LoadBalancerBackendAddress struct {
	// LoadBalancerBackendAddressPropertiesFormat - Properties of load balancer backend address pool.
	*LoadBalancerBackendAddressPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the backend address.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerBackendAddress.
func (lbba LoadBalancerBackendAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lbba.LoadBalancerBackendAddressPropertiesFormat != nil {
		objectMap["properties"] = lbba.LoadBalancerBackendAddressPropertiesFormat
	}
	if lbba.Name != nil {
		objectMap["name"] = lbba.Name
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LoadBalancerBackendAddress struct.
func (lbba *LoadBalancerBackendAddress) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var loadBalancerBackendAddressPropertiesFormat LoadBalancerBackendAddressPropertiesFormat
				err = json.Unmarshal(*v, &loadBalancerBackendAddressPropertiesFormat)
				if err != nil {
					return err
				}
				lbba.LoadBalancerBackendAddressPropertiesFormat = &loadBalancerBackendAddressPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lbba.Name = &name
			}
		}
	}

	return nil
}

// LoadBalancerBackendAddressPoolListResult response for ListBackendAddressPool API service call.
type LoadBalancerBackendAddressPoolListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of backend address pools in a load balancer.
	Value *[]BackendAddressPool `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerBackendAddressPoolListResult.
func (lbbaplr LoadBalancerBackendAddressPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lbbaplr.Value != nil {
		objectMap["value"] = lbbaplr.Value
	}
	return json.Marshal(objectMap)
}

// LoadBalancerBackendAddressPoolListResultIterator provides access to a complete listing of
// BackendAddressPool values.
type LoadBalancerBackendAddressPoolListResultIterator struct {
	i    int
	page LoadBalancerBackendAddressPoolListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LoadBalancerBackendAddressPoolListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerBackendAddressPoolListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LoadBalancerBackendAddressPoolListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LoadBalancerBackendAddressPoolListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LoadBalancerBackendAddressPoolListResultIterator) Response() LoadBalancerBackendAddressPoolListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LoadBalancerBackendAddressPoolListResultIterator) Value() BackendAddressPool {
	if !iter.page.NotDone() {
		return BackendAddressPool{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LoadBalancerBackendAddressPoolListResultIterator type.
func NewLoadBalancerBackendAddressPoolListResultIterator(page LoadBalancerBackendAddressPoolListResultPage) LoadBalancerBackendAddressPoolListResultIterator {
	return LoadBalancerBackendAddressPoolListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lbbaplr LoadBalancerBackendAddressPoolListResult) IsEmpty() bool {
	return lbbaplr.Value == nil || len(*lbbaplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lbbaplr LoadBalancerBackendAddressPoolListResult) hasNextLink() bool {
	return lbbaplr.NextLink != nil && len(*lbbaplr.NextLink) != 0
}

// loadBalancerBackendAddressPoolListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lbbaplr LoadBalancerBackendAddressPoolListResult) loadBalancerBackendAddressPoolListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lbbaplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lbbaplr.NextLink)))
}

// LoadBalancerBackendAddressPoolListResultPage contains a page of BackendAddressPool values.
type LoadBalancerBackendAddressPoolListResultPage struct {
	fn      func(context.Context, LoadBalancerBackendAddressPoolListResult) (LoadBalancerBackendAddressPoolListResult, error)
	lbbaplr LoadBalancerBackendAddressPoolListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LoadBalancerBackendAddressPoolListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerBackendAddressPoolListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lbbaplr)
		if err != nil {
			return err
		}
		page.lbbaplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LoadBalancerBackendAddressPoolListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LoadBalancerBackendAddressPoolListResultPage) NotDone() bool {
	return !page.lbbaplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LoadBalancerBackendAddressPoolListResultPage) Response() LoadBalancerBackendAddressPoolListResult {
	return page.lbbaplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LoadBalancerBackendAddressPoolListResultPage) Values() []BackendAddressPool {
	if page.lbbaplr.IsEmpty() {
		return nil
	}
	return *page.lbbaplr.Value
}

// Creates a new instance of the LoadBalancerBackendAddressPoolListResultPage type.
func NewLoadBalancerBackendAddressPoolListResultPage(cur LoadBalancerBackendAddressPoolListResult, getNextPage func(context.Context, LoadBalancerBackendAddressPoolListResult) (LoadBalancerBackendAddressPoolListResult, error)) LoadBalancerBackendAddressPoolListResultPage {
	return LoadBalancerBackendAddressPoolListResultPage{
		fn:      getNextPage,
		lbbaplr: cur,
	}
}

// LoadBalancerBackendAddressPoolsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type LoadBalancerBackendAddressPoolsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(LoadBalancerBackendAddressPoolsClient) (BackendAddressPool, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *LoadBalancerBackendAddressPoolsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for LoadBalancerBackendAddressPoolsCreateOrUpdateFuture.Result.
func (future *LoadBalancerBackendAddressPoolsCreateOrUpdateFuture) result(client LoadBalancerBackendAddressPoolsClient) (bap BackendAddressPool, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.LoadBalancerBackendAddressPoolsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bap.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.LoadBalancerBackendAddressPoolsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bap.Response.Response, err = future.GetResult(sender); err == nil && bap.Response.Response.StatusCode != http.StatusNoContent {
		bap, err = client.CreateOrUpdateResponder(bap.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.LoadBalancerBackendAddressPoolsCreateOrUpdateFuture", "Result", bap.Response.Response, "Failure responding to request")
		}
	}
	return
}

// LoadBalancerBackendAddressPoolsDeleteFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type LoadBalancerBackendAddressPoolsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(LoadBalancerBackendAddressPoolsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *LoadBalancerBackendAddressPoolsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for LoadBalancerBackendAddressPoolsDeleteFuture.Result.
func (future *LoadBalancerBackendAddressPoolsDeleteFuture) result(client LoadBalancerBackendAddressPoolsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.LoadBalancerBackendAddressPoolsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.LoadBalancerBackendAddressPoolsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// LoadBalancerBackendAddressPropertiesFormat properties of the load balancer backend addresses.
type LoadBalancerBackendAddressPropertiesFormat struct {
	// VirtualNetwork - Reference to an existing virtual network.
	VirtualNetwork *SubResource `json:"virtualNetwork,omitempty"`
	// Subnet - Reference to an existing subnet.
	Subnet *SubResource `json:"subnet,omitempty"`
	// IPAddress - IP Address belonging to the referenced virtual network.
	IPAddress *string `json:"ipAddress,omitempty"`
	// NetworkInterfaceIPConfiguration - READ-ONLY; Reference to IP address defined in network interfaces.
	NetworkInterfaceIPConfiguration *SubResource `json:"networkInterfaceIPConfiguration,omitempty"`
	// LoadBalancerFrontendIPConfiguration - Reference to the frontend ip address configuration defined in regional loadbalancer.
	LoadBalancerFrontendIPConfiguration *SubResource `json:"loadBalancerFrontendIPConfiguration,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerBackendAddressPropertiesFormat.
func (lbbapf LoadBalancerBackendAddressPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lbbapf.VirtualNetwork != nil {
		objectMap["virtualNetwork"] = lbbapf.VirtualNetwork
	}
	if lbbapf.Subnet != nil {
		objectMap["subnet"] = lbbapf.Subnet
	}
	if lbbapf.IPAddress != nil {
		objectMap["ipAddress"] = lbbapf.IPAddress
	}
	if lbbapf.LoadBalancerFrontendIPConfiguration != nil {
		objectMap["loadBalancerFrontendIPConfiguration"] = lbbapf.LoadBalancerFrontendIPConfiguration
	}
	return json.Marshal(objectMap)
}

// LoadBalancerFrontendIPConfigurationListResult response for ListFrontendIPConfiguration API service call.
type LoadBalancerFrontendIPConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of frontend IP configurations in a load balancer.
	Value *[]FrontendIPConfiguration `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerFrontendIPConfigurationListResult.
func (lbficlr LoadBalancerFrontendIPConfigurationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lbficlr.Value != nil {
		objectMap["value"] = lbficlr.Value
	}
	return json.Marshal(objectMap)
}

// LoadBalancerFrontendIPConfigurationListResultIterator provides access to a complete listing of
// FrontendIPConfiguration values.
type LoadBalancerFrontendIPConfigurationListResultIterator struct {
	i    int
	page LoadBalancerFrontendIPConfigurationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LoadBalancerFrontendIPConfigurationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerFrontendIPConfigurationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LoadBalancerFrontendIPConfigurationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LoadBalancerFrontendIPConfigurationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LoadBalancerFrontendIPConfigurationListResultIterator) Response() LoadBalancerFrontendIPConfigurationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LoadBalancerFrontendIPConfigurationListResultIterator) Value() FrontendIPConfiguration {
	if !iter.page.NotDone() {
		return FrontendIPConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LoadBalancerFrontendIPConfigurationListResultIterator type.
func NewLoadBalancerFrontendIPConfigurationListResultIterator(page LoadBalancerFrontendIPConfigurationListResultPage) LoadBalancerFrontendIPConfigurationListResultIterator {
	return LoadBalancerFrontendIPConfigurationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lbficlr LoadBalancerFrontendIPConfigurationListResult) IsEmpty() bool {
	return lbficlr.Value == nil || len(*lbficlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lbficlr LoadBalancerFrontendIPConfigurationListResult) hasNextLink() bool {
	return lbficlr.NextLink != nil && len(*lbficlr.NextLink) != 0
}

// loadBalancerFrontendIPConfigurationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lbficlr LoadBalancerFrontendIPConfigurationListResult) loadBalancerFrontendIPConfigurationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lbficlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lbficlr.NextLink)))
}

// LoadBalancerFrontendIPConfigurationListResultPage contains a page of FrontendIPConfiguration values.
type LoadBalancerFrontendIPConfigurationListResultPage struct {
	fn      func(context.Context, LoadBalancerFrontendIPConfigurationListResult) (LoadBalancerFrontendIPConfigurationListResult, error)
	lbficlr LoadBalancerFrontendIPConfigurationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LoadBalancerFrontendIPConfigurationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerFrontendIPConfigurationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lbficlr)
		if err != nil {
			return err
		}
		page.lbficlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LoadBalancerFrontendIPConfigurationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LoadBalancerFrontendIPConfigurationListResultPage) NotDone() bool {
	return !page.lbficlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LoadBalancerFrontendIPConfigurationListResultPage) Response() LoadBalancerFrontendIPConfigurationListResult {
	return page.lbficlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LoadBalancerFrontendIPConfigurationListResultPage) Values() []FrontendIPConfiguration {
	if page.lbficlr.IsEmpty() {
		return nil
	}
	return *page.lbficlr.Value
}

// Creates a new instance of the LoadBalancerFrontendIPConfigurationListResultPage type.
func NewLoadBalancerFrontendIPConfigurationListResultPage(cur LoadBalancerFrontendIPConfigurationListResult, getNextPage func(context.Context, LoadBalancerFrontendIPConfigurationListResult) (LoadBalancerFrontendIPConfigurationListResult, error)) LoadBalancerFrontendIPConfigurationListResultPage {
	return LoadBalancerFrontendIPConfigurationListResultPage{
		fn:      getNextPage,
		lbficlr: cur,
	}
}

// LoadBalancerListResult response for ListLoadBalancers API service call.
type LoadBalancerListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of load balancers in a resource group.
	Value *[]LoadBalancer `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerListResult.
func (lblr LoadBalancerListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lblr.Value != nil {
		objectMap["value"] = lblr.Value
	}
	return json.Marshal(objectMap)
}

// LoadBalancerListResultIterator provides access to a complete listing of LoadBalancer values.
type LoadBalancerListResultIterator struct {
	i    int
	page LoadBalancerListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LoadBalancerListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LoadBalancerListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LoadBalancerListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LoadBalancerListResultIterator) Response() LoadBalancerListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LoadBalancerListResultIterator) Value() LoadBalancer {
	if !iter.page.NotDone() {
		return LoadBalancer{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LoadBalancerListResultIterator type.
func NewLoadBalancerListResultIterator(page LoadBalancerListResultPage) LoadBalancerListResultIterator {
	return LoadBalancerListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lblr LoadBalancerListResult) IsEmpty() bool {
	return lblr.Value == nil || len(*lblr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lblr LoadBalancerListResult) hasNextLink() bool {
	return lblr.NextLink != nil && len(*lblr.NextLink) != 0
}

// loadBalancerListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lblr LoadBalancerListResult) loadBalancerListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lblr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lblr.NextLink)))
}

// LoadBalancerListResultPage contains a page of LoadBalancer values.
type LoadBalancerListResultPage struct {
	fn   func(context.Context, LoadBalancerListResult) (LoadBalancerListResult, error)
	lblr LoadBalancerListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LoadBalancerListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lblr)
		if err != nil {
			return err
		}
		page.lblr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LoadBalancerListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LoadBalancerListResultPage) NotDone() bool {
	return !page.lblr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LoadBalancerListResultPage) Response() LoadBalancerListResult {
	return page.lblr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LoadBalancerListResultPage) Values() []LoadBalancer {
	if page.lblr.IsEmpty() {
		return nil
	}
	return *page.lblr.Value
}

// Creates a new instance of the LoadBalancerListResultPage type.
func NewLoadBalancerListResultPage(cur LoadBalancerListResult, getNextPage func(context.Context, LoadBalancerListResult) (LoadBalancerListResult, error)) LoadBalancerListResultPage {
	return LoadBalancerListResultPage{
		fn:   getNextPage,
		lblr: cur,
	}
}

// LoadBalancerLoadBalancingRuleListResult response for ListLoadBalancingRule API service call.
type LoadBalancerLoadBalancingRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of load balancing rules in a load balancer.
	Value *[]LoadBalancingRule `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerLoadBalancingRuleListResult.
func (lblbrlr LoadBalancerLoadBalancingRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lblbrlr.Value != nil {
		objectMap["value"] = lblbrlr.Value
	}
	return json.Marshal(objectMap)
}

// LoadBalancerLoadBalancingRuleListResultIterator provides access to a complete listing of
// LoadBalancingRule values.
type LoadBalancerLoadBalancingRuleListResultIterator struct {
	i    int
	page LoadBalancerLoadBalancingRuleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LoadBalancerLoadBalancingRuleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerLoadBalancingRuleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LoadBalancerLoadBalancingRuleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LoadBalancerLoadBalancingRuleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LoadBalancerLoadBalancingRuleListResultIterator) Response() LoadBalancerLoadBalancingRuleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LoadBalancerLoadBalancingRuleListResultIterator) Value() LoadBalancingRule {
	if !iter.page.NotDone() {
		return LoadBalancingRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LoadBalancerLoadBalancingRuleListResultIterator type.
func NewLoadBalancerLoadBalancingRuleListResultIterator(page LoadBalancerLoadBalancingRuleListResultPage) LoadBalancerLoadBalancingRuleListResultIterator {
	return LoadBalancerLoadBalancingRuleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lblbrlr LoadBalancerLoadBalancingRuleListResult) IsEmpty() bool {
	return lblbrlr.Value == nil || len(*lblbrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lblbrlr LoadBalancerLoadBalancingRuleListResult) hasNextLink() bool {
	return lblbrlr.NextLink != nil && len(*lblbrlr.NextLink) != 0
}

// loadBalancerLoadBalancingRuleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lblbrlr LoadBalancerLoadBalancingRuleListResult) loadBalancerLoadBalancingRuleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lblbrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lblbrlr.NextLink)))
}

// LoadBalancerLoadBalancingRuleListResultPage contains a page of LoadBalancingRule values.
type LoadBalancerLoadBalancingRuleListResultPage struct {
	fn      func(context.Context, LoadBalancerLoadBalancingRuleListResult) (LoadBalancerLoadBalancingRuleListResult, error)
	lblbrlr LoadBalancerLoadBalancingRuleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LoadBalancerLoadBalancingRuleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerLoadBalancingRuleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lblbrlr)
		if err != nil {
			return err
		}
		page.lblbrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LoadBalancerLoadBalancingRuleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LoadBalancerLoadBalancingRuleListResultPage) NotDone() bool {
	return !page.lblbrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LoadBalancerLoadBalancingRuleListResultPage) Response() LoadBalancerLoadBalancingRuleListResult {
	return page.lblbrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LoadBalancerLoadBalancingRuleListResultPage) Values() []LoadBalancingRule {
	if page.lblbrlr.IsEmpty() {
		return nil
	}
	return *page.lblbrlr.Value
}

// Creates a new instance of the LoadBalancerLoadBalancingRuleListResultPage type.
func NewLoadBalancerLoadBalancingRuleListResultPage(cur LoadBalancerLoadBalancingRuleListResult, getNextPage func(context.Context, LoadBalancerLoadBalancingRuleListResult) (LoadBalancerLoadBalancingRuleListResult, error)) LoadBalancerLoadBalancingRuleListResultPage {
	return LoadBalancerLoadBalancingRuleListResultPage{
		fn:      getNextPage,
		lblbrlr: cur,
	}
}

// LoadBalancerOutboundRuleListResult response for ListOutboundRule API service call.
type LoadBalancerOutboundRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of outbound rules in a load balancer.
	Value *[]OutboundRule `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerOutboundRuleListResult.
func (lborlr LoadBalancerOutboundRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lborlr.Value != nil {
		objectMap["value"] = lborlr.Value
	}
	return json.Marshal(objectMap)
}

// LoadBalancerOutboundRuleListResultIterator provides access to a complete listing of OutboundRule values.
type LoadBalancerOutboundRuleListResultIterator struct {
	i    int
	page LoadBalancerOutboundRuleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LoadBalancerOutboundRuleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerOutboundRuleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LoadBalancerOutboundRuleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LoadBalancerOutboundRuleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LoadBalancerOutboundRuleListResultIterator) Response() LoadBalancerOutboundRuleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LoadBalancerOutboundRuleListResultIterator) Value() OutboundRule {
	if !iter.page.NotDone() {
		return OutboundRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LoadBalancerOutboundRuleListResultIterator type.
func NewLoadBalancerOutboundRuleListResultIterator(page LoadBalancerOutboundRuleListResultPage) LoadBalancerOutboundRuleListResultIterator {
	return LoadBalancerOutboundRuleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lborlr LoadBalancerOutboundRuleListResult) IsEmpty() bool {
	return lborlr.Value == nil || len(*lborlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lborlr LoadBalancerOutboundRuleListResult) hasNextLink() bool {
	return lborlr.NextLink != nil && len(*lborlr.NextLink) != 0
}

// loadBalancerOutboundRuleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lborlr LoadBalancerOutboundRuleListResult) loadBalancerOutboundRuleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lborlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lborlr.NextLink)))
}

// LoadBalancerOutboundRuleListResultPage contains a page of OutboundRule values.
type LoadBalancerOutboundRuleListResultPage struct {
	fn     func(context.Context, LoadBalancerOutboundRuleListResult) (LoadBalancerOutboundRuleListResult, error)
	lborlr LoadBalancerOutboundRuleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LoadBalancerOutboundRuleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerOutboundRuleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lborlr)
		if err != nil {
			return err
		}
		page.lborlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LoadBalancerOutboundRuleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LoadBalancerOutboundRuleListResultPage) NotDone() bool {
	return !page.lborlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LoadBalancerOutboundRuleListResultPage) Response() LoadBalancerOutboundRuleListResult {
	return page.lborlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LoadBalancerOutboundRuleListResultPage) Values() []OutboundRule {
	if page.lborlr.IsEmpty() {
		return nil
	}
	return *page.lborlr.Value
}

// Creates a new instance of the LoadBalancerOutboundRuleListResultPage type.
func NewLoadBalancerOutboundRuleListResultPage(cur LoadBalancerOutboundRuleListResult, getNextPage func(context.Context, LoadBalancerOutboundRuleListResult) (LoadBalancerOutboundRuleListResult, error)) LoadBalancerOutboundRuleListResultPage {
	return LoadBalancerOutboundRuleListResultPage{
		fn:     getNextPage,
		lborlr: cur,
	}
}

// LoadBalancerProbeListResult response for ListProbe API service call.
type LoadBalancerProbeListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of probes in a load balancer.
	Value *[]Probe `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerProbeListResult.
func (lbplr LoadBalancerProbeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lbplr.Value != nil {
		objectMap["value"] = lbplr.Value
	}
	return json.Marshal(objectMap)
}

// LoadBalancerProbeListResultIterator provides access to a complete listing of Probe values.
type LoadBalancerProbeListResultIterator struct {
	i    int
	page LoadBalancerProbeListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LoadBalancerProbeListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerProbeListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LoadBalancerProbeListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LoadBalancerProbeListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LoadBalancerProbeListResultIterator) Response() LoadBalancerProbeListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LoadBalancerProbeListResultIterator) Value() Probe {
	if !iter.page.NotDone() {
		return Probe{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LoadBalancerProbeListResultIterator type.
func NewLoadBalancerProbeListResultIterator(page LoadBalancerProbeListResultPage) LoadBalancerProbeListResultIterator {
	return LoadBalancerProbeListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lbplr LoadBalancerProbeListResult) IsEmpty() bool {
	return lbplr.Value == nil || len(*lbplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lbplr LoadBalancerProbeListResult) hasNextLink() bool {
	return lbplr.NextLink != nil && len(*lbplr.NextLink) != 0
}

// loadBalancerProbeListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lbplr LoadBalancerProbeListResult) loadBalancerProbeListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lbplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lbplr.NextLink)))
}

// LoadBalancerProbeListResultPage contains a page of Probe values.
type LoadBalancerProbeListResultPage struct {
	fn    func(context.Context, LoadBalancerProbeListResult) (LoadBalancerProbeListResult, error)
	lbplr LoadBalancerProbeListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LoadBalancerProbeListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LoadBalancerProbeListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lbplr)
		if err != nil {
			return err
		}
		page.lbplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LoadBalancerProbeListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LoadBalancerProbeListResultPage) NotDone() bool {
	return !page.lbplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LoadBalancerProbeListResultPage) Response() LoadBalancerProbeListResult {
	return page.lbplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LoadBalancerProbeListResultPage) Values() []Probe {
	if page.lbplr.IsEmpty() {
		return nil
	}
	return *page.lbplr.Value
}

// Creates a new instance of the LoadBalancerProbeListResultPage type.
func NewLoadBalancerProbeListResultPage(cur LoadBalancerProbeListResult, getNextPage func(context.Context, LoadBalancerProbeListResult) (LoadBalancerProbeListResult, error)) LoadBalancerProbeListResultPage {
	return LoadBalancerProbeListResultPage{
		fn:    getNextPage,
		lbplr: cur,
	}
}

// LoadBalancerPropertiesFormat properties of the load balancer.
type LoadBalancerPropertiesFormat struct {
	// FrontendIPConfigurations - Object representing the frontend IPs to be used for the load balancer.
	FrontendIPConfigurations *[]FrontendIPConfiguration `json:"frontendIPConfigurations,omitempty"`
	// BackendAddressPools - Collection of backend address pools used by a load balancer.
	BackendAddressPools *[]BackendAddressPool `json:"backendAddressPools,omitempty"`
	// LoadBalancingRules - Object collection representing the load balancing rules Gets the provisioning.
	LoadBalancingRules *[]LoadBalancingRule `json:"loadBalancingRules,omitempty"`
	// Probes - Collection of probe objects used in the load balancer.
	Probes *[]Probe `json:"probes,omitempty"`
	// InboundNatRules - Collection of inbound NAT Rules used by a load balancer. Defining inbound NAT rules on your load balancer is mutually exclusive with defining an inbound NAT pool. Inbound NAT pools are referenced from virtual machine scale sets. NICs that are associated with individual virtual machines cannot reference an Inbound NAT pool. They have to reference individual inbound NAT rules.
	InboundNatRules *[]InboundNatRule `json:"inboundNatRules,omitempty"`
	// InboundNatPools - Defines an external port range for inbound NAT to a single backend port on NICs associated with a load balancer. Inbound NAT rules are created automatically for each NIC associated with the Load Balancer using an external port from this range. Defining an Inbound NAT pool on your Load Balancer is mutually exclusive with defining inbound Nat rules. Inbound NAT pools are referenced from virtual machine scale sets. NICs that are associated with individual virtual machines cannot reference an inbound NAT pool. They have to reference individual inbound NAT rules.
	InboundNatPools *[]InboundNatPool `json:"inboundNatPools,omitempty"`
	// OutboundRules - The outbound rules.
	OutboundRules *[]OutboundRule `json:"outboundRules,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the load balancer resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the load balancer resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancerPropertiesFormat.
func (lbpf LoadBalancerPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lbpf.FrontendIPConfigurations != nil {
		objectMap["frontendIPConfigurations"] = lbpf.FrontendIPConfigurations
	}
	if lbpf.BackendAddressPools != nil {
		objectMap["backendAddressPools"] = lbpf.BackendAddressPools
	}
	if lbpf.LoadBalancingRules != nil {
		objectMap["loadBalancingRules"] = lbpf.LoadBalancingRules
	}
	if lbpf.Probes != nil {
		objectMap["probes"] = lbpf.Probes
	}
	if lbpf.InboundNatRules != nil {
		objectMap["inboundNatRules"] = lbpf.InboundNatRules
	}
	if lbpf.InboundNatPools != nil {
		objectMap["inboundNatPools"] = lbpf.InboundNatPools
	}
	if lbpf.OutboundRules != nil {
		objectMap["outboundRules"] = lbpf.OutboundRules
	}
	return json.Marshal(objectMap)
}

// LoadBalancersCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LoadBalancersCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(LoadBalancersClient) (LoadBalancer, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *LoadBalancersCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for LoadBalancersCreateOrUpdateFuture.Result.
func (future *LoadBalancersCreateOrUpdateFuture) result(client LoadBalancersClient) (lb LoadBalancer, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.LoadBalancersCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lb.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.LoadBalancersCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lb.Response.Response, err = future.GetResult(sender); err == nil && lb.Response.Response.StatusCode != http.StatusNoContent {
		lb, err = client.CreateOrUpdateResponder(lb.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.LoadBalancersCreateOrUpdateFuture", "Result", lb.Response.Response, "Failure responding to request")
		}
	}
	return
}

// LoadBalancersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LoadBalancersDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(LoadBalancersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *LoadBalancersDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for LoadBalancersDeleteFuture.Result.
func (future *LoadBalancersDeleteFuture) result(client LoadBalancersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.LoadBalancersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.LoadBalancersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// LoadBalancerSku SKU of a load balancer.
type LoadBalancerSku struct {
	// Name - Name of a load balancer SKU. Possible values include: 'LoadBalancerSkuNameBasic', 'LoadBalancerSkuNameStandard'
	Name LoadBalancerSkuName `json:"name,omitempty"`
	// Tier - Tier of a load balancer SKU. Possible values include: 'LoadBalancerSkuTierRegional', 'LoadBalancerSkuTierGlobal'
	Tier LoadBalancerSkuTier `json:"tier,omitempty"`
}

// LoadBalancingRule a load balancing rule for a load balancer.
type LoadBalancingRule struct {
	autorest.Response `json:"-"`
	// LoadBalancingRulePropertiesFormat - Properties of load balancer load balancing rule.
	*LoadBalancingRulePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the set of load balancing rules used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancingRule.
func (lbr LoadBalancingRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lbr.LoadBalancingRulePropertiesFormat != nil {
		objectMap["properties"] = lbr.LoadBalancingRulePropertiesFormat
	}
	if lbr.Name != nil {
		objectMap["name"] = lbr.Name
	}
	if lbr.ID != nil {
		objectMap["id"] = lbr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LoadBalancingRule struct.
func (lbr *LoadBalancingRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var loadBalancingRulePropertiesFormat LoadBalancingRulePropertiesFormat
				err = json.Unmarshal(*v, &loadBalancingRulePropertiesFormat)
				if err != nil {
					return err
				}
				lbr.LoadBalancingRulePropertiesFormat = &loadBalancingRulePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lbr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				lbr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lbr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				lbr.ID = &ID
			}
		}
	}

	return nil
}

// LoadBalancingRulePropertiesFormat properties of the load balancer.
type LoadBalancingRulePropertiesFormat struct {
	// FrontendIPConfiguration - A reference to frontend IP addresses.
	FrontendIPConfiguration *SubResource `json:"frontendIPConfiguration,omitempty"`
	// BackendAddressPool - A reference to a pool of DIPs. Inbound traffic is randomly load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`
	// Probe - The reference to the load balancer probe used by the load balancing rule.
	Probe *SubResource `json:"probe,omitempty"`
	// Protocol - The reference to the transport protocol used by the load balancing rule. Possible values include: 'TransportProtocolUDP', 'TransportProtocolTCP', 'TransportProtocolAll'
	Protocol TransportProtocol `json:"protocol,omitempty"`
	// LoadDistribution - The load distribution policy for this rule. Possible values include: 'LoadDistributionDefault', 'LoadDistributionSourceIP', 'LoadDistributionSourceIPProtocol'
	LoadDistribution LoadDistribution `json:"loadDistribution,omitempty"`
	// FrontendPort - The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values are between 0 and 65534. Note that value 0 enables "Any Port".
	FrontendPort *int32 `json:"frontendPort,omitempty"`
	// BackendPort - The port used for internal connections on the endpoint. Acceptable values are between 0 and 65535. Note that value 0 enables "Any Port".
	BackendPort *int32 `json:"backendPort,omitempty"`
	// IdleTimeoutInMinutes - The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
	IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
	// EnableFloatingIP - Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
	EnableFloatingIP *bool `json:"enableFloatingIP,omitempty"`
	// EnableTCPReset - Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
	EnableTCPReset *bool `json:"enableTcpReset,omitempty"`
	// DisableOutboundSnat - Configures SNAT for the VMs in the backend pool to use the publicIP address specified in the frontend of the load balancing rule.
	DisableOutboundSnat *bool `json:"disableOutboundSnat,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the load balancing rule resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for LoadBalancingRulePropertiesFormat.
func (lbrpf LoadBalancingRulePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lbrpf.FrontendIPConfiguration != nil {
		objectMap["frontendIPConfiguration"] = lbrpf.FrontendIPConfiguration
	}
	if lbrpf.BackendAddressPool != nil {
		objectMap["backendAddressPool"] = lbrpf.BackendAddressPool
	}
	if lbrpf.Probe != nil {
		objectMap["probe"] = lbrpf.Probe
	}
	if lbrpf.Protocol != "" {
		objectMap["protocol"] = lbrpf.Protocol
	}
	if lbrpf.LoadDistribution != "" {
		objectMap["loadDistribution"] = lbrpf.LoadDistribution
	}
	if lbrpf.FrontendPort != nil {
		objectMap["frontendPort"] = lbrpf.FrontendPort
	}
	if lbrpf.BackendPort != nil {
		objectMap["backendPort"] = lbrpf.BackendPort
	}
	if lbrpf.IdleTimeoutInMinutes != nil {
		objectMap["idleTimeoutInMinutes"] = lbrpf.IdleTimeoutInMinutes
	}
	if lbrpf.EnableFloatingIP != nil {
		objectMap["enableFloatingIP"] = lbrpf.EnableFloatingIP
	}
	if lbrpf.EnableTCPReset != nil {
		objectMap["enableTcpReset"] = lbrpf.EnableTCPReset
	}
	if lbrpf.DisableOutboundSnat != nil {
		objectMap["disableOutboundSnat"] = lbrpf.DisableOutboundSnat
	}
	return json.Marshal(objectMap)
}

// LocalNetworkGateway a common class for general resource information.
type LocalNetworkGateway struct {
	autorest.Response `json:"-"`
	// LocalNetworkGatewayPropertiesFormat - Properties of the local network gateway.
	*LocalNetworkGatewayPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for LocalNetworkGateway.
func (lng LocalNetworkGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lng.LocalNetworkGatewayPropertiesFormat != nil {
		objectMap["properties"] = lng.LocalNetworkGatewayPropertiesFormat
	}
	if lng.ID != nil {
		objectMap["id"] = lng.ID
	}
	if lng.Location != nil {
		objectMap["location"] = lng.Location
	}
	if lng.Tags != nil {
		objectMap["tags"] = lng.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LocalNetworkGateway struct.
func (lng *LocalNetworkGateway) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var localNetworkGatewayPropertiesFormat LocalNetworkGatewayPropertiesFormat
				err = json.Unmarshal(*v, &localNetworkGatewayPropertiesFormat)
				if err != nil {
					return err
				}
				lng.LocalNetworkGatewayPropertiesFormat = &localNetworkGatewayPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				lng.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				lng.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lng.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lng.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				lng.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				lng.Tags = tags
			}
		}
	}

	return nil
}

// LocalNetworkGatewayListResult response for ListLocalNetworkGateways API service call.
type LocalNetworkGatewayListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of local network gateways that exists in a resource group.
	Value *[]LocalNetworkGateway `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for LocalNetworkGatewayListResult.
func (lnglr LocalNetworkGatewayListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lnglr.Value != nil {
		objectMap["value"] = lnglr.Value
	}
	return json.Marshal(objectMap)
}

// LocalNetworkGatewayListResultIterator provides access to a complete listing of LocalNetworkGateway
// values.
type LocalNetworkGatewayListResultIterator struct {
	i    int
	page LocalNetworkGatewayListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LocalNetworkGatewayListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LocalNetworkGatewayListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LocalNetworkGatewayListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LocalNetworkGatewayListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LocalNetworkGatewayListResultIterator) Response() LocalNetworkGatewayListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LocalNetworkGatewayListResultIterator) Value() LocalNetworkGateway {
	if !iter.page.NotDone() {
		return LocalNetworkGateway{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LocalNetworkGatewayListResultIterator type.
func NewLocalNetworkGatewayListResultIterator(page LocalNetworkGatewayListResultPage) LocalNetworkGatewayListResultIterator {
	return LocalNetworkGatewayListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lnglr LocalNetworkGatewayListResult) IsEmpty() bool {
	return lnglr.Value == nil || len(*lnglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lnglr LocalNetworkGatewayListResult) hasNextLink() bool {
	return lnglr.NextLink != nil && len(*lnglr.NextLink) != 0
}

// localNetworkGatewayListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lnglr LocalNetworkGatewayListResult) localNetworkGatewayListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lnglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lnglr.NextLink)))
}

// LocalNetworkGatewayListResultPage contains a page of LocalNetworkGateway values.
type LocalNetworkGatewayListResultPage struct {
	fn    func(context.Context, LocalNetworkGatewayListResult) (LocalNetworkGatewayListResult, error)
	lnglr LocalNetworkGatewayListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LocalNetworkGatewayListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LocalNetworkGatewayListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lnglr)
		if err != nil {
			return err
		}
		page.lnglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LocalNetworkGatewayListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LocalNetworkGatewayListResultPage) NotDone() bool {
	return !page.lnglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LocalNetworkGatewayListResultPage) Response() LocalNetworkGatewayListResult {
	return page.lnglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LocalNetworkGatewayListResultPage) Values() []LocalNetworkGateway {
	if page.lnglr.IsEmpty() {
		return nil
	}
	return *page.lnglr.Value
}

// Creates a new instance of the LocalNetworkGatewayListResultPage type.
func NewLocalNetworkGatewayListResultPage(cur LocalNetworkGatewayListResult, getNextPage func(context.Context, LocalNetworkGatewayListResult) (LocalNetworkGatewayListResult, error)) LocalNetworkGatewayListResultPage {
	return LocalNetworkGatewayListResultPage{
		fn:    getNextPage,
		lnglr: cur,
	}
}

// LocalNetworkGatewayPropertiesFormat localNetworkGateway properties.
type LocalNetworkGatewayPropertiesFormat struct {
	// LocalNetworkAddressSpace - Local network site address space.
	LocalNetworkAddressSpace *AddressSpace `json:"localNetworkAddressSpace,omitempty"`
	// GatewayIPAddress - IP address of local network gateway.
	GatewayIPAddress *string `json:"gatewayIpAddress,omitempty"`
	// Fqdn - FQDN of local network gateway.
	Fqdn *string `json:"fqdn,omitempty"`
	// BgpSettings - Local network gateway's BGP speaker settings.
	BgpSettings *BgpSettings `json:"bgpSettings,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the local network gateway resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the local network gateway resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for LocalNetworkGatewayPropertiesFormat.
func (lngpf LocalNetworkGatewayPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lngpf.LocalNetworkAddressSpace != nil {
		objectMap["localNetworkAddressSpace"] = lngpf.LocalNetworkAddressSpace
	}
	if lngpf.GatewayIPAddress != nil {
		objectMap["gatewayIpAddress"] = lngpf.GatewayIPAddress
	}
	if lngpf.Fqdn != nil {
		objectMap["fqdn"] = lngpf.Fqdn
	}
	if lngpf.BgpSettings != nil {
		objectMap["bgpSettings"] = lngpf.BgpSettings
	}
	return json.Marshal(objectMap)
}

// LocalNetworkGatewaysCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LocalNetworkGatewaysCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(LocalNetworkGatewaysClient) (LocalNetworkGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *LocalNetworkGatewaysCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for LocalNetworkGatewaysCreateOrUpdateFuture.Result.
func (future *LocalNetworkGatewaysCreateOrUpdateFuture) result(client LocalNetworkGatewaysClient) (lng LocalNetworkGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.LocalNetworkGatewaysCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lng.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.LocalNetworkGatewaysCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lng.Response.Response, err = future.GetResult(sender); err == nil && lng.Response.Response.StatusCode != http.StatusNoContent {
		lng, err = client.CreateOrUpdateResponder(lng.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.LocalNetworkGatewaysCreateOrUpdateFuture", "Result", lng.Response.Response, "Failure responding to request")
		}
	}
	return
}

// LocalNetworkGatewaysDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LocalNetworkGatewaysDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(LocalNetworkGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *LocalNetworkGatewaysDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for LocalNetworkGatewaysDeleteFuture.Result.
func (future *LocalNetworkGatewaysDeleteFuture) result(client LocalNetworkGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.LocalNetworkGatewaysDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.LocalNetworkGatewaysDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// LogSpecification description of logging specification.
type LogSpecification struct {
	// Name - The name of the specification.
	Name *string `json:"name,omitempty"`
	// DisplayName - The display name of the specification.
	DisplayName *string `json:"displayName,omitempty"`
	// BlobDuration - Duration of the blob.
	BlobDuration *string `json:"blobDuration,omitempty"`
}

// ManagedRuleGroupOverride defines a managed rule group override setting.
type ManagedRuleGroupOverride struct {
	// RuleGroupName - The managed rule group to override.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`
	// Rules - List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules *[]ManagedRuleOverride `json:"rules,omitempty"`
}

// ManagedRuleOverride defines a managed rule group override setting.
type ManagedRuleOverride struct {
	// RuleID - Identifier for the managed rule.
	RuleID *string `json:"ruleId,omitempty"`
	// State - The state of the managed rule. Defaults to Disabled if not specified. Possible values include: 'ManagedRuleEnabledStateDisabled'
	State ManagedRuleEnabledState `json:"state,omitempty"`
}

// ManagedRulesDefinition allow to exclude some variable satisfy the condition for the WAF check.
type ManagedRulesDefinition struct {
	// Exclusions - The Exclusions that are applied on the policy.
	Exclusions *[]OwaspCrsExclusionEntry `json:"exclusions,omitempty"`
	// ManagedRuleSets - The managed rule sets that are associated with the policy.
	ManagedRuleSets *[]ManagedRuleSet `json:"managedRuleSets,omitempty"`
}

// ManagedRuleSet defines a managed rule set.
type ManagedRuleSet struct {
	// RuleSetType - Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`
	// RuleSetVersion - Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
	// RuleGroupOverrides - Defines the rule group overrides to apply to the rule set.
	RuleGroupOverrides *[]ManagedRuleGroupOverride `json:"ruleGroupOverrides,omitempty"`
}

// ManagedServiceIdentity identity for the resource.
type ManagedServiceIdentity struct {
	// PrincipalID - READ-ONLY; The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine. Possible values include: 'ResourceIdentityTypeSystemAssigned', 'ResourceIdentityTypeUserAssigned', 'ResourceIdentityTypeSystemAssignedUserAssigned', 'ResourceIdentityTypeNone'
	Type ResourceIdentityType `json:"type,omitempty"`
	// UserAssignedIdentities - The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]*ManagedServiceIdentityUserAssignedIdentitiesValue `json:"userAssignedIdentities"`
}

// MarshalJSON is the custom marshaler for ManagedServiceIdentity.
func (msi ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if msi.Type != "" {
		objectMap["type"] = msi.Type
	}
	if msi.UserAssignedIdentities != nil {
		objectMap["userAssignedIdentities"] = msi.UserAssignedIdentities
	}
	return json.Marshal(objectMap)
}

// ManagedServiceIdentityUserAssignedIdentitiesValue ...
type ManagedServiceIdentityUserAssignedIdentitiesValue struct {
	// PrincipalID - READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// ClientID - READ-ONLY; The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagedServiceIdentityUserAssignedIdentitiesValue.
func (msiAiv ManagedServiceIdentityUserAssignedIdentitiesValue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// MatchCondition define match conditions.
type MatchCondition struct {
	// MatchVariables - List of match variables.
	MatchVariables *[]MatchVariable `json:"matchVariables,omitempty"`
	// Operator - The operator to be matched. Possible values include: 'WebApplicationFirewallOperatorIPMatch', 'WebApplicationFirewallOperatorEqual', 'WebApplicationFirewallOperatorContains', 'WebApplicationFirewallOperatorLessThan', 'WebApplicationFirewallOperatorGreaterThan', 'WebApplicationFirewallOperatorLessThanOrEqual', 'WebApplicationFirewallOperatorGreaterThanOrEqual', 'WebApplicationFirewallOperatorBeginsWith', 'WebApplicationFirewallOperatorEndsWith', 'WebApplicationFirewallOperatorRegex', 'WebApplicationFirewallOperatorGeoMatch'
	Operator WebApplicationFirewallOperator `json:"operator,omitempty"`
	// NegationConditon - Whether this is negate condition or not.
	NegationConditon *bool `json:"negationConditon,omitempty"`
	// MatchValues - Match value.
	MatchValues *[]string `json:"matchValues,omitempty"`
	// Transforms - List of transforms.
	Transforms *[]WebApplicationFirewallTransform `json:"transforms,omitempty"`
}

// MatchedRule matched rule.
type MatchedRule struct {
	// RuleName - Name of the matched network security rule.
	RuleName *string `json:"ruleName,omitempty"`
	// Action - The network traffic is allowed or denied. Possible values are 'Allow' and 'Deny'.
	Action *string `json:"action,omitempty"`
}

// MatchVariable define match variables.
type MatchVariable struct {
	// VariableName - Match Variable. Possible values include: 'WebApplicationFirewallMatchVariableRemoteAddr', 'WebApplicationFirewallMatchVariableRequestMethod', 'WebApplicationFirewallMatchVariableQueryString', 'WebApplicationFirewallMatchVariablePostArgs', 'WebApplicationFirewallMatchVariableRequestURI', 'WebApplicationFirewallMatchVariableRequestHeaders', 'WebApplicationFirewallMatchVariableRequestBody', 'WebApplicationFirewallMatchVariableRequestCookies'
	VariableName WebApplicationFirewallMatchVariable `json:"variableName,omitempty"`
	// Selector - The selector of match variable.
	Selector *string `json:"selector,omitempty"`
}

// MetricSpecification description of metrics specification.
type MetricSpecification struct {
	// Name - The name of the metric.
	Name *string `json:"name,omitempty"`
	// DisplayName - The display name of the metric.
	DisplayName *string `json:"displayName,omitempty"`
	// DisplayDescription - The description of the metric.
	DisplayDescription *string `json:"displayDescription,omitempty"`
	// Unit - Units the metric to be displayed in.
	Unit *string `json:"unit,omitempty"`
	// AggregationType - The aggregation type.
	AggregationType *string `json:"aggregationType,omitempty"`
	// Availabilities - List of availability.
	Availabilities *[]Availability `json:"availabilities,omitempty"`
	// EnableRegionalMdmAccount - Whether regional MDM account enabled.
	EnableRegionalMdmAccount *bool `json:"enableRegionalMdmAccount,omitempty"`
	// FillGapWithZero - Whether gaps would be filled with zeros.
	FillGapWithZero *bool `json:"fillGapWithZero,omitempty"`
	// MetricFilterPattern - Pattern for the filter of the metric.
	MetricFilterPattern *string `json:"metricFilterPattern,omitempty"`
	// Dimensions - List of dimensions.
	Dimensions *[]Dimension `json:"dimensions,omitempty"`
	// IsInternal - Whether the metric is internal.
	IsInternal *bool `json:"isInternal,omitempty"`
	// SourceMdmAccount - The source MDM account.
	SourceMdmAccount *string `json:"sourceMdmAccount,omitempty"`
	// SourceMdmNamespace - The source MDM namespace.
	SourceMdmNamespace *string `json:"sourceMdmNamespace,omitempty"`
	// ResourceIDDimensionNameOverride - The resource Id dimension name override.
	ResourceIDDimensionNameOverride *string `json:"resourceIdDimensionNameOverride,omitempty"`
}

// NatGateway nat Gateway resource.
type NatGateway struct {
	autorest.Response `json:"-"`
	// Sku - The nat gateway SKU.
	Sku *NatGatewaySku `json:"sku,omitempty"`
	// NatGatewayPropertiesFormat - Nat Gateway properties.
	*NatGatewayPropertiesFormat `json:"properties,omitempty"`
	// Zones - A list of availability zones denoting the zone in which Nat Gateway should be deployed.
	Zones *[]string `json:"zones,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for NatGateway.
func (ng NatGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ng.Sku != nil {
		objectMap["sku"] = ng.Sku
	}
	if ng.NatGatewayPropertiesFormat != nil {
		objectMap["properties"] = ng.NatGatewayPropertiesFormat
	}
	if ng.Zones != nil {
		objectMap["zones"] = ng.Zones
	}
	if ng.ID != nil {
		objectMap["id"] = ng.ID
	}
	if ng.Location != nil {
		objectMap["location"] = ng.Location
	}
	if ng.Tags != nil {
		objectMap["tags"] = ng.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for NatGateway struct.
func (ng *NatGateway) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "sku":
			if v != nil {
				var sku NatGatewaySku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				ng.Sku = &sku
			}
		case "properties":
			if v != nil {
				var natGatewayPropertiesFormat NatGatewayPropertiesFormat
				err = json.Unmarshal(*v, &natGatewayPropertiesFormat)
				if err != nil {
					return err
				}
				ng.NatGatewayPropertiesFormat = &natGatewayPropertiesFormat
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				ng.Zones = &zones
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ng.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ng.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ng.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ng.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ng.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ng.Tags = tags
			}
		}
	}

	return nil
}

// NatGatewayListResult response for ListNatGateways API service call.
type NatGatewayListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of Nat Gateways that exists in a resource group.
	Value *[]NatGateway `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// NatGatewayListResultIterator provides access to a complete listing of NatGateway values.
type NatGatewayListResultIterator struct {
	i    int
	page NatGatewayListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *NatGatewayListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/NatGatewayListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *NatGatewayListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter NatGatewayListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter NatGatewayListResultIterator) Response() NatGatewayListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter NatGatewayListResultIterator) Value() NatGateway {
	if !iter.page.NotDone() {
		return NatGateway{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the NatGatewayListResultIterator type.
func NewNatGatewayListResultIterator(page NatGatewayListResultPage) NatGatewayListResultIterator {
	return NatGatewayListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (nglr NatGatewayListResult) IsEmpty() bool {
	return nglr.Value == nil || len(*nglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (nglr NatGatewayListResult) hasNextLink() bool {
	return nglr.NextLink != nil && len(*nglr.NextLink) != 0
}

// natGatewayListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (nglr NatGatewayListResult) natGatewayListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !nglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(nglr.NextLink)))
}

// NatGatewayListResultPage contains a page of NatGateway values.
type NatGatewayListResultPage struct {
	fn   func(context.Context, NatGatewayListResult) (NatGatewayListResult, error)
	nglr NatGatewayListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *NatGatewayListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/NatGatewayListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.nglr)
		if err != nil {
			return err
		}
		page.nglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *NatGatewayListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page NatGatewayListResultPage) NotDone() bool {
	return !page.nglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page NatGatewayListResultPage) Response() NatGatewayListResult {
	return page.nglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page NatGatewayListResultPage) Values() []NatGateway {
	if page.nglr.IsEmpty() {
		return nil
	}
	return *page.nglr.Value
}

// Creates a new instance of the NatGatewayListResultPage type.
func NewNatGatewayListResultPage(cur NatGatewayListResult, getNextPage func(context.Context, NatGatewayListResult) (NatGatewayListResult, error)) NatGatewayListResultPage {
	return NatGatewayListResultPage{
		fn:   getNextPage,
		nglr: cur,
	}
}

// NatGatewayPropertiesFormat nat Gateway properties.
type NatGatewayPropertiesFormat struct {
	// IdleTimeoutInMinutes - The idle timeout of the nat gateway.
	IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
	// PublicIPAddresses - An array of public ip addresses associated with the nat gateway resource.
	PublicIPAddresses *[]SubResource `json:"publicIpAddresses,omitempty"`
	// PublicIPPrefixes - An array of public ip prefixes associated with the nat gateway resource.
	PublicIPPrefixes *[]SubResource `json:"publicIpPrefixes,omitempty"`
	// Subnets - READ-ONLY; An array of references to the subnets using this nat gateway resource.
	Subnets *[]SubResource `json:"subnets,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the NAT gateway resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the NAT gateway resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for NatGatewayPropertiesFormat.
func (ngpf NatGatewayPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ngpf.IdleTimeoutInMinutes != nil {
		objectMap["idleTimeoutInMinutes"] = ngpf.IdleTimeoutInMinutes
	}
	if ngpf.PublicIPAddresses != nil {
		objectMap["publicIpAddresses"] = ngpf.PublicIPAddresses
	}
	if ngpf.PublicIPPrefixes != nil {
		objectMap["publicIpPrefixes"] = ngpf.PublicIPPrefixes
	}
	return json.Marshal(objectMap)
}

// NatGatewaysCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type NatGatewaysCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(NatGatewaysClient) (NatGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *NatGatewaysCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for NatGatewaysCreateOrUpdateFuture.Result.
func (future *NatGatewaysCreateOrUpdateFuture) result(client NatGatewaysClient) (ng NatGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.NatGatewaysCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ng.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.NatGatewaysCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ng.Response.Response, err = future.GetResult(sender); err == nil && ng.Response.Response.StatusCode != http.StatusNoContent {
		ng, err = client.CreateOrUpdateResponder(ng.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.NatGatewaysCreateOrUpdateFuture", "Result", ng.Response.Response, "Failure responding to request")
		}
	}
	return
}

// NatGatewaysDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type NatGatewaysDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(NatGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *NatGatewaysDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for NatGatewaysDeleteFuture.Result.
func (future *NatGatewaysDeleteFuture) result(client NatGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.NatGatewaysDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.NatGatewaysDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// NatGatewaySku SKU of nat gateway.
type NatGatewaySku struct {
	// Name - Name of Nat Gateway SKU. Possible values include: 'NatGatewaySkuNameStandard'
	Name NatGatewaySkuName `json:"name,omitempty"`
}

// NatRule rule of type nat.
type NatRule struct {
	// IPProtocols - Array of FirewallPolicyRuleNetworkProtocols.
	IPProtocols *[]FirewallPolicyRuleNetworkProtocol `json:"ipProtocols,omitempty"`
	// SourceAddresses - List of source IP addresses for this rule.
	SourceAddresses *[]string `json:"sourceAddresses,omitempty"`
	// DestinationAddresses - List of destination IP addresses or Service Tags.
	DestinationAddresses *[]string `json:"destinationAddresses,omitempty"`
	// DestinationPorts - List of destination ports.
	DestinationPorts *[]string `json:"destinationPorts,omitempty"`
	// TranslatedAddress - The translated address for this NAT rule.
	TranslatedAddress *string `json:"translatedAddress,omitempty"`
	// TranslatedPort - The translated port for this NAT rule.
	TranslatedPort *string `json:"translatedPort,omitempty"`
	// SourceIPGroups - List of source IpGroups for this rule.
	SourceIPGroups *[]string `json:"sourceIpGroups,omitempty"`
	// TranslatedFqdn - The translated FQDN for this NAT rule.
	TranslatedFqdn *string `json:"translatedFqdn,omitempty"`
	// Name - Name of the rule.
	Name *string `json:"name,omitempty"`
	// Description - Description of the rule.
	Description *string `json:"description,omitempty"`
	// RuleType - Possible values include: 'RuleTypeFirewallPolicyRule', 'RuleTypeApplicationRule', 'RuleTypeNatRule', 'RuleTypeNetworkRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

// MarshalJSON is the custom marshaler for NatRule.
func (nr NatRule) MarshalJSON() ([]byte, error) {
	nr.RuleType = RuleTypeNatRule
	objectMap := make(map[string]interface{})
	if nr.IPProtocols != nil {
		objectMap["ipProtocols"] = nr.IPProtocols
	}
	if nr.SourceAddresses != nil {
		objectMap["sourceAddresses"] = nr.SourceAddresses
	}
	if nr.DestinationAddresses != nil {
		objectMap["destinationAddresses"] = nr.DestinationAddresses
	}
	if nr.DestinationPorts != nil {
		objectMap["destinationPorts"] = nr.DestinationPorts
	}
	if nr.TranslatedAddress != nil {
		objectMap["translatedAddress"] = nr.TranslatedAddress
	}
	if nr.TranslatedPort != nil {
		objectMap["translatedPort"] = nr.TranslatedPort
	}
	if nr.SourceIPGroups != nil {
		objectMap["sourceIpGroups"] = nr.SourceIPGroups
	}
	if nr.TranslatedFqdn != nil {
		objectMap["translatedFqdn"] = nr.TranslatedFqdn
	}
	if nr.Name != nil {
		objectMap["name"] = nr.Name
	}
	if nr.Description != nil {
		objectMap["description"] = nr.Description
	}
	if nr.RuleType != "" {
		objectMap["ruleType"] = nr.RuleType
	}
	return json.Marshal(objectMap)
}

// AsApplicationRule is the BasicFirewallPolicyRule implementation for NatRule.
func (nr NatRule) AsApplicationRule() (*ApplicationRule, bool) {
	return nil, false
}

// AsNatRule is the BasicFirewallPolicyRule implementation for NatRule.
func (nr NatRule) AsNatRule() (*NatRule, bool) {
	return &nr, true
}

// AsRule is the BasicFirewallPolicyRule implementation for NatRule.
func (nr NatRule) AsRule() (*Rule, bool) {
	return nil, false
}

// AsFirewallPolicyRule is the BasicFirewallPolicyRule implementation for NatRule.
func (nr NatRule) AsFirewallPolicyRule() (*FirewallPolicyRule, bool) {
	return nil, false
}

// AsBasicFirewallPolicyRule is the BasicFirewallPolicyRule implementation for NatRule.
func (nr NatRule) AsBasicFirewallPolicyRule() (BasicFirewallPolicyRule, bool) {
	return &nr, true
}

// NatRulesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type NatRulesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(NatRulesClient) (VpnGatewayNatRule, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *NatRulesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for NatRulesCreateOrUpdateFuture.Result.
func (future *NatRulesCreateOrUpdateFuture) result(client NatRulesClient) (vgnr VpnGatewayNatRule, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.NatRulesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vgnr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.NatRulesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vgnr.Response.Response, err = future.GetResult(sender); err == nil && vgnr.Response.Response.StatusCode != http.StatusNoContent {
		vgnr, err = client.CreateOrUpdateResponder(vgnr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.NatRulesCreateOrUpdateFuture", "Result", vgnr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// NatRulesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type NatRulesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(NatRulesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *NatRulesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for NatRulesDeleteFuture.Result.
func (future *NatRulesDeleteFuture) result(client NatRulesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.NatRulesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.NatRulesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// NextHopParameters parameters that define the source and destination endpoint.
type NextHopParameters struct {
	// TargetResourceID - The resource identifier of the target resource against which the action is to be performed.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
	// SourceIPAddress - The source IP address.
	SourceIPAddress *string `json:"sourceIPAddress,omitempty"`
	// DestinationIPAddress - The destination IP address.
	DestinationIPAddress *string `json:"destinationIPAddress,omitempty"`
	// TargetNicResourceID - The NIC ID. (If VM has multiple NICs and IP forwarding is enabled on any of the nics, then this parameter must be specified. Otherwise optional).
	TargetNicResourceID *string `json:"targetNicResourceId,omitempty"`
}

// NextHopResult the information about next hop from the specified VM.
type NextHopResult struct {
	autorest.Response `json:"-"`
	// NextHopType - Next hop type. Possible values include: 'NextHopTypeInternet', 'NextHopTypeVirtualAppliance', 'NextHopTypeVirtualNetworkGateway', 'NextHopTypeVnetLocal', 'NextHopTypeHyperNetGateway', 'NextHopTypeNone'
	NextHopType NextHopType `json:"nextHopType,omitempty"`
	// NextHopIPAddress - Next hop IP Address.
	NextHopIPAddress *string `json:"nextHopIpAddress,omitempty"`
	// RouteTableID - The resource identifier for the route table associated with the route being returned. If the route being returned does not correspond to any user created routes then this field will be the string 'System Route'.
	RouteTableID *string `json:"routeTableId,omitempty"`
}

// O365BreakOutCategoryPolicies office365 breakout categories.
type O365BreakOutCategoryPolicies struct {
	// Allow - Flag to control allow category.
	Allow *bool `json:"allow,omitempty"`
	// Optimize - Flag to control optimize category.
	Optimize *bool `json:"optimize,omitempty"`
	// Default - Flag to control default category.
	Default *bool `json:"default,omitempty"`
}

// O365PolicyProperties the Office365 breakout policy.
type O365PolicyProperties struct {
	// BreakOutCategories - Office365 breakout categories.
	BreakOutCategories *O365BreakOutCategoryPolicies `json:"breakOutCategories,omitempty"`
}

// Office365PolicyProperties network Virtual Appliance Sku Properties.
type Office365PolicyProperties struct {
	// BreakOutCategories - Office 365 breakout categories.
	BreakOutCategories *BreakOutCategoryPolicies `json:"breakOutCategories,omitempty"`
}

// Operation network REST API operation definition.
type Operation struct {
	// Name - Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty"`
	// Display - Display metadata associated with the operation.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - Origin of the operation.
	Origin *string `json:"origin,omitempty"`
	// OperationPropertiesFormat - Operation properties format.
	*OperationPropertiesFormat `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Name != nil {
		objectMap["name"] = o.Name
	}
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	if o.Origin != nil {
		objectMap["origin"] = o.Origin
	}
	if o.OperationPropertiesFormat != nil {
		objectMap["properties"] = o.OperationPropertiesFormat
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Operation struct.
func (o *Operation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				o.Name = &name
			}
		case "display":
			if v != nil {
				var display OperationDisplay
				err = json.Unmarshal(*v, &display)
				if err != nil {
					return err
				}
				o.Display = &display
			}
		case "origin":
			if v != nil {
				var origin string
				err = json.Unmarshal(*v, &origin)
				if err != nil {
					return err
				}
				o.Origin = &origin
			}
		case "properties":
			if v != nil {
				var operationPropertiesFormat OperationPropertiesFormat
				err = json.Unmarshal(*v, &operationPropertiesFormat)
				if err != nil {
					return err
				}
				o.OperationPropertiesFormat = &operationPropertiesFormat
			}
		}
	}

	return nil
}

// OperationDisplay display metadata associated with the operation.
type OperationDisplay struct {
	// Provider - Service provider: Microsoft Network.
	Provider *string `json:"provider,omitempty"`
	// Resource - Resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Operation - Type of the operation: get, read, delete, etc.
	Operation *string `json:"operation,omitempty"`
	// Description - Description of the operation.
	Description *string `json:"description,omitempty"`
}

// OperationListResult result of the request to list Network operations. It contains a list of operations
// and a URL link to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Network operations supported by the Network resource provider.
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// OperationPropertiesFormat description of operation properties format.
type OperationPropertiesFormat struct {
	// ServiceSpecification - Specification of the service.
	ServiceSpecification *OperationPropertiesFormatServiceSpecification `json:"serviceSpecification,omitempty"`
}

// OperationPropertiesFormatServiceSpecification specification of the service.
type OperationPropertiesFormatServiceSpecification struct {
	// MetricSpecifications - Operation service specification.
	MetricSpecifications *[]MetricSpecification `json:"metricSpecifications,omitempty"`
	// LogSpecifications - Operation log specification.
	LogSpecifications *[]LogSpecification `json:"logSpecifications,omitempty"`
}

// OutboundRule outbound rule of the load balancer.
type OutboundRule struct {
	autorest.Response `json:"-"`
	// OutboundRulePropertiesFormat - Properties of load balancer outbound rule.
	*OutboundRulePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the set of outbound rules used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for OutboundRule.
func (or OutboundRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if or.OutboundRulePropertiesFormat != nil {
		objectMap["properties"] = or.OutboundRulePropertiesFormat
	}
	if or.Name != nil {
		objectMap["name"] = or.Name
	}
	if or.ID != nil {
		objectMap["id"] = or.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OutboundRule struct.
func (or *OutboundRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var outboundRulePropertiesFormat OutboundRulePropertiesFormat
				err = json.Unmarshal(*v, &outboundRulePropertiesFormat)
				if err != nil {
					return err
				}
				or.OutboundRulePropertiesFormat = &outboundRulePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				or.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				or.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				or.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				or.ID = &ID
			}
		}
	}

	return nil
}

// OutboundRulePropertiesFormat outbound rule of the load balancer.
type OutboundRulePropertiesFormat struct {
	// AllocatedOutboundPorts - The number of outbound ports to be used for NAT.
	AllocatedOutboundPorts *int32 `json:"allocatedOutboundPorts,omitempty"`
	// FrontendIPConfigurations - The Frontend IP addresses of the load balancer.
	FrontendIPConfigurations *[]SubResource `json:"frontendIPConfigurations,omitempty"`
	// BackendAddressPool - A reference to a pool of DIPs. Outbound traffic is randomly load balanced across IPs in the backend IPs.
	BackendAddressPool *SubResource `json:"backendAddressPool,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the outbound rule resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Protocol - The protocol for the outbound rule in load balancer. Possible values include: 'LoadBalancerOutboundRuleProtocolTCP', 'LoadBalancerOutboundRuleProtocolUDP', 'LoadBalancerOutboundRuleProtocolAll'
	Protocol LoadBalancerOutboundRuleProtocol `json:"protocol,omitempty"`
	// EnableTCPReset - Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
	EnableTCPReset *bool `json:"enableTcpReset,omitempty"`
	// IdleTimeoutInMinutes - The timeout for the TCP idle connection.
	IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
}

// MarshalJSON is the custom marshaler for OutboundRulePropertiesFormat.
func (orpf OutboundRulePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if orpf.AllocatedOutboundPorts != nil {
		objectMap["allocatedOutboundPorts"] = orpf.AllocatedOutboundPorts
	}
	if orpf.FrontendIPConfigurations != nil {
		objectMap["frontendIPConfigurations"] = orpf.FrontendIPConfigurations
	}
	if orpf.BackendAddressPool != nil {
		objectMap["backendAddressPool"] = orpf.BackendAddressPool
	}
	if orpf.Protocol != "" {
		objectMap["protocol"] = orpf.Protocol
	}
	if orpf.EnableTCPReset != nil {
		objectMap["enableTcpReset"] = orpf.EnableTCPReset
	}
	if orpf.IdleTimeoutInMinutes != nil {
		objectMap["idleTimeoutInMinutes"] = orpf.IdleTimeoutInMinutes
	}
	return json.Marshal(objectMap)
}

// OwaspCrsExclusionEntry allow to exclude some variable satisfy the condition for the WAF check.
type OwaspCrsExclusionEntry struct {
	// MatchVariable - The variable to be excluded. Possible values include: 'OwaspCrsExclusionEntryMatchVariableRequestHeaderNames', 'OwaspCrsExclusionEntryMatchVariableRequestCookieNames', 'OwaspCrsExclusionEntryMatchVariableRequestArgNames'
	MatchVariable OwaspCrsExclusionEntryMatchVariable `json:"matchVariable,omitempty"`
	// SelectorMatchOperator - When matchVariable is a collection, operate on the selector to specify which elements in the collection this exclusion applies to. Possible values include: 'OwaspCrsExclusionEntrySelectorMatchOperatorEquals', 'OwaspCrsExclusionEntrySelectorMatchOperatorContains', 'OwaspCrsExclusionEntrySelectorMatchOperatorStartsWith', 'OwaspCrsExclusionEntrySelectorMatchOperatorEndsWith', 'OwaspCrsExclusionEntrySelectorMatchOperatorEqualsAny'
	SelectorMatchOperator OwaspCrsExclusionEntrySelectorMatchOperator `json:"selectorMatchOperator,omitempty"`
	// Selector - When matchVariable is a collection, operator used to specify which elements in the collection this exclusion applies to.
	Selector *string `json:"selector,omitempty"`
}

// P2SConnectionConfiguration p2SConnectionConfiguration Resource.
type P2SConnectionConfiguration struct {
	// P2SConnectionConfigurationProperties - Properties of the P2S connection configuration.
	*P2SConnectionConfigurationProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for P2SConnectionConfiguration.
func (pcc P2SConnectionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pcc.P2SConnectionConfigurationProperties != nil {
		objectMap["properties"] = pcc.P2SConnectionConfigurationProperties
	}
	if pcc.Name != nil {
		objectMap["name"] = pcc.Name
	}
	if pcc.ID != nil {
		objectMap["id"] = pcc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for P2SConnectionConfiguration struct.
func (pcc *P2SConnectionConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var p2SConnectionConfigurationProperties P2SConnectionConfigurationProperties
				err = json.Unmarshal(*v, &p2SConnectionConfigurationProperties)
				if err != nil {
					return err
				}
				pcc.P2SConnectionConfigurationProperties = &p2SConnectionConfigurationProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pcc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pcc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pcc.ID = &ID
			}
		}
	}

	return nil
}

// P2SConnectionConfigurationProperties parameters for P2SConnectionConfiguration.
type P2SConnectionConfigurationProperties struct {
	// VpnClientAddressPool - The reference to the address space resource which represents Address space for P2S VpnClient.
	VpnClientAddressPool *AddressSpace `json:"vpnClientAddressPool,omitempty"`
	// RoutingConfiguration - The Routing Configuration indicating the associated and propagated route tables on this connection.
	RoutingConfiguration *RoutingConfiguration `json:"routingConfiguration,omitempty"`
	// EnableInternetSecurity - Flag indicating whether the enable internet security flag is turned on for the P2S Connections or not.
	EnableInternetSecurity *bool `json:"enableInternetSecurity,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the P2SConnectionConfiguration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for P2SConnectionConfigurationProperties.
func (pccp P2SConnectionConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pccp.VpnClientAddressPool != nil {
		objectMap["vpnClientAddressPool"] = pccp.VpnClientAddressPool
	}
	if pccp.RoutingConfiguration != nil {
		objectMap["routingConfiguration"] = pccp.RoutingConfiguration
	}
	if pccp.EnableInternetSecurity != nil {
		objectMap["enableInternetSecurity"] = pccp.EnableInternetSecurity
	}
	return json.Marshal(objectMap)
}

// P2SVpnConnectionHealth p2S Vpn connection detailed health written to sas url.
type P2SVpnConnectionHealth struct {
	autorest.Response `json:"-"`
	// SasURL - Returned sas url of the blob to which the p2s vpn connection detailed health will be written.
	SasURL *string `json:"sasUrl,omitempty"`
}

// P2SVpnConnectionHealthRequest list of P2S Vpn connection health request.
type P2SVpnConnectionHealthRequest struct {
	// VpnUserNamesFilter - The list of p2s vpn user names whose p2s vpn connection detailed health to retrieve for.
	VpnUserNamesFilter *[]string `json:"vpnUserNamesFilter,omitempty"`
	// OutputBlobSasURL - The sas-url to download the P2S Vpn connection health detail.
	OutputBlobSasURL *string `json:"outputBlobSasUrl,omitempty"`
}

// P2SVpnConnectionRequest list of p2s vpn connections to be disconnected.
type P2SVpnConnectionRequest struct {
	// VpnConnectionIds - List of p2s vpn connection Ids.
	VpnConnectionIds *[]string `json:"vpnConnectionIds,omitempty"`
}

// P2SVpnGateway p2SVpnGateway Resource.
type P2SVpnGateway struct {
	autorest.Response `json:"-"`
	// P2SVpnGatewayProperties - Properties of the P2SVpnGateway.
	*P2SVpnGatewayProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for P2SVpnGateway.
func (pvg P2SVpnGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pvg.P2SVpnGatewayProperties != nil {
		objectMap["properties"] = pvg.P2SVpnGatewayProperties
	}
	if pvg.ID != nil {
		objectMap["id"] = pvg.ID
	}
	if pvg.Location != nil {
		objectMap["location"] = pvg.Location
	}
	if pvg.Tags != nil {
		objectMap["tags"] = pvg.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for P2SVpnGateway struct.
func (pvg *P2SVpnGateway) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var p2SVpnGatewayProperties P2SVpnGatewayProperties
				err = json.Unmarshal(*v, &p2SVpnGatewayProperties)
				if err != nil {
					return err
				}
				pvg.P2SVpnGatewayProperties = &p2SVpnGatewayProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pvg.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pvg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pvg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pvg.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pvg.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pvg.Tags = tags
			}
		}
	}

	return nil
}

// P2SVpnGatewayProperties parameters for P2SVpnGateway.
type P2SVpnGatewayProperties struct {
	// VirtualHub - The VirtualHub to which the gateway belongs.
	VirtualHub *SubResource `json:"virtualHub,omitempty"`
	// P2SConnectionConfigurations - List of all p2s connection configurations of the gateway.
	P2SConnectionConfigurations *[]P2SConnectionConfiguration `json:"p2SConnectionConfigurations,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the P2S VPN gateway resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// VpnGatewayScaleUnit - The scale unit for this p2s vpn gateway.
	VpnGatewayScaleUnit *int32 `json:"vpnGatewayScaleUnit,omitempty"`
	// VpnServerConfiguration - The VpnServerConfiguration to which the p2sVpnGateway is attached to.
	VpnServerConfiguration *SubResource `json:"vpnServerConfiguration,omitempty"`
	// VpnClientConnectionHealth - READ-ONLY; All P2S VPN clients' connection health status.
	VpnClientConnectionHealth *VpnClientConnectionHealth `json:"vpnClientConnectionHealth,omitempty"`
	// CustomDNSServers - List of all customer specified DNS servers IP addresses.
	CustomDNSServers *[]string `json:"customDnsServers,omitempty"`
	// IsRoutingPreferenceInternet - Enable Routing Preference property for the Public IP Interface of the P2SVpnGateway.
	IsRoutingPreferenceInternet *bool `json:"isRoutingPreferenceInternet,omitempty"`
}

// MarshalJSON is the custom marshaler for P2SVpnGatewayProperties.
func (pvgp P2SVpnGatewayProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pvgp.VirtualHub != nil {
		objectMap["virtualHub"] = pvgp.VirtualHub
	}
	if pvgp.P2SConnectionConfigurations != nil {
		objectMap["p2SConnectionConfigurations"] = pvgp.P2SConnectionConfigurations
	}
	if pvgp.VpnGatewayScaleUnit != nil {
		objectMap["vpnGatewayScaleUnit"] = pvgp.VpnGatewayScaleUnit
	}
	if pvgp.VpnServerConfiguration != nil {
		objectMap["vpnServerConfiguration"] = pvgp.VpnServerConfiguration
	}
	if pvgp.CustomDNSServers != nil {
		objectMap["customDnsServers"] = pvgp.CustomDNSServers
	}
	if pvgp.IsRoutingPreferenceInternet != nil {
		objectMap["isRoutingPreferenceInternet"] = pvgp.IsRoutingPreferenceInternet
	}
	return json.Marshal(objectMap)
}

// P2sVpnGatewaysCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type P2sVpnGatewaysCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(P2sVpnGatewaysClient) (P2SVpnGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *P2sVpnGatewaysCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for P2sVpnGatewaysCreateOrUpdateFuture.Result.
func (future *P2sVpnGatewaysCreateOrUpdateFuture) result(client P2sVpnGatewaysClient) (pvg P2SVpnGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pvg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.P2sVpnGatewaysCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pvg.Response.Response, err = future.GetResult(sender); err == nil && pvg.Response.Response.StatusCode != http.StatusNoContent {
		pvg, err = client.CreateOrUpdateResponder(pvg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysCreateOrUpdateFuture", "Result", pvg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// P2sVpnGatewaysDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type P2sVpnGatewaysDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(P2sVpnGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *P2sVpnGatewaysDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for P2sVpnGatewaysDeleteFuture.Result.
func (future *P2sVpnGatewaysDeleteFuture) result(client P2sVpnGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.P2sVpnGatewaysDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// P2sVpnGatewaysDisconnectP2sVpnConnectionsFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type P2sVpnGatewaysDisconnectP2sVpnConnectionsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(P2sVpnGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *P2sVpnGatewaysDisconnectP2sVpnConnectionsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for P2sVpnGatewaysDisconnectP2sVpnConnectionsFuture.Result.
func (future *P2sVpnGatewaysDisconnectP2sVpnConnectionsFuture) result(client P2sVpnGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysDisconnectP2sVpnConnectionsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.P2sVpnGatewaysDisconnectP2sVpnConnectionsFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// P2sVpnGatewaysGenerateVpnProfileFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type P2sVpnGatewaysGenerateVpnProfileFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(P2sVpnGatewaysClient) (VpnProfileResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *P2sVpnGatewaysGenerateVpnProfileFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for P2sVpnGatewaysGenerateVpnProfileFuture.Result.
func (future *P2sVpnGatewaysGenerateVpnProfileFuture) result(client P2sVpnGatewaysClient) (vpr VpnProfileResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysGenerateVpnProfileFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vpr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.P2sVpnGatewaysGenerateVpnProfileFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vpr.Response.Response, err = future.GetResult(sender); err == nil && vpr.Response.Response.StatusCode != http.StatusNoContent {
		vpr, err = client.GenerateVpnProfileResponder(vpr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysGenerateVpnProfileFuture", "Result", vpr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// P2sVpnGatewaysGetP2sVpnConnectionHealthDetailedFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type P2sVpnGatewaysGetP2sVpnConnectionHealthDetailedFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(P2sVpnGatewaysClient) (P2SVpnConnectionHealth, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *P2sVpnGatewaysGetP2sVpnConnectionHealthDetailedFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for P2sVpnGatewaysGetP2sVpnConnectionHealthDetailedFuture.Result.
func (future *P2sVpnGatewaysGetP2sVpnConnectionHealthDetailedFuture) result(client P2sVpnGatewaysClient) (pvch P2SVpnConnectionHealth, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysGetP2sVpnConnectionHealthDetailedFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pvch.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.P2sVpnGatewaysGetP2sVpnConnectionHealthDetailedFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pvch.Response.Response, err = future.GetResult(sender); err == nil && pvch.Response.Response.StatusCode != http.StatusNoContent {
		pvch, err = client.GetP2sVpnConnectionHealthDetailedResponder(pvch.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysGetP2sVpnConnectionHealthDetailedFuture", "Result", pvch.Response.Response, "Failure responding to request")
		}
	}
	return
}

// P2sVpnGatewaysGetP2sVpnConnectionHealthFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type P2sVpnGatewaysGetP2sVpnConnectionHealthFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(P2sVpnGatewaysClient) (P2SVpnGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *P2sVpnGatewaysGetP2sVpnConnectionHealthFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for P2sVpnGatewaysGetP2sVpnConnectionHealthFuture.Result.
func (future *P2sVpnGatewaysGetP2sVpnConnectionHealthFuture) result(client P2sVpnGatewaysClient) (pvg P2SVpnGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysGetP2sVpnConnectionHealthFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pvg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.P2sVpnGatewaysGetP2sVpnConnectionHealthFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pvg.Response.Response, err = future.GetResult(sender); err == nil && pvg.Response.Response.StatusCode != http.StatusNoContent {
		pvg, err = client.GetP2sVpnConnectionHealthResponder(pvg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysGetP2sVpnConnectionHealthFuture", "Result", pvg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// P2SVpnGatewaysResetFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type P2SVpnGatewaysResetFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(P2sVpnGatewaysClient) (P2SVpnGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *P2SVpnGatewaysResetFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for P2SVpnGatewaysResetFuture.Result.
func (future *P2SVpnGatewaysResetFuture) result(client P2sVpnGatewaysClient) (pvg P2SVpnGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.P2SVpnGatewaysResetFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pvg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.P2SVpnGatewaysResetFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pvg.Response.Response, err = future.GetResult(sender); err == nil && pvg.Response.Response.StatusCode != http.StatusNoContent {
		pvg, err = client.ResetResponder(pvg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.P2SVpnGatewaysResetFuture", "Result", pvg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// P2sVpnGatewaysUpdateTagsFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type P2sVpnGatewaysUpdateTagsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(P2sVpnGatewaysClient) (P2SVpnGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *P2sVpnGatewaysUpdateTagsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for P2sVpnGatewaysUpdateTagsFuture.Result.
func (future *P2sVpnGatewaysUpdateTagsFuture) result(client P2sVpnGatewaysClient) (pvg P2SVpnGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysUpdateTagsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pvg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.P2sVpnGatewaysUpdateTagsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pvg.Response.Response, err = future.GetResult(sender); err == nil && pvg.Response.Response.StatusCode != http.StatusNoContent {
		pvg, err = client.UpdateTagsResponder(pvg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.P2sVpnGatewaysUpdateTagsFuture", "Result", pvg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// P2SVpnProfileParameters vpn Client Parameters for package generation.
type P2SVpnProfileParameters struct {
	// AuthenticationMethod - VPN client authentication method. Possible values include: 'AuthenticationMethodEAPTLS', 'AuthenticationMethodEAPMSCHAPv2'
	AuthenticationMethod AuthenticationMethod `json:"authenticationMethod,omitempty"`
}

// PacketCapture parameters that define the create packet capture operation.
type PacketCapture struct {
	// PacketCaptureParameters - Properties of the packet capture.
	*PacketCaptureParameters `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PacketCapture.
func (pc PacketCapture) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pc.PacketCaptureParameters != nil {
		objectMap["properties"] = pc.PacketCaptureParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PacketCapture struct.
func (pc *PacketCapture) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var packetCaptureParameters PacketCaptureParameters
				err = json.Unmarshal(*v, &packetCaptureParameters)
				if err != nil {
					return err
				}
				pc.PacketCaptureParameters = &packetCaptureParameters
			}
		}
	}

	return nil
}

// PacketCaptureFilter filter that is applied to packet capture request. Multiple filters can be applied.
type PacketCaptureFilter struct {
	// Protocol - Protocol to be filtered on. Possible values include: 'PcProtocolTCP', 'PcProtocolUDP', 'PcProtocolAny'
	Protocol PcProtocol `json:"protocol,omitempty"`
	// LocalIPAddress - Local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5"? for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
	LocalIPAddress *string `json:"localIPAddress,omitempty"`
	// RemoteIPAddress - Local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
	RemoteIPAddress *string `json:"remoteIPAddress,omitempty"`
	// LocalPort - Local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
	LocalPort *string `json:"localPort,omitempty"`
	// RemotePort - Remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Default = null.
	RemotePort *string `json:"remotePort,omitempty"`
}

// PacketCaptureListResult list of packet capture sessions.
type PacketCaptureListResult struct {
	autorest.Response `json:"-"`
	// Value - Information about packet capture sessions.
	Value *[]PacketCaptureResult `json:"value,omitempty"`
}

// PacketCaptureParameters parameters that define the create packet capture operation.
type PacketCaptureParameters struct {
	// Target - The ID of the targeted resource, only VM is currently supported.
	Target *string `json:"target,omitempty"`
	// BytesToCapturePerPacket - Number of bytes captured per packet, the remaining bytes are truncated.
	BytesToCapturePerPacket *int64 `json:"bytesToCapturePerPacket,omitempty"`
	// TotalBytesPerSession - Maximum size of the capture output.
	TotalBytesPerSession *int64 `json:"totalBytesPerSession,omitempty"`
	// TimeLimitInSeconds - Maximum duration of the capture session in seconds.
	TimeLimitInSeconds *int32 `json:"timeLimitInSeconds,omitempty"`
	// StorageLocation - The storage location for a packet capture session.
	StorageLocation *PacketCaptureStorageLocation `json:"storageLocation,omitempty"`
	// Filters - A list of packet capture filters.
	Filters *[]PacketCaptureFilter `json:"filters,omitempty"`
}

// PacketCaptureQueryStatusResult status of packet capture session.
type PacketCaptureQueryStatusResult struct {
	autorest.Response `json:"-"`
	// Name - The name of the packet capture resource.
	Name *string `json:"name,omitempty"`
	// ID - The ID of the packet capture resource.
	ID *string `json:"id,omitempty"`
	// CaptureStartTime - The start time of the packet capture session.
	CaptureStartTime *date.Time `json:"captureStartTime,omitempty"`
	// PacketCaptureStatus - The status of the packet capture session. Possible values include: 'PcStatusNotStarted', 'PcStatusRunning', 'PcStatusStopped', 'PcStatusError', 'PcStatusUnknown'
	PacketCaptureStatus PcStatus `json:"packetCaptureStatus,omitempty"`
	// StopReason - The reason the current packet capture session was stopped.
	StopReason *string `json:"stopReason,omitempty"`
	// PacketCaptureError - List of errors of packet capture session.
	PacketCaptureError *[]PcError `json:"packetCaptureError,omitempty"`
}

// PacketCaptureResult information about packet capture session.
type PacketCaptureResult struct {
	autorest.Response `json:"-"`
	// Name - READ-ONLY; Name of the packet capture session.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; ID of the packet capture operation.
	ID *string `json:"id,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// PacketCaptureResultProperties - Properties of the packet capture result.
	*PacketCaptureResultProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PacketCaptureResult.
func (pcr PacketCaptureResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pcr.PacketCaptureResultProperties != nil {
		objectMap["properties"] = pcr.PacketCaptureResultProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PacketCaptureResult struct.
func (pcr *PacketCaptureResult) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pcr.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pcr.ID = &ID
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pcr.Etag = &etag
			}
		case "properties":
			if v != nil {
				var packetCaptureResultProperties PacketCaptureResultProperties
				err = json.Unmarshal(*v, &packetCaptureResultProperties)
				if err != nil {
					return err
				}
				pcr.PacketCaptureResultProperties = &packetCaptureResultProperties
			}
		}
	}

	return nil
}

// PacketCaptureResultProperties the properties of a packet capture session.
type PacketCaptureResultProperties struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the packet capture session. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Target - The ID of the targeted resource, only VM is currently supported.
	Target *string `json:"target,omitempty"`
	// BytesToCapturePerPacket - Number of bytes captured per packet, the remaining bytes are truncated.
	BytesToCapturePerPacket *int64 `json:"bytesToCapturePerPacket,omitempty"`
	// TotalBytesPerSession - Maximum size of the capture output.
	TotalBytesPerSession *int64 `json:"totalBytesPerSession,omitempty"`
	// TimeLimitInSeconds - Maximum duration of the capture session in seconds.
	TimeLimitInSeconds *int32 `json:"timeLimitInSeconds,omitempty"`
	// StorageLocation - The storage location for a packet capture session.
	StorageLocation *PacketCaptureStorageLocation `json:"storageLocation,omitempty"`
	// Filters - A list of packet capture filters.
	Filters *[]PacketCaptureFilter `json:"filters,omitempty"`
}

// MarshalJSON is the custom marshaler for PacketCaptureResultProperties.
func (pcrp PacketCaptureResultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pcrp.Target != nil {
		objectMap["target"] = pcrp.Target
	}
	if pcrp.BytesToCapturePerPacket != nil {
		objectMap["bytesToCapturePerPacket"] = pcrp.BytesToCapturePerPacket
	}
	if pcrp.TotalBytesPerSession != nil {
		objectMap["totalBytesPerSession"] = pcrp.TotalBytesPerSession
	}
	if pcrp.TimeLimitInSeconds != nil {
		objectMap["timeLimitInSeconds"] = pcrp.TimeLimitInSeconds
	}
	if pcrp.StorageLocation != nil {
		objectMap["storageLocation"] = pcrp.StorageLocation
	}
	if pcrp.Filters != nil {
		objectMap["filters"] = pcrp.Filters
	}
	return json.Marshal(objectMap)
}

// PacketCapturesCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PacketCapturesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PacketCapturesClient) (PacketCaptureResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PacketCapturesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PacketCapturesCreateFuture.Result.
func (future *PacketCapturesCreateFuture) result(client PacketCapturesClient) (pcr PacketCaptureResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PacketCapturesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pcr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PacketCapturesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pcr.Response.Response, err = future.GetResult(sender); err == nil && pcr.Response.Response.StatusCode != http.StatusNoContent {
		pcr, err = client.CreateResponder(pcr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PacketCapturesCreateFuture", "Result", pcr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PacketCapturesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PacketCapturesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PacketCapturesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PacketCapturesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PacketCapturesDeleteFuture.Result.
func (future *PacketCapturesDeleteFuture) result(client PacketCapturesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PacketCapturesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PacketCapturesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PacketCapturesGetStatusFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PacketCapturesGetStatusFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PacketCapturesClient) (PacketCaptureQueryStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PacketCapturesGetStatusFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PacketCapturesGetStatusFuture.Result.
func (future *PacketCapturesGetStatusFuture) result(client PacketCapturesClient) (pcqsr PacketCaptureQueryStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PacketCapturesGetStatusFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pcqsr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PacketCapturesGetStatusFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pcqsr.Response.Response, err = future.GetResult(sender); err == nil && pcqsr.Response.Response.StatusCode != http.StatusNoContent {
		pcqsr, err = client.GetStatusResponder(pcqsr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PacketCapturesGetStatusFuture", "Result", pcqsr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PacketCapturesStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PacketCapturesStopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PacketCapturesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PacketCapturesStopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PacketCapturesStopFuture.Result.
func (future *PacketCapturesStopFuture) result(client PacketCapturesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PacketCapturesStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PacketCapturesStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PacketCaptureStorageLocation the storage location for a packet capture session.
type PacketCaptureStorageLocation struct {
	// StorageID - The ID of the storage account to save the packet capture session. Required if no local file path is provided.
	StorageID *string `json:"storageId,omitempty"`
	// StoragePath - The URI of the storage path to save the packet capture. Must be a well-formed URI describing the location to save the packet capture.
	StoragePath *string `json:"storagePath,omitempty"`
	// FilePath - A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures. Required if no storage ID is provided, otherwise optional.
	FilePath *string `json:"filePath,omitempty"`
}

// PatchRouteFilter route Filter Resource.
type PatchRouteFilter struct {
	// RouteFilterPropertiesFormat - Properties of the route filter.
	*RouteFilterPropertiesFormat `json:"properties,omitempty"`
	// Name - READ-ONLY; The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for PatchRouteFilter.
func (prf PatchRouteFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if prf.RouteFilterPropertiesFormat != nil {
		objectMap["properties"] = prf.RouteFilterPropertiesFormat
	}
	if prf.Tags != nil {
		objectMap["tags"] = prf.Tags
	}
	if prf.ID != nil {
		objectMap["id"] = prf.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PatchRouteFilter struct.
func (prf *PatchRouteFilter) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var routeFilterPropertiesFormat RouteFilterPropertiesFormat
				err = json.Unmarshal(*v, &routeFilterPropertiesFormat)
				if err != nil {
					return err
				}
				prf.RouteFilterPropertiesFormat = &routeFilterPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				prf.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				prf.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				prf.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				prf.Tags = tags
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				prf.ID = &ID
			}
		}
	}

	return nil
}

// PatchRouteFilterRule route Filter Rule Resource.
type PatchRouteFilterRule struct {
	// RouteFilterRulePropertiesFormat - Properties of the route filter rule.
	*RouteFilterRulePropertiesFormat `json:"properties,omitempty"`
	// Name - READ-ONLY; The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for PatchRouteFilterRule.
func (prfr PatchRouteFilterRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if prfr.RouteFilterRulePropertiesFormat != nil {
		objectMap["properties"] = prfr.RouteFilterRulePropertiesFormat
	}
	if prfr.ID != nil {
		objectMap["id"] = prfr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PatchRouteFilterRule struct.
func (prfr *PatchRouteFilterRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var routeFilterRulePropertiesFormat RouteFilterRulePropertiesFormat
				err = json.Unmarshal(*v, &routeFilterRulePropertiesFormat)
				if err != nil {
					return err
				}
				prfr.RouteFilterRulePropertiesFormat = &routeFilterRulePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				prfr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				prfr.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				prfr.ID = &ID
			}
		}
	}

	return nil
}

// PeerExpressRouteCircuitConnection peer Express Route Circuit Connection in an ExpressRouteCircuitPeering
// resource.
type PeerExpressRouteCircuitConnection struct {
	autorest.Response `json:"-"`
	// PeerExpressRouteCircuitConnectionPropertiesFormat - Properties of the peer express route circuit connection.
	*PeerExpressRouteCircuitConnectionPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for PeerExpressRouteCircuitConnection.
func (percc PeerExpressRouteCircuitConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if percc.PeerExpressRouteCircuitConnectionPropertiesFormat != nil {
		objectMap["properties"] = percc.PeerExpressRouteCircuitConnectionPropertiesFormat
	}
	if percc.Name != nil {
		objectMap["name"] = percc.Name
	}
	if percc.ID != nil {
		objectMap["id"] = percc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PeerExpressRouteCircuitConnection struct.
func (percc *PeerExpressRouteCircuitConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var peerExpressRouteCircuitConnectionPropertiesFormat PeerExpressRouteCircuitConnectionPropertiesFormat
				err = json.Unmarshal(*v, &peerExpressRouteCircuitConnectionPropertiesFormat)
				if err != nil {
					return err
				}
				percc.PeerExpressRouteCircuitConnectionPropertiesFormat = &peerExpressRouteCircuitConnectionPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				percc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				percc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				percc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				percc.ID = &ID
			}
		}
	}

	return nil
}

// PeerExpressRouteCircuitConnectionListResult response for ListPeeredConnections API service call
// retrieves all global reach peer circuit connections that belongs to a Private Peering for an
// ExpressRouteCircuit.
type PeerExpressRouteCircuitConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - The global reach peer circuit connection associated with Private Peering in an ExpressRoute Circuit.
	Value *[]PeerExpressRouteCircuitConnection `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PeerExpressRouteCircuitConnectionListResultIterator provides access to a complete listing of
// PeerExpressRouteCircuitConnection values.
type PeerExpressRouteCircuitConnectionListResultIterator struct {
	i    int
	page PeerExpressRouteCircuitConnectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PeerExpressRouteCircuitConnectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PeerExpressRouteCircuitConnectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PeerExpressRouteCircuitConnectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PeerExpressRouteCircuitConnectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PeerExpressRouteCircuitConnectionListResultIterator) Response() PeerExpressRouteCircuitConnectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PeerExpressRouteCircuitConnectionListResultIterator) Value() PeerExpressRouteCircuitConnection {
	if !iter.page.NotDone() {
		return PeerExpressRouteCircuitConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PeerExpressRouteCircuitConnectionListResultIterator type.
func NewPeerExpressRouteCircuitConnectionListResultIterator(page PeerExpressRouteCircuitConnectionListResultPage) PeerExpressRouteCircuitConnectionListResultIterator {
	return PeerExpressRouteCircuitConnectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (percclr PeerExpressRouteCircuitConnectionListResult) IsEmpty() bool {
	return percclr.Value == nil || len(*percclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (percclr PeerExpressRouteCircuitConnectionListResult) hasNextLink() bool {
	return percclr.NextLink != nil && len(*percclr.NextLink) != 0
}

// peerExpressRouteCircuitConnectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (percclr PeerExpressRouteCircuitConnectionListResult) peerExpressRouteCircuitConnectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !percclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(percclr.NextLink)))
}

// PeerExpressRouteCircuitConnectionListResultPage contains a page of PeerExpressRouteCircuitConnection
// values.
type PeerExpressRouteCircuitConnectionListResultPage struct {
	fn      func(context.Context, PeerExpressRouteCircuitConnectionListResult) (PeerExpressRouteCircuitConnectionListResult, error)
	percclr PeerExpressRouteCircuitConnectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PeerExpressRouteCircuitConnectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PeerExpressRouteCircuitConnectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.percclr)
		if err != nil {
			return err
		}
		page.percclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PeerExpressRouteCircuitConnectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PeerExpressRouteCircuitConnectionListResultPage) NotDone() bool {
	return !page.percclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PeerExpressRouteCircuitConnectionListResultPage) Response() PeerExpressRouteCircuitConnectionListResult {
	return page.percclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PeerExpressRouteCircuitConnectionListResultPage) Values() []PeerExpressRouteCircuitConnection {
	if page.percclr.IsEmpty() {
		return nil
	}
	return *page.percclr.Value
}

// Creates a new instance of the PeerExpressRouteCircuitConnectionListResultPage type.
func NewPeerExpressRouteCircuitConnectionListResultPage(cur PeerExpressRouteCircuitConnectionListResult, getNextPage func(context.Context, PeerExpressRouteCircuitConnectionListResult) (PeerExpressRouteCircuitConnectionListResult, error)) PeerExpressRouteCircuitConnectionListResultPage {
	return PeerExpressRouteCircuitConnectionListResultPage{
		fn:      getNextPage,
		percclr: cur,
	}
}

// PeerExpressRouteCircuitConnectionPropertiesFormat properties of the peer express route circuit
// connection.
type PeerExpressRouteCircuitConnectionPropertiesFormat struct {
	// ExpressRouteCircuitPeering - Reference to Express Route Circuit Private Peering Resource of the circuit.
	ExpressRouteCircuitPeering *SubResource `json:"expressRouteCircuitPeering,omitempty"`
	// PeerExpressRouteCircuitPeering - Reference to Express Route Circuit Private Peering Resource of the peered circuit.
	PeerExpressRouteCircuitPeering *SubResource `json:"peerExpressRouteCircuitPeering,omitempty"`
	// AddressPrefix - /29 IP address space to carve out Customer addresses for tunnels.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// CircuitConnectionStatus - Express Route Circuit connection state. Possible values include: 'CircuitConnectionStatusConnected', 'CircuitConnectionStatusConnecting', 'CircuitConnectionStatusDisconnected'
	CircuitConnectionStatus CircuitConnectionStatus `json:"circuitConnectionStatus,omitempty"`
	// ConnectionName - The name of the express route circuit connection resource.
	ConnectionName *string `json:"connectionName,omitempty"`
	// AuthResourceGUID - The resource guid of the authorization used for the express route circuit connection.
	AuthResourceGUID *string `json:"authResourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the peer express route circuit connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for PeerExpressRouteCircuitConnectionPropertiesFormat.
func (perccpf PeerExpressRouteCircuitConnectionPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if perccpf.ExpressRouteCircuitPeering != nil {
		objectMap["expressRouteCircuitPeering"] = perccpf.ExpressRouteCircuitPeering
	}
	if perccpf.PeerExpressRouteCircuitPeering != nil {
		objectMap["peerExpressRouteCircuitPeering"] = perccpf.PeerExpressRouteCircuitPeering
	}
	if perccpf.AddressPrefix != nil {
		objectMap["addressPrefix"] = perccpf.AddressPrefix
	}
	if perccpf.CircuitConnectionStatus != "" {
		objectMap["circuitConnectionStatus"] = perccpf.CircuitConnectionStatus
	}
	if perccpf.ConnectionName != nil {
		objectMap["connectionName"] = perccpf.ConnectionName
	}
	if perccpf.AuthResourceGUID != nil {
		objectMap["authResourceGuid"] = perccpf.AuthResourceGUID
	}
	return json.Marshal(objectMap)
}

// PeerRoute peer routing details.
type PeerRoute struct {
	// LocalAddress - READ-ONLY; The peer's local address.
	LocalAddress *string `json:"localAddress,omitempty"`
	// NetworkProperty - READ-ONLY; The route's network prefix.
	NetworkProperty *string `json:"network,omitempty"`
	// NextHop - READ-ONLY; The route's next hop.
	NextHop *string `json:"nextHop,omitempty"`
	// SourcePeer - READ-ONLY; The peer this route was learned from.
	SourcePeer *string `json:"sourcePeer,omitempty"`
	// Origin - READ-ONLY; The source this route was learned from.
	Origin *string `json:"origin,omitempty"`
	// AsPath - READ-ONLY; The route's AS path sequence.
	AsPath *string `json:"asPath,omitempty"`
	// Weight - READ-ONLY; The route's weight.
	Weight *int32 `json:"weight,omitempty"`
}

// MarshalJSON is the custom marshaler for PeerRoute.
func (pr PeerRoute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PeerRouteList list of virtual router peer routes.
type PeerRouteList struct {
	autorest.Response `json:"-"`
	// Value - List of peer routes.
	Value *[]PeerRoute `json:"value,omitempty"`
}

// PolicySettings defines contents of a web application firewall global configuration.
type PolicySettings struct {
	// State - The state of the policy. Possible values include: 'WebApplicationFirewallEnabledStateDisabled', 'WebApplicationFirewallEnabledStateEnabled'
	State WebApplicationFirewallEnabledState `json:"state,omitempty"`
	// Mode - The mode of the policy. Possible values include: 'WebApplicationFirewallModePrevention', 'WebApplicationFirewallModeDetection'
	Mode WebApplicationFirewallMode `json:"mode,omitempty"`
	// RequestBodyCheck - Whether to allow WAF to check request Body.
	RequestBodyCheck *bool `json:"requestBodyCheck,omitempty"`
	// MaxRequestBodySizeInKb - Maximum request body size in Kb for WAF.
	MaxRequestBodySizeInKb *int32 `json:"maxRequestBodySizeInKb,omitempty"`
	// FileUploadLimitInMb - Maximum file upload size in Mb for WAF.
	FileUploadLimitInMb *int32 `json:"fileUploadLimitInMb,omitempty"`
}

// PrepareNetworkPoliciesRequest details of PrepareNetworkPolicies for Subnet.
type PrepareNetworkPoliciesRequest struct {
	// ServiceName - The name of the service for which subnet is being prepared for.
	ServiceName *string `json:"serviceName,omitempty"`
	// NetworkIntentPolicyConfigurations - A list of NetworkIntentPolicyConfiguration.
	NetworkIntentPolicyConfigurations *[]IntentPolicyConfiguration `json:"networkIntentPolicyConfigurations,omitempty"`
}

// PrivateDNSZoneConfig privateDnsZoneConfig resource.
type PrivateDNSZoneConfig struct {
	// Name - Name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// PrivateDNSZonePropertiesFormat - Properties of the private dns zone configuration.
	*PrivateDNSZonePropertiesFormat `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateDNSZoneConfig.
func (pdzc PrivateDNSZoneConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pdzc.Name != nil {
		objectMap["name"] = pdzc.Name
	}
	if pdzc.PrivateDNSZonePropertiesFormat != nil {
		objectMap["properties"] = pdzc.PrivateDNSZonePropertiesFormat
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateDNSZoneConfig struct.
func (pdzc *PrivateDNSZoneConfig) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pdzc.Name = &name
			}
		case "properties":
			if v != nil {
				var privateDNSZonePropertiesFormat PrivateDNSZonePropertiesFormat
				err = json.Unmarshal(*v, &privateDNSZonePropertiesFormat)
				if err != nil {
					return err
				}
				pdzc.PrivateDNSZonePropertiesFormat = &privateDNSZonePropertiesFormat
			}
		}
	}

	return nil
}

// PrivateDNSZoneGroup private dns zone group resource.
type PrivateDNSZoneGroup struct {
	autorest.Response `json:"-"`
	// Name - Name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// PrivateDNSZoneGroupPropertiesFormat - Properties of the private dns zone group.
	*PrivateDNSZoneGroupPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateDNSZoneGroup.
func (pdzg PrivateDNSZoneGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pdzg.Name != nil {
		objectMap["name"] = pdzg.Name
	}
	if pdzg.PrivateDNSZoneGroupPropertiesFormat != nil {
		objectMap["properties"] = pdzg.PrivateDNSZoneGroupPropertiesFormat
	}
	if pdzg.ID != nil {
		objectMap["id"] = pdzg.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateDNSZoneGroup struct.
func (pdzg *PrivateDNSZoneGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pdzg.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pdzg.Etag = &etag
			}
		case "properties":
			if v != nil {
				var privateDNSZoneGroupPropertiesFormat PrivateDNSZoneGroupPropertiesFormat
				err = json.Unmarshal(*v, &privateDNSZoneGroupPropertiesFormat)
				if err != nil {
					return err
				}
				pdzg.PrivateDNSZoneGroupPropertiesFormat = &privateDNSZoneGroupPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pdzg.ID = &ID
			}
		}
	}

	return nil
}

// PrivateDNSZoneGroupListResult response for the ListPrivateDnsZoneGroups API service call.
type PrivateDNSZoneGroupListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of private dns zone group resources in a private endpoint.
	Value *[]PrivateDNSZoneGroup `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateDNSZoneGroupListResult.
func (pdzglr PrivateDNSZoneGroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pdzglr.Value != nil {
		objectMap["value"] = pdzglr.Value
	}
	return json.Marshal(objectMap)
}

// PrivateDNSZoneGroupListResultIterator provides access to a complete listing of PrivateDNSZoneGroup
// values.
type PrivateDNSZoneGroupListResultIterator struct {
	i    int
	page PrivateDNSZoneGroupListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PrivateDNSZoneGroupListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateDNSZoneGroupListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PrivateDNSZoneGroupListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PrivateDNSZoneGroupListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PrivateDNSZoneGroupListResultIterator) Response() PrivateDNSZoneGroupListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PrivateDNSZoneGroupListResultIterator) Value() PrivateDNSZoneGroup {
	if !iter.page.NotDone() {
		return PrivateDNSZoneGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PrivateDNSZoneGroupListResultIterator type.
func NewPrivateDNSZoneGroupListResultIterator(page PrivateDNSZoneGroupListResultPage) PrivateDNSZoneGroupListResultIterator {
	return PrivateDNSZoneGroupListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pdzglr PrivateDNSZoneGroupListResult) IsEmpty() bool {
	return pdzglr.Value == nil || len(*pdzglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pdzglr PrivateDNSZoneGroupListResult) hasNextLink() bool {
	return pdzglr.NextLink != nil && len(*pdzglr.NextLink) != 0
}

// privateDNSZoneGroupListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pdzglr PrivateDNSZoneGroupListResult) privateDNSZoneGroupListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pdzglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pdzglr.NextLink)))
}

// PrivateDNSZoneGroupListResultPage contains a page of PrivateDNSZoneGroup values.
type PrivateDNSZoneGroupListResultPage struct {
	fn     func(context.Context, PrivateDNSZoneGroupListResult) (PrivateDNSZoneGroupListResult, error)
	pdzglr PrivateDNSZoneGroupListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PrivateDNSZoneGroupListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateDNSZoneGroupListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pdzglr)
		if err != nil {
			return err
		}
		page.pdzglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PrivateDNSZoneGroupListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PrivateDNSZoneGroupListResultPage) NotDone() bool {
	return !page.pdzglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PrivateDNSZoneGroupListResultPage) Response() PrivateDNSZoneGroupListResult {
	return page.pdzglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PrivateDNSZoneGroupListResultPage) Values() []PrivateDNSZoneGroup {
	if page.pdzglr.IsEmpty() {
		return nil
	}
	return *page.pdzglr.Value
}

// Creates a new instance of the PrivateDNSZoneGroupListResultPage type.
func NewPrivateDNSZoneGroupListResultPage(cur PrivateDNSZoneGroupListResult, getNextPage func(context.Context, PrivateDNSZoneGroupListResult) (PrivateDNSZoneGroupListResult, error)) PrivateDNSZoneGroupListResultPage {
	return PrivateDNSZoneGroupListResultPage{
		fn:     getNextPage,
		pdzglr: cur,
	}
}

// PrivateDNSZoneGroupPropertiesFormat properties of the private dns zone group.
type PrivateDNSZoneGroupPropertiesFormat struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the private dns zone group resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PrivateDNSZoneConfigs - A collection of private dns zone configurations of the private dns zone group.
	PrivateDNSZoneConfigs *[]PrivateDNSZoneConfig `json:"privateDnsZoneConfigs,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateDNSZoneGroupPropertiesFormat.
func (pdzgpf PrivateDNSZoneGroupPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pdzgpf.PrivateDNSZoneConfigs != nil {
		objectMap["privateDnsZoneConfigs"] = pdzgpf.PrivateDNSZoneConfigs
	}
	return json.Marshal(objectMap)
}

// PrivateDNSZoneGroupsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PrivateDNSZoneGroupsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateDNSZoneGroupsClient) (PrivateDNSZoneGroup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateDNSZoneGroupsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateDNSZoneGroupsCreateOrUpdateFuture.Result.
func (future *PrivateDNSZoneGroupsCreateOrUpdateFuture) result(client PrivateDNSZoneGroupsClient) (pdzg PrivateDNSZoneGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateDNSZoneGroupsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pdzg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateDNSZoneGroupsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pdzg.Response.Response, err = future.GetResult(sender); err == nil && pdzg.Response.Response.StatusCode != http.StatusNoContent {
		pdzg, err = client.CreateOrUpdateResponder(pdzg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PrivateDNSZoneGroupsCreateOrUpdateFuture", "Result", pdzg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PrivateDNSZoneGroupsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PrivateDNSZoneGroupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateDNSZoneGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateDNSZoneGroupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateDNSZoneGroupsDeleteFuture.Result.
func (future *PrivateDNSZoneGroupsDeleteFuture) result(client PrivateDNSZoneGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateDNSZoneGroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateDNSZoneGroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PrivateDNSZonePropertiesFormat properties of the private dns zone configuration resource.
type PrivateDNSZonePropertiesFormat struct {
	// PrivateDNSZoneID - The resource id of the private dns zone.
	PrivateDNSZoneID *string `json:"privateDnsZoneId,omitempty"`
	// RecordSets - READ-ONLY; A collection of information regarding a recordSet, holding information to identify private resources.
	RecordSets *[]RecordSet `json:"recordSets,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateDNSZonePropertiesFormat.
func (pdzpf PrivateDNSZonePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pdzpf.PrivateDNSZoneID != nil {
		objectMap["privateDnsZoneId"] = pdzpf.PrivateDNSZoneID
	}
	return json.Marshal(objectMap)
}

// PrivateEndpoint private endpoint resource.
type PrivateEndpoint struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// PrivateEndpointProperties - Properties of the private endpoint.
	*PrivateEndpointProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PrivateEndpoint.
func (peVar PrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if peVar.ExtendedLocation != nil {
		objectMap["extendedLocation"] = peVar.ExtendedLocation
	}
	if peVar.PrivateEndpointProperties != nil {
		objectMap["properties"] = peVar.PrivateEndpointProperties
	}
	if peVar.ID != nil {
		objectMap["id"] = peVar.ID
	}
	if peVar.Location != nil {
		objectMap["location"] = peVar.Location
	}
	if peVar.Tags != nil {
		objectMap["tags"] = peVar.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateEndpoint struct.
func (peVar *PrivateEndpoint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				peVar.ExtendedLocation = &extendedLocation
			}
		case "properties":
			if v != nil {
				var privateEndpointProperties PrivateEndpointProperties
				err = json.Unmarshal(*v, &privateEndpointProperties)
				if err != nil {
					return err
				}
				peVar.PrivateEndpointProperties = &privateEndpointProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				peVar.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				peVar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				peVar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				peVar.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				peVar.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				peVar.Tags = tags
			}
		}
	}

	return nil
}

// PrivateEndpointConnection privateEndpointConnection resource.
type PrivateEndpointConnection struct {
	autorest.Response `json:"-"`
	// PrivateEndpointConnectionProperties - Properties of the private end point connection.
	*PrivateEndpointConnectionProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointConnection.
func (pec PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pec.PrivateEndpointConnectionProperties != nil {
		objectMap["properties"] = pec.PrivateEndpointConnectionProperties
	}
	if pec.Name != nil {
		objectMap["name"] = pec.Name
	}
	if pec.ID != nil {
		objectMap["id"] = pec.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateEndpointConnection struct.
func (pec *PrivateEndpointConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateEndpointConnectionProperties PrivateEndpointConnectionProperties
				err = json.Unmarshal(*v, &privateEndpointConnectionProperties)
				if err != nil {
					return err
				}
				pec.PrivateEndpointConnectionProperties = &privateEndpointConnectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pec.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pec.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pec.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pec.ID = &ID
			}
		}
	}

	return nil
}

// PrivateEndpointConnectionListResult response for the ListPrivateEndpointConnection API service call.
type PrivateEndpointConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of PrivateEndpointConnection resources for a specific private link service.
	Value *[]PrivateEndpointConnection `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointConnectionListResult.
func (peclr PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if peclr.Value != nil {
		objectMap["value"] = peclr.Value
	}
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionListResultIterator provides access to a complete listing of
// PrivateEndpointConnection values.
type PrivateEndpointConnectionListResultIterator struct {
	i    int
	page PrivateEndpointConnectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PrivateEndpointConnectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateEndpointConnectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PrivateEndpointConnectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PrivateEndpointConnectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PrivateEndpointConnectionListResultIterator) Response() PrivateEndpointConnectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PrivateEndpointConnectionListResultIterator) Value() PrivateEndpointConnection {
	if !iter.page.NotDone() {
		return PrivateEndpointConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PrivateEndpointConnectionListResultIterator type.
func NewPrivateEndpointConnectionListResultIterator(page PrivateEndpointConnectionListResultPage) PrivateEndpointConnectionListResultIterator {
	return PrivateEndpointConnectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (peclr PrivateEndpointConnectionListResult) IsEmpty() bool {
	return peclr.Value == nil || len(*peclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (peclr PrivateEndpointConnectionListResult) hasNextLink() bool {
	return peclr.NextLink != nil && len(*peclr.NextLink) != 0
}

// privateEndpointConnectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (peclr PrivateEndpointConnectionListResult) privateEndpointConnectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !peclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(peclr.NextLink)))
}

// PrivateEndpointConnectionListResultPage contains a page of PrivateEndpointConnection values.
type PrivateEndpointConnectionListResultPage struct {
	fn    func(context.Context, PrivateEndpointConnectionListResult) (PrivateEndpointConnectionListResult, error)
	peclr PrivateEndpointConnectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PrivateEndpointConnectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateEndpointConnectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.peclr)
		if err != nil {
			return err
		}
		page.peclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PrivateEndpointConnectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PrivateEndpointConnectionListResultPage) NotDone() bool {
	return !page.peclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PrivateEndpointConnectionListResultPage) Response() PrivateEndpointConnectionListResult {
	return page.peclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PrivateEndpointConnectionListResultPage) Values() []PrivateEndpointConnection {
	if page.peclr.IsEmpty() {
		return nil
	}
	return *page.peclr.Value
}

// Creates a new instance of the PrivateEndpointConnectionListResultPage type.
func NewPrivateEndpointConnectionListResultPage(cur PrivateEndpointConnectionListResult, getNextPage func(context.Context, PrivateEndpointConnectionListResult) (PrivateEndpointConnectionListResult, error)) PrivateEndpointConnectionListResultPage {
	return PrivateEndpointConnectionListResultPage{
		fn:    getNextPage,
		peclr: cur,
	}
}

// PrivateEndpointConnectionProperties properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// PrivateEndpoint - READ-ONLY; The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`
	// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the private endpoint connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// LinkIdentifier - READ-ONLY; The consumer link id.
	LinkIdentifier *string `json:"linkIdentifier,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointConnectionProperties.
func (pecp PrivateEndpointConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pecp.PrivateLinkServiceConnectionState != nil {
		objectMap["privateLinkServiceConnectionState"] = pecp.PrivateLinkServiceConnectionState
	}
	return json.Marshal(objectMap)
}

// PrivateEndpointListResult response for the ListPrivateEndpoints API service call.
type PrivateEndpointListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of private endpoint resources in a resource group.
	Value *[]PrivateEndpoint `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointListResult.
func (pelr PrivateEndpointListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pelr.Value != nil {
		objectMap["value"] = pelr.Value
	}
	return json.Marshal(objectMap)
}

// PrivateEndpointListResultIterator provides access to a complete listing of PrivateEndpoint values.
type PrivateEndpointListResultIterator struct {
	i    int
	page PrivateEndpointListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PrivateEndpointListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateEndpointListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PrivateEndpointListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PrivateEndpointListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PrivateEndpointListResultIterator) Response() PrivateEndpointListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PrivateEndpointListResultIterator) Value() PrivateEndpoint {
	if !iter.page.NotDone() {
		return PrivateEndpoint{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PrivateEndpointListResultIterator type.
func NewPrivateEndpointListResultIterator(page PrivateEndpointListResultPage) PrivateEndpointListResultIterator {
	return PrivateEndpointListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pelr PrivateEndpointListResult) IsEmpty() bool {
	return pelr.Value == nil || len(*pelr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pelr PrivateEndpointListResult) hasNextLink() bool {
	return pelr.NextLink != nil && len(*pelr.NextLink) != 0
}

// privateEndpointListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pelr PrivateEndpointListResult) privateEndpointListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pelr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pelr.NextLink)))
}

// PrivateEndpointListResultPage contains a page of PrivateEndpoint values.
type PrivateEndpointListResultPage struct {
	fn   func(context.Context, PrivateEndpointListResult) (PrivateEndpointListResult, error)
	pelr PrivateEndpointListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PrivateEndpointListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateEndpointListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pelr)
		if err != nil {
			return err
		}
		page.pelr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PrivateEndpointListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PrivateEndpointListResultPage) NotDone() bool {
	return !page.pelr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PrivateEndpointListResultPage) Response() PrivateEndpointListResult {
	return page.pelr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PrivateEndpointListResultPage) Values() []PrivateEndpoint {
	if page.pelr.IsEmpty() {
		return nil
	}
	return *page.pelr.Value
}

// Creates a new instance of the PrivateEndpointListResultPage type.
func NewPrivateEndpointListResultPage(cur PrivateEndpointListResult, getNextPage func(context.Context, PrivateEndpointListResult) (PrivateEndpointListResult, error)) PrivateEndpointListResultPage {
	return PrivateEndpointListResultPage{
		fn:   getNextPage,
		pelr: cur,
	}
}

// PrivateEndpointProperties properties of the private endpoint.
type PrivateEndpointProperties struct {
	// Subnet - The ID of the subnet from which the private IP will be allocated.
	Subnet *Subnet `json:"subnet,omitempty"`
	// NetworkInterfaces - READ-ONLY; An array of references to the network interfaces created for this private endpoint.
	NetworkInterfaces *[]Interface `json:"networkInterfaces,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the private endpoint resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PrivateLinkServiceConnections - A grouping of information about the connection to the remote resource.
	PrivateLinkServiceConnections *[]PrivateLinkServiceConnection `json:"privateLinkServiceConnections,omitempty"`
	// ManualPrivateLinkServiceConnections - A grouping of information about the connection to the remote resource. Used when the network admin does not have access to approve connections to the remote resource.
	ManualPrivateLinkServiceConnections *[]PrivateLinkServiceConnection `json:"manualPrivateLinkServiceConnections,omitempty"`
	// CustomDNSConfigs - An array of custom dns configurations.
	CustomDNSConfigs *[]CustomDNSConfigPropertiesFormat `json:"customDnsConfigs,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointProperties.
func (pep PrivateEndpointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pep.Subnet != nil {
		objectMap["subnet"] = pep.Subnet
	}
	if pep.PrivateLinkServiceConnections != nil {
		objectMap["privateLinkServiceConnections"] = pep.PrivateLinkServiceConnections
	}
	if pep.ManualPrivateLinkServiceConnections != nil {
		objectMap["manualPrivateLinkServiceConnections"] = pep.ManualPrivateLinkServiceConnections
	}
	if pep.CustomDNSConfigs != nil {
		objectMap["customDnsConfigs"] = pep.CustomDNSConfigs
	}
	return json.Marshal(objectMap)
}

// PrivateEndpointsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PrivateEndpointsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateEndpointsClient) (PrivateEndpoint, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateEndpointsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateEndpointsCreateOrUpdateFuture.Result.
func (future *PrivateEndpointsCreateOrUpdateFuture) result(client PrivateEndpointsClient) (peVar PrivateEndpoint, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateEndpointsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		peVar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateEndpointsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if peVar.Response.Response, err = future.GetResult(sender); err == nil && peVar.Response.Response.StatusCode != http.StatusNoContent {
		peVar, err = client.CreateOrUpdateResponder(peVar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PrivateEndpointsCreateOrUpdateFuture", "Result", peVar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PrivateEndpointsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PrivateEndpointsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateEndpointsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateEndpointsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateEndpointsDeleteFuture.Result.
func (future *PrivateEndpointsDeleteFuture) result(client PrivateEndpointsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateEndpointsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateEndpointsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PrivateLinkService private link service resource.
type PrivateLinkService struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of the load balancer.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// PrivateLinkServiceProperties - Properties of the private link service.
	*PrivateLinkServiceProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PrivateLinkService.
func (pls PrivateLinkService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pls.ExtendedLocation != nil {
		objectMap["extendedLocation"] = pls.ExtendedLocation
	}
	if pls.PrivateLinkServiceProperties != nil {
		objectMap["properties"] = pls.PrivateLinkServiceProperties
	}
	if pls.ID != nil {
		objectMap["id"] = pls.ID
	}
	if pls.Location != nil {
		objectMap["location"] = pls.Location
	}
	if pls.Tags != nil {
		objectMap["tags"] = pls.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateLinkService struct.
func (pls *PrivateLinkService) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				pls.ExtendedLocation = &extendedLocation
			}
		case "properties":
			if v != nil {
				var privateLinkServiceProperties PrivateLinkServiceProperties
				err = json.Unmarshal(*v, &privateLinkServiceProperties)
				if err != nil {
					return err
				}
				pls.PrivateLinkServiceProperties = &privateLinkServiceProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pls.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pls.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pls.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pls.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pls.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pls.Tags = tags
			}
		}
	}

	return nil
}

// PrivateLinkServiceConnection privateLinkServiceConnection resource.
type PrivateLinkServiceConnection struct {
	// PrivateLinkServiceConnectionProperties - Properties of the private link service connection.
	*PrivateLinkServiceConnectionProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkServiceConnection.
func (plsc PrivateLinkServiceConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plsc.PrivateLinkServiceConnectionProperties != nil {
		objectMap["properties"] = plsc.PrivateLinkServiceConnectionProperties
	}
	if plsc.Name != nil {
		objectMap["name"] = plsc.Name
	}
	if plsc.ID != nil {
		objectMap["id"] = plsc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateLinkServiceConnection struct.
func (plsc *PrivateLinkServiceConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateLinkServiceConnectionProperties PrivateLinkServiceConnectionProperties
				err = json.Unmarshal(*v, &privateLinkServiceConnectionProperties)
				if err != nil {
					return err
				}
				plsc.PrivateLinkServiceConnectionProperties = &privateLinkServiceConnectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				plsc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				plsc.Type = &typeVar
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				plsc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				plsc.ID = &ID
			}
		}
	}

	return nil
}

// PrivateLinkServiceConnectionProperties properties of the PrivateLinkServiceConnection.
type PrivateLinkServiceConnectionProperties struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the private link service connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PrivateLinkServiceID - The resource id of private link service.
	PrivateLinkServiceID *string `json:"privateLinkServiceId,omitempty"`
	// GroupIds - The ID(s) of the group(s) obtained from the remote resource that this private endpoint should connect to.
	GroupIds *[]string `json:"groupIds,omitempty"`
	// RequestMessage - A message passed to the owner of the remote resource with this connection request. Restricted to 140 chars.
	RequestMessage *string `json:"requestMessage,omitempty"`
	// PrivateLinkServiceConnectionState - A collection of read-only information about the state of the connection to the remote resource.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkServiceConnectionProperties.
func (plscp PrivateLinkServiceConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plscp.PrivateLinkServiceID != nil {
		objectMap["privateLinkServiceId"] = plscp.PrivateLinkServiceID
	}
	if plscp.GroupIds != nil {
		objectMap["groupIds"] = plscp.GroupIds
	}
	if plscp.RequestMessage != nil {
		objectMap["requestMessage"] = plscp.RequestMessage
	}
	if plscp.PrivateLinkServiceConnectionState != nil {
		objectMap["privateLinkServiceConnectionState"] = plscp.PrivateLinkServiceConnectionState
	}
	return json.Marshal(objectMap)
}

// PrivateLinkServiceConnectionState a collection of information about the state of the connection between
// service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// Status - Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *string `json:"status,omitempty"`
	// Description - The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`
	// ActionsRequired - A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `json:"actionsRequired,omitempty"`
}

// PrivateLinkServiceIPConfiguration the private link service ip configuration.
type PrivateLinkServiceIPConfiguration struct {
	// PrivateLinkServiceIPConfigurationProperties - Properties of the private link service ip configuration.
	*PrivateLinkServiceIPConfigurationProperties `json:"properties,omitempty"`
	// Name - The name of private link service ip configuration.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkServiceIPConfiguration.
func (plsic PrivateLinkServiceIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plsic.PrivateLinkServiceIPConfigurationProperties != nil {
		objectMap["properties"] = plsic.PrivateLinkServiceIPConfigurationProperties
	}
	if plsic.Name != nil {
		objectMap["name"] = plsic.Name
	}
	if plsic.ID != nil {
		objectMap["id"] = plsic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateLinkServiceIPConfiguration struct.
func (plsic *PrivateLinkServiceIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateLinkServiceIPConfigurationProperties PrivateLinkServiceIPConfigurationProperties
				err = json.Unmarshal(*v, &privateLinkServiceIPConfigurationProperties)
				if err != nil {
					return err
				}
				plsic.PrivateLinkServiceIPConfigurationProperties = &privateLinkServiceIPConfigurationProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				plsic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				plsic.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				plsic.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				plsic.ID = &ID
			}
		}
	}

	return nil
}

// PrivateLinkServiceIPConfigurationProperties properties of private link service IP configuration.
type PrivateLinkServiceIPConfigurationProperties struct {
	// PrivateIPAddress - The private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	// Subnet - The reference to the subnet resource.
	Subnet *Subnet `json:"subnet,omitempty"`
	// Primary - Whether the ip configuration is primary or not.
	Primary *bool `json:"primary,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the private link service IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PrivateIPAddressVersion - Whether the specific IP configuration is IPv4 or IPv6. Default is IPv4. Possible values include: 'IPVersionIPv4', 'IPVersionIPv6'
	PrivateIPAddressVersion IPVersion `json:"privateIPAddressVersion,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkServiceIPConfigurationProperties.
func (plsicp PrivateLinkServiceIPConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plsicp.PrivateIPAddress != nil {
		objectMap["privateIPAddress"] = plsicp.PrivateIPAddress
	}
	if plsicp.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = plsicp.PrivateIPAllocationMethod
	}
	if plsicp.Subnet != nil {
		objectMap["subnet"] = plsicp.Subnet
	}
	if plsicp.Primary != nil {
		objectMap["primary"] = plsicp.Primary
	}
	if plsicp.PrivateIPAddressVersion != "" {
		objectMap["privateIPAddressVersion"] = plsicp.PrivateIPAddressVersion
	}
	return json.Marshal(objectMap)
}

// PrivateLinkServiceListResult response for the ListPrivateLinkService API service call.
type PrivateLinkServiceListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of PrivateLinkService resources in a resource group.
	Value *[]PrivateLinkService `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkServiceListResult.
func (plslr PrivateLinkServiceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plslr.Value != nil {
		objectMap["value"] = plslr.Value
	}
	return json.Marshal(objectMap)
}

// PrivateLinkServiceListResultIterator provides access to a complete listing of PrivateLinkService values.
type PrivateLinkServiceListResultIterator struct {
	i    int
	page PrivateLinkServiceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PrivateLinkServiceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateLinkServiceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PrivateLinkServiceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PrivateLinkServiceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PrivateLinkServiceListResultIterator) Response() PrivateLinkServiceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PrivateLinkServiceListResultIterator) Value() PrivateLinkService {
	if !iter.page.NotDone() {
		return PrivateLinkService{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PrivateLinkServiceListResultIterator type.
func NewPrivateLinkServiceListResultIterator(page PrivateLinkServiceListResultPage) PrivateLinkServiceListResultIterator {
	return PrivateLinkServiceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plslr PrivateLinkServiceListResult) IsEmpty() bool {
	return plslr.Value == nil || len(*plslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plslr PrivateLinkServiceListResult) hasNextLink() bool {
	return plslr.NextLink != nil && len(*plslr.NextLink) != 0
}

// privateLinkServiceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plslr PrivateLinkServiceListResult) privateLinkServiceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plslr.NextLink)))
}

// PrivateLinkServiceListResultPage contains a page of PrivateLinkService values.
type PrivateLinkServiceListResultPage struct {
	fn    func(context.Context, PrivateLinkServiceListResult) (PrivateLinkServiceListResult, error)
	plslr PrivateLinkServiceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PrivateLinkServiceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PrivateLinkServiceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plslr)
		if err != nil {
			return err
		}
		page.plslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PrivateLinkServiceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PrivateLinkServiceListResultPage) NotDone() bool {
	return !page.plslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PrivateLinkServiceListResultPage) Response() PrivateLinkServiceListResult {
	return page.plslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PrivateLinkServiceListResultPage) Values() []PrivateLinkService {
	if page.plslr.IsEmpty() {
		return nil
	}
	return *page.plslr.Value
}

// Creates a new instance of the PrivateLinkServiceListResultPage type.
func NewPrivateLinkServiceListResultPage(cur PrivateLinkServiceListResult, getNextPage func(context.Context, PrivateLinkServiceListResult) (PrivateLinkServiceListResult, error)) PrivateLinkServiceListResultPage {
	return PrivateLinkServiceListResultPage{
		fn:    getNextPage,
		plslr: cur,
	}
}

// PrivateLinkServiceProperties properties of the private link service.
type PrivateLinkServiceProperties struct {
	// LoadBalancerFrontendIPConfigurations - An array of references to the load balancer IP configurations.
	LoadBalancerFrontendIPConfigurations *[]FrontendIPConfiguration `json:"loadBalancerFrontendIpConfigurations,omitempty"`
	// IPConfigurations - An array of private link service IP configurations.
	IPConfigurations *[]PrivateLinkServiceIPConfiguration `json:"ipConfigurations,omitempty"`
	// NetworkInterfaces - READ-ONLY; An array of references to the network interfaces created for this private link service.
	NetworkInterfaces *[]Interface `json:"networkInterfaces,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the private link service resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PrivateEndpointConnections - READ-ONLY; An array of list about connections to the private endpoint.
	PrivateEndpointConnections *[]PrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`
	// Visibility - The visibility list of the private link service.
	Visibility *PrivateLinkServicePropertiesVisibility `json:"visibility,omitempty"`
	// AutoApproval - The auto-approval list of the private link service.
	AutoApproval *PrivateLinkServicePropertiesAutoApproval `json:"autoApproval,omitempty"`
	// Fqdns - The list of Fqdn.
	Fqdns *[]string `json:"fqdns,omitempty"`
	// Alias - READ-ONLY; The alias of the private link service.
	Alias *string `json:"alias,omitempty"`
	// EnableProxyProtocol - Whether the private link service is enabled for proxy protocol or not.
	EnableProxyProtocol *bool `json:"enableProxyProtocol,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkServiceProperties.
func (plsp PrivateLinkServiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plsp.LoadBalancerFrontendIPConfigurations != nil {
		objectMap["loadBalancerFrontendIpConfigurations"] = plsp.LoadBalancerFrontendIPConfigurations
	}
	if plsp.IPConfigurations != nil {
		objectMap["ipConfigurations"] = plsp.IPConfigurations
	}
	if plsp.Visibility != nil {
		objectMap["visibility"] = plsp.Visibility
	}
	if plsp.AutoApproval != nil {
		objectMap["autoApproval"] = plsp.AutoApproval
	}
	if plsp.Fqdns != nil {
		objectMap["fqdns"] = plsp.Fqdns
	}
	if plsp.EnableProxyProtocol != nil {
		objectMap["enableProxyProtocol"] = plsp.EnableProxyProtocol
	}
	return json.Marshal(objectMap)
}

// PrivateLinkServicePropertiesAutoApproval the auto-approval list of the private link service.
type PrivateLinkServicePropertiesAutoApproval struct {
	// Subscriptions - The list of subscriptions.
	Subscriptions *[]string `json:"subscriptions,omitempty"`
}

// PrivateLinkServicePropertiesVisibility the visibility list of the private link service.
type PrivateLinkServicePropertiesVisibility struct {
	// Subscriptions - The list of subscriptions.
	Subscriptions *[]string `json:"subscriptions,omitempty"`
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupFuture an abstraction for monitoring
// and retrieving the results of a long-running operation.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateLinkServicesClient) (PrivateLinkServiceVisibility, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupFuture.Result.
func (future *PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupFuture) result(client PrivateLinkServicesClient) (plsv PrivateLinkServiceVisibility, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		plsv.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if plsv.Response.Response, err = future.GetResult(sender); err == nil && plsv.Response.Response.StatusCode != http.StatusNoContent {
		plsv, err = client.CheckPrivateLinkServiceVisibilityByResourceGroupResponder(plsv.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupFuture", "Result", plsv.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateLinkServicesClient) (PrivateLinkServiceVisibility, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateLinkServicesCheckPrivateLinkServiceVisibilityFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateLinkServicesCheckPrivateLinkServiceVisibilityFuture.Result.
func (future *PrivateLinkServicesCheckPrivateLinkServiceVisibilityFuture) result(client PrivateLinkServicesClient) (plsv PrivateLinkServiceVisibility, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateLinkServicesCheckPrivateLinkServiceVisibilityFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		plsv.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateLinkServicesCheckPrivateLinkServiceVisibilityFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if plsv.Response.Response, err = future.GetResult(sender); err == nil && plsv.Response.Response.StatusCode != http.StatusNoContent {
		plsv, err = client.CheckPrivateLinkServiceVisibilityResponder(plsv.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PrivateLinkServicesCheckPrivateLinkServiceVisibilityFuture", "Result", plsv.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PrivateLinkServicesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PrivateLinkServicesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateLinkServicesClient) (PrivateLinkService, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateLinkServicesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateLinkServicesCreateOrUpdateFuture.Result.
func (future *PrivateLinkServicesCreateOrUpdateFuture) result(client PrivateLinkServicesClient) (pls PrivateLinkService, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateLinkServicesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pls.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateLinkServicesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pls.Response.Response, err = future.GetResult(sender); err == nil && pls.Response.Response.StatusCode != http.StatusNoContent {
		pls, err = client.CreateOrUpdateResponder(pls.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PrivateLinkServicesCreateOrUpdateFuture", "Result", pls.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PrivateLinkServicesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PrivateLinkServicesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateLinkServicesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateLinkServicesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateLinkServicesDeleteFuture.Result.
func (future *PrivateLinkServicesDeleteFuture) result(client PrivateLinkServicesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateLinkServicesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateLinkServicesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PrivateLinkServicesDeletePrivateEndpointConnectionFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type PrivateLinkServicesDeletePrivateEndpointConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateLinkServicesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateLinkServicesDeletePrivateEndpointConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateLinkServicesDeletePrivateEndpointConnectionFuture.Result.
func (future *PrivateLinkServicesDeletePrivateEndpointConnectionFuture) result(client PrivateLinkServicesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PrivateLinkServicesDeletePrivateEndpointConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PrivateLinkServicesDeletePrivateEndpointConnectionFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PrivateLinkServiceVisibility response for the CheckPrivateLinkServiceVisibility API service call.
type PrivateLinkServiceVisibility struct {
	autorest.Response `json:"-"`
	// Visible - Private Link Service Visibility (True/False).
	Visible *bool `json:"visible,omitempty"`
}

// Probe a load balancer probe.
type Probe struct {
	autorest.Response `json:"-"`
	// ProbePropertiesFormat - Properties of load balancer probe.
	*ProbePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within the set of probes used by the load balancer. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for Probe.
func (p Probe) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ProbePropertiesFormat != nil {
		objectMap["properties"] = p.ProbePropertiesFormat
	}
	if p.Name != nil {
		objectMap["name"] = p.Name
	}
	if p.ID != nil {
		objectMap["id"] = p.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Probe struct.
func (p *Probe) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var probePropertiesFormat ProbePropertiesFormat
				err = json.Unmarshal(*v, &probePropertiesFormat)
				if err != nil {
					return err
				}
				p.ProbePropertiesFormat = &probePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				p.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		}
	}

	return nil
}

// ProbePropertiesFormat load balancer probe resource.
type ProbePropertiesFormat struct {
	// LoadBalancingRules - READ-ONLY; The load balancer rules that use this probe.
	LoadBalancingRules *[]SubResource `json:"loadBalancingRules,omitempty"`
	// Protocol - The protocol of the end point. If 'Tcp' is specified, a received ACK is required for the probe to be successful. If 'Http' or 'Https' is specified, a 200 OK response from the specifies URI is required for the probe to be successful. Possible values include: 'ProbeProtocolHTTP', 'ProbeProtocolTCP', 'ProbeProtocolHTTPS'
	Protocol ProbeProtocol `json:"protocol,omitempty"`
	// Port - The port for communicating the probe. Possible values range from 1 to 65535, inclusive.
	Port *int32 `json:"port,omitempty"`
	// IntervalInSeconds - The interval, in seconds, for how frequently to probe the endpoint for health status. Typically, the interval is slightly less than half the allocated timeout period (in seconds) which allows two full probes before taking the instance out of rotation. The default value is 15, the minimum value is 5.
	IntervalInSeconds *int32 `json:"intervalInSeconds,omitempty"`
	// NumberOfProbes - The number of probes where if no response, will result in stopping further traffic from being delivered to the endpoint. This values allows endpoints to be taken out of rotation faster or slower than the typical times used in Azure.
	NumberOfProbes *int32 `json:"numberOfProbes,omitempty"`
	// RequestPath - The URI used for requesting health status from the VM. Path is required if a protocol is set to http. Otherwise, it is not allowed. There is no default value.
	RequestPath *string `json:"requestPath,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the probe resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ProbePropertiesFormat.
func (ppf ProbePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ppf.Protocol != "" {
		objectMap["protocol"] = ppf.Protocol
	}
	if ppf.Port != nil {
		objectMap["port"] = ppf.Port
	}
	if ppf.IntervalInSeconds != nil {
		objectMap["intervalInSeconds"] = ppf.IntervalInSeconds
	}
	if ppf.NumberOfProbes != nil {
		objectMap["numberOfProbes"] = ppf.NumberOfProbes
	}
	if ppf.RequestPath != nil {
		objectMap["requestPath"] = ppf.RequestPath
	}
	return json.Marshal(objectMap)
}

// Profile network profile resource.
type Profile struct {
	autorest.Response `json:"-"`
	// ProfilePropertiesFormat - Network profile properties.
	*ProfilePropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Profile.
func (p Profile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ProfilePropertiesFormat != nil {
		objectMap["properties"] = p.ProfilePropertiesFormat
	}
	if p.ID != nil {
		objectMap["id"] = p.ID
	}
	if p.Location != nil {
		objectMap["location"] = p.Location
	}
	if p.Tags != nil {
		objectMap["tags"] = p.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Profile struct.
func (p *Profile) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var profilePropertiesFormat ProfilePropertiesFormat
				err = json.Unmarshal(*v, &profilePropertiesFormat)
				if err != nil {
					return err
				}
				p.ProfilePropertiesFormat = &profilePropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				p.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				p.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				p.Tags = tags
			}
		}
	}

	return nil
}

// ProfileListResult response for ListNetworkProfiles API service call.
type ProfileListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of network profiles that exist in a resource group.
	Value *[]Profile `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ProfileListResultIterator provides access to a complete listing of Profile values.
type ProfileListResultIterator struct {
	i    int
	page ProfileListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProfileListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProfileListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProfileListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProfileListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProfileListResultIterator) Response() ProfileListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProfileListResultIterator) Value() Profile {
	if !iter.page.NotDone() {
		return Profile{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProfileListResultIterator type.
func NewProfileListResultIterator(page ProfileListResultPage) ProfileListResultIterator {
	return ProfileListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plr ProfileListResult) IsEmpty() bool {
	return plr.Value == nil || len(*plr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plr ProfileListResult) hasNextLink() bool {
	return plr.NextLink != nil && len(*plr.NextLink) != 0
}

// profileListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plr ProfileListResult) profileListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plr.NextLink)))
}

// ProfileListResultPage contains a page of Profile values.
type ProfileListResultPage struct {
	fn  func(context.Context, ProfileListResult) (ProfileListResult, error)
	plr ProfileListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProfileListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProfileListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plr)
		if err != nil {
			return err
		}
		page.plr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProfileListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProfileListResultPage) NotDone() bool {
	return !page.plr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProfileListResultPage) Response() ProfileListResult {
	return page.plr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProfileListResultPage) Values() []Profile {
	if page.plr.IsEmpty() {
		return nil
	}
	return *page.plr.Value
}

// Creates a new instance of the ProfileListResultPage type.
func NewProfileListResultPage(cur ProfileListResult, getNextPage func(context.Context, ProfileListResult) (ProfileListResult, error)) ProfileListResultPage {
	return ProfileListResultPage{
		fn:  getNextPage,
		plr: cur,
	}
}

// ProfilePropertiesFormat network profile properties.
type ProfilePropertiesFormat struct {
	// ContainerNetworkInterfaces - READ-ONLY; List of child container network interfaces.
	ContainerNetworkInterfaces *[]ContainerNetworkInterface `json:"containerNetworkInterfaces,omitempty"`
	// ContainerNetworkInterfaceConfigurations - List of chid container network interface configurations.
	ContainerNetworkInterfaceConfigurations *[]ContainerNetworkInterfaceConfiguration `json:"containerNetworkInterfaceConfigurations,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the network profile resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the network profile resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ProfilePropertiesFormat.
func (ppf ProfilePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ppf.ContainerNetworkInterfaceConfigurations != nil {
		objectMap["containerNetworkInterfaceConfigurations"] = ppf.ContainerNetworkInterfaceConfigurations
	}
	return json.Marshal(objectMap)
}

// ProfilesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ProfilesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ProfilesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ProfilesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ProfilesDeleteFuture.Result.
func (future *ProfilesDeleteFuture) result(client ProfilesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ProfilesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ProfilesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PropagatedRouteTable the list of RouteTables to advertise the routes to.
type PropagatedRouteTable struct {
	// Labels - The list of labels.
	Labels *[]string `json:"labels,omitempty"`
	// Ids - The list of resource ids of all the RouteTables.
	Ids *[]SubResource `json:"ids,omitempty"`
}

// ProtocolConfiguration configuration of the protocol.
type ProtocolConfiguration struct {
	// HTTPConfiguration - HTTP configuration of the connectivity check.
	HTTPConfiguration *HTTPConfiguration `json:"HTTPConfiguration,omitempty"`
}

// ProtocolCustomSettingsFormat dDoS custom policy properties.
type ProtocolCustomSettingsFormat struct {
	// Protocol - The protocol for which the DDoS protection policy is being customized. Possible values include: 'DdosCustomPolicyProtocolTCP', 'DdosCustomPolicyProtocolUDP', 'DdosCustomPolicyProtocolSyn'
	Protocol DdosCustomPolicyProtocol `json:"protocol,omitempty"`
	// TriggerRateOverride - The customized DDoS protection trigger rate.
	TriggerRateOverride *string `json:"triggerRateOverride,omitempty"`
	// SourceRateOverride - The customized DDoS protection source rate.
	SourceRateOverride *string `json:"sourceRateOverride,omitempty"`
	// TriggerSensitivityOverride - The customized DDoS protection trigger rate sensitivity degrees. High: Trigger rate set with most sensitivity w.r.t. normal traffic. Default: Trigger rate set with moderate sensitivity w.r.t. normal traffic. Low: Trigger rate set with less sensitivity w.r.t. normal traffic. Relaxed: Trigger rate set with least sensitivity w.r.t. normal traffic. Possible values include: 'DdosCustomPolicyTriggerSensitivityOverrideRelaxed', 'DdosCustomPolicyTriggerSensitivityOverrideLow', 'DdosCustomPolicyTriggerSensitivityOverrideDefault', 'DdosCustomPolicyTriggerSensitivityOverrideHigh'
	TriggerSensitivityOverride DdosCustomPolicyTriggerSensitivityOverride `json:"triggerSensitivityOverride,omitempty"`
}

// PublicIPAddress public IP address resource.
type PublicIPAddress struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Sku - The public IP address SKU.
	Sku *PublicIPAddressSku `json:"sku,omitempty"`
	// PublicIPAddressPropertiesFormat - Public IP address properties.
	*PublicIPAddressPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Zones - A list of availability zones denoting the IP allocated for the resource needs to come from.
	Zones *[]string `json:"zones,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PublicIPAddress.
func (pia PublicIPAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pia.ExtendedLocation != nil {
		objectMap["extendedLocation"] = pia.ExtendedLocation
	}
	if pia.Sku != nil {
		objectMap["sku"] = pia.Sku
	}
	if pia.PublicIPAddressPropertiesFormat != nil {
		objectMap["properties"] = pia.PublicIPAddressPropertiesFormat
	}
	if pia.Zones != nil {
		objectMap["zones"] = pia.Zones
	}
	if pia.ID != nil {
		objectMap["id"] = pia.ID
	}
	if pia.Location != nil {
		objectMap["location"] = pia.Location
	}
	if pia.Tags != nil {
		objectMap["tags"] = pia.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PublicIPAddress struct.
func (pia *PublicIPAddress) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				pia.ExtendedLocation = &extendedLocation
			}
		case "sku":
			if v != nil {
				var sku PublicIPAddressSku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				pia.Sku = &sku
			}
		case "properties":
			if v != nil {
				var publicIPAddressPropertiesFormat PublicIPAddressPropertiesFormat
				err = json.Unmarshal(*v, &publicIPAddressPropertiesFormat)
				if err != nil {
					return err
				}
				pia.PublicIPAddressPropertiesFormat = &publicIPAddressPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pia.Etag = &etag
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				pia.Zones = &zones
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pia.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pia.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pia.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pia.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pia.Tags = tags
			}
		}
	}

	return nil
}

// PublicIPAddressDNSSettings contains FQDN of the DNS record associated with the public IP address.
type PublicIPAddressDNSSettings struct {
	// DomainNameLabel - The domain name label. The concatenation of the domain name label and the regionalized DNS zone make up the fully qualified domain name associated with the public IP address. If a domain name label is specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system.
	DomainNameLabel *string `json:"domainNameLabel,omitempty"`
	// Fqdn - The Fully Qualified Domain Name of the A DNS record associated with the public IP. This is the concatenation of the domainNameLabel and the regionalized DNS zone.
	Fqdn *string `json:"fqdn,omitempty"`
	// ReverseFqdn - The reverse FQDN. A user-visible, fully qualified domain name that resolves to this public IP address. If the reverseFqdn is specified, then a PTR DNS record is created pointing from the IP address in the in-addr.arpa domain to the reverse FQDN.
	ReverseFqdn *string `json:"reverseFqdn,omitempty"`
}

// PublicIPAddressesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PublicIPAddressesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PublicIPAddressesClient) (PublicIPAddress, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PublicIPAddressesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PublicIPAddressesCreateOrUpdateFuture.Result.
func (future *PublicIPAddressesCreateOrUpdateFuture) result(client PublicIPAddressesClient) (pia PublicIPAddress, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PublicIPAddressesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pia.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PublicIPAddressesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pia.Response.Response, err = future.GetResult(sender); err == nil && pia.Response.Response.StatusCode != http.StatusNoContent {
		pia, err = client.CreateOrUpdateResponder(pia.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PublicIPAddressesCreateOrUpdateFuture", "Result", pia.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PublicIPAddressesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PublicIPAddressesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PublicIPAddressesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PublicIPAddressesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PublicIPAddressesDeleteFuture.Result.
func (future *PublicIPAddressesDeleteFuture) result(client PublicIPAddressesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PublicIPAddressesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PublicIPAddressesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PublicIPAddressListResult response for ListPublicIpAddresses API service call.
type PublicIPAddressListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of public IP addresses that exists in a resource group.
	Value *[]PublicIPAddress `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PublicIPAddressListResultIterator provides access to a complete listing of PublicIPAddress values.
type PublicIPAddressListResultIterator struct {
	i    int
	page PublicIPAddressListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PublicIPAddressListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PublicIPAddressListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PublicIPAddressListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PublicIPAddressListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PublicIPAddressListResultIterator) Response() PublicIPAddressListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PublicIPAddressListResultIterator) Value() PublicIPAddress {
	if !iter.page.NotDone() {
		return PublicIPAddress{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PublicIPAddressListResultIterator type.
func NewPublicIPAddressListResultIterator(page PublicIPAddressListResultPage) PublicIPAddressListResultIterator {
	return PublicIPAddressListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pialr PublicIPAddressListResult) IsEmpty() bool {
	return pialr.Value == nil || len(*pialr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pialr PublicIPAddressListResult) hasNextLink() bool {
	return pialr.NextLink != nil && len(*pialr.NextLink) != 0
}

// publicIPAddressListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pialr PublicIPAddressListResult) publicIPAddressListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pialr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pialr.NextLink)))
}

// PublicIPAddressListResultPage contains a page of PublicIPAddress values.
type PublicIPAddressListResultPage struct {
	fn    func(context.Context, PublicIPAddressListResult) (PublicIPAddressListResult, error)
	pialr PublicIPAddressListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PublicIPAddressListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PublicIPAddressListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pialr)
		if err != nil {
			return err
		}
		page.pialr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PublicIPAddressListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PublicIPAddressListResultPage) NotDone() bool {
	return !page.pialr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PublicIPAddressListResultPage) Response() PublicIPAddressListResult {
	return page.pialr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PublicIPAddressListResultPage) Values() []PublicIPAddress {
	if page.pialr.IsEmpty() {
		return nil
	}
	return *page.pialr.Value
}

// Creates a new instance of the PublicIPAddressListResultPage type.
func NewPublicIPAddressListResultPage(cur PublicIPAddressListResult, getNextPage func(context.Context, PublicIPAddressListResult) (PublicIPAddressListResult, error)) PublicIPAddressListResultPage {
	return PublicIPAddressListResultPage{
		fn:    getNextPage,
		pialr: cur,
	}
}

// PublicIPAddressPropertiesFormat public IP address properties.
type PublicIPAddressPropertiesFormat struct {
	// PublicIPAllocationMethod - The public IP address allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PublicIPAllocationMethod IPAllocationMethod `json:"publicIPAllocationMethod,omitempty"`
	// PublicIPAddressVersion - The public IP address version. Possible values include: 'IPVersionIPv4', 'IPVersionIPv6'
	PublicIPAddressVersion IPVersion `json:"publicIPAddressVersion,omitempty"`
	// IPConfiguration - READ-ONLY; The IP configuration associated with the public IP address.
	IPConfiguration *IPConfiguration `json:"ipConfiguration,omitempty"`
	// DNSSettings - The FQDN of the DNS record associated with the public IP address.
	DNSSettings *PublicIPAddressDNSSettings `json:"dnsSettings,omitempty"`
	// DdosSettings - The DDoS protection custom policy associated with the public IP address.
	DdosSettings *DdosSettings `json:"ddosSettings,omitempty"`
	// IPTags - The list of tags associated with the public IP address.
	IPTags *[]IPTag `json:"ipTags,omitempty"`
	// IPAddress - The IP address associated with the public IP address resource.
	IPAddress *string `json:"ipAddress,omitempty"`
	// PublicIPPrefix - The Public IP Prefix this Public IP Address should be allocated from.
	PublicIPPrefix *SubResource `json:"publicIPPrefix,omitempty"`
	// IdleTimeoutInMinutes - The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the public IP address resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the public IP address resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ServicePublicIPAddress - The service public IP address of the public IP address resource.
	ServicePublicIPAddress *PublicIPAddress `json:"servicePublicIPAddress,omitempty"`
	// NatGateway - The NatGateway for the Public IP address.
	NatGateway *NatGateway `json:"natGateway,omitempty"`
	// MigrationPhase - Migration phase of Public IP Address. Possible values include: 'PublicIPAddressMigrationPhaseNone', 'PublicIPAddressMigrationPhasePrepare', 'PublicIPAddressMigrationPhaseCommit', 'PublicIPAddressMigrationPhaseAbort', 'PublicIPAddressMigrationPhaseCommitted'
	MigrationPhase PublicIPAddressMigrationPhase `json:"migrationPhase,omitempty"`
	// LinkedPublicIPAddress - The linked public IP address of the public IP address resource.
	LinkedPublicIPAddress *PublicIPAddress `json:"linkedPublicIPAddress,omitempty"`
}

// MarshalJSON is the custom marshaler for PublicIPAddressPropertiesFormat.
func (piapf PublicIPAddressPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if piapf.PublicIPAllocationMethod != "" {
		objectMap["publicIPAllocationMethod"] = piapf.PublicIPAllocationMethod
	}
	if piapf.PublicIPAddressVersion != "" {
		objectMap["publicIPAddressVersion"] = piapf.PublicIPAddressVersion
	}
	if piapf.DNSSettings != nil {
		objectMap["dnsSettings"] = piapf.DNSSettings
	}
	if piapf.DdosSettings != nil {
		objectMap["ddosSettings"] = piapf.DdosSettings
	}
	if piapf.IPTags != nil {
		objectMap["ipTags"] = piapf.IPTags
	}
	if piapf.IPAddress != nil {
		objectMap["ipAddress"] = piapf.IPAddress
	}
	if piapf.PublicIPPrefix != nil {
		objectMap["publicIPPrefix"] = piapf.PublicIPPrefix
	}
	if piapf.IdleTimeoutInMinutes != nil {
		objectMap["idleTimeoutInMinutes"] = piapf.IdleTimeoutInMinutes
	}
	if piapf.ServicePublicIPAddress != nil {
		objectMap["servicePublicIPAddress"] = piapf.ServicePublicIPAddress
	}
	if piapf.NatGateway != nil {
		objectMap["natGateway"] = piapf.NatGateway
	}
	if piapf.MigrationPhase != "" {
		objectMap["migrationPhase"] = piapf.MigrationPhase
	}
	if piapf.LinkedPublicIPAddress != nil {
		objectMap["linkedPublicIPAddress"] = piapf.LinkedPublicIPAddress
	}
	return json.Marshal(objectMap)
}

// PublicIPAddressSku SKU of a public IP address.
type PublicIPAddressSku struct {
	// Name - Name of a public IP address SKU. Possible values include: 'PublicIPAddressSkuNameBasic', 'PublicIPAddressSkuNameStandard'
	Name PublicIPAddressSkuName `json:"name,omitempty"`
	// Tier - Tier of a public IP address SKU. Possible values include: 'PublicIPAddressSkuTierRegional', 'PublicIPAddressSkuTierGlobal'
	Tier PublicIPAddressSkuTier `json:"tier,omitempty"`
}

// PublicIPPrefix public IP prefix resource.
type PublicIPPrefix struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of the public ip address.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Sku - The public IP prefix SKU.
	Sku *PublicIPPrefixSku `json:"sku,omitempty"`
	// PublicIPPrefixPropertiesFormat - Public IP prefix properties.
	*PublicIPPrefixPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Zones - A list of availability zones denoting the IP allocated for the resource needs to come from.
	Zones *[]string `json:"zones,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PublicIPPrefix.
func (pip PublicIPPrefix) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pip.ExtendedLocation != nil {
		objectMap["extendedLocation"] = pip.ExtendedLocation
	}
	if pip.Sku != nil {
		objectMap["sku"] = pip.Sku
	}
	if pip.PublicIPPrefixPropertiesFormat != nil {
		objectMap["properties"] = pip.PublicIPPrefixPropertiesFormat
	}
	if pip.Zones != nil {
		objectMap["zones"] = pip.Zones
	}
	if pip.ID != nil {
		objectMap["id"] = pip.ID
	}
	if pip.Location != nil {
		objectMap["location"] = pip.Location
	}
	if pip.Tags != nil {
		objectMap["tags"] = pip.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PublicIPPrefix struct.
func (pip *PublicIPPrefix) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				pip.ExtendedLocation = &extendedLocation
			}
		case "sku":
			if v != nil {
				var sku PublicIPPrefixSku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				pip.Sku = &sku
			}
		case "properties":
			if v != nil {
				var publicIPPrefixPropertiesFormat PublicIPPrefixPropertiesFormat
				err = json.Unmarshal(*v, &publicIPPrefixPropertiesFormat)
				if err != nil {
					return err
				}
				pip.PublicIPPrefixPropertiesFormat = &publicIPPrefixPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pip.Etag = &etag
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				pip.Zones = &zones
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pip.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pip.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pip.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pip.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pip.Tags = tags
			}
		}
	}

	return nil
}

// PublicIPPrefixesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PublicIPPrefixesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PublicIPPrefixesClient) (PublicIPPrefix, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PublicIPPrefixesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PublicIPPrefixesCreateOrUpdateFuture.Result.
func (future *PublicIPPrefixesCreateOrUpdateFuture) result(client PublicIPPrefixesClient) (pip PublicIPPrefix, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PublicIPPrefixesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pip.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PublicIPPrefixesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pip.Response.Response, err = future.GetResult(sender); err == nil && pip.Response.Response.StatusCode != http.StatusNoContent {
		pip, err = client.CreateOrUpdateResponder(pip.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PublicIPPrefixesCreateOrUpdateFuture", "Result", pip.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PublicIPPrefixesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PublicIPPrefixesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PublicIPPrefixesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PublicIPPrefixesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PublicIPPrefixesDeleteFuture.Result.
func (future *PublicIPPrefixesDeleteFuture) result(client PublicIPPrefixesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PublicIPPrefixesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PublicIPPrefixesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PublicIPPrefixListResult response for ListPublicIpPrefixes API service call.
type PublicIPPrefixListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of public IP prefixes that exists in a resource group.
	Value *[]PublicIPPrefix `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PublicIPPrefixListResultIterator provides access to a complete listing of PublicIPPrefix values.
type PublicIPPrefixListResultIterator struct {
	i    int
	page PublicIPPrefixListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PublicIPPrefixListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PublicIPPrefixListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PublicIPPrefixListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PublicIPPrefixListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PublicIPPrefixListResultIterator) Response() PublicIPPrefixListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PublicIPPrefixListResultIterator) Value() PublicIPPrefix {
	if !iter.page.NotDone() {
		return PublicIPPrefix{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PublicIPPrefixListResultIterator type.
func NewPublicIPPrefixListResultIterator(page PublicIPPrefixListResultPage) PublicIPPrefixListResultIterator {
	return PublicIPPrefixListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (piplr PublicIPPrefixListResult) IsEmpty() bool {
	return piplr.Value == nil || len(*piplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (piplr PublicIPPrefixListResult) hasNextLink() bool {
	return piplr.NextLink != nil && len(*piplr.NextLink) != 0
}

// publicIPPrefixListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (piplr PublicIPPrefixListResult) publicIPPrefixListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !piplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(piplr.NextLink)))
}

// PublicIPPrefixListResultPage contains a page of PublicIPPrefix values.
type PublicIPPrefixListResultPage struct {
	fn    func(context.Context, PublicIPPrefixListResult) (PublicIPPrefixListResult, error)
	piplr PublicIPPrefixListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PublicIPPrefixListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PublicIPPrefixListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.piplr)
		if err != nil {
			return err
		}
		page.piplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PublicIPPrefixListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PublicIPPrefixListResultPage) NotDone() bool {
	return !page.piplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PublicIPPrefixListResultPage) Response() PublicIPPrefixListResult {
	return page.piplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PublicIPPrefixListResultPage) Values() []PublicIPPrefix {
	if page.piplr.IsEmpty() {
		return nil
	}
	return *page.piplr.Value
}

// Creates a new instance of the PublicIPPrefixListResultPage type.
func NewPublicIPPrefixListResultPage(cur PublicIPPrefixListResult, getNextPage func(context.Context, PublicIPPrefixListResult) (PublicIPPrefixListResult, error)) PublicIPPrefixListResultPage {
	return PublicIPPrefixListResultPage{
		fn:    getNextPage,
		piplr: cur,
	}
}

// PublicIPPrefixPropertiesFormat public IP prefix properties.
type PublicIPPrefixPropertiesFormat struct {
	// PublicIPAddressVersion - The public IP address version. Possible values include: 'IPVersionIPv4', 'IPVersionIPv6'
	PublicIPAddressVersion IPVersion `json:"publicIPAddressVersion,omitempty"`
	// IPTags - The list of tags associated with the public IP prefix.
	IPTags *[]IPTag `json:"ipTags,omitempty"`
	// PrefixLength - The Length of the Public IP Prefix.
	PrefixLength *int32 `json:"prefixLength,omitempty"`
	// IPPrefix - READ-ONLY; The allocated Prefix.
	IPPrefix *string `json:"ipPrefix,omitempty"`
	// PublicIPAddresses - READ-ONLY; The list of all referenced PublicIPAddresses.
	PublicIPAddresses *[]ReferencedPublicIPAddress `json:"publicIPAddresses,omitempty"`
	// LoadBalancerFrontendIPConfiguration - READ-ONLY; The reference to load balancer frontend IP configuration associated with the public IP prefix.
	LoadBalancerFrontendIPConfiguration *SubResource `json:"loadBalancerFrontendIpConfiguration,omitempty"`
	// CustomIPPrefix - The customIpPrefix that this prefix is associated with.
	CustomIPPrefix *SubResource `json:"customIPPrefix,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the public IP prefix resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the public IP prefix resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// NatGateway - NatGateway of Public IP Prefix.
	NatGateway *NatGateway `json:"natGateway,omitempty"`
}

// MarshalJSON is the custom marshaler for PublicIPPrefixPropertiesFormat.
func (pippf PublicIPPrefixPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pippf.PublicIPAddressVersion != "" {
		objectMap["publicIPAddressVersion"] = pippf.PublicIPAddressVersion
	}
	if pippf.IPTags != nil {
		objectMap["ipTags"] = pippf.IPTags
	}
	if pippf.PrefixLength != nil {
		objectMap["prefixLength"] = pippf.PrefixLength
	}
	if pippf.CustomIPPrefix != nil {
		objectMap["customIPPrefix"] = pippf.CustomIPPrefix
	}
	if pippf.NatGateway != nil {
		objectMap["natGateway"] = pippf.NatGateway
	}
	return json.Marshal(objectMap)
}

// PublicIPPrefixSku SKU of a public IP prefix.
type PublicIPPrefixSku struct {
	// Name - Name of a public IP prefix SKU. Possible values include: 'PublicIPPrefixSkuNameStandard'
	Name PublicIPPrefixSkuName `json:"name,omitempty"`
	// Tier - Tier of a public IP prefix SKU. Possible values include: 'PublicIPPrefixSkuTierRegional', 'PublicIPPrefixSkuTierGlobal'
	Tier PublicIPPrefixSkuTier `json:"tier,omitempty"`
}

// PutBastionShareableLinkAllFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PutBastionShareableLinkAllFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BaseClient) (BastionShareableLinkListResultPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PutBastionShareableLinkAllFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PutBastionShareableLinkAllFuture.Result.
func (future *PutBastionShareableLinkAllFuture) result(client BaseClient) (bsllrp BastionShareableLinkListResultPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PutBastionShareableLinkAllFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bsllrp.bsllr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PutBastionShareableLinkAllFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bsllrp.bsllr.Response.Response, err = future.GetResult(sender); err == nil && bsllrp.bsllr.Response.Response.StatusCode != http.StatusNoContent {
		bsllrp, err = client.PutBastionShareableLinkResponder(bsllrp.bsllr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PutBastionShareableLinkAllFuture", "Result", bsllrp.bsllr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PutBastionShareableLinkFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PutBastionShareableLinkFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BaseClient) (BastionShareableLinkListResultPage, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PutBastionShareableLinkFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PutBastionShareableLinkFuture.Result.
func (future *PutBastionShareableLinkFuture) result(client BaseClient) (bsllrp BastionShareableLinkListResultPage, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.PutBastionShareableLinkFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bsllrp.bsllr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.PutBastionShareableLinkFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bsllrp.bsllr.Response.Response, err = future.GetResult(sender); err == nil && bsllrp.bsllr.Response.Response.StatusCode != http.StatusNoContent {
		bsllrp, err = client.PutBastionShareableLinkResponder(bsllrp.bsllr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.PutBastionShareableLinkFuture", "Result", bsllrp.bsllr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// QosIPRange qos Traffic Profiler IP Range properties.
type QosIPRange struct {
	// StartIP - Start IP Address.
	StartIP *string `json:"startIP,omitempty"`
	// EndIP - End IP Address.
	EndIP *string `json:"endIP,omitempty"`
}

// QosPortRange qos Traffic Profiler Port range properties.
type QosPortRange struct {
	// Start - Qos Port Range start.
	Start *int32 `json:"start,omitempty"`
	// End - Qos Port Range end.
	End *int32 `json:"end,omitempty"`
}

// QueryTroubleshootingParameters parameters that define the resource to query the troubleshooting result.
type QueryTroubleshootingParameters struct {
	// TargetResourceID - The target resource ID to query the troubleshooting result.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
}

// RadiusServer radius Server Settings.
type RadiusServer struct {
	// RadiusServerAddress - The address of this radius server.
	RadiusServerAddress *string `json:"radiusServerAddress,omitempty"`
	// RadiusServerScore - The initial score assigned to this radius server.
	RadiusServerScore *int64 `json:"radiusServerScore,omitempty"`
	// RadiusServerSecret - The secret used for this radius server.
	RadiusServerSecret *string `json:"radiusServerSecret,omitempty"`
}

// RecordSet a collective group of information about the record set information.
type RecordSet struct {
	// RecordType - Resource record type.
	RecordType *string `json:"recordType,omitempty"`
	// RecordSetName - Recordset name.
	RecordSetName *string `json:"recordSetName,omitempty"`
	// Fqdn - Fqdn that resolves to private endpoint ip address.
	Fqdn *string `json:"fqdn,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the recordset. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// TTL - Recordset time to live.
	TTL *int32 `json:"ttl,omitempty"`
	// IPAddresses - The private ip address of the private endpoint.
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
}

// MarshalJSON is the custom marshaler for RecordSet.
func (rs RecordSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rs.RecordType != nil {
		objectMap["recordType"] = rs.RecordType
	}
	if rs.RecordSetName != nil {
		objectMap["recordSetName"] = rs.RecordSetName
	}
	if rs.Fqdn != nil {
		objectMap["fqdn"] = rs.Fqdn
	}
	if rs.TTL != nil {
		objectMap["ttl"] = rs.TTL
	}
	if rs.IPAddresses != nil {
		objectMap["ipAddresses"] = rs.IPAddresses
	}
	return json.Marshal(objectMap)
}

// ReferencedPublicIPAddress reference to a public IP address.
type ReferencedPublicIPAddress struct {
	// ID - The PublicIPAddress Reference.
	ID *string `json:"id,omitempty"`
}

// Resource common resource representation.
type Resource struct {
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.ID != nil {
		objectMap["id"] = r.ID
	}
	if r.Location != nil {
		objectMap["location"] = r.Location
	}
	if r.Tags != nil {
		objectMap["tags"] = r.Tags
	}
	return json.Marshal(objectMap)
}

// ResourceNavigationLink resourceNavigationLink resource.
type ResourceNavigationLink struct {
	// ResourceNavigationLinkFormat - Resource navigation link properties format.
	*ResourceNavigationLinkFormat `json:"properties,omitempty"`
	// Name - Name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceNavigationLink.
func (rnl ResourceNavigationLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rnl.ResourceNavigationLinkFormat != nil {
		objectMap["properties"] = rnl.ResourceNavigationLinkFormat
	}
	if rnl.Name != nil {
		objectMap["name"] = rnl.Name
	}
	if rnl.ID != nil {
		objectMap["id"] = rnl.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ResourceNavigationLink struct.
func (rnl *ResourceNavigationLink) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var resourceNavigationLinkFormat ResourceNavigationLinkFormat
				err = json.Unmarshal(*v, &resourceNavigationLinkFormat)
				if err != nil {
					return err
				}
				rnl.ResourceNavigationLinkFormat = &resourceNavigationLinkFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rnl.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				rnl.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rnl.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rnl.ID = &ID
			}
		}
	}

	return nil
}

// ResourceNavigationLinkFormat properties of ResourceNavigationLink.
type ResourceNavigationLinkFormat struct {
	// LinkedResourceType - Resource type of the linked resource.
	LinkedResourceType *string `json:"linkedResourceType,omitempty"`
	// Link - Link to the external resource.
	Link *string `json:"link,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource navigation link resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceNavigationLinkFormat.
func (rnlf ResourceNavigationLinkFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rnlf.LinkedResourceType != nil {
		objectMap["linkedResourceType"] = rnlf.LinkedResourceType
	}
	if rnlf.Link != nil {
		objectMap["link"] = rnlf.Link
	}
	return json.Marshal(objectMap)
}

// ResourceNavigationLinksListResult response for ResourceNavigationLinks_List operation.
type ResourceNavigationLinksListResult struct {
	autorest.Response `json:"-"`
	// Value - The resource navigation links in a subnet.
	Value *[]ResourceNavigationLink `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceNavigationLinksListResult.
func (rnllr ResourceNavigationLinksListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rnllr.Value != nil {
		objectMap["value"] = rnllr.Value
	}
	return json.Marshal(objectMap)
}

// ResourceSet the base resource set for visibility and auto-approval.
type ResourceSet struct {
	// Subscriptions - The list of subscriptions.
	Subscriptions *[]string `json:"subscriptions,omitempty"`
}

// RetentionPolicyParameters parameters that define the retention policy for flow log.
type RetentionPolicyParameters struct {
	// Days - Number of days to retain flow log records.
	Days *int32 `json:"days,omitempty"`
	// Enabled - Flag to enable/disable retention.
	Enabled *bool `json:"enabled,omitempty"`
}

// Route route resource.
type Route struct {
	autorest.Response `json:"-"`
	// RoutePropertiesFormat - Properties of the route.
	*RoutePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - The type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for Route.
func (r Route) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.RoutePropertiesFormat != nil {
		objectMap["properties"] = r.RoutePropertiesFormat
	}
	if r.Name != nil {
		objectMap["name"] = r.Name
	}
	if r.Type != nil {
		objectMap["type"] = r.Type
	}
	if r.ID != nil {
		objectMap["id"] = r.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Route struct.
func (r *Route) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var routePropertiesFormat RoutePropertiesFormat
				err = json.Unmarshal(*v, &routePropertiesFormat)
				if err != nil {
					return err
				}
				r.RoutePropertiesFormat = &routePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				r.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				r.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				r.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				r.ID = &ID
			}
		}
	}

	return nil
}

// RouteFilter route Filter Resource.
type RouteFilter struct {
	autorest.Response `json:"-"`
	// RouteFilterPropertiesFormat - Properties of the route filter.
	*RouteFilterPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for RouteFilter.
func (rf RouteFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rf.RouteFilterPropertiesFormat != nil {
		objectMap["properties"] = rf.RouteFilterPropertiesFormat
	}
	if rf.ID != nil {
		objectMap["id"] = rf.ID
	}
	if rf.Location != nil {
		objectMap["location"] = rf.Location
	}
	if rf.Tags != nil {
		objectMap["tags"] = rf.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RouteFilter struct.
func (rf *RouteFilter) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var routeFilterPropertiesFormat RouteFilterPropertiesFormat
				err = json.Unmarshal(*v, &routeFilterPropertiesFormat)
				if err != nil {
					return err
				}
				rf.RouteFilterPropertiesFormat = &routeFilterPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				rf.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rf.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rf.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rf.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				rf.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				rf.Tags = tags
			}
		}
	}

	return nil
}

// RouteFilterListResult response for the ListRouteFilters API service call.
type RouteFilterListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of route filters in a resource group.
	Value *[]RouteFilter `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RouteFilterListResultIterator provides access to a complete listing of RouteFilter values.
type RouteFilterListResultIterator struct {
	i    int
	page RouteFilterListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RouteFilterListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RouteFilterListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RouteFilterListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RouteFilterListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RouteFilterListResultIterator) Response() RouteFilterListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RouteFilterListResultIterator) Value() RouteFilter {
	if !iter.page.NotDone() {
		return RouteFilter{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RouteFilterListResultIterator type.
func NewRouteFilterListResultIterator(page RouteFilterListResultPage) RouteFilterListResultIterator {
	return RouteFilterListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rflr RouteFilterListResult) IsEmpty() bool {
	return rflr.Value == nil || len(*rflr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rflr RouteFilterListResult) hasNextLink() bool {
	return rflr.NextLink != nil && len(*rflr.NextLink) != 0
}

// routeFilterListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rflr RouteFilterListResult) routeFilterListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rflr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rflr.NextLink)))
}

// RouteFilterListResultPage contains a page of RouteFilter values.
type RouteFilterListResultPage struct {
	fn   func(context.Context, RouteFilterListResult) (RouteFilterListResult, error)
	rflr RouteFilterListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RouteFilterListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RouteFilterListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rflr)
		if err != nil {
			return err
		}
		page.rflr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RouteFilterListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RouteFilterListResultPage) NotDone() bool {
	return !page.rflr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RouteFilterListResultPage) Response() RouteFilterListResult {
	return page.rflr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RouteFilterListResultPage) Values() []RouteFilter {
	if page.rflr.IsEmpty() {
		return nil
	}
	return *page.rflr.Value
}

// Creates a new instance of the RouteFilterListResultPage type.
func NewRouteFilterListResultPage(cur RouteFilterListResult, getNextPage func(context.Context, RouteFilterListResult) (RouteFilterListResult, error)) RouteFilterListResultPage {
	return RouteFilterListResultPage{
		fn:   getNextPage,
		rflr: cur,
	}
}

// RouteFilterPropertiesFormat route Filter Resource.
type RouteFilterPropertiesFormat struct {
	// Rules - Collection of RouteFilterRules contained within a route filter.
	Rules *[]RouteFilterRule `json:"rules,omitempty"`
	// Peerings - READ-ONLY; A collection of references to express route circuit peerings.
	Peerings *[]ExpressRouteCircuitPeering `json:"peerings,omitempty"`
	// Ipv6Peerings - READ-ONLY; A collection of references to express route circuit ipv6 peerings.
	Ipv6Peerings *[]ExpressRouteCircuitPeering `json:"ipv6Peerings,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the route filter resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for RouteFilterPropertiesFormat.
func (rfpf RouteFilterPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rfpf.Rules != nil {
		objectMap["rules"] = rfpf.Rules
	}
	return json.Marshal(objectMap)
}

// RouteFilterRule route Filter Rule Resource.
type RouteFilterRule struct {
	autorest.Response `json:"-"`
	// RouteFilterRulePropertiesFormat - Properties of the route filter rule.
	*RouteFilterRulePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for RouteFilterRule.
func (rfr RouteFilterRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rfr.RouteFilterRulePropertiesFormat != nil {
		objectMap["properties"] = rfr.RouteFilterRulePropertiesFormat
	}
	if rfr.Name != nil {
		objectMap["name"] = rfr.Name
	}
	if rfr.Location != nil {
		objectMap["location"] = rfr.Location
	}
	if rfr.ID != nil {
		objectMap["id"] = rfr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RouteFilterRule struct.
func (rfr *RouteFilterRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var routeFilterRulePropertiesFormat RouteFilterRulePropertiesFormat
				err = json.Unmarshal(*v, &routeFilterRulePropertiesFormat)
				if err != nil {
					return err
				}
				rfr.RouteFilterRulePropertiesFormat = &routeFilterRulePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rfr.Name = &name
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				rfr.Location = &location
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				rfr.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rfr.ID = &ID
			}
		}
	}

	return nil
}

// RouteFilterRuleListResult response for the ListRouteFilterRules API service call.
type RouteFilterRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of RouteFilterRules in a resource group.
	Value *[]RouteFilterRule `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RouteFilterRuleListResultIterator provides access to a complete listing of RouteFilterRule values.
type RouteFilterRuleListResultIterator struct {
	i    int
	page RouteFilterRuleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RouteFilterRuleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RouteFilterRuleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RouteFilterRuleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RouteFilterRuleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RouteFilterRuleListResultIterator) Response() RouteFilterRuleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RouteFilterRuleListResultIterator) Value() RouteFilterRule {
	if !iter.page.NotDone() {
		return RouteFilterRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RouteFilterRuleListResultIterator type.
func NewRouteFilterRuleListResultIterator(page RouteFilterRuleListResultPage) RouteFilterRuleListResultIterator {
	return RouteFilterRuleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rfrlr RouteFilterRuleListResult) IsEmpty() bool {
	return rfrlr.Value == nil || len(*rfrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rfrlr RouteFilterRuleListResult) hasNextLink() bool {
	return rfrlr.NextLink != nil && len(*rfrlr.NextLink) != 0
}

// routeFilterRuleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rfrlr RouteFilterRuleListResult) routeFilterRuleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rfrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rfrlr.NextLink)))
}

// RouteFilterRuleListResultPage contains a page of RouteFilterRule values.
type RouteFilterRuleListResultPage struct {
	fn    func(context.Context, RouteFilterRuleListResult) (RouteFilterRuleListResult, error)
	rfrlr RouteFilterRuleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RouteFilterRuleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RouteFilterRuleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rfrlr)
		if err != nil {
			return err
		}
		page.rfrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RouteFilterRuleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RouteFilterRuleListResultPage) NotDone() bool {
	return !page.rfrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RouteFilterRuleListResultPage) Response() RouteFilterRuleListResult {
	return page.rfrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RouteFilterRuleListResultPage) Values() []RouteFilterRule {
	if page.rfrlr.IsEmpty() {
		return nil
	}
	return *page.rfrlr.Value
}

// Creates a new instance of the RouteFilterRuleListResultPage type.
func NewRouteFilterRuleListResultPage(cur RouteFilterRuleListResult, getNextPage func(context.Context, RouteFilterRuleListResult) (RouteFilterRuleListResult, error)) RouteFilterRuleListResultPage {
	return RouteFilterRuleListResultPage{
		fn:    getNextPage,
		rfrlr: cur,
	}
}

// RouteFilterRulePropertiesFormat route Filter Rule Resource.
type RouteFilterRulePropertiesFormat struct {
	// Access - The access type of the rule. Possible values include: 'AccessAllow', 'AccessDeny'
	Access Access `json:"access,omitempty"`
	// RouteFilterRuleType - The rule type of the rule.
	RouteFilterRuleType *string `json:"routeFilterRuleType,omitempty"`
	// Communities - The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020'].
	Communities *[]string `json:"communities,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the route filter rule resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for RouteFilterRulePropertiesFormat.
func (rfrpf RouteFilterRulePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rfrpf.Access != "" {
		objectMap["access"] = rfrpf.Access
	}
	if rfrpf.RouteFilterRuleType != nil {
		objectMap["routeFilterRuleType"] = rfrpf.RouteFilterRuleType
	}
	if rfrpf.Communities != nil {
		objectMap["communities"] = rfrpf.Communities
	}
	return json.Marshal(objectMap)
}

// RouteFilterRulesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type RouteFilterRulesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RouteFilterRulesClient) (RouteFilterRule, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RouteFilterRulesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RouteFilterRulesCreateOrUpdateFuture.Result.
func (future *RouteFilterRulesCreateOrUpdateFuture) result(client RouteFilterRulesClient) (rfr RouteFilterRule, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.RouteFilterRulesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rfr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.RouteFilterRulesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rfr.Response.Response, err = future.GetResult(sender); err == nil && rfr.Response.Response.StatusCode != http.StatusNoContent {
		rfr, err = client.CreateOrUpdateResponder(rfr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.RouteFilterRulesCreateOrUpdateFuture", "Result", rfr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RouteFilterRulesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type RouteFilterRulesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RouteFilterRulesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RouteFilterRulesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RouteFilterRulesDeleteFuture.Result.
func (future *RouteFilterRulesDeleteFuture) result(client RouteFilterRulesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.RouteFilterRulesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.RouteFilterRulesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// RouteFiltersCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type RouteFiltersCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RouteFiltersClient) (RouteFilter, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RouteFiltersCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RouteFiltersCreateOrUpdateFuture.Result.
func (future *RouteFiltersCreateOrUpdateFuture) result(client RouteFiltersClient) (rf RouteFilter, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.RouteFiltersCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rf.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.RouteFiltersCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rf.Response.Response, err = future.GetResult(sender); err == nil && rf.Response.Response.StatusCode != http.StatusNoContent {
		rf, err = client.CreateOrUpdateResponder(rf.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.RouteFiltersCreateOrUpdateFuture", "Result", rf.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RouteFiltersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type RouteFiltersDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RouteFiltersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RouteFiltersDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RouteFiltersDeleteFuture.Result.
func (future *RouteFiltersDeleteFuture) result(client RouteFiltersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.RouteFiltersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.RouteFiltersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// RouteListResult response for the ListRoute API service call.
type RouteListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of routes in a resource group.
	Value *[]Route `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RouteListResultIterator provides access to a complete listing of Route values.
type RouteListResultIterator struct {
	i    int
	page RouteListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RouteListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RouteListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RouteListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RouteListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RouteListResultIterator) Response() RouteListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RouteListResultIterator) Value() Route {
	if !iter.page.NotDone() {
		return Route{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RouteListResultIterator type.
func NewRouteListResultIterator(page RouteListResultPage) RouteListResultIterator {
	return RouteListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rlr RouteListResult) IsEmpty() bool {
	return rlr.Value == nil || len(*rlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rlr RouteListResult) hasNextLink() bool {
	return rlr.NextLink != nil && len(*rlr.NextLink) != 0
}

// routeListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rlr RouteListResult) routeListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rlr.NextLink)))
}

// RouteListResultPage contains a page of Route values.
type RouteListResultPage struct {
	fn  func(context.Context, RouteListResult) (RouteListResult, error)
	rlr RouteListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RouteListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RouteListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rlr)
		if err != nil {
			return err
		}
		page.rlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RouteListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RouteListResultPage) NotDone() bool {
	return !page.rlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RouteListResultPage) Response() RouteListResult {
	return page.rlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RouteListResultPage) Values() []Route {
	if page.rlr.IsEmpty() {
		return nil
	}
	return *page.rlr.Value
}

// Creates a new instance of the RouteListResultPage type.
func NewRouteListResultPage(cur RouteListResult, getNextPage func(context.Context, RouteListResult) (RouteListResult, error)) RouteListResultPage {
	return RouteListResultPage{
		fn:  getNextPage,
		rlr: cur,
	}
}

// RoutePropertiesFormat route resource.
type RoutePropertiesFormat struct {
	// AddressPrefix - The destination CIDR to which the route applies.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// NextHopType - The type of Azure hop the packet should be sent to. Possible values include: 'RouteNextHopTypeVirtualNetworkGateway', 'RouteNextHopTypeVnetLocal', 'RouteNextHopTypeInternet', 'RouteNextHopTypeVirtualAppliance', 'RouteNextHopTypeNone'
	NextHopType RouteNextHopType `json:"nextHopType,omitempty"`
	// NextHopIPAddress - The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
	NextHopIPAddress *string `json:"nextHopIpAddress,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the route resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// HasBgpOverride - A value indicating whether this route overrides overlapping BGP routes regardless of LPM.
	HasBgpOverride *bool `json:"hasBgpOverride,omitempty"`
}

// MarshalJSON is the custom marshaler for RoutePropertiesFormat.
func (rpf RoutePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rpf.AddressPrefix != nil {
		objectMap["addressPrefix"] = rpf.AddressPrefix
	}
	if rpf.NextHopType != "" {
		objectMap["nextHopType"] = rpf.NextHopType
	}
	if rpf.NextHopIPAddress != nil {
		objectMap["nextHopIpAddress"] = rpf.NextHopIPAddress
	}
	if rpf.HasBgpOverride != nil {
		objectMap["hasBgpOverride"] = rpf.HasBgpOverride
	}
	return json.Marshal(objectMap)
}

// RoutesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type RoutesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RoutesClient) (Route, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RoutesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RoutesCreateOrUpdateFuture.Result.
func (future *RoutesCreateOrUpdateFuture) result(client RoutesClient) (r Route, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.RoutesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		r.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.RoutesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if r.Response.Response, err = future.GetResult(sender); err == nil && r.Response.Response.StatusCode != http.StatusNoContent {
		r, err = client.CreateOrUpdateResponder(r.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.RoutesCreateOrUpdateFuture", "Result", r.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RoutesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type RoutesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RoutesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RoutesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RoutesDeleteFuture.Result.
func (future *RoutesDeleteFuture) result(client RoutesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.RoutesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.RoutesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// RouteTable route table resource.
type RouteTable struct {
	autorest.Response `json:"-"`
	// RouteTablePropertiesFormat - Properties of the route table.
	*RouteTablePropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for RouteTable.
func (rt RouteTable) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rt.RouteTablePropertiesFormat != nil {
		objectMap["properties"] = rt.RouteTablePropertiesFormat
	}
	if rt.ID != nil {
		objectMap["id"] = rt.ID
	}
	if rt.Location != nil {
		objectMap["location"] = rt.Location
	}
	if rt.Tags != nil {
		objectMap["tags"] = rt.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RouteTable struct.
func (rt *RouteTable) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var routeTablePropertiesFormat RouteTablePropertiesFormat
				err = json.Unmarshal(*v, &routeTablePropertiesFormat)
				if err != nil {
					return err
				}
				rt.RouteTablePropertiesFormat = &routeTablePropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				rt.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rt.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rt.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rt.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				rt.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				rt.Tags = tags
			}
		}
	}

	return nil
}

// RouteTableListResult response for the ListRouteTable API service call.
type RouteTableListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of route tables in a resource group.
	Value *[]RouteTable `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RouteTableListResultIterator provides access to a complete listing of RouteTable values.
type RouteTableListResultIterator struct {
	i    int
	page RouteTableListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RouteTableListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RouteTableListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RouteTableListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RouteTableListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RouteTableListResultIterator) Response() RouteTableListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RouteTableListResultIterator) Value() RouteTable {
	if !iter.page.NotDone() {
		return RouteTable{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RouteTableListResultIterator type.
func NewRouteTableListResultIterator(page RouteTableListResultPage) RouteTableListResultIterator {
	return RouteTableListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rtlr RouteTableListResult) IsEmpty() bool {
	return rtlr.Value == nil || len(*rtlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rtlr RouteTableListResult) hasNextLink() bool {
	return rtlr.NextLink != nil && len(*rtlr.NextLink) != 0
}

// routeTableListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rtlr RouteTableListResult) routeTableListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rtlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rtlr.NextLink)))
}

// RouteTableListResultPage contains a page of RouteTable values.
type RouteTableListResultPage struct {
	fn   func(context.Context, RouteTableListResult) (RouteTableListResult, error)
	rtlr RouteTableListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RouteTableListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RouteTableListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rtlr)
		if err != nil {
			return err
		}
		page.rtlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RouteTableListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RouteTableListResultPage) NotDone() bool {
	return !page.rtlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RouteTableListResultPage) Response() RouteTableListResult {
	return page.rtlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RouteTableListResultPage) Values() []RouteTable {
	if page.rtlr.IsEmpty() {
		return nil
	}
	return *page.rtlr.Value
}

// Creates a new instance of the RouteTableListResultPage type.
func NewRouteTableListResultPage(cur RouteTableListResult, getNextPage func(context.Context, RouteTableListResult) (RouteTableListResult, error)) RouteTableListResultPage {
	return RouteTableListResultPage{
		fn:   getNextPage,
		rtlr: cur,
	}
}

// RouteTablePropertiesFormat route Table resource.
type RouteTablePropertiesFormat struct {
	// Routes - Collection of routes contained within a route table.
	Routes *[]Route `json:"routes,omitempty"`
	// Subnets - READ-ONLY; A collection of references to subnets.
	Subnets *[]Subnet `json:"subnets,omitempty"`
	// DisableBgpRoutePropagation - Whether to disable the routes learned by BGP on that route table. True means disable.
	DisableBgpRoutePropagation *bool `json:"disableBgpRoutePropagation,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the route table resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the route table.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
}

// MarshalJSON is the custom marshaler for RouteTablePropertiesFormat.
func (rtpf RouteTablePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rtpf.Routes != nil {
		objectMap["routes"] = rtpf.Routes
	}
	if rtpf.DisableBgpRoutePropagation != nil {
		objectMap["disableBgpRoutePropagation"] = rtpf.DisableBgpRoutePropagation
	}
	return json.Marshal(objectMap)
}

// RouteTablesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type RouteTablesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RouteTablesClient) (RouteTable, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RouteTablesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RouteTablesCreateOrUpdateFuture.Result.
func (future *RouteTablesCreateOrUpdateFuture) result(client RouteTablesClient) (rt RouteTable, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.RouteTablesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.RouteTablesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rt.Response.Response, err = future.GetResult(sender); err == nil && rt.Response.Response.StatusCode != http.StatusNoContent {
		rt, err = client.CreateOrUpdateResponder(rt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.RouteTablesCreateOrUpdateFuture", "Result", rt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RouteTablesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type RouteTablesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RouteTablesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RouteTablesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RouteTablesDeleteFuture.Result.
func (future *RouteTablesDeleteFuture) result(client RouteTablesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.RouteTablesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.RouteTablesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// RoutingConfiguration routing Configuration indicating the associated and propagated route tables for
// this connection.
type RoutingConfiguration struct {
	// AssociatedRouteTable - The resource id RouteTable associated with this RoutingConfiguration.
	AssociatedRouteTable *SubResource `json:"associatedRouteTable,omitempty"`
	// PropagatedRouteTables - The list of RouteTables to advertise the routes to.
	PropagatedRouteTables *PropagatedRouteTable `json:"propagatedRouteTables,omitempty"`
	// VnetRoutes - List of routes that control routing from VirtualHub into a virtual network connection.
	VnetRoutes *VnetRoute `json:"vnetRoutes,omitempty"`
}

// Rule rule of type network.
type Rule struct {
	// IPProtocols - Array of FirewallPolicyRuleNetworkProtocols.
	IPProtocols *[]FirewallPolicyRuleNetworkProtocol `json:"ipProtocols,omitempty"`
	// SourceAddresses - List of source IP addresses for this rule.
	SourceAddresses *[]string `json:"sourceAddresses,omitempty"`
	// DestinationAddresses - List of destination IP addresses or Service Tags.
	DestinationAddresses *[]string `json:"destinationAddresses,omitempty"`
	// DestinationPorts - List of destination ports.
	DestinationPorts *[]string `json:"destinationPorts,omitempty"`
	// SourceIPGroups - List of source IpGroups for this rule.
	SourceIPGroups *[]string `json:"sourceIpGroups,omitempty"`
	// DestinationIPGroups - List of destination IpGroups for this rule.
	DestinationIPGroups *[]string `json:"destinationIpGroups,omitempty"`
	// DestinationFqdns - List of destination FQDNs.
	DestinationFqdns *[]string `json:"destinationFqdns,omitempty"`
	// Name - Name of the rule.
	Name *string `json:"name,omitempty"`
	// Description - Description of the rule.
	Description *string `json:"description,omitempty"`
	// RuleType - Possible values include: 'RuleTypeFirewallPolicyRule', 'RuleTypeApplicationRule', 'RuleTypeNatRule', 'RuleTypeNetworkRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

// MarshalJSON is the custom marshaler for Rule.
func (r Rule) MarshalJSON() ([]byte, error) {
	r.RuleType = RuleTypeNetworkRule
	objectMap := make(map[string]interface{})
	if r.IPProtocols != nil {
		objectMap["ipProtocols"] = r.IPProtocols
	}
	if r.SourceAddresses != nil {
		objectMap["sourceAddresses"] = r.SourceAddresses
	}
	if r.DestinationAddresses != nil {
		objectMap["destinationAddresses"] = r.DestinationAddresses
	}
	if r.DestinationPorts != nil {
		objectMap["destinationPorts"] = r.DestinationPorts
	}
	if r.SourceIPGroups != nil {
		objectMap["sourceIpGroups"] = r.SourceIPGroups
	}
	if r.DestinationIPGroups != nil {
		objectMap["destinationIpGroups"] = r.DestinationIPGroups
	}
	if r.DestinationFqdns != nil {
		objectMap["destinationFqdns"] = r.DestinationFqdns
	}
	if r.Name != nil {
		objectMap["name"] = r.Name
	}
	if r.Description != nil {
		objectMap["description"] = r.Description
	}
	if r.RuleType != "" {
		objectMap["ruleType"] = r.RuleType
	}
	return json.Marshal(objectMap)
}

// AsApplicationRule is the BasicFirewallPolicyRule implementation for Rule.
func (r Rule) AsApplicationRule() (*ApplicationRule, bool) {
	return nil, false
}

// AsNatRule is the BasicFirewallPolicyRule implementation for Rule.
func (r Rule) AsNatRule() (*NatRule, bool) {
	return nil, false
}

// AsRule is the BasicFirewallPolicyRule implementation for Rule.
func (r Rule) AsRule() (*Rule, bool) {
	return &r, true
}

// AsFirewallPolicyRule is the BasicFirewallPolicyRule implementation for Rule.
func (r Rule) AsFirewallPolicyRule() (*FirewallPolicyRule, bool) {
	return nil, false
}

// AsBasicFirewallPolicyRule is the BasicFirewallPolicyRule implementation for Rule.
func (r Rule) AsBasicFirewallPolicyRule() (BasicFirewallPolicyRule, bool) {
	return &r, true
}

// SecurityGroup networkSecurityGroup resource.
type SecurityGroup struct {
	autorest.Response `json:"-"`
	// SecurityGroupPropertiesFormat - Properties of the network security group.
	*SecurityGroupPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SecurityGroup.
func (sg SecurityGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sg.SecurityGroupPropertiesFormat != nil {
		objectMap["properties"] = sg.SecurityGroupPropertiesFormat
	}
	if sg.ID != nil {
		objectMap["id"] = sg.ID
	}
	if sg.Location != nil {
		objectMap["location"] = sg.Location
	}
	if sg.Tags != nil {
		objectMap["tags"] = sg.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SecurityGroup struct.
func (sg *SecurityGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var securityGroupPropertiesFormat SecurityGroupPropertiesFormat
				err = json.Unmarshal(*v, &securityGroupPropertiesFormat)
				if err != nil {
					return err
				}
				sg.SecurityGroupPropertiesFormat = &securityGroupPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sg.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sg.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sg.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sg.Tags = tags
			}
		}
	}

	return nil
}

// SecurityGroupListResult response for ListNetworkSecurityGroups API service call.
type SecurityGroupListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of NetworkSecurityGroup resources.
	Value *[]SecurityGroup `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// SecurityGroupListResultIterator provides access to a complete listing of SecurityGroup values.
type SecurityGroupListResultIterator struct {
	i    int
	page SecurityGroupListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SecurityGroupListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SecurityGroupListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SecurityGroupListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SecurityGroupListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SecurityGroupListResultIterator) Response() SecurityGroupListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SecurityGroupListResultIterator) Value() SecurityGroup {
	if !iter.page.NotDone() {
		return SecurityGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SecurityGroupListResultIterator type.
func NewSecurityGroupListResultIterator(page SecurityGroupListResultPage) SecurityGroupListResultIterator {
	return SecurityGroupListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sglr SecurityGroupListResult) IsEmpty() bool {
	return sglr.Value == nil || len(*sglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sglr SecurityGroupListResult) hasNextLink() bool {
	return sglr.NextLink != nil && len(*sglr.NextLink) != 0
}

// securityGroupListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sglr SecurityGroupListResult) securityGroupListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !sglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sglr.NextLink)))
}

// SecurityGroupListResultPage contains a page of SecurityGroup values.
type SecurityGroupListResultPage struct {
	fn   func(context.Context, SecurityGroupListResult) (SecurityGroupListResult, error)
	sglr SecurityGroupListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SecurityGroupListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SecurityGroupListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sglr)
		if err != nil {
			return err
		}
		page.sglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SecurityGroupListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SecurityGroupListResultPage) NotDone() bool {
	return !page.sglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SecurityGroupListResultPage) Response() SecurityGroupListResult {
	return page.sglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SecurityGroupListResultPage) Values() []SecurityGroup {
	if page.sglr.IsEmpty() {
		return nil
	}
	return *page.sglr.Value
}

// Creates a new instance of the SecurityGroupListResultPage type.
func NewSecurityGroupListResultPage(cur SecurityGroupListResult, getNextPage func(context.Context, SecurityGroupListResult) (SecurityGroupListResult, error)) SecurityGroupListResultPage {
	return SecurityGroupListResultPage{
		fn:   getNextPage,
		sglr: cur,
	}
}

// SecurityGroupNetworkInterface network interface and all its associated security rules.
type SecurityGroupNetworkInterface struct {
	// ID - ID of the network interface.
	ID *string `json:"id,omitempty"`
	// SecurityRuleAssociations - All security rules associated with the network interface.
	SecurityRuleAssociations *SecurityRuleAssociations `json:"securityRuleAssociations,omitempty"`
}

// SecurityGroupPropertiesFormat network Security Group resource.
type SecurityGroupPropertiesFormat struct {
	// SecurityRules - A collection of security rules of the network security group.
	SecurityRules *[]SecurityRule `json:"securityRules,omitempty"`
	// DefaultSecurityRules - READ-ONLY; The default security rules of network security group.
	DefaultSecurityRules *[]SecurityRule `json:"defaultSecurityRules,omitempty"`
	// NetworkInterfaces - READ-ONLY; A collection of references to network interfaces.
	NetworkInterfaces *[]Interface `json:"networkInterfaces,omitempty"`
	// Subnets - READ-ONLY; A collection of references to subnets.
	Subnets *[]Subnet `json:"subnets,omitempty"`
	// FlowLogs - READ-ONLY; A collection of references to flow log resources.
	FlowLogs *[]FlowLog `json:"flowLogs,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the network security group resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the network security group resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SecurityGroupPropertiesFormat.
func (sgpf SecurityGroupPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgpf.SecurityRules != nil {
		objectMap["securityRules"] = sgpf.SecurityRules
	}
	return json.Marshal(objectMap)
}

// SecurityGroupResult network configuration diagnostic result corresponded provided traffic query.
type SecurityGroupResult struct {
	// SecurityRuleAccessResult - The network traffic is allowed or denied. Possible values include: 'SecurityRuleAccessAllow', 'SecurityRuleAccessDeny'
	SecurityRuleAccessResult SecurityRuleAccess `json:"securityRuleAccessResult,omitempty"`
	// EvaluatedNetworkSecurityGroups - READ-ONLY; List of results network security groups diagnostic.
	EvaluatedNetworkSecurityGroups *[]EvaluatedNetworkSecurityGroup `json:"evaluatedNetworkSecurityGroups,omitempty"`
}

// MarshalJSON is the custom marshaler for SecurityGroupResult.
func (sgr SecurityGroupResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgr.SecurityRuleAccessResult != "" {
		objectMap["securityRuleAccessResult"] = sgr.SecurityRuleAccessResult
	}
	return json.Marshal(objectMap)
}

// SecurityGroupsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SecurityGroupsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SecurityGroupsClient) (SecurityGroup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SecurityGroupsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SecurityGroupsCreateOrUpdateFuture.Result.
func (future *SecurityGroupsCreateOrUpdateFuture) result(client SecurityGroupsClient) (sg SecurityGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SecurityGroupsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SecurityGroupsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sg.Response.Response, err = future.GetResult(sender); err == nil && sg.Response.Response.StatusCode != http.StatusNoContent {
		sg, err = client.CreateOrUpdateResponder(sg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.SecurityGroupsCreateOrUpdateFuture", "Result", sg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SecurityGroupsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SecurityGroupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SecurityGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SecurityGroupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SecurityGroupsDeleteFuture.Result.
func (future *SecurityGroupsDeleteFuture) result(client SecurityGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SecurityGroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SecurityGroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SecurityGroupViewParameters parameters that define the VM to check security groups for.
type SecurityGroupViewParameters struct {
	// TargetResourceID - ID of the target VM.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
}

// SecurityGroupViewResult the information about security rules applied to the specified VM.
type SecurityGroupViewResult struct {
	autorest.Response `json:"-"`
	// NetworkInterfaces - List of network interfaces on the specified VM.
	NetworkInterfaces *[]SecurityGroupNetworkInterface `json:"networkInterfaces,omitempty"`
}

// SecurityPartnerProvider security Partner Provider resource.
type SecurityPartnerProvider struct {
	autorest.Response `json:"-"`
	// SecurityPartnerProviderPropertiesFormat - Properties of the Security Partner Provider.
	*SecurityPartnerProviderPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SecurityPartnerProvider.
func (spp SecurityPartnerProvider) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spp.SecurityPartnerProviderPropertiesFormat != nil {
		objectMap["properties"] = spp.SecurityPartnerProviderPropertiesFormat
	}
	if spp.ID != nil {
		objectMap["id"] = spp.ID
	}
	if spp.Location != nil {
		objectMap["location"] = spp.Location
	}
	if spp.Tags != nil {
		objectMap["tags"] = spp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SecurityPartnerProvider struct.
func (spp *SecurityPartnerProvider) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var securityPartnerProviderPropertiesFormat SecurityPartnerProviderPropertiesFormat
				err = json.Unmarshal(*v, &securityPartnerProviderPropertiesFormat)
				if err != nil {
					return err
				}
				spp.SecurityPartnerProviderPropertiesFormat = &securityPartnerProviderPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				spp.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				spp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				spp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				spp.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				spp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				spp.Tags = tags
			}
		}
	}

	return nil
}

// SecurityPartnerProviderListResult response for ListSecurityPartnerProviders API service call.
type SecurityPartnerProviderListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Security Partner Providers in a resource group.
	Value *[]SecurityPartnerProvider `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// SecurityPartnerProviderListResultIterator provides access to a complete listing of
// SecurityPartnerProvider values.
type SecurityPartnerProviderListResultIterator struct {
	i    int
	page SecurityPartnerProviderListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SecurityPartnerProviderListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SecurityPartnerProviderListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SecurityPartnerProviderListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SecurityPartnerProviderListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SecurityPartnerProviderListResultIterator) Response() SecurityPartnerProviderListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SecurityPartnerProviderListResultIterator) Value() SecurityPartnerProvider {
	if !iter.page.NotDone() {
		return SecurityPartnerProvider{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SecurityPartnerProviderListResultIterator type.
func NewSecurityPartnerProviderListResultIterator(page SecurityPartnerProviderListResultPage) SecurityPartnerProviderListResultIterator {
	return SecurityPartnerProviderListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (spplr SecurityPartnerProviderListResult) IsEmpty() bool {
	return spplr.Value == nil || len(*spplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (spplr SecurityPartnerProviderListResult) hasNextLink() bool {
	return spplr.NextLink != nil && len(*spplr.NextLink) != 0
}

// securityPartnerProviderListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (spplr SecurityPartnerProviderListResult) securityPartnerProviderListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !spplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(spplr.NextLink)))
}

// SecurityPartnerProviderListResultPage contains a page of SecurityPartnerProvider values.
type SecurityPartnerProviderListResultPage struct {
	fn    func(context.Context, SecurityPartnerProviderListResult) (SecurityPartnerProviderListResult, error)
	spplr SecurityPartnerProviderListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SecurityPartnerProviderListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SecurityPartnerProviderListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.spplr)
		if err != nil {
			return err
		}
		page.spplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SecurityPartnerProviderListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SecurityPartnerProviderListResultPage) NotDone() bool {
	return !page.spplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SecurityPartnerProviderListResultPage) Response() SecurityPartnerProviderListResult {
	return page.spplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SecurityPartnerProviderListResultPage) Values() []SecurityPartnerProvider {
	if page.spplr.IsEmpty() {
		return nil
	}
	return *page.spplr.Value
}

// Creates a new instance of the SecurityPartnerProviderListResultPage type.
func NewSecurityPartnerProviderListResultPage(cur SecurityPartnerProviderListResult, getNextPage func(context.Context, SecurityPartnerProviderListResult) (SecurityPartnerProviderListResult, error)) SecurityPartnerProviderListResultPage {
	return SecurityPartnerProviderListResultPage{
		fn:    getNextPage,
		spplr: cur,
	}
}

// SecurityPartnerProviderPropertiesFormat properties of the Security Partner Provider.
type SecurityPartnerProviderPropertiesFormat struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the Security Partner Provider resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// SecurityProviderName - The security provider name. Possible values include: 'SecurityProviderNameZScaler', 'SecurityProviderNameIBoss', 'SecurityProviderNameCheckpoint'
	SecurityProviderName SecurityProviderName `json:"securityProviderName,omitempty"`
	// ConnectionStatus - READ-ONLY; The connection status with the Security Partner Provider. Possible values include: 'SecurityPartnerProviderConnectionStatusUnknown', 'SecurityPartnerProviderConnectionStatusPartiallyConnected', 'SecurityPartnerProviderConnectionStatusConnected', 'SecurityPartnerProviderConnectionStatusNotConnected'
	ConnectionStatus SecurityPartnerProviderConnectionStatus `json:"connectionStatus,omitempty"`
	// VirtualHub - The virtualHub to which the Security Partner Provider belongs.
	VirtualHub *SubResource `json:"virtualHub,omitempty"`
}

// MarshalJSON is the custom marshaler for SecurityPartnerProviderPropertiesFormat.
func (spppf SecurityPartnerProviderPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spppf.SecurityProviderName != "" {
		objectMap["securityProviderName"] = spppf.SecurityProviderName
	}
	if spppf.VirtualHub != nil {
		objectMap["virtualHub"] = spppf.VirtualHub
	}
	return json.Marshal(objectMap)
}

// SecurityPartnerProvidersCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type SecurityPartnerProvidersCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SecurityPartnerProvidersClient) (SecurityPartnerProvider, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SecurityPartnerProvidersCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SecurityPartnerProvidersCreateOrUpdateFuture.Result.
func (future *SecurityPartnerProvidersCreateOrUpdateFuture) result(client SecurityPartnerProvidersClient) (spp SecurityPartnerProvider, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SecurityPartnerProvidersCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		spp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SecurityPartnerProvidersCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if spp.Response.Response, err = future.GetResult(sender); err == nil && spp.Response.Response.StatusCode != http.StatusNoContent {
		spp, err = client.CreateOrUpdateResponder(spp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.SecurityPartnerProvidersCreateOrUpdateFuture", "Result", spp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SecurityPartnerProvidersDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SecurityPartnerProvidersDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SecurityPartnerProvidersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SecurityPartnerProvidersDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SecurityPartnerProvidersDeleteFuture.Result.
func (future *SecurityPartnerProvidersDeleteFuture) result(client SecurityPartnerProvidersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SecurityPartnerProvidersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SecurityPartnerProvidersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SecurityRule network security rule.
type SecurityRule struct {
	autorest.Response `json:"-"`
	// SecurityRulePropertiesFormat - Properties of the security rule.
	*SecurityRulePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - The type of the resource.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for SecurityRule.
func (sr SecurityRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.SecurityRulePropertiesFormat != nil {
		objectMap["properties"] = sr.SecurityRulePropertiesFormat
	}
	if sr.Name != nil {
		objectMap["name"] = sr.Name
	}
	if sr.Type != nil {
		objectMap["type"] = sr.Type
	}
	if sr.ID != nil {
		objectMap["id"] = sr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SecurityRule struct.
func (sr *SecurityRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var securityRulePropertiesFormat SecurityRulePropertiesFormat
				err = json.Unmarshal(*v, &securityRulePropertiesFormat)
				if err != nil {
					return err
				}
				sr.SecurityRulePropertiesFormat = &securityRulePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sr.ID = &ID
			}
		}
	}

	return nil
}

// SecurityRuleAssociations all security rules associated with the network interface.
type SecurityRuleAssociations struct {
	// NetworkInterfaceAssociation - Network interface and it's custom security rules.
	NetworkInterfaceAssociation *InterfaceAssociation `json:"networkInterfaceAssociation,omitempty"`
	// SubnetAssociation - Subnet and it's custom security rules.
	SubnetAssociation *SubnetAssociation `json:"subnetAssociation,omitempty"`
	// DefaultSecurityRules - Collection of default security rules of the network security group.
	DefaultSecurityRules *[]SecurityRule `json:"defaultSecurityRules,omitempty"`
	// EffectiveSecurityRules - Collection of effective security rules.
	EffectiveSecurityRules *[]EffectiveNetworkSecurityRule `json:"effectiveSecurityRules,omitempty"`
}

// SecurityRuleListResult response for ListSecurityRule API service call. Retrieves all security rules that
// belongs to a network security group.
type SecurityRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - The security rules in a network security group.
	Value *[]SecurityRule `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// SecurityRuleListResultIterator provides access to a complete listing of SecurityRule values.
type SecurityRuleListResultIterator struct {
	i    int
	page SecurityRuleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SecurityRuleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SecurityRuleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SecurityRuleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SecurityRuleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SecurityRuleListResultIterator) Response() SecurityRuleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SecurityRuleListResultIterator) Value() SecurityRule {
	if !iter.page.NotDone() {
		return SecurityRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SecurityRuleListResultIterator type.
func NewSecurityRuleListResultIterator(page SecurityRuleListResultPage) SecurityRuleListResultIterator {
	return SecurityRuleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (srlr SecurityRuleListResult) IsEmpty() bool {
	return srlr.Value == nil || len(*srlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (srlr SecurityRuleListResult) hasNextLink() bool {
	return srlr.NextLink != nil && len(*srlr.NextLink) != 0
}

// securityRuleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (srlr SecurityRuleListResult) securityRuleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !srlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(srlr.NextLink)))
}

// SecurityRuleListResultPage contains a page of SecurityRule values.
type SecurityRuleListResultPage struct {
	fn   func(context.Context, SecurityRuleListResult) (SecurityRuleListResult, error)
	srlr SecurityRuleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SecurityRuleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SecurityRuleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.srlr)
		if err != nil {
			return err
		}
		page.srlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SecurityRuleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SecurityRuleListResultPage) NotDone() bool {
	return !page.srlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SecurityRuleListResultPage) Response() SecurityRuleListResult {
	return page.srlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SecurityRuleListResultPage) Values() []SecurityRule {
	if page.srlr.IsEmpty() {
		return nil
	}
	return *page.srlr.Value
}

// Creates a new instance of the SecurityRuleListResultPage type.
func NewSecurityRuleListResultPage(cur SecurityRuleListResult, getNextPage func(context.Context, SecurityRuleListResult) (SecurityRuleListResult, error)) SecurityRuleListResultPage {
	return SecurityRuleListResultPage{
		fn:   getNextPage,
		srlr: cur,
	}
}

// SecurityRulePropertiesFormat security rule resource.
type SecurityRulePropertiesFormat struct {
	// Description - A description for this rule. Restricted to 140 chars.
	Description *string `json:"description,omitempty"`
	// Protocol - Network protocol this rule applies to. Possible values include: 'SecurityRuleProtocolTCP', 'SecurityRuleProtocolUDP', 'SecurityRuleProtocolIcmp', 'SecurityRuleProtocolEsp', 'SecurityRuleProtocolAsterisk', 'SecurityRuleProtocolAh'
	Protocol SecurityRuleProtocol `json:"protocol,omitempty"`
	// SourcePortRange - The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	SourcePortRange *string `json:"sourcePortRange,omitempty"`
	// DestinationPortRange - The destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
	DestinationPortRange *string `json:"destinationPortRange,omitempty"`
	// SourceAddressPrefix - The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from.
	SourceAddressPrefix *string `json:"sourceAddressPrefix,omitempty"`
	// SourceAddressPrefixes - The CIDR or source IP ranges.
	SourceAddressPrefixes *[]string `json:"sourceAddressPrefixes,omitempty"`
	// SourceApplicationSecurityGroups - The application security group specified as source.
	SourceApplicationSecurityGroups *[]ApplicationSecurityGroup `json:"sourceApplicationSecurityGroups,omitempty"`
	// DestinationAddressPrefix - The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
	DestinationAddressPrefix *string `json:"destinationAddressPrefix,omitempty"`
	// DestinationAddressPrefixes - The destination address prefixes. CIDR or destination IP ranges.
	DestinationAddressPrefixes *[]string `json:"destinationAddressPrefixes,omitempty"`
	// DestinationApplicationSecurityGroups - The application security group specified as destination.
	DestinationApplicationSecurityGroups *[]ApplicationSecurityGroup `json:"destinationApplicationSecurityGroups,omitempty"`
	// SourcePortRanges - The source port ranges.
	SourcePortRanges *[]string `json:"sourcePortRanges,omitempty"`
	// DestinationPortRanges - The destination port ranges.
	DestinationPortRanges *[]string `json:"destinationPortRanges,omitempty"`
	// Access - The network traffic is allowed or denied. Possible values include: 'SecurityRuleAccessAllow', 'SecurityRuleAccessDeny'
	Access SecurityRuleAccess `json:"access,omitempty"`
	// Priority - The priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
	Priority *int32 `json:"priority,omitempty"`
	// Direction - The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values include: 'SecurityRuleDirectionInbound', 'SecurityRuleDirectionOutbound'
	Direction SecurityRuleDirection `json:"direction,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the security rule resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SecurityRulePropertiesFormat.
func (srpf SecurityRulePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if srpf.Description != nil {
		objectMap["description"] = srpf.Description
	}
	if srpf.Protocol != "" {
		objectMap["protocol"] = srpf.Protocol
	}
	if srpf.SourcePortRange != nil {
		objectMap["sourcePortRange"] = srpf.SourcePortRange
	}
	if srpf.DestinationPortRange != nil {
		objectMap["destinationPortRange"] = srpf.DestinationPortRange
	}
	if srpf.SourceAddressPrefix != nil {
		objectMap["sourceAddressPrefix"] = srpf.SourceAddressPrefix
	}
	if srpf.SourceAddressPrefixes != nil {
		objectMap["sourceAddressPrefixes"] = srpf.SourceAddressPrefixes
	}
	if srpf.SourceApplicationSecurityGroups != nil {
		objectMap["sourceApplicationSecurityGroups"] = srpf.SourceApplicationSecurityGroups
	}
	if srpf.DestinationAddressPrefix != nil {
		objectMap["destinationAddressPrefix"] = srpf.DestinationAddressPrefix
	}
	if srpf.DestinationAddressPrefixes != nil {
		objectMap["destinationAddressPrefixes"] = srpf.DestinationAddressPrefixes
	}
	if srpf.DestinationApplicationSecurityGroups != nil {
		objectMap["destinationApplicationSecurityGroups"] = srpf.DestinationApplicationSecurityGroups
	}
	if srpf.SourcePortRanges != nil {
		objectMap["sourcePortRanges"] = srpf.SourcePortRanges
	}
	if srpf.DestinationPortRanges != nil {
		objectMap["destinationPortRanges"] = srpf.DestinationPortRanges
	}
	if srpf.Access != "" {
		objectMap["access"] = srpf.Access
	}
	if srpf.Priority != nil {
		objectMap["priority"] = srpf.Priority
	}
	if srpf.Direction != "" {
		objectMap["direction"] = srpf.Direction
	}
	return json.Marshal(objectMap)
}

// SecurityRulesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SecurityRulesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SecurityRulesClient) (SecurityRule, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SecurityRulesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SecurityRulesCreateOrUpdateFuture.Result.
func (future *SecurityRulesCreateOrUpdateFuture) result(client SecurityRulesClient) (sr SecurityRule, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SecurityRulesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SecurityRulesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sr.Response.Response, err = future.GetResult(sender); err == nil && sr.Response.Response.StatusCode != http.StatusNoContent {
		sr, err = client.CreateOrUpdateResponder(sr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.SecurityRulesCreateOrUpdateFuture", "Result", sr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SecurityRulesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SecurityRulesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SecurityRulesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SecurityRulesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SecurityRulesDeleteFuture.Result.
func (future *SecurityRulesDeleteFuture) result(client SecurityRulesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SecurityRulesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SecurityRulesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SecurityRulesEvaluationResult network security rules evaluation result.
type SecurityRulesEvaluationResult struct {
	// Name - Name of the network security rule.
	Name *string `json:"name,omitempty"`
	// ProtocolMatched - Value indicating whether protocol is matched.
	ProtocolMatched *bool `json:"protocolMatched,omitempty"`
	// SourceMatched - Value indicating whether source is matched.
	SourceMatched *bool `json:"sourceMatched,omitempty"`
	// SourcePortMatched - Value indicating whether source port is matched.
	SourcePortMatched *bool `json:"sourcePortMatched,omitempty"`
	// DestinationMatched - Value indicating whether destination is matched.
	DestinationMatched *bool `json:"destinationMatched,omitempty"`
	// DestinationPortMatched - Value indicating whether destination port is matched.
	DestinationPortMatched *bool `json:"destinationPortMatched,omitempty"`
}

// ServiceAssociationLink serviceAssociationLink resource.
type ServiceAssociationLink struct {
	// ServiceAssociationLinkPropertiesFormat - Resource navigation link properties format.
	*ServiceAssociationLinkPropertiesFormat `json:"properties,omitempty"`
	// Name - Name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceAssociationLink.
func (sal ServiceAssociationLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sal.ServiceAssociationLinkPropertiesFormat != nil {
		objectMap["properties"] = sal.ServiceAssociationLinkPropertiesFormat
	}
	if sal.Name != nil {
		objectMap["name"] = sal.Name
	}
	if sal.ID != nil {
		objectMap["id"] = sal.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServiceAssociationLink struct.
func (sal *ServiceAssociationLink) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serviceAssociationLinkPropertiesFormat ServiceAssociationLinkPropertiesFormat
				err = json.Unmarshal(*v, &serviceAssociationLinkPropertiesFormat)
				if err != nil {
					return err
				}
				sal.ServiceAssociationLinkPropertiesFormat = &serviceAssociationLinkPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sal.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sal.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sal.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sal.ID = &ID
			}
		}
	}

	return nil
}

// ServiceAssociationLinkPropertiesFormat properties of ServiceAssociationLink.
type ServiceAssociationLinkPropertiesFormat struct {
	// LinkedResourceType - Resource type of the linked resource.
	LinkedResourceType *string `json:"linkedResourceType,omitempty"`
	// Link - Link to the external resource.
	Link *string `json:"link,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the service association link resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// AllowDelete - If true, the resource can be deleted.
	AllowDelete *bool `json:"allowDelete,omitempty"`
	// Locations - A list of locations.
	Locations *[]string `json:"locations,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceAssociationLinkPropertiesFormat.
func (salpf ServiceAssociationLinkPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if salpf.LinkedResourceType != nil {
		objectMap["linkedResourceType"] = salpf.LinkedResourceType
	}
	if salpf.Link != nil {
		objectMap["link"] = salpf.Link
	}
	if salpf.AllowDelete != nil {
		objectMap["allowDelete"] = salpf.AllowDelete
	}
	if salpf.Locations != nil {
		objectMap["locations"] = salpf.Locations
	}
	return json.Marshal(objectMap)
}

// ServiceAssociationLinksListResult response for ServiceAssociationLinks_List operation.
type ServiceAssociationLinksListResult struct {
	autorest.Response `json:"-"`
	// Value - The service association links in a subnet.
	Value *[]ServiceAssociationLink `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceAssociationLinksListResult.
func (sallr ServiceAssociationLinksListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sallr.Value != nil {
		objectMap["value"] = sallr.Value
	}
	return json.Marshal(objectMap)
}

// ServiceDelegationPropertiesFormat properties of a service delegation.
type ServiceDelegationPropertiesFormat struct {
	// ServiceName - The name of the service to whom the subnet should be delegated (e.g. Microsoft.Sql/servers).
	ServiceName *string `json:"serviceName,omitempty"`
	// Actions - READ-ONLY; The actions permitted to the service upon delegation.
	Actions *[]string `json:"actions,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the service delegation resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceDelegationPropertiesFormat.
func (sdpf ServiceDelegationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sdpf.ServiceName != nil {
		objectMap["serviceName"] = sdpf.ServiceName
	}
	return json.Marshal(objectMap)
}

// ServiceEndpointPoliciesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type ServiceEndpointPoliciesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServiceEndpointPoliciesClient) (ServiceEndpointPolicy, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServiceEndpointPoliciesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServiceEndpointPoliciesCreateOrUpdateFuture.Result.
func (future *ServiceEndpointPoliciesCreateOrUpdateFuture) result(client ServiceEndpointPoliciesClient) (sep ServiceEndpointPolicy, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ServiceEndpointPoliciesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sep.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ServiceEndpointPoliciesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sep.Response.Response, err = future.GetResult(sender); err == nil && sep.Response.Response.StatusCode != http.StatusNoContent {
		sep, err = client.CreateOrUpdateResponder(sep.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ServiceEndpointPoliciesCreateOrUpdateFuture", "Result", sep.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ServiceEndpointPoliciesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ServiceEndpointPoliciesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServiceEndpointPoliciesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServiceEndpointPoliciesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServiceEndpointPoliciesDeleteFuture.Result.
func (future *ServiceEndpointPoliciesDeleteFuture) result(client ServiceEndpointPoliciesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ServiceEndpointPoliciesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ServiceEndpointPoliciesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServiceEndpointPolicy service End point policy resource.
type ServiceEndpointPolicy struct {
	autorest.Response `json:"-"`
	// ServiceEndpointPolicyPropertiesFormat - Properties of the service end point policy.
	*ServiceEndpointPolicyPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Kind - READ-ONLY; Kind of service endpoint policy. This is metadata used for the Azure portal experience.
	Kind *string `json:"kind,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ServiceEndpointPolicy.
func (sep ServiceEndpointPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sep.ServiceEndpointPolicyPropertiesFormat != nil {
		objectMap["properties"] = sep.ServiceEndpointPolicyPropertiesFormat
	}
	if sep.ID != nil {
		objectMap["id"] = sep.ID
	}
	if sep.Location != nil {
		objectMap["location"] = sep.Location
	}
	if sep.Tags != nil {
		objectMap["tags"] = sep.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServiceEndpointPolicy struct.
func (sep *ServiceEndpointPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serviceEndpointPolicyPropertiesFormat ServiceEndpointPolicyPropertiesFormat
				err = json.Unmarshal(*v, &serviceEndpointPolicyPropertiesFormat)
				if err != nil {
					return err
				}
				sep.ServiceEndpointPolicyPropertiesFormat = &serviceEndpointPolicyPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sep.Etag = &etag
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sep.Kind = &kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sep.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sep.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sep.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sep.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sep.Tags = tags
			}
		}
	}

	return nil
}

// ServiceEndpointPolicyDefinition service Endpoint policy definitions.
type ServiceEndpointPolicyDefinition struct {
	autorest.Response `json:"-"`
	// ServiceEndpointPolicyDefinitionPropertiesFormat - Properties of the service endpoint policy definition.
	*ServiceEndpointPolicyDefinitionPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceEndpointPolicyDefinition.
func (sepd ServiceEndpointPolicyDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sepd.ServiceEndpointPolicyDefinitionPropertiesFormat != nil {
		objectMap["properties"] = sepd.ServiceEndpointPolicyDefinitionPropertiesFormat
	}
	if sepd.Name != nil {
		objectMap["name"] = sepd.Name
	}
	if sepd.ID != nil {
		objectMap["id"] = sepd.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServiceEndpointPolicyDefinition struct.
func (sepd *ServiceEndpointPolicyDefinition) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serviceEndpointPolicyDefinitionPropertiesFormat ServiceEndpointPolicyDefinitionPropertiesFormat
				err = json.Unmarshal(*v, &serviceEndpointPolicyDefinitionPropertiesFormat)
				if err != nil {
					return err
				}
				sepd.ServiceEndpointPolicyDefinitionPropertiesFormat = &serviceEndpointPolicyDefinitionPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sepd.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				sepd.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sepd.ID = &ID
			}
		}
	}

	return nil
}

// ServiceEndpointPolicyDefinitionListResult response for ListServiceEndpointPolicyDefinition API service
// call. Retrieves all service endpoint policy definition that belongs to a service endpoint policy.
type ServiceEndpointPolicyDefinitionListResult struct {
	autorest.Response `json:"-"`
	// Value - The service endpoint policy definition in a service endpoint policy.
	Value *[]ServiceEndpointPolicyDefinition `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ServiceEndpointPolicyDefinitionListResultIterator provides access to a complete listing of
// ServiceEndpointPolicyDefinition values.
type ServiceEndpointPolicyDefinitionListResultIterator struct {
	i    int
	page ServiceEndpointPolicyDefinitionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ServiceEndpointPolicyDefinitionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServiceEndpointPolicyDefinitionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ServiceEndpointPolicyDefinitionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ServiceEndpointPolicyDefinitionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ServiceEndpointPolicyDefinitionListResultIterator) Response() ServiceEndpointPolicyDefinitionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ServiceEndpointPolicyDefinitionListResultIterator) Value() ServiceEndpointPolicyDefinition {
	if !iter.page.NotDone() {
		return ServiceEndpointPolicyDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ServiceEndpointPolicyDefinitionListResultIterator type.
func NewServiceEndpointPolicyDefinitionListResultIterator(page ServiceEndpointPolicyDefinitionListResultPage) ServiceEndpointPolicyDefinitionListResultIterator {
	return ServiceEndpointPolicyDefinitionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sepdlr ServiceEndpointPolicyDefinitionListResult) IsEmpty() bool {
	return sepdlr.Value == nil || len(*sepdlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sepdlr ServiceEndpointPolicyDefinitionListResult) hasNextLink() bool {
	return sepdlr.NextLink != nil && len(*sepdlr.NextLink) != 0
}

// serviceEndpointPolicyDefinitionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sepdlr ServiceEndpointPolicyDefinitionListResult) serviceEndpointPolicyDefinitionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !sepdlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sepdlr.NextLink)))
}

// ServiceEndpointPolicyDefinitionListResultPage contains a page of ServiceEndpointPolicyDefinition values.
type ServiceEndpointPolicyDefinitionListResultPage struct {
	fn     func(context.Context, ServiceEndpointPolicyDefinitionListResult) (ServiceEndpointPolicyDefinitionListResult, error)
	sepdlr ServiceEndpointPolicyDefinitionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ServiceEndpointPolicyDefinitionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServiceEndpointPolicyDefinitionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sepdlr)
		if err != nil {
			return err
		}
		page.sepdlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ServiceEndpointPolicyDefinitionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ServiceEndpointPolicyDefinitionListResultPage) NotDone() bool {
	return !page.sepdlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ServiceEndpointPolicyDefinitionListResultPage) Response() ServiceEndpointPolicyDefinitionListResult {
	return page.sepdlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ServiceEndpointPolicyDefinitionListResultPage) Values() []ServiceEndpointPolicyDefinition {
	if page.sepdlr.IsEmpty() {
		return nil
	}
	return *page.sepdlr.Value
}

// Creates a new instance of the ServiceEndpointPolicyDefinitionListResultPage type.
func NewServiceEndpointPolicyDefinitionListResultPage(cur ServiceEndpointPolicyDefinitionListResult, getNextPage func(context.Context, ServiceEndpointPolicyDefinitionListResult) (ServiceEndpointPolicyDefinitionListResult, error)) ServiceEndpointPolicyDefinitionListResultPage {
	return ServiceEndpointPolicyDefinitionListResultPage{
		fn:     getNextPage,
		sepdlr: cur,
	}
}

// ServiceEndpointPolicyDefinitionPropertiesFormat service Endpoint policy definition resource.
type ServiceEndpointPolicyDefinitionPropertiesFormat struct {
	// Description - A description for this rule. Restricted to 140 chars.
	Description *string `json:"description,omitempty"`
	// Service - Service endpoint name.
	Service *string `json:"service,omitempty"`
	// ServiceResources - A list of service resources.
	ServiceResources *[]string `json:"serviceResources,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the service endpoint policy definition resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceEndpointPolicyDefinitionPropertiesFormat.
func (sepdpf ServiceEndpointPolicyDefinitionPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sepdpf.Description != nil {
		objectMap["description"] = sepdpf.Description
	}
	if sepdpf.Service != nil {
		objectMap["service"] = sepdpf.Service
	}
	if sepdpf.ServiceResources != nil {
		objectMap["serviceResources"] = sepdpf.ServiceResources
	}
	return json.Marshal(objectMap)
}

// ServiceEndpointPolicyDefinitionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type ServiceEndpointPolicyDefinitionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServiceEndpointPolicyDefinitionsClient) (ServiceEndpointPolicyDefinition, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServiceEndpointPolicyDefinitionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServiceEndpointPolicyDefinitionsCreateOrUpdateFuture.Result.
func (future *ServiceEndpointPolicyDefinitionsCreateOrUpdateFuture) result(client ServiceEndpointPolicyDefinitionsClient) (sepd ServiceEndpointPolicyDefinition, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ServiceEndpointPolicyDefinitionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sepd.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ServiceEndpointPolicyDefinitionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sepd.Response.Response, err = future.GetResult(sender); err == nil && sepd.Response.Response.StatusCode != http.StatusNoContent {
		sepd, err = client.CreateOrUpdateResponder(sepd.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.ServiceEndpointPolicyDefinitionsCreateOrUpdateFuture", "Result", sepd.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ServiceEndpointPolicyDefinitionsDeleteFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type ServiceEndpointPolicyDefinitionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServiceEndpointPolicyDefinitionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServiceEndpointPolicyDefinitionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServiceEndpointPolicyDefinitionsDeleteFuture.Result.
func (future *ServiceEndpointPolicyDefinitionsDeleteFuture) result(client ServiceEndpointPolicyDefinitionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.ServiceEndpointPolicyDefinitionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.ServiceEndpointPolicyDefinitionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServiceEndpointPolicyListResult response for ListServiceEndpointPolicies API service call.
type ServiceEndpointPolicyListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of ServiceEndpointPolicy resources.
	Value *[]ServiceEndpointPolicy `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceEndpointPolicyListResult.
func (seplr ServiceEndpointPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if seplr.Value != nil {
		objectMap["value"] = seplr.Value
	}
	return json.Marshal(objectMap)
}

// ServiceEndpointPolicyListResultIterator provides access to a complete listing of ServiceEndpointPolicy
// values.
type ServiceEndpointPolicyListResultIterator struct {
	i    int
	page ServiceEndpointPolicyListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ServiceEndpointPolicyListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServiceEndpointPolicyListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ServiceEndpointPolicyListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ServiceEndpointPolicyListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ServiceEndpointPolicyListResultIterator) Response() ServiceEndpointPolicyListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ServiceEndpointPolicyListResultIterator) Value() ServiceEndpointPolicy {
	if !iter.page.NotDone() {
		return ServiceEndpointPolicy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ServiceEndpointPolicyListResultIterator type.
func NewServiceEndpointPolicyListResultIterator(page ServiceEndpointPolicyListResultPage) ServiceEndpointPolicyListResultIterator {
	return ServiceEndpointPolicyListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (seplr ServiceEndpointPolicyListResult) IsEmpty() bool {
	return seplr.Value == nil || len(*seplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (seplr ServiceEndpointPolicyListResult) hasNextLink() bool {
	return seplr.NextLink != nil && len(*seplr.NextLink) != 0
}

// serviceEndpointPolicyListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (seplr ServiceEndpointPolicyListResult) serviceEndpointPolicyListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !seplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(seplr.NextLink)))
}

// ServiceEndpointPolicyListResultPage contains a page of ServiceEndpointPolicy values.
type ServiceEndpointPolicyListResultPage struct {
	fn    func(context.Context, ServiceEndpointPolicyListResult) (ServiceEndpointPolicyListResult, error)
	seplr ServiceEndpointPolicyListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ServiceEndpointPolicyListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServiceEndpointPolicyListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.seplr)
		if err != nil {
			return err
		}
		page.seplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ServiceEndpointPolicyListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ServiceEndpointPolicyListResultPage) NotDone() bool {
	return !page.seplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ServiceEndpointPolicyListResultPage) Response() ServiceEndpointPolicyListResult {
	return page.seplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ServiceEndpointPolicyListResultPage) Values() []ServiceEndpointPolicy {
	if page.seplr.IsEmpty() {
		return nil
	}
	return *page.seplr.Value
}

// Creates a new instance of the ServiceEndpointPolicyListResultPage type.
func NewServiceEndpointPolicyListResultPage(cur ServiceEndpointPolicyListResult, getNextPage func(context.Context, ServiceEndpointPolicyListResult) (ServiceEndpointPolicyListResult, error)) ServiceEndpointPolicyListResultPage {
	return ServiceEndpointPolicyListResultPage{
		fn:    getNextPage,
		seplr: cur,
	}
}

// ServiceEndpointPolicyPropertiesFormat service Endpoint Policy resource.
type ServiceEndpointPolicyPropertiesFormat struct {
	// ServiceEndpointPolicyDefinitions - A collection of service endpoint policy definitions of the service endpoint policy.
	ServiceEndpointPolicyDefinitions *[]ServiceEndpointPolicyDefinition `json:"serviceEndpointPolicyDefinitions,omitempty"`
	// Subnets - READ-ONLY; A collection of references to subnets.
	Subnets *[]Subnet `json:"subnets,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the service endpoint policy resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the service endpoint policy resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceEndpointPolicyPropertiesFormat.
func (seppf ServiceEndpointPolicyPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if seppf.ServiceEndpointPolicyDefinitions != nil {
		objectMap["serviceEndpointPolicyDefinitions"] = seppf.ServiceEndpointPolicyDefinitions
	}
	return json.Marshal(objectMap)
}

// ServiceEndpointPropertiesFormat the service endpoint properties.
type ServiceEndpointPropertiesFormat struct {
	// Service - The type of the endpoint service.
	Service *string `json:"service,omitempty"`
	// Locations - A list of locations.
	Locations *[]string `json:"locations,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the service endpoint resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceEndpointPropertiesFormat.
func (sepf ServiceEndpointPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sepf.Service != nil {
		objectMap["service"] = sepf.Service
	}
	if sepf.Locations != nil {
		objectMap["locations"] = sepf.Locations
	}
	return json.Marshal(objectMap)
}

// ServiceTagInformation the service tag information.
type ServiceTagInformation struct {
	// Properties - READ-ONLY; Properties of the service tag information.
	Properties *ServiceTagInformationPropertiesFormat `json:"properties,omitempty"`
	// Name - READ-ONLY; The name of service tag.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; The ID of service tag.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceTagInformation.
func (sti ServiceTagInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ServiceTagInformationPropertiesFormat properties of the service tag information.
type ServiceTagInformationPropertiesFormat struct {
	// ChangeNumber - READ-ONLY; The iteration number of service tag.
	ChangeNumber *string `json:"changeNumber,omitempty"`
	// Region - READ-ONLY; The region of service tag.
	Region *string `json:"region,omitempty"`
	// SystemService - READ-ONLY; The name of system service.
	SystemService *string `json:"systemService,omitempty"`
	// AddressPrefixes - READ-ONLY; The list of IP address prefixes.
	AddressPrefixes *[]string `json:"addressPrefixes,omitempty"`
	// State - READ-ONLY; The state of the service tag.
	State *string `json:"state,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceTagInformationPropertiesFormat.
func (stipf ServiceTagInformationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ServiceTagsListResult response for the ListServiceTags API service call.
type ServiceTagsListResult struct {
	autorest.Response `json:"-"`
	// Name - READ-ONLY; The name of the cloud.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; The ID of the cloud.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; The azure resource type.
	Type *string `json:"type,omitempty"`
	// ChangeNumber - READ-ONLY; The iteration number.
	ChangeNumber *string `json:"changeNumber,omitempty"`
	// Cloud - READ-ONLY; The name of the cloud.
	Cloud *string `json:"cloud,omitempty"`
	// Values - READ-ONLY; The list of service tag information resources.
	Values *[]ServiceTagInformation `json:"values,omitempty"`
	// NextLink - READ-ONLY; The URL to get next page of service tag information resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceTagsListResult.
func (stlr ServiceTagsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SessionIds list of session IDs.
type SessionIds struct {
	// SessionIds - List of session IDs.
	SessionIds *[]string `json:"sessionIds,omitempty"`
}

// StaticRoute list of all Static Routes.
type StaticRoute struct {
	// Name - The name of the StaticRoute that is unique within a VnetRoute.
	Name *string `json:"name,omitempty"`
	// AddressPrefixes - List of all address prefixes.
	AddressPrefixes *[]string `json:"addressPrefixes,omitempty"`
	// NextHopIPAddress - The ip address of the next hop.
	NextHopIPAddress *string `json:"nextHopIpAddress,omitempty"`
}

// String ...
type String struct {
	autorest.Response `json:"-"`
	Value             *string `json:"value,omitempty"`
}

// Subnet subnet in a virtual network resource.
type Subnet struct {
	autorest.Response `json:"-"`
	// SubnetPropertiesFormat - Properties of the subnet.
	*SubnetPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for Subnet.
func (s Subnet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.SubnetPropertiesFormat != nil {
		objectMap["properties"] = s.SubnetPropertiesFormat
	}
	if s.Name != nil {
		objectMap["name"] = s.Name
	}
	if s.Type != nil {
		objectMap["type"] = s.Type
	}
	if s.ID != nil {
		objectMap["id"] = s.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Subnet struct.
func (s *Subnet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var subnetPropertiesFormat SubnetPropertiesFormat
				err = json.Unmarshal(*v, &subnetPropertiesFormat)
				if err != nil {
					return err
				}
				s.SubnetPropertiesFormat = &subnetPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				s.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				s.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				s.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				s.ID = &ID
			}
		}
	}

	return nil
}

// SubnetAssociation subnet and it's custom security rules.
type SubnetAssociation struct {
	// ID - READ-ONLY; Subnet ID.
	ID *string `json:"id,omitempty"`
	// SecurityRules - Collection of custom security rules.
	SecurityRules *[]SecurityRule `json:"securityRules,omitempty"`
}

// MarshalJSON is the custom marshaler for SubnetAssociation.
func (sa SubnetAssociation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sa.SecurityRules != nil {
		objectMap["securityRules"] = sa.SecurityRules
	}
	return json.Marshal(objectMap)
}

// SubnetListResult response for ListSubnets API service callRetrieves all subnet that belongs to a virtual
// network.
type SubnetListResult struct {
	autorest.Response `json:"-"`
	// Value - The subnets in a virtual network.
	Value *[]Subnet `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// SubnetListResultIterator provides access to a complete listing of Subnet values.
type SubnetListResultIterator struct {
	i    int
	page SubnetListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SubnetListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubnetListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SubnetListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SubnetListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SubnetListResultIterator) Response() SubnetListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SubnetListResultIterator) Value() Subnet {
	if !iter.page.NotDone() {
		return Subnet{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SubnetListResultIterator type.
func NewSubnetListResultIterator(page SubnetListResultPage) SubnetListResultIterator {
	return SubnetListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (slr SubnetListResult) IsEmpty() bool {
	return slr.Value == nil || len(*slr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (slr SubnetListResult) hasNextLink() bool {
	return slr.NextLink != nil && len(*slr.NextLink) != 0
}

// subnetListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (slr SubnetListResult) subnetListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !slr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(slr.NextLink)))
}

// SubnetListResultPage contains a page of Subnet values.
type SubnetListResultPage struct {
	fn  func(context.Context, SubnetListResult) (SubnetListResult, error)
	slr SubnetListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SubnetListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubnetListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.slr)
		if err != nil {
			return err
		}
		page.slr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SubnetListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SubnetListResultPage) NotDone() bool {
	return !page.slr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SubnetListResultPage) Response() SubnetListResult {
	return page.slr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SubnetListResultPage) Values() []Subnet {
	if page.slr.IsEmpty() {
		return nil
	}
	return *page.slr.Value
}

// Creates a new instance of the SubnetListResultPage type.
func NewSubnetListResultPage(cur SubnetListResult, getNextPage func(context.Context, SubnetListResult) (SubnetListResult, error)) SubnetListResultPage {
	return SubnetListResultPage{
		fn:  getNextPage,
		slr: cur,
	}
}

// SubnetPropertiesFormat properties of the subnet.
type SubnetPropertiesFormat struct {
	// AddressPrefix - The address prefix for the subnet.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// AddressPrefixes - List of address prefixes for the subnet.
	AddressPrefixes *[]string `json:"addressPrefixes,omitempty"`
	// NetworkSecurityGroup - The reference to the NetworkSecurityGroup resource.
	NetworkSecurityGroup *SecurityGroup `json:"networkSecurityGroup,omitempty"`
	// RouteTable - The reference to the RouteTable resource.
	RouteTable *RouteTable `json:"routeTable,omitempty"`
	// NatGateway - Nat gateway associated with this subnet.
	NatGateway *SubResource `json:"natGateway,omitempty"`
	// ServiceEndpoints - An array of service endpoints.
	ServiceEndpoints *[]ServiceEndpointPropertiesFormat `json:"serviceEndpoints,omitempty"`
	// ServiceEndpointPolicies - An array of service endpoint policies.
	ServiceEndpointPolicies *[]ServiceEndpointPolicy `json:"serviceEndpointPolicies,omitempty"`
	// PrivateEndpoints - READ-ONLY; An array of references to private endpoints.
	PrivateEndpoints *[]PrivateEndpoint `json:"privateEndpoints,omitempty"`
	// IPConfigurations - READ-ONLY; An array of references to the network interface IP configurations using subnet.
	IPConfigurations *[]IPConfiguration `json:"ipConfigurations,omitempty"`
	// IPConfigurationProfiles - READ-ONLY; Array of IP configuration profiles which reference this subnet.
	IPConfigurationProfiles *[]IPConfigurationProfile `json:"ipConfigurationProfiles,omitempty"`
	// IPAllocations - Array of IpAllocation which reference this subnet.
	IPAllocations *[]SubResource `json:"ipAllocations,omitempty"`
	// ResourceNavigationLinks - READ-ONLY; An array of references to the external resources using subnet.
	ResourceNavigationLinks *[]ResourceNavigationLink `json:"resourceNavigationLinks,omitempty"`
	// ServiceAssociationLinks - READ-ONLY; An array of references to services injecting into this subnet.
	ServiceAssociationLinks *[]ServiceAssociationLink `json:"serviceAssociationLinks,omitempty"`
	// Delegations - An array of references to the delegations on the subnet.
	Delegations *[]Delegation `json:"delegations,omitempty"`
	// Purpose - READ-ONLY; A read-only string identifying the intention of use for this subnet based on delegations and other user-defined properties.
	Purpose *string `json:"purpose,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the subnet resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// PrivateEndpointNetworkPolicies - Enable or Disable apply network policies on private end point in the subnet. Possible values include: 'VirtualNetworkPrivateEndpointNetworkPoliciesEnabled', 'VirtualNetworkPrivateEndpointNetworkPoliciesDisabled'
	PrivateEndpointNetworkPolicies VirtualNetworkPrivateEndpointNetworkPolicies `json:"privateEndpointNetworkPolicies,omitempty"`
	// PrivateLinkServiceNetworkPolicies - Enable or Disable apply network policies on private link service in the subnet. Possible values include: 'VirtualNetworkPrivateLinkServiceNetworkPoliciesEnabled', 'VirtualNetworkPrivateLinkServiceNetworkPoliciesDisabled'
	PrivateLinkServiceNetworkPolicies VirtualNetworkPrivateLinkServiceNetworkPolicies `json:"privateLinkServiceNetworkPolicies,omitempty"`
	// ApplicationGatewayIPConfigurations - Application gateway IP configurations of virtual network resource.
	ApplicationGatewayIPConfigurations *[]ApplicationGatewayIPConfiguration `json:"applicationGatewayIpConfigurations,omitempty"`
}

// MarshalJSON is the custom marshaler for SubnetPropertiesFormat.
func (spf SubnetPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spf.AddressPrefix != nil {
		objectMap["addressPrefix"] = spf.AddressPrefix
	}
	if spf.AddressPrefixes != nil {
		objectMap["addressPrefixes"] = spf.AddressPrefixes
	}
	if spf.NetworkSecurityGroup != nil {
		objectMap["networkSecurityGroup"] = spf.NetworkSecurityGroup
	}
	if spf.RouteTable != nil {
		objectMap["routeTable"] = spf.RouteTable
	}
	if spf.NatGateway != nil {
		objectMap["natGateway"] = spf.NatGateway
	}
	if spf.ServiceEndpoints != nil {
		objectMap["serviceEndpoints"] = spf.ServiceEndpoints
	}
	if spf.ServiceEndpointPolicies != nil {
		objectMap["serviceEndpointPolicies"] = spf.ServiceEndpointPolicies
	}
	if spf.IPAllocations != nil {
		objectMap["ipAllocations"] = spf.IPAllocations
	}
	if spf.Delegations != nil {
		objectMap["delegations"] = spf.Delegations
	}
	if spf.PrivateEndpointNetworkPolicies != "" {
		objectMap["privateEndpointNetworkPolicies"] = spf.PrivateEndpointNetworkPolicies
	}
	if spf.PrivateLinkServiceNetworkPolicies != "" {
		objectMap["privateLinkServiceNetworkPolicies"] = spf.PrivateLinkServiceNetworkPolicies
	}
	if spf.ApplicationGatewayIPConfigurations != nil {
		objectMap["applicationGatewayIpConfigurations"] = spf.ApplicationGatewayIPConfigurations
	}
	return json.Marshal(objectMap)
}

// SubnetsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubnetsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubnetsClient) (Subnet, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubnetsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubnetsCreateOrUpdateFuture.Result.
func (future *SubnetsCreateOrUpdateFuture) result(client SubnetsClient) (s Subnet, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SubnetsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SubnetsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.CreateOrUpdateResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.SubnetsCreateOrUpdateFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SubnetsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubnetsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubnetsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubnetsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubnetsDeleteFuture.Result.
func (future *SubnetsDeleteFuture) result(client SubnetsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SubnetsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SubnetsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SubnetsPrepareNetworkPoliciesFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SubnetsPrepareNetworkPoliciesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubnetsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubnetsPrepareNetworkPoliciesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubnetsPrepareNetworkPoliciesFuture.Result.
func (future *SubnetsPrepareNetworkPoliciesFuture) result(client SubnetsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SubnetsPrepareNetworkPoliciesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SubnetsPrepareNetworkPoliciesFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SubnetsUnprepareNetworkPoliciesFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SubnetsUnprepareNetworkPoliciesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubnetsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubnetsUnprepareNetworkPoliciesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubnetsUnprepareNetworkPoliciesFuture.Result.
func (future *SubnetsUnprepareNetworkPoliciesFuture) result(client SubnetsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.SubnetsUnprepareNetworkPoliciesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.SubnetsUnprepareNetworkPoliciesFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SubResource reference to another subresource.
type SubResource struct {
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// TagsObject tags object for patch operations.
type TagsObject struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for TagsObject.
func (toVar TagsObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if toVar.Tags != nil {
		objectMap["tags"] = toVar.Tags
	}
	return json.Marshal(objectMap)
}

// Topology topology of the specified resource group.
type Topology struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; GUID representing the operation id.
	ID *string `json:"id,omitempty"`
	// CreatedDateTime - READ-ONLY; The datetime when the topology was initially created for the resource group.
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastModified - READ-ONLY; The datetime when the topology was last modified.
	LastModified *date.Time `json:"lastModified,omitempty"`
	// Resources - A list of topology resources.
	Resources *[]TopologyResource `json:"resources,omitempty"`
}

// MarshalJSON is the custom marshaler for Topology.
func (t Topology) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.Resources != nil {
		objectMap["resources"] = t.Resources
	}
	return json.Marshal(objectMap)
}

// TopologyAssociation resources that have an association with the parent resource.
type TopologyAssociation struct {
	// Name - The name of the resource that is associated with the parent resource.
	Name *string `json:"name,omitempty"`
	// ResourceID - The ID of the resource that is associated with the parent resource.
	ResourceID *string `json:"resourceId,omitempty"`
	// AssociationType - The association type of the child resource to the parent resource. Possible values include: 'AssociationTypeAssociated', 'AssociationTypeContains'
	AssociationType AssociationType `json:"associationType,omitempty"`
}

// TopologyParameters parameters that define the representation of topology.
type TopologyParameters struct {
	// TargetResourceGroupName - The name of the target resource group to perform topology on.
	TargetResourceGroupName *string `json:"targetResourceGroupName,omitempty"`
	// TargetVirtualNetwork - The reference to the Virtual Network resource.
	TargetVirtualNetwork *SubResource `json:"targetVirtualNetwork,omitempty"`
	// TargetSubnet - The reference to the Subnet resource.
	TargetSubnet *SubResource `json:"targetSubnet,omitempty"`
}

// TopologyResource the network resource topology information for the given resource group.
type TopologyResource struct {
	// Name - Name of the resource.
	Name *string `json:"name,omitempty"`
	// ID - ID of the resource.
	ID *string `json:"id,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Associations - Holds the associations the resource has with other resources in the resource group.
	Associations *[]TopologyAssociation `json:"associations,omitempty"`
}

// TrafficAnalyticsConfigurationProperties parameters that define the configuration of traffic analytics.
type TrafficAnalyticsConfigurationProperties struct {
	// Enabled - Flag to enable/disable traffic analytics.
	Enabled *bool `json:"enabled,omitempty"`
	// WorkspaceID - The resource guid of the attached workspace.
	WorkspaceID *string `json:"workspaceId,omitempty"`
	// WorkspaceRegion - The location of the attached workspace.
	WorkspaceRegion *string `json:"workspaceRegion,omitempty"`
	// WorkspaceResourceID - Resource Id of the attached workspace.
	WorkspaceResourceID *string `json:"workspaceResourceId,omitempty"`
	// TrafficAnalyticsInterval - The interval in minutes which would decide how frequently TA service should do flow analytics.
	TrafficAnalyticsInterval *int32 `json:"trafficAnalyticsInterval,omitempty"`
}

// TrafficAnalyticsProperties parameters that define the configuration of traffic analytics.
type TrafficAnalyticsProperties struct {
	// NetworkWatcherFlowAnalyticsConfiguration - Parameters that define the configuration of traffic analytics.
	NetworkWatcherFlowAnalyticsConfiguration *TrafficAnalyticsConfigurationProperties `json:"networkWatcherFlowAnalyticsConfiguration,omitempty"`
}

// TrafficSelectorPolicy an traffic selector policy for a virtual network gateway connection.
type TrafficSelectorPolicy struct {
	// LocalAddressRanges - A collection of local address spaces in CIDR format.
	LocalAddressRanges *[]string `json:"localAddressRanges,omitempty"`
	// RemoteAddressRanges - A collection of remote address spaces in CIDR format.
	RemoteAddressRanges *[]string `json:"remoteAddressRanges,omitempty"`
}

// TroubleshootingDetails information gained from troubleshooting of specified resource.
type TroubleshootingDetails struct {
	// ID - The id of the get troubleshoot operation.
	ID *string `json:"id,omitempty"`
	// ReasonType - Reason type of failure.
	ReasonType *string `json:"reasonType,omitempty"`
	// Summary - A summary of troubleshooting.
	Summary *string `json:"summary,omitempty"`
	// Detail - Details on troubleshooting results.
	Detail *string `json:"detail,omitempty"`
	// RecommendedActions - List of recommended actions.
	RecommendedActions *[]TroubleshootingRecommendedActions `json:"recommendedActions,omitempty"`
}

// TroubleshootingParameters parameters that define the resource to troubleshoot.
type TroubleshootingParameters struct {
	// TargetResourceID - The target resource to troubleshoot.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
	// TroubleshootingProperties - Properties of the troubleshooting resource.
	*TroubleshootingProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for TroubleshootingParameters.
func (tp TroubleshootingParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tp.TargetResourceID != nil {
		objectMap["targetResourceId"] = tp.TargetResourceID
	}
	if tp.TroubleshootingProperties != nil {
		objectMap["properties"] = tp.TroubleshootingProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TroubleshootingParameters struct.
func (tp *TroubleshootingParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "targetResourceId":
			if v != nil {
				var targetResourceID string
				err = json.Unmarshal(*v, &targetResourceID)
				if err != nil {
					return err
				}
				tp.TargetResourceID = &targetResourceID
			}
		case "properties":
			if v != nil {
				var troubleshootingProperties TroubleshootingProperties
				err = json.Unmarshal(*v, &troubleshootingProperties)
				if err != nil {
					return err
				}
				tp.TroubleshootingProperties = &troubleshootingProperties
			}
		}
	}

	return nil
}

// TroubleshootingProperties storage location provided for troubleshoot.
type TroubleshootingProperties struct {
	// StorageID - The ID for the storage account to save the troubleshoot result.
	StorageID *string `json:"storageId,omitempty"`
	// StoragePath - The path to the blob to save the troubleshoot result in.
	StoragePath *string `json:"storagePath,omitempty"`
}

// TroubleshootingRecommendedActions recommended actions based on discovered issues.
type TroubleshootingRecommendedActions struct {
	// ActionID - ID of the recommended action.
	ActionID *string `json:"actionId,omitempty"`
	// ActionText - Description of recommended actions.
	ActionText *string `json:"actionText,omitempty"`
	// ActionURI - The uri linking to a documentation for the recommended troubleshooting actions.
	ActionURI *string `json:"actionUri,omitempty"`
	// ActionURIText - The information from the URI for the recommended troubleshooting actions.
	ActionURIText *string `json:"actionUriText,omitempty"`
}

// TroubleshootingResult troubleshooting information gained from specified resource.
type TroubleshootingResult struct {
	autorest.Response `json:"-"`
	// StartTime - The start time of the troubleshooting.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time of the troubleshooting.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Code - The result code of the troubleshooting.
	Code *string `json:"code,omitempty"`
	// Results - Information from troubleshooting.
	Results *[]TroubleshootingDetails `json:"results,omitempty"`
}

// TunnelConnectionHealth virtualNetworkGatewayConnection properties.
type TunnelConnectionHealth struct {
	// Tunnel - READ-ONLY; Tunnel name.
	Tunnel *string `json:"tunnel,omitempty"`
	// ConnectionStatus - READ-ONLY; Virtual Network Gateway connection status. Possible values include: 'VirtualNetworkGatewayConnectionStatusUnknown', 'VirtualNetworkGatewayConnectionStatusConnecting', 'VirtualNetworkGatewayConnectionStatusConnected', 'VirtualNetworkGatewayConnectionStatusNotConnected'
	ConnectionStatus VirtualNetworkGatewayConnectionStatus `json:"connectionStatus,omitempty"`
	// IngressBytesTransferred - READ-ONLY; The Ingress Bytes Transferred in this connection.
	IngressBytesTransferred *int64 `json:"ingressBytesTransferred,omitempty"`
	// EgressBytesTransferred - READ-ONLY; The Egress Bytes Transferred in this connection.
	EgressBytesTransferred *int64 `json:"egressBytesTransferred,omitempty"`
	// LastConnectionEstablishedUtcTime - READ-ONLY; The time at which connection was established in Utc format.
	LastConnectionEstablishedUtcTime *string `json:"lastConnectionEstablishedUtcTime,omitempty"`
}

// MarshalJSON is the custom marshaler for TunnelConnectionHealth.
func (tch TunnelConnectionHealth) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UnprepareNetworkPoliciesRequest details of UnprepareNetworkPolicies for Subnet.
type UnprepareNetworkPoliciesRequest struct {
	// ServiceName - The name of the service for which subnet is being unprepared for.
	ServiceName *string `json:"serviceName,omitempty"`
}

// Usage the network resource usage.
type Usage struct {
	// ID - READ-ONLY; Resource identifier.
	ID *string `json:"id,omitempty"`
	// Unit - An enum describing the unit of measurement.
	Unit *string `json:"unit,omitempty"`
	// CurrentValue - The current value of the usage.
	CurrentValue *int64 `json:"currentValue,omitempty"`
	// Limit - The limit of usage.
	Limit *int64 `json:"limit,omitempty"`
	// Name - The name of the type of usage.
	Name *UsageName `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for Usage.
func (u Usage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if u.Unit != nil {
		objectMap["unit"] = u.Unit
	}
	if u.CurrentValue != nil {
		objectMap["currentValue"] = u.CurrentValue
	}
	if u.Limit != nil {
		objectMap["limit"] = u.Limit
	}
	if u.Name != nil {
		objectMap["name"] = u.Name
	}
	return json.Marshal(objectMap)
}

// UsageName the usage names.
type UsageName struct {
	// Value - A string describing the resource name.
	Value *string `json:"value,omitempty"`
	// LocalizedValue - A localized string describing the resource name.
	LocalizedValue *string `json:"localizedValue,omitempty"`
}

// UsagesListResult the list usages operation response.
type UsagesListResult struct {
	autorest.Response `json:"-"`
	// Value - The list network resource usages.
	Value *[]Usage `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// UsagesListResultIterator provides access to a complete listing of Usage values.
type UsagesListResultIterator struct {
	i    int
	page UsagesListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *UsagesListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/UsagesListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *UsagesListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter UsagesListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter UsagesListResultIterator) Response() UsagesListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter UsagesListResultIterator) Value() Usage {
	if !iter.page.NotDone() {
		return Usage{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the UsagesListResultIterator type.
func NewUsagesListResultIterator(page UsagesListResultPage) UsagesListResultIterator {
	return UsagesListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ulr UsagesListResult) IsEmpty() bool {
	return ulr.Value == nil || len(*ulr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ulr UsagesListResult) hasNextLink() bool {
	return ulr.NextLink != nil && len(*ulr.NextLink) != 0
}

// usagesListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ulr UsagesListResult) usagesListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ulr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ulr.NextLink)))
}

// UsagesListResultPage contains a page of Usage values.
type UsagesListResultPage struct {
	fn  func(context.Context, UsagesListResult) (UsagesListResult, error)
	ulr UsagesListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *UsagesListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/UsagesListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ulr)
		if err != nil {
			return err
		}
		page.ulr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *UsagesListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page UsagesListResultPage) NotDone() bool {
	return !page.ulr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page UsagesListResultPage) Response() UsagesListResult {
	return page.ulr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page UsagesListResultPage) Values() []Usage {
	if page.ulr.IsEmpty() {
		return nil
	}
	return *page.ulr.Value
}

// Creates a new instance of the UsagesListResultPage type.
func NewUsagesListResultPage(cur UsagesListResult, getNextPage func(context.Context, UsagesListResult) (UsagesListResult, error)) UsagesListResultPage {
	return UsagesListResultPage{
		fn:  getNextPage,
		ulr: cur,
	}
}

// VerificationIPFlowParameters parameters that define the IP flow to be verified.
type VerificationIPFlowParameters struct {
	// TargetResourceID - The ID of the target resource to perform next-hop on.
	TargetResourceID *string `json:"targetResourceId,omitempty"`
	// Direction - The direction of the packet represented as a 5-tuple. Possible values include: 'DirectionInbound', 'DirectionOutbound'
	Direction Direction `json:"direction,omitempty"`
	// Protocol - Protocol to be verified on. Possible values include: 'IPFlowProtocolTCP', 'IPFlowProtocolUDP'
	Protocol IPFlowProtocol `json:"protocol,omitempty"`
	// LocalPort - The local port. Acceptable values are a single integer in the range (0-65535). Support for * for the source port, which depends on the direction.
	LocalPort *string `json:"localPort,omitempty"`
	// RemotePort - The remote port. Acceptable values are a single integer in the range (0-65535). Support for * for the source port, which depends on the direction.
	RemotePort *string `json:"remotePort,omitempty"`
	// LocalIPAddress - The local IP address. Acceptable values are valid IPv4 addresses.
	LocalIPAddress *string `json:"localIPAddress,omitempty"`
	// RemoteIPAddress - The remote IP address. Acceptable values are valid IPv4 addresses.
	RemoteIPAddress *string `json:"remoteIPAddress,omitempty"`
	// TargetNicResourceID - The NIC ID. (If VM has multiple NICs and IP forwarding is enabled on any of them, then this parameter must be specified. Otherwise optional).
	TargetNicResourceID *string `json:"targetNicResourceId,omitempty"`
}

// VerificationIPFlowResult results of IP flow verification on the target resource.
type VerificationIPFlowResult struct {
	autorest.Response `json:"-"`
	// Access - Indicates whether the traffic is allowed or denied. Possible values include: 'AccessAllow', 'AccessDeny'
	Access Access `json:"access,omitempty"`
	// RuleName - Name of the rule. If input is not matched against any security rule, it is not displayed.
	RuleName *string `json:"ruleName,omitempty"`
}

// VirtualAppliance networkVirtualAppliance Resource.
type VirtualAppliance struct {
	autorest.Response `json:"-"`
	// VirtualAppliancePropertiesFormat - Properties of the Network Virtual Appliance.
	*VirtualAppliancePropertiesFormat `json:"properties,omitempty"`
	// Identity - The service principal that has read access to cloud-init and config blob.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualAppliance.
func (va VirtualAppliance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if va.VirtualAppliancePropertiesFormat != nil {
		objectMap["properties"] = va.VirtualAppliancePropertiesFormat
	}
	if va.Identity != nil {
		objectMap["identity"] = va.Identity
	}
	if va.ID != nil {
		objectMap["id"] = va.ID
	}
	if va.Location != nil {
		objectMap["location"] = va.Location
	}
	if va.Tags != nil {
		objectMap["tags"] = va.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualAppliance struct.
func (va *VirtualAppliance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualAppliancePropertiesFormat VirtualAppliancePropertiesFormat
				err = json.Unmarshal(*v, &virtualAppliancePropertiesFormat)
				if err != nil {
					return err
				}
				va.VirtualAppliancePropertiesFormat = &virtualAppliancePropertiesFormat
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				va.Identity = &identity
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				va.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				va.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				va.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				va.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				va.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				va.Tags = tags
			}
		}
	}

	return nil
}

// VirtualApplianceListResult response for ListNetworkVirtualAppliances API service call.
type VirtualApplianceListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Network Virtual Appliances.
	Value *[]VirtualAppliance `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VirtualApplianceListResultIterator provides access to a complete listing of VirtualAppliance values.
type VirtualApplianceListResultIterator struct {
	i    int
	page VirtualApplianceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualApplianceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualApplianceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualApplianceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualApplianceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualApplianceListResultIterator) Response() VirtualApplianceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualApplianceListResultIterator) Value() VirtualAppliance {
	if !iter.page.NotDone() {
		return VirtualAppliance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualApplianceListResultIterator type.
func NewVirtualApplianceListResultIterator(page VirtualApplianceListResultPage) VirtualApplianceListResultIterator {
	return VirtualApplianceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (valr VirtualApplianceListResult) IsEmpty() bool {
	return valr.Value == nil || len(*valr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (valr VirtualApplianceListResult) hasNextLink() bool {
	return valr.NextLink != nil && len(*valr.NextLink) != 0
}

// virtualApplianceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (valr VirtualApplianceListResult) virtualApplianceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !valr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(valr.NextLink)))
}

// VirtualApplianceListResultPage contains a page of VirtualAppliance values.
type VirtualApplianceListResultPage struct {
	fn   func(context.Context, VirtualApplianceListResult) (VirtualApplianceListResult, error)
	valr VirtualApplianceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualApplianceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualApplianceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.valr)
		if err != nil {
			return err
		}
		page.valr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualApplianceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualApplianceListResultPage) NotDone() bool {
	return !page.valr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualApplianceListResultPage) Response() VirtualApplianceListResult {
	return page.valr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualApplianceListResultPage) Values() []VirtualAppliance {
	if page.valr.IsEmpty() {
		return nil
	}
	return *page.valr.Value
}

// Creates a new instance of the VirtualApplianceListResultPage type.
func NewVirtualApplianceListResultPage(cur VirtualApplianceListResult, getNextPage func(context.Context, VirtualApplianceListResult) (VirtualApplianceListResult, error)) VirtualApplianceListResultPage {
	return VirtualApplianceListResultPage{
		fn:   getNextPage,
		valr: cur,
	}
}

// VirtualApplianceNicProperties network Virtual Appliance NIC properties.
type VirtualApplianceNicProperties struct {
	// Name - READ-ONLY; NIC name.
	Name *string `json:"name,omitempty"`
	// PublicIPAddress - READ-ONLY; Public IP address.
	PublicIPAddress *string `json:"publicIpAddress,omitempty"`
	// PrivateIPAddress - READ-ONLY; Private IP address.
	PrivateIPAddress *string `json:"privateIpAddress,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualApplianceNicProperties.
func (vanp VirtualApplianceNicProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// VirtualAppliancePropertiesFormat network Virtual Appliance definition.
type VirtualAppliancePropertiesFormat struct {
	// NvaSku - Network Virtual Appliance SKU.
	NvaSku *VirtualApplianceSkuProperties `json:"nvaSku,omitempty"`
	// AddressPrefix - READ-ONLY; Address Prefix.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// BootStrapConfigurationBlobs - BootStrapConfigurationBlobs storage URLs.
	BootStrapConfigurationBlobs *[]string `json:"bootStrapConfigurationBlobs,omitempty"`
	// VirtualHub - The Virtual Hub where Network Virtual Appliance is being deployed.
	VirtualHub *SubResource `json:"virtualHub,omitempty"`
	// CloudInitConfigurationBlobs - CloudInitConfigurationBlob storage URLs.
	CloudInitConfigurationBlobs *[]string `json:"cloudInitConfigurationBlobs,omitempty"`
	// CloudInitConfiguration - CloudInitConfiguration string in plain text.
	CloudInitConfiguration *string `json:"cloudInitConfiguration,omitempty"`
	// VirtualApplianceAsn - VirtualAppliance ASN.
	VirtualApplianceAsn *int64 `json:"virtualApplianceAsn,omitempty"`
	// VirtualApplianceNics - READ-ONLY; List of Virtual Appliance Network Interfaces.
	VirtualApplianceNics *[]VirtualApplianceNicProperties `json:"virtualApplianceNics,omitempty"`
	// VirtualApplianceSites - READ-ONLY; List of references to VirtualApplianceSite.
	VirtualApplianceSites *[]SubResource `json:"virtualApplianceSites,omitempty"`
	// InboundSecurityRules - READ-ONLY; List of references to InboundSecurityRules.
	InboundSecurityRules *[]SubResource `json:"inboundSecurityRules,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualAppliancePropertiesFormat.
func (vapf VirtualAppliancePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vapf.NvaSku != nil {
		objectMap["nvaSku"] = vapf.NvaSku
	}
	if vapf.BootStrapConfigurationBlobs != nil {
		objectMap["bootStrapConfigurationBlobs"] = vapf.BootStrapConfigurationBlobs
	}
	if vapf.VirtualHub != nil {
		objectMap["virtualHub"] = vapf.VirtualHub
	}
	if vapf.CloudInitConfigurationBlobs != nil {
		objectMap["cloudInitConfigurationBlobs"] = vapf.CloudInitConfigurationBlobs
	}
	if vapf.CloudInitConfiguration != nil {
		objectMap["cloudInitConfiguration"] = vapf.CloudInitConfiguration
	}
	if vapf.VirtualApplianceAsn != nil {
		objectMap["virtualApplianceAsn"] = vapf.VirtualApplianceAsn
	}
	return json.Marshal(objectMap)
}

// VirtualAppliancesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualAppliancesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualAppliancesClient) (VirtualAppliance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualAppliancesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualAppliancesCreateOrUpdateFuture.Result.
func (future *VirtualAppliancesCreateOrUpdateFuture) result(client VirtualAppliancesClient) (va VirtualAppliance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualAppliancesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		va.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualAppliancesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if va.Response.Response, err = future.GetResult(sender); err == nil && va.Response.Response.StatusCode != http.StatusNoContent {
		va, err = client.CreateOrUpdateResponder(va.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualAppliancesCreateOrUpdateFuture", "Result", va.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualAppliancesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualAppliancesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualAppliancesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualAppliancesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualAppliancesDeleteFuture.Result.
func (future *VirtualAppliancesDeleteFuture) result(client VirtualAppliancesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualAppliancesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualAppliancesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualApplianceSite virtual Appliance Site resource.
type VirtualApplianceSite struct {
	autorest.Response `json:"-"`
	// VirtualApplianceSiteProperties - The properties of the Virtual Appliance Sites.
	*VirtualApplianceSiteProperties `json:"properties,omitempty"`
	// Name - Name of the virtual appliance site.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Site type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualApplianceSite.
func (vas VirtualApplianceSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vas.VirtualApplianceSiteProperties != nil {
		objectMap["properties"] = vas.VirtualApplianceSiteProperties
	}
	if vas.Name != nil {
		objectMap["name"] = vas.Name
	}
	if vas.ID != nil {
		objectMap["id"] = vas.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualApplianceSite struct.
func (vas *VirtualApplianceSite) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualApplianceSiteProperties VirtualApplianceSiteProperties
				err = json.Unmarshal(*v, &virtualApplianceSiteProperties)
				if err != nil {
					return err
				}
				vas.VirtualApplianceSiteProperties = &virtualApplianceSiteProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vas.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vas.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vas.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vas.ID = &ID
			}
		}
	}

	return nil
}

// VirtualApplianceSiteListResult response for ListNetworkVirtualApplianceSites API service call.
type VirtualApplianceSiteListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Network Virtual Appliance sites.
	Value *[]VirtualApplianceSite `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VirtualApplianceSiteListResultIterator provides access to a complete listing of VirtualApplianceSite
// values.
type VirtualApplianceSiteListResultIterator struct {
	i    int
	page VirtualApplianceSiteListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualApplianceSiteListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualApplianceSiteListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualApplianceSiteListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualApplianceSiteListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualApplianceSiteListResultIterator) Response() VirtualApplianceSiteListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualApplianceSiteListResultIterator) Value() VirtualApplianceSite {
	if !iter.page.NotDone() {
		return VirtualApplianceSite{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualApplianceSiteListResultIterator type.
func NewVirtualApplianceSiteListResultIterator(page VirtualApplianceSiteListResultPage) VirtualApplianceSiteListResultIterator {
	return VirtualApplianceSiteListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vaslr VirtualApplianceSiteListResult) IsEmpty() bool {
	return vaslr.Value == nil || len(*vaslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vaslr VirtualApplianceSiteListResult) hasNextLink() bool {
	return vaslr.NextLink != nil && len(*vaslr.NextLink) != 0
}

// virtualApplianceSiteListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vaslr VirtualApplianceSiteListResult) virtualApplianceSiteListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vaslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vaslr.NextLink)))
}

// VirtualApplianceSiteListResultPage contains a page of VirtualApplianceSite values.
type VirtualApplianceSiteListResultPage struct {
	fn    func(context.Context, VirtualApplianceSiteListResult) (VirtualApplianceSiteListResult, error)
	vaslr VirtualApplianceSiteListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualApplianceSiteListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualApplianceSiteListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vaslr)
		if err != nil {
			return err
		}
		page.vaslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualApplianceSiteListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualApplianceSiteListResultPage) NotDone() bool {
	return !page.vaslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualApplianceSiteListResultPage) Response() VirtualApplianceSiteListResult {
	return page.vaslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualApplianceSiteListResultPage) Values() []VirtualApplianceSite {
	if page.vaslr.IsEmpty() {
		return nil
	}
	return *page.vaslr.Value
}

// Creates a new instance of the VirtualApplianceSiteListResultPage type.
func NewVirtualApplianceSiteListResultPage(cur VirtualApplianceSiteListResult, getNextPage func(context.Context, VirtualApplianceSiteListResult) (VirtualApplianceSiteListResult, error)) VirtualApplianceSiteListResultPage {
	return VirtualApplianceSiteListResultPage{
		fn:    getNextPage,
		vaslr: cur,
	}
}

// VirtualApplianceSiteProperties properties of the rule group.
type VirtualApplianceSiteProperties struct {
	// AddressPrefix - Address Prefix.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// O365Policy - Office 365 Policy.
	O365Policy *Office365PolicyProperties `json:"o365Policy,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualApplianceSiteProperties.
func (vasp VirtualApplianceSiteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vasp.AddressPrefix != nil {
		objectMap["addressPrefix"] = vasp.AddressPrefix
	}
	if vasp.O365Policy != nil {
		objectMap["o365Policy"] = vasp.O365Policy
	}
	return json.Marshal(objectMap)
}

// VirtualApplianceSitesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualApplianceSitesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualApplianceSitesClient) (VirtualApplianceSite, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualApplianceSitesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualApplianceSitesCreateOrUpdateFuture.Result.
func (future *VirtualApplianceSitesCreateOrUpdateFuture) result(client VirtualApplianceSitesClient) (vas VirtualApplianceSite, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualApplianceSitesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vas.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualApplianceSitesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vas.Response.Response, err = future.GetResult(sender); err == nil && vas.Response.Response.StatusCode != http.StatusNoContent {
		vas, err = client.CreateOrUpdateResponder(vas.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualApplianceSitesCreateOrUpdateFuture", "Result", vas.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualApplianceSitesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualApplianceSitesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualApplianceSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualApplianceSitesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualApplianceSitesDeleteFuture.Result.
func (future *VirtualApplianceSitesDeleteFuture) result(client VirtualApplianceSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualApplianceSitesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualApplianceSitesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualApplianceSku definition of the NetworkVirtualApplianceSkus resource.
type VirtualApplianceSku struct {
	autorest.Response `json:"-"`
	// VirtualApplianceSkuPropertiesFormat - NetworkVirtualApplianceSku properties.
	*VirtualApplianceSkuPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualApplianceSku.
func (vas VirtualApplianceSku) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vas.VirtualApplianceSkuPropertiesFormat != nil {
		objectMap["properties"] = vas.VirtualApplianceSkuPropertiesFormat
	}
	if vas.ID != nil {
		objectMap["id"] = vas.ID
	}
	if vas.Location != nil {
		objectMap["location"] = vas.Location
	}
	if vas.Tags != nil {
		objectMap["tags"] = vas.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualApplianceSku struct.
func (vas *VirtualApplianceSku) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualApplianceSkuPropertiesFormat VirtualApplianceSkuPropertiesFormat
				err = json.Unmarshal(*v, &virtualApplianceSkuPropertiesFormat)
				if err != nil {
					return err
				}
				vas.VirtualApplianceSkuPropertiesFormat = &virtualApplianceSkuPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vas.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vas.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vas.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vas.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vas.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vas.Tags = tags
			}
		}
	}

	return nil
}

// VirtualApplianceSkuInstances list of available Sku and instances.
type VirtualApplianceSkuInstances struct {
	// ScaleUnit - READ-ONLY; Scale Unit.
	ScaleUnit *string `json:"scaleUnit,omitempty"`
	// InstanceCount - READ-ONLY; Instance Count.
	InstanceCount *int32 `json:"instanceCount,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualApplianceSkuInstances.
func (vasi VirtualApplianceSkuInstances) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// VirtualApplianceSkuListResult response for ListNetworkVirtualApplianceSkus API service call.
type VirtualApplianceSkuListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Network Virtual Appliance Skus that are available.
	Value *[]VirtualApplianceSku `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VirtualApplianceSkuListResultIterator provides access to a complete listing of VirtualApplianceSku
// values.
type VirtualApplianceSkuListResultIterator struct {
	i    int
	page VirtualApplianceSkuListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualApplianceSkuListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualApplianceSkuListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualApplianceSkuListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualApplianceSkuListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualApplianceSkuListResultIterator) Response() VirtualApplianceSkuListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualApplianceSkuListResultIterator) Value() VirtualApplianceSku {
	if !iter.page.NotDone() {
		return VirtualApplianceSku{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualApplianceSkuListResultIterator type.
func NewVirtualApplianceSkuListResultIterator(page VirtualApplianceSkuListResultPage) VirtualApplianceSkuListResultIterator {
	return VirtualApplianceSkuListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vaslr VirtualApplianceSkuListResult) IsEmpty() bool {
	return vaslr.Value == nil || len(*vaslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vaslr VirtualApplianceSkuListResult) hasNextLink() bool {
	return vaslr.NextLink != nil && len(*vaslr.NextLink) != 0
}

// virtualApplianceSkuListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vaslr VirtualApplianceSkuListResult) virtualApplianceSkuListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vaslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vaslr.NextLink)))
}

// VirtualApplianceSkuListResultPage contains a page of VirtualApplianceSku values.
type VirtualApplianceSkuListResultPage struct {
	fn    func(context.Context, VirtualApplianceSkuListResult) (VirtualApplianceSkuListResult, error)
	vaslr VirtualApplianceSkuListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualApplianceSkuListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualApplianceSkuListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vaslr)
		if err != nil {
			return err
		}
		page.vaslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualApplianceSkuListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualApplianceSkuListResultPage) NotDone() bool {
	return !page.vaslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualApplianceSkuListResultPage) Response() VirtualApplianceSkuListResult {
	return page.vaslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualApplianceSkuListResultPage) Values() []VirtualApplianceSku {
	if page.vaslr.IsEmpty() {
		return nil
	}
	return *page.vaslr.Value
}

// Creates a new instance of the VirtualApplianceSkuListResultPage type.
func NewVirtualApplianceSkuListResultPage(cur VirtualApplianceSkuListResult, getNextPage func(context.Context, VirtualApplianceSkuListResult) (VirtualApplianceSkuListResult, error)) VirtualApplianceSkuListResultPage {
	return VirtualApplianceSkuListResultPage{
		fn:    getNextPage,
		vaslr: cur,
	}
}

// VirtualApplianceSkuProperties network Virtual Appliance Sku Properties.
type VirtualApplianceSkuProperties struct {
	// Vendor - Virtual Appliance Vendor.
	Vendor *string `json:"vendor,omitempty"`
	// BundledScaleUnit - Virtual Appliance Scale Unit.
	BundledScaleUnit *string `json:"bundledScaleUnit,omitempty"`
	// MarketPlaceVersion - Virtual Appliance Version.
	MarketPlaceVersion *string `json:"marketPlaceVersion,omitempty"`
}

// VirtualApplianceSkuPropertiesFormat properties specific to NetworkVirtualApplianceSkus.
type VirtualApplianceSkuPropertiesFormat struct {
	// Vendor - READ-ONLY; Network Virtual Appliance Sku vendor.
	Vendor *string `json:"vendor,omitempty"`
	// AvailableVersions - READ-ONLY; Available Network Virtual Appliance versions.
	AvailableVersions *[]string `json:"availableVersions,omitempty"`
	// AvailableScaleUnits - The list of scale units available.
	AvailableScaleUnits *[]VirtualApplianceSkuInstances `json:"availableScaleUnits,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualApplianceSkuPropertiesFormat.
func (vaspf VirtualApplianceSkuPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vaspf.AvailableScaleUnits != nil {
		objectMap["availableScaleUnits"] = vaspf.AvailableScaleUnits
	}
	return json.Marshal(objectMap)
}

// VirtualHub virtualHub Resource.
type VirtualHub struct {
	autorest.Response `json:"-"`
	// VirtualHubProperties - Properties of the virtual hub.
	*VirtualHubProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualHub.
func (vh VirtualHub) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vh.VirtualHubProperties != nil {
		objectMap["properties"] = vh.VirtualHubProperties
	}
	if vh.ID != nil {
		objectMap["id"] = vh.ID
	}
	if vh.Location != nil {
		objectMap["location"] = vh.Location
	}
	if vh.Tags != nil {
		objectMap["tags"] = vh.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualHub struct.
func (vh *VirtualHub) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualHubProperties VirtualHubProperties
				err = json.Unmarshal(*v, &virtualHubProperties)
				if err != nil {
					return err
				}
				vh.VirtualHubProperties = &virtualHubProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vh.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vh.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vh.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vh.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vh.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vh.Tags = tags
			}
		}
	}

	return nil
}

// VirtualHubBgpConnectionCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type VirtualHubBgpConnectionCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubBgpConnectionClient) (BgpConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubBgpConnectionCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubBgpConnectionCreateOrUpdateFuture.Result.
func (future *VirtualHubBgpConnectionCreateOrUpdateFuture) result(client VirtualHubBgpConnectionClient) (bc BgpConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubBgpConnectionCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubBgpConnectionCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bc.Response.Response, err = future.GetResult(sender); err == nil && bc.Response.Response.StatusCode != http.StatusNoContent {
		bc, err = client.CreateOrUpdateResponder(bc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualHubBgpConnectionCreateOrUpdateFuture", "Result", bc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualHubBgpConnectionDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualHubBgpConnectionDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubBgpConnectionClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubBgpConnectionDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubBgpConnectionDeleteFuture.Result.
func (future *VirtualHubBgpConnectionDeleteFuture) result(client VirtualHubBgpConnectionClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubBgpConnectionDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubBgpConnectionDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualHubBgpConnectionsListAdvertisedRoutesFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualHubBgpConnectionsListAdvertisedRoutesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubBgpConnectionsClient) (PeerRouteList, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubBgpConnectionsListAdvertisedRoutesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubBgpConnectionsListAdvertisedRoutesFuture.Result.
func (future *VirtualHubBgpConnectionsListAdvertisedRoutesFuture) result(client VirtualHubBgpConnectionsClient) (prl PeerRouteList, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubBgpConnectionsListAdvertisedRoutesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		prl.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubBgpConnectionsListAdvertisedRoutesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if prl.Response.Response, err = future.GetResult(sender); err == nil && prl.Response.Response.StatusCode != http.StatusNoContent {
		prl, err = client.ListAdvertisedRoutesResponder(prl.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualHubBgpConnectionsListAdvertisedRoutesFuture", "Result", prl.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualHubBgpConnectionsListLearnedRoutesFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type VirtualHubBgpConnectionsListLearnedRoutesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubBgpConnectionsClient) (PeerRouteList, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubBgpConnectionsListLearnedRoutesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubBgpConnectionsListLearnedRoutesFuture.Result.
func (future *VirtualHubBgpConnectionsListLearnedRoutesFuture) result(client VirtualHubBgpConnectionsClient) (prl PeerRouteList, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubBgpConnectionsListLearnedRoutesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		prl.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubBgpConnectionsListLearnedRoutesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if prl.Response.Response, err = future.GetResult(sender); err == nil && prl.Response.Response.StatusCode != http.StatusNoContent {
		prl, err = client.ListLearnedRoutesResponder(prl.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualHubBgpConnectionsListLearnedRoutesFuture", "Result", prl.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualHubEffectiveRoute the effective route configured on the virtual hub or specified resource.
type VirtualHubEffectiveRoute struct {
	// AddressPrefixes - The list of address prefixes.
	AddressPrefixes *[]string `json:"addressPrefixes,omitempty"`
	// NextHops - The list of next hops.
	NextHops *[]string `json:"nextHops,omitempty"`
	// NextHopType - The type of the next hop.
	NextHopType *string `json:"nextHopType,omitempty"`
	// AsPath - The ASPath of this route.
	AsPath *string `json:"asPath,omitempty"`
	// RouteOrigin - The origin of this route.
	RouteOrigin *string `json:"routeOrigin,omitempty"`
}

// VirtualHubEffectiveRouteList effectiveRoutes List.
type VirtualHubEffectiveRouteList struct {
	// Value - The list of effective routes configured on the virtual hub or the specified resource.
	Value *[]VirtualHubEffectiveRoute `json:"value,omitempty"`
}

// VirtualHubID virtual Hub identifier.
type VirtualHubID struct {
	// ID - The resource URI for the Virtual Hub where the ExpressRoute gateway is or will be deployed. The Virtual Hub resource and the ExpressRoute gateway resource reside in the same subscription.
	ID *string `json:"id,omitempty"`
}

// VirtualHubIPConfigurationCreateOrUpdateFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type VirtualHubIPConfigurationCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubIPConfigurationClient) (HubIPConfiguration, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubIPConfigurationCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubIPConfigurationCreateOrUpdateFuture.Result.
func (future *VirtualHubIPConfigurationCreateOrUpdateFuture) result(client VirtualHubIPConfigurationClient) (hic HubIPConfiguration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubIPConfigurationCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		hic.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubIPConfigurationCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if hic.Response.Response, err = future.GetResult(sender); err == nil && hic.Response.Response.StatusCode != http.StatusNoContent {
		hic, err = client.CreateOrUpdateResponder(hic.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualHubIPConfigurationCreateOrUpdateFuture", "Result", hic.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualHubIPConfigurationDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualHubIPConfigurationDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubIPConfigurationClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubIPConfigurationDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubIPConfigurationDeleteFuture.Result.
func (future *VirtualHubIPConfigurationDeleteFuture) result(client VirtualHubIPConfigurationClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubIPConfigurationDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubIPConfigurationDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualHubProperties parameters for VirtualHub.
type VirtualHubProperties struct {
	// VirtualWan - The VirtualWAN to which the VirtualHub belongs.
	VirtualWan *SubResource `json:"virtualWan,omitempty"`
	// VpnGateway - The VpnGateway associated with this VirtualHub.
	VpnGateway *SubResource `json:"vpnGateway,omitempty"`
	// P2SVpnGateway - The P2SVpnGateway associated with this VirtualHub.
	P2SVpnGateway *SubResource `json:"p2SVpnGateway,omitempty"`
	// ExpressRouteGateway - The expressRouteGateway associated with this VirtualHub.
	ExpressRouteGateway *SubResource `json:"expressRouteGateway,omitempty"`
	// AzureFirewall - The azureFirewall associated with this VirtualHub.
	AzureFirewall *SubResource `json:"azureFirewall,omitempty"`
	// SecurityPartnerProvider - The securityPartnerProvider associated with this VirtualHub.
	SecurityPartnerProvider *SubResource `json:"securityPartnerProvider,omitempty"`
	// AddressPrefix - Address-prefix for this VirtualHub.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// RouteTable - The routeTable associated with this virtual hub.
	RouteTable *VirtualHubRouteTable `json:"routeTable,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual hub resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// SecurityProviderName - The Security Provider name.
	SecurityProviderName *string `json:"securityProviderName,omitempty"`
	// VirtualHubRouteTableV2s - List of all virtual hub route table v2s associated with this VirtualHub.
	VirtualHubRouteTableV2s *[]VirtualHubRouteTableV2 `json:"virtualHubRouteTableV2s,omitempty"`
	// Sku - The sku of this VirtualHub.
	Sku *string `json:"sku,omitempty"`
	// RoutingState - The routing state. Possible values include: 'RoutingStateNone', 'RoutingStateProvisioned', 'RoutingStateProvisioning', 'RoutingStateFailed'
	RoutingState RoutingState `json:"routingState,omitempty"`
	// BgpConnections - READ-ONLY; List of references to Bgp Connections.
	BgpConnections *[]SubResource `json:"bgpConnections,omitempty"`
	// IPConfigurations - READ-ONLY; List of references to IpConfigurations.
	IPConfigurations *[]SubResource `json:"ipConfigurations,omitempty"`
	// VirtualRouterAsn - VirtualRouter ASN.
	VirtualRouterAsn *int64 `json:"virtualRouterAsn,omitempty"`
	// VirtualRouterIps - VirtualRouter IPs.
	VirtualRouterIps *[]string `json:"virtualRouterIps,omitempty"`
	// AllowBranchToBranchTraffic - Flag to control transit for VirtualRouter hub.
	AllowBranchToBranchTraffic *bool `json:"allowBranchToBranchTraffic,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualHubProperties.
func (vhp VirtualHubProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vhp.VirtualWan != nil {
		objectMap["virtualWan"] = vhp.VirtualWan
	}
	if vhp.VpnGateway != nil {
		objectMap["vpnGateway"] = vhp.VpnGateway
	}
	if vhp.P2SVpnGateway != nil {
		objectMap["p2SVpnGateway"] = vhp.P2SVpnGateway
	}
	if vhp.ExpressRouteGateway != nil {
		objectMap["expressRouteGateway"] = vhp.ExpressRouteGateway
	}
	if vhp.AzureFirewall != nil {
		objectMap["azureFirewall"] = vhp.AzureFirewall
	}
	if vhp.SecurityPartnerProvider != nil {
		objectMap["securityPartnerProvider"] = vhp.SecurityPartnerProvider
	}
	if vhp.AddressPrefix != nil {
		objectMap["addressPrefix"] = vhp.AddressPrefix
	}
	if vhp.RouteTable != nil {
		objectMap["routeTable"] = vhp.RouteTable
	}
	if vhp.SecurityProviderName != nil {
		objectMap["securityProviderName"] = vhp.SecurityProviderName
	}
	if vhp.VirtualHubRouteTableV2s != nil {
		objectMap["virtualHubRouteTableV2s"] = vhp.VirtualHubRouteTableV2s
	}
	if vhp.Sku != nil {
		objectMap["sku"] = vhp.Sku
	}
	if vhp.RoutingState != "" {
		objectMap["routingState"] = vhp.RoutingState
	}
	if vhp.VirtualRouterAsn != nil {
		objectMap["virtualRouterAsn"] = vhp.VirtualRouterAsn
	}
	if vhp.VirtualRouterIps != nil {
		objectMap["virtualRouterIps"] = vhp.VirtualRouterIps
	}
	if vhp.AllowBranchToBranchTraffic != nil {
		objectMap["allowBranchToBranchTraffic"] = vhp.AllowBranchToBranchTraffic
	}
	return json.Marshal(objectMap)
}

// VirtualHubRoute virtualHub route.
type VirtualHubRoute struct {
	// AddressPrefixes - List of all addressPrefixes.
	AddressPrefixes *[]string `json:"addressPrefixes,omitempty"`
	// NextHopIPAddress - NextHop ip address.
	NextHopIPAddress *string `json:"nextHopIpAddress,omitempty"`
}

// VirtualHubRouteTable virtualHub route table.
type VirtualHubRouteTable struct {
	// Routes - List of all routes.
	Routes *[]VirtualHubRoute `json:"routes,omitempty"`
}

// VirtualHubRouteTableV2 virtualHubRouteTableV2 Resource.
type VirtualHubRouteTableV2 struct {
	autorest.Response `json:"-"`
	// VirtualHubRouteTableV2Properties - Properties of the virtual hub route table v2.
	*VirtualHubRouteTableV2Properties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualHubRouteTableV2.
func (vhrtv VirtualHubRouteTableV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vhrtv.VirtualHubRouteTableV2Properties != nil {
		objectMap["properties"] = vhrtv.VirtualHubRouteTableV2Properties
	}
	if vhrtv.Name != nil {
		objectMap["name"] = vhrtv.Name
	}
	if vhrtv.ID != nil {
		objectMap["id"] = vhrtv.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualHubRouteTableV2 struct.
func (vhrtv *VirtualHubRouteTableV2) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualHubRouteTableV2Properties VirtualHubRouteTableV2Properties
				err = json.Unmarshal(*v, &virtualHubRouteTableV2Properties)
				if err != nil {
					return err
				}
				vhrtv.VirtualHubRouteTableV2Properties = &virtualHubRouteTableV2Properties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vhrtv.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vhrtv.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vhrtv.ID = &ID
			}
		}
	}

	return nil
}

// VirtualHubRouteTableV2Properties parameters for VirtualHubRouteTableV2.
type VirtualHubRouteTableV2Properties struct {
	// Routes - List of all routes.
	Routes *[]VirtualHubRouteV2 `json:"routes,omitempty"`
	// AttachedConnections - List of all connections attached to this route table v2.
	AttachedConnections *[]string `json:"attachedConnections,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual hub route table v2 resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualHubRouteTableV2Properties.
func (vhrtvp VirtualHubRouteTableV2Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vhrtvp.Routes != nil {
		objectMap["routes"] = vhrtvp.Routes
	}
	if vhrtvp.AttachedConnections != nil {
		objectMap["attachedConnections"] = vhrtvp.AttachedConnections
	}
	return json.Marshal(objectMap)
}

// VirtualHubRouteTableV2sCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type VirtualHubRouteTableV2sCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubRouteTableV2sClient) (VirtualHubRouteTableV2, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubRouteTableV2sCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubRouteTableV2sCreateOrUpdateFuture.Result.
func (future *VirtualHubRouteTableV2sCreateOrUpdateFuture) result(client VirtualHubRouteTableV2sClient) (vhrtv VirtualHubRouteTableV2, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubRouteTableV2sCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vhrtv.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubRouteTableV2sCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vhrtv.Response.Response, err = future.GetResult(sender); err == nil && vhrtv.Response.Response.StatusCode != http.StatusNoContent {
		vhrtv, err = client.CreateOrUpdateResponder(vhrtv.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualHubRouteTableV2sCreateOrUpdateFuture", "Result", vhrtv.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualHubRouteTableV2sDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualHubRouteTableV2sDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubRouteTableV2sClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubRouteTableV2sDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubRouteTableV2sDeleteFuture.Result.
func (future *VirtualHubRouteTableV2sDeleteFuture) result(client VirtualHubRouteTableV2sClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubRouteTableV2sDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubRouteTableV2sDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualHubRouteV2 virtualHubRouteTableV2 route.
type VirtualHubRouteV2 struct {
	// DestinationType - The type of destinations.
	DestinationType *string `json:"destinationType,omitempty"`
	// Destinations - List of all destinations.
	Destinations *[]string `json:"destinations,omitempty"`
	// NextHopType - The type of next hops.
	NextHopType *string `json:"nextHopType,omitempty"`
	// NextHops - NextHops ip address.
	NextHops *[]string `json:"nextHops,omitempty"`
}

// VirtualHubsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualHubsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubsClient) (VirtualHub, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubsCreateOrUpdateFuture.Result.
func (future *VirtualHubsCreateOrUpdateFuture) result(client VirtualHubsClient) (vh VirtualHub, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vh.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vh.Response.Response, err = future.GetResult(sender); err == nil && vh.Response.Response.StatusCode != http.StatusNoContent {
		vh, err = client.CreateOrUpdateResponder(vh.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualHubsCreateOrUpdateFuture", "Result", vh.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualHubsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualHubsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubsDeleteFuture.Result.
func (future *VirtualHubsDeleteFuture) result(client VirtualHubsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualHubsGetEffectiveVirtualHubRoutesFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type VirtualHubsGetEffectiveVirtualHubRoutesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualHubsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualHubsGetEffectiveVirtualHubRoutesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualHubsGetEffectiveVirtualHubRoutesFuture.Result.
func (future *VirtualHubsGetEffectiveVirtualHubRoutesFuture) result(client VirtualHubsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualHubsGetEffectiveVirtualHubRoutesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualHubsGetEffectiveVirtualHubRoutesFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetwork virtual Network resource.
type VirtualNetwork struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of the virtual network.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// VirtualNetworkPropertiesFormat - Properties of the virtual network.
	*VirtualNetworkPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualNetwork.
func (vn VirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vn.ExtendedLocation != nil {
		objectMap["extendedLocation"] = vn.ExtendedLocation
	}
	if vn.VirtualNetworkPropertiesFormat != nil {
		objectMap["properties"] = vn.VirtualNetworkPropertiesFormat
	}
	if vn.ID != nil {
		objectMap["id"] = vn.ID
	}
	if vn.Location != nil {
		objectMap["location"] = vn.Location
	}
	if vn.Tags != nil {
		objectMap["tags"] = vn.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetwork struct.
func (vn *VirtualNetwork) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				vn.ExtendedLocation = &extendedLocation
			}
		case "properties":
			if v != nil {
				var virtualNetworkPropertiesFormat VirtualNetworkPropertiesFormat
				err = json.Unmarshal(*v, &virtualNetworkPropertiesFormat)
				if err != nil {
					return err
				}
				vn.VirtualNetworkPropertiesFormat = &virtualNetworkPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vn.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vn.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vn.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vn.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vn.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vn.Tags = tags
			}
		}
	}

	return nil
}

// VirtualNetworkBgpCommunities bgp Communities sent over ExpressRoute with each route corresponding to a
// prefix in this VNET.
type VirtualNetworkBgpCommunities struct {
	// VirtualNetworkCommunity - The BGP community associated with the virtual network.
	VirtualNetworkCommunity *string `json:"virtualNetworkCommunity,omitempty"`
	// RegionalCommunity - READ-ONLY; The BGP community associated with the region of the virtual network.
	RegionalCommunity *string `json:"regionalCommunity,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkBgpCommunities.
func (vnbc VirtualNetworkBgpCommunities) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnbc.VirtualNetworkCommunity != nil {
		objectMap["virtualNetworkCommunity"] = vnbc.VirtualNetworkCommunity
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkConnectionGatewayReference a reference to VirtualNetworkGateway or LocalNetworkGateway
// resource.
type VirtualNetworkConnectionGatewayReference struct {
	// ID - The ID of VirtualNetworkGateway or LocalNetworkGateway resource.
	ID *string `json:"id,omitempty"`
}

// VirtualNetworkGateway a common class for general resource information.
type VirtualNetworkGateway struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extended location of type local virtual network gateway.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// VirtualNetworkGatewayPropertiesFormat - Properties of the virtual network gateway.
	*VirtualNetworkGatewayPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGateway.
func (vng VirtualNetworkGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vng.ExtendedLocation != nil {
		objectMap["extendedLocation"] = vng.ExtendedLocation
	}
	if vng.VirtualNetworkGatewayPropertiesFormat != nil {
		objectMap["properties"] = vng.VirtualNetworkGatewayPropertiesFormat
	}
	if vng.ID != nil {
		objectMap["id"] = vng.ID
	}
	if vng.Location != nil {
		objectMap["location"] = vng.Location
	}
	if vng.Tags != nil {
		objectMap["tags"] = vng.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetworkGateway struct.
func (vng *VirtualNetworkGateway) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				vng.ExtendedLocation = &extendedLocation
			}
		case "properties":
			if v != nil {
				var virtualNetworkGatewayPropertiesFormat VirtualNetworkGatewayPropertiesFormat
				err = json.Unmarshal(*v, &virtualNetworkGatewayPropertiesFormat)
				if err != nil {
					return err
				}
				vng.VirtualNetworkGatewayPropertiesFormat = &virtualNetworkGatewayPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vng.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vng.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vng.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vng.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vng.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vng.Tags = tags
			}
		}
	}

	return nil
}

// VirtualNetworkGatewayConnection a common class for general resource information.
type VirtualNetworkGatewayConnection struct {
	autorest.Response `json:"-"`
	// VirtualNetworkGatewayConnectionPropertiesFormat - Properties of the virtual network gateway connection.
	*VirtualNetworkGatewayConnectionPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayConnection.
func (vngc VirtualNetworkGatewayConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngc.VirtualNetworkGatewayConnectionPropertiesFormat != nil {
		objectMap["properties"] = vngc.VirtualNetworkGatewayConnectionPropertiesFormat
	}
	if vngc.ID != nil {
		objectMap["id"] = vngc.ID
	}
	if vngc.Location != nil {
		objectMap["location"] = vngc.Location
	}
	if vngc.Tags != nil {
		objectMap["tags"] = vngc.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetworkGatewayConnection struct.
func (vngc *VirtualNetworkGatewayConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualNetworkGatewayConnectionPropertiesFormat VirtualNetworkGatewayConnectionPropertiesFormat
				err = json.Unmarshal(*v, &virtualNetworkGatewayConnectionPropertiesFormat)
				if err != nil {
					return err
				}
				vngc.VirtualNetworkGatewayConnectionPropertiesFormat = &virtualNetworkGatewayConnectionPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vngc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vngc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vngc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vngc.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vngc.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vngc.Tags = tags
			}
		}
	}

	return nil
}

// VirtualNetworkGatewayConnectionListEntity a common class for general resource information.
type VirtualNetworkGatewayConnectionListEntity struct {
	// VirtualNetworkGatewayConnectionListEntityPropertiesFormat - Properties of the virtual network gateway connection.
	*VirtualNetworkGatewayConnectionListEntityPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayConnectionListEntity.
func (vngcle VirtualNetworkGatewayConnectionListEntity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngcle.VirtualNetworkGatewayConnectionListEntityPropertiesFormat != nil {
		objectMap["properties"] = vngcle.VirtualNetworkGatewayConnectionListEntityPropertiesFormat
	}
	if vngcle.ID != nil {
		objectMap["id"] = vngcle.ID
	}
	if vngcle.Location != nil {
		objectMap["location"] = vngcle.Location
	}
	if vngcle.Tags != nil {
		objectMap["tags"] = vngcle.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetworkGatewayConnectionListEntity struct.
func (vngcle *VirtualNetworkGatewayConnectionListEntity) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualNetworkGatewayConnectionListEntityPropertiesFormat VirtualNetworkGatewayConnectionListEntityPropertiesFormat
				err = json.Unmarshal(*v, &virtualNetworkGatewayConnectionListEntityPropertiesFormat)
				if err != nil {
					return err
				}
				vngcle.VirtualNetworkGatewayConnectionListEntityPropertiesFormat = &virtualNetworkGatewayConnectionListEntityPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vngcle.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vngcle.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vngcle.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vngcle.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vngcle.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vngcle.Tags = tags
			}
		}
	}

	return nil
}

// VirtualNetworkGatewayConnectionListEntityPropertiesFormat virtualNetworkGatewayConnection properties.
type VirtualNetworkGatewayConnectionListEntityPropertiesFormat struct {
	// AuthorizationKey - The authorizationKey.
	AuthorizationKey *string `json:"authorizationKey,omitempty"`
	// VirtualNetworkGateway1 - The reference to virtual network gateway resource.
	VirtualNetworkGateway1 *VirtualNetworkConnectionGatewayReference `json:"virtualNetworkGateway1,omitempty"`
	// VirtualNetworkGateway2 - The reference to virtual network gateway resource.
	VirtualNetworkGateway2 *VirtualNetworkConnectionGatewayReference `json:"virtualNetworkGateway2,omitempty"`
	// LocalNetworkGateway2 - The reference to local network gateway resource.
	LocalNetworkGateway2 *VirtualNetworkConnectionGatewayReference `json:"localNetworkGateway2,omitempty"`
	// ConnectionType - Gateway connection type. Possible values include: 'VirtualNetworkGatewayConnectionTypeIPsec', 'VirtualNetworkGatewayConnectionTypeVnet2Vnet', 'VirtualNetworkGatewayConnectionTypeExpressRoute', 'VirtualNetworkGatewayConnectionTypeVPNClient'
	ConnectionType VirtualNetworkGatewayConnectionType `json:"connectionType,omitempty"`
	// ConnectionProtocol - Connection protocol used for this connection. Possible values include: 'VirtualNetworkGatewayConnectionProtocolIKEv2', 'VirtualNetworkGatewayConnectionProtocolIKEv1'
	ConnectionProtocol VirtualNetworkGatewayConnectionProtocol `json:"connectionProtocol,omitempty"`
	// RoutingWeight - The routing weight.
	RoutingWeight *int32 `json:"routingWeight,omitempty"`
	// ConnectionMode - The connection mode for this connection. Possible values include: 'VirtualNetworkGatewayConnectionModeDefault', 'VirtualNetworkGatewayConnectionModeResponderOnly', 'VirtualNetworkGatewayConnectionModeInitiatorOnly'
	ConnectionMode VirtualNetworkGatewayConnectionMode `json:"connectionMode,omitempty"`
	// SharedKey - The IPSec shared key.
	SharedKey *string `json:"sharedKey,omitempty"`
	// ConnectionStatus - READ-ONLY; Virtual Network Gateway connection status. Possible values include: 'VirtualNetworkGatewayConnectionStatusUnknown', 'VirtualNetworkGatewayConnectionStatusConnecting', 'VirtualNetworkGatewayConnectionStatusConnected', 'VirtualNetworkGatewayConnectionStatusNotConnected'
	ConnectionStatus VirtualNetworkGatewayConnectionStatus `json:"connectionStatus,omitempty"`
	// TunnelConnectionStatus - READ-ONLY; Collection of all tunnels' connection health status.
	TunnelConnectionStatus *[]TunnelConnectionHealth `json:"tunnelConnectionStatus,omitempty"`
	// EgressBytesTransferred - READ-ONLY; The egress bytes transferred in this connection.
	EgressBytesTransferred *int64 `json:"egressBytesTransferred,omitempty"`
	// IngressBytesTransferred - READ-ONLY; The ingress bytes transferred in this connection.
	IngressBytesTransferred *int64 `json:"ingressBytesTransferred,omitempty"`
	// Peer - The reference to peerings resource.
	Peer *SubResource `json:"peer,omitempty"`
	// EnableBgp - EnableBgp flag.
	EnableBgp *bool `json:"enableBgp,omitempty"`
	// UsePolicyBasedTrafficSelectors - Enable policy-based traffic selectors.
	UsePolicyBasedTrafficSelectors *bool `json:"usePolicyBasedTrafficSelectors,omitempty"`
	// IpsecPolicies - The IPSec Policies to be considered by this connection.
	IpsecPolicies *[]IpsecPolicy `json:"ipsecPolicies,omitempty"`
	// TrafficSelectorPolicies - The Traffic Selector Policies to be considered by this connection.
	TrafficSelectorPolicies *[]TrafficSelectorPolicy `json:"trafficSelectorPolicies,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the virtual network gateway connection resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual network gateway connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ExpressRouteGatewayBypass - Bypass ExpressRoute Gateway for data forwarding.
	ExpressRouteGatewayBypass *bool `json:"expressRouteGatewayBypass,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayConnectionListEntityPropertiesFormat.
func (vngclepf VirtualNetworkGatewayConnectionListEntityPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngclepf.AuthorizationKey != nil {
		objectMap["authorizationKey"] = vngclepf.AuthorizationKey
	}
	if vngclepf.VirtualNetworkGateway1 != nil {
		objectMap["virtualNetworkGateway1"] = vngclepf.VirtualNetworkGateway1
	}
	if vngclepf.VirtualNetworkGateway2 != nil {
		objectMap["virtualNetworkGateway2"] = vngclepf.VirtualNetworkGateway2
	}
	if vngclepf.LocalNetworkGateway2 != nil {
		objectMap["localNetworkGateway2"] = vngclepf.LocalNetworkGateway2
	}
	if vngclepf.ConnectionType != "" {
		objectMap["connectionType"] = vngclepf.ConnectionType
	}
	if vngclepf.ConnectionProtocol != "" {
		objectMap["connectionProtocol"] = vngclepf.ConnectionProtocol
	}
	if vngclepf.RoutingWeight != nil {
		objectMap["routingWeight"] = vngclepf.RoutingWeight
	}
	if vngclepf.ConnectionMode != "" {
		objectMap["connectionMode"] = vngclepf.ConnectionMode
	}
	if vngclepf.SharedKey != nil {
		objectMap["sharedKey"] = vngclepf.SharedKey
	}
	if vngclepf.Peer != nil {
		objectMap["peer"] = vngclepf.Peer
	}
	if vngclepf.EnableBgp != nil {
		objectMap["enableBgp"] = vngclepf.EnableBgp
	}
	if vngclepf.UsePolicyBasedTrafficSelectors != nil {
		objectMap["usePolicyBasedTrafficSelectors"] = vngclepf.UsePolicyBasedTrafficSelectors
	}
	if vngclepf.IpsecPolicies != nil {
		objectMap["ipsecPolicies"] = vngclepf.IpsecPolicies
	}
	if vngclepf.TrafficSelectorPolicies != nil {
		objectMap["trafficSelectorPolicies"] = vngclepf.TrafficSelectorPolicies
	}
	if vngclepf.ExpressRouteGatewayBypass != nil {
		objectMap["expressRouteGatewayBypass"] = vngclepf.ExpressRouteGatewayBypass
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkGatewayConnectionListResult response for the ListVirtualNetworkGatewayConnections API
// service call.
type VirtualNetworkGatewayConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of VirtualNetworkGatewayConnection resources that exists in a resource group.
	Value *[]VirtualNetworkGatewayConnection `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayConnectionListResult.
func (vngclr VirtualNetworkGatewayConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngclr.Value != nil {
		objectMap["value"] = vngclr.Value
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkGatewayConnectionListResultIterator provides access to a complete listing of
// VirtualNetworkGatewayConnection values.
type VirtualNetworkGatewayConnectionListResultIterator struct {
	i    int
	page VirtualNetworkGatewayConnectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworkGatewayConnectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkGatewayConnectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworkGatewayConnectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworkGatewayConnectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworkGatewayConnectionListResultIterator) Response() VirtualNetworkGatewayConnectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworkGatewayConnectionListResultIterator) Value() VirtualNetworkGatewayConnection {
	if !iter.page.NotDone() {
		return VirtualNetworkGatewayConnection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworkGatewayConnectionListResultIterator type.
func NewVirtualNetworkGatewayConnectionListResultIterator(page VirtualNetworkGatewayConnectionListResultPage) VirtualNetworkGatewayConnectionListResultIterator {
	return VirtualNetworkGatewayConnectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vngclr VirtualNetworkGatewayConnectionListResult) IsEmpty() bool {
	return vngclr.Value == nil || len(*vngclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vngclr VirtualNetworkGatewayConnectionListResult) hasNextLink() bool {
	return vngclr.NextLink != nil && len(*vngclr.NextLink) != 0
}

// virtualNetworkGatewayConnectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vngclr VirtualNetworkGatewayConnectionListResult) virtualNetworkGatewayConnectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vngclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vngclr.NextLink)))
}

// VirtualNetworkGatewayConnectionListResultPage contains a page of VirtualNetworkGatewayConnection values.
type VirtualNetworkGatewayConnectionListResultPage struct {
	fn     func(context.Context, VirtualNetworkGatewayConnectionListResult) (VirtualNetworkGatewayConnectionListResult, error)
	vngclr VirtualNetworkGatewayConnectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworkGatewayConnectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkGatewayConnectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vngclr)
		if err != nil {
			return err
		}
		page.vngclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworkGatewayConnectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworkGatewayConnectionListResultPage) NotDone() bool {
	return !page.vngclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworkGatewayConnectionListResultPage) Response() VirtualNetworkGatewayConnectionListResult {
	return page.vngclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworkGatewayConnectionListResultPage) Values() []VirtualNetworkGatewayConnection {
	if page.vngclr.IsEmpty() {
		return nil
	}
	return *page.vngclr.Value
}

// Creates a new instance of the VirtualNetworkGatewayConnectionListResultPage type.
func NewVirtualNetworkGatewayConnectionListResultPage(cur VirtualNetworkGatewayConnectionListResult, getNextPage func(context.Context, VirtualNetworkGatewayConnectionListResult) (VirtualNetworkGatewayConnectionListResult, error)) VirtualNetworkGatewayConnectionListResultPage {
	return VirtualNetworkGatewayConnectionListResultPage{
		fn:     getNextPage,
		vngclr: cur,
	}
}

// VirtualNetworkGatewayConnectionPropertiesFormat virtualNetworkGatewayConnection properties.
type VirtualNetworkGatewayConnectionPropertiesFormat struct {
	// AuthorizationKey - The authorizationKey.
	AuthorizationKey *string `json:"authorizationKey,omitempty"`
	// VirtualNetworkGateway1 - The reference to virtual network gateway resource.
	VirtualNetworkGateway1 *VirtualNetworkGateway `json:"virtualNetworkGateway1,omitempty"`
	// VirtualNetworkGateway2 - The reference to virtual network gateway resource.
	VirtualNetworkGateway2 *VirtualNetworkGateway `json:"virtualNetworkGateway2,omitempty"`
	// LocalNetworkGateway2 - The reference to local network gateway resource.
	LocalNetworkGateway2 *LocalNetworkGateway `json:"localNetworkGateway2,omitempty"`
	// ConnectionType - Gateway connection type. Possible values include: 'VirtualNetworkGatewayConnectionTypeIPsec', 'VirtualNetworkGatewayConnectionTypeVnet2Vnet', 'VirtualNetworkGatewayConnectionTypeExpressRoute', 'VirtualNetworkGatewayConnectionTypeVPNClient'
	ConnectionType VirtualNetworkGatewayConnectionType `json:"connectionType,omitempty"`
	// ConnectionProtocol - Connection protocol used for this connection. Possible values include: 'VirtualNetworkGatewayConnectionProtocolIKEv2', 'VirtualNetworkGatewayConnectionProtocolIKEv1'
	ConnectionProtocol VirtualNetworkGatewayConnectionProtocol `json:"connectionProtocol,omitempty"`
	// RoutingWeight - The routing weight.
	RoutingWeight *int32 `json:"routingWeight,omitempty"`
	// DpdTimeoutSeconds - The dead peer detection timeout of this connection in seconds.
	DpdTimeoutSeconds *int32 `json:"dpdTimeoutSeconds,omitempty"`
	// ConnectionMode - The connection mode for this connection. Possible values include: 'VirtualNetworkGatewayConnectionModeDefault', 'VirtualNetworkGatewayConnectionModeResponderOnly', 'VirtualNetworkGatewayConnectionModeInitiatorOnly'
	ConnectionMode VirtualNetworkGatewayConnectionMode `json:"connectionMode,omitempty"`
	// SharedKey - The IPSec shared key.
	SharedKey *string `json:"sharedKey,omitempty"`
	// ConnectionStatus - READ-ONLY; Virtual Network Gateway connection status. Possible values include: 'VirtualNetworkGatewayConnectionStatusUnknown', 'VirtualNetworkGatewayConnectionStatusConnecting', 'VirtualNetworkGatewayConnectionStatusConnected', 'VirtualNetworkGatewayConnectionStatusNotConnected'
	ConnectionStatus VirtualNetworkGatewayConnectionStatus `json:"connectionStatus,omitempty"`
	// TunnelConnectionStatus - READ-ONLY; Collection of all tunnels' connection health status.
	TunnelConnectionStatus *[]TunnelConnectionHealth `json:"tunnelConnectionStatus,omitempty"`
	// EgressBytesTransferred - READ-ONLY; The egress bytes transferred in this connection.
	EgressBytesTransferred *int64 `json:"egressBytesTransferred,omitempty"`
	// IngressBytesTransferred - READ-ONLY; The ingress bytes transferred in this connection.
	IngressBytesTransferred *int64 `json:"ingressBytesTransferred,omitempty"`
	// Peer - The reference to peerings resource.
	Peer *SubResource `json:"peer,omitempty"`
	// EnableBgp - EnableBgp flag.
	EnableBgp *bool `json:"enableBgp,omitempty"`
	// UseLocalAzureIPAddress - Use private local Azure IP for the connection.
	UseLocalAzureIPAddress *bool `json:"useLocalAzureIpAddress,omitempty"`
	// UsePolicyBasedTrafficSelectors - Enable policy-based traffic selectors.
	UsePolicyBasedTrafficSelectors *bool `json:"usePolicyBasedTrafficSelectors,omitempty"`
	// IpsecPolicies - The IPSec Policies to be considered by this connection.
	IpsecPolicies *[]IpsecPolicy `json:"ipsecPolicies,omitempty"`
	// TrafficSelectorPolicies - The Traffic Selector Policies to be considered by this connection.
	TrafficSelectorPolicies *[]TrafficSelectorPolicy `json:"trafficSelectorPolicies,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the virtual network gateway connection resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual network gateway connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ExpressRouteGatewayBypass - Bypass ExpressRoute Gateway for data forwarding.
	ExpressRouteGatewayBypass *bool `json:"expressRouteGatewayBypass,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayConnectionPropertiesFormat.
func (vngcpf VirtualNetworkGatewayConnectionPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngcpf.AuthorizationKey != nil {
		objectMap["authorizationKey"] = vngcpf.AuthorizationKey
	}
	if vngcpf.VirtualNetworkGateway1 != nil {
		objectMap["virtualNetworkGateway1"] = vngcpf.VirtualNetworkGateway1
	}
	if vngcpf.VirtualNetworkGateway2 != nil {
		objectMap["virtualNetworkGateway2"] = vngcpf.VirtualNetworkGateway2
	}
	if vngcpf.LocalNetworkGateway2 != nil {
		objectMap["localNetworkGateway2"] = vngcpf.LocalNetworkGateway2
	}
	if vngcpf.ConnectionType != "" {
		objectMap["connectionType"] = vngcpf.ConnectionType
	}
	if vngcpf.ConnectionProtocol != "" {
		objectMap["connectionProtocol"] = vngcpf.ConnectionProtocol
	}
	if vngcpf.RoutingWeight != nil {
		objectMap["routingWeight"] = vngcpf.RoutingWeight
	}
	if vngcpf.DpdTimeoutSeconds != nil {
		objectMap["dpdTimeoutSeconds"] = vngcpf.DpdTimeoutSeconds
	}
	if vngcpf.ConnectionMode != "" {
		objectMap["connectionMode"] = vngcpf.ConnectionMode
	}
	if vngcpf.SharedKey != nil {
		objectMap["sharedKey"] = vngcpf.SharedKey
	}
	if vngcpf.Peer != nil {
		objectMap["peer"] = vngcpf.Peer
	}
	if vngcpf.EnableBgp != nil {
		objectMap["enableBgp"] = vngcpf.EnableBgp
	}
	if vngcpf.UseLocalAzureIPAddress != nil {
		objectMap["useLocalAzureIpAddress"] = vngcpf.UseLocalAzureIPAddress
	}
	if vngcpf.UsePolicyBasedTrafficSelectors != nil {
		objectMap["usePolicyBasedTrafficSelectors"] = vngcpf.UsePolicyBasedTrafficSelectors
	}
	if vngcpf.IpsecPolicies != nil {
		objectMap["ipsecPolicies"] = vngcpf.IpsecPolicies
	}
	if vngcpf.TrafficSelectorPolicies != nil {
		objectMap["trafficSelectorPolicies"] = vngcpf.TrafficSelectorPolicies
	}
	if vngcpf.ExpressRouteGatewayBypass != nil {
		objectMap["expressRouteGatewayBypass"] = vngcpf.ExpressRouteGatewayBypass
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkGatewayConnectionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewayConnectionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (VirtualNetworkGatewayConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsCreateOrUpdateFuture.Result.
func (future *VirtualNetworkGatewayConnectionsCreateOrUpdateFuture) result(client VirtualNetworkGatewayConnectionsClient) (vngc VirtualNetworkGatewayConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vngc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vngc.Response.Response, err = future.GetResult(sender); err == nil && vngc.Response.Response.StatusCode != http.StatusNoContent {
		vngc, err = client.CreateOrUpdateResponder(vngc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsCreateOrUpdateFuture", "Result", vngc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewayConnectionsDeleteFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type VirtualNetworkGatewayConnectionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsDeleteFuture.Result.
func (future *VirtualNetworkGatewayConnectionsDeleteFuture) result(client VirtualNetworkGatewayConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworkGatewayConnectionsGetIkeSasFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type VirtualNetworkGatewayConnectionsGetIkeSasFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsGetIkeSasFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsGetIkeSasFuture.Result.
func (future *VirtualNetworkGatewayConnectionsGetIkeSasFuture) result(client VirtualNetworkGatewayConnectionsClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsGetIkeSasFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsGetIkeSasFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.GetIkeSasResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsGetIkeSasFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewayConnectionsResetConnectionFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewayConnectionsResetConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsResetConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsResetConnectionFuture.Result.
func (future *VirtualNetworkGatewayConnectionsResetConnectionFuture) result(client VirtualNetworkGatewayConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsResetConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsResetConnectionFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworkGatewayConnectionsResetSharedKeyFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewayConnectionsResetSharedKeyFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (ConnectionResetSharedKey, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsResetSharedKeyFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsResetSharedKeyFuture.Result.
func (future *VirtualNetworkGatewayConnectionsResetSharedKeyFuture) result(client VirtualNetworkGatewayConnectionsClient) (crsk ConnectionResetSharedKey, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsResetSharedKeyFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		crsk.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsResetSharedKeyFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if crsk.Response.Response, err = future.GetResult(sender); err == nil && crsk.Response.Response.StatusCode != http.StatusNoContent {
		crsk, err = client.ResetSharedKeyResponder(crsk.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsResetSharedKeyFuture", "Result", crsk.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewayConnectionsSetSharedKeyFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewayConnectionsSetSharedKeyFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (ConnectionSharedKey, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsSetSharedKeyFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsSetSharedKeyFuture.Result.
func (future *VirtualNetworkGatewayConnectionsSetSharedKeyFuture) result(client VirtualNetworkGatewayConnectionsClient) (csk ConnectionSharedKey, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsSetSharedKeyFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		csk.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsSetSharedKeyFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if csk.Response.Response, err = future.GetResult(sender); err == nil && csk.Response.Response.StatusCode != http.StatusNoContent {
		csk, err = client.SetSharedKeyResponder(csk.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsSetSharedKeyFuture", "Result", csk.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewayConnectionsStartPacketCaptureFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type VirtualNetworkGatewayConnectionsStartPacketCaptureFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsStartPacketCaptureFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsStartPacketCaptureFuture.Result.
func (future *VirtualNetworkGatewayConnectionsStartPacketCaptureFuture) result(client VirtualNetworkGatewayConnectionsClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsStartPacketCaptureFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsStartPacketCaptureFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.StartPacketCaptureResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsStartPacketCaptureFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewayConnectionsStopPacketCaptureFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewayConnectionsStopPacketCaptureFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsStopPacketCaptureFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsStopPacketCaptureFuture.Result.
func (future *VirtualNetworkGatewayConnectionsStopPacketCaptureFuture) result(client VirtualNetworkGatewayConnectionsClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsStopPacketCaptureFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsStopPacketCaptureFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.StopPacketCaptureResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsStopPacketCaptureFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewayConnectionsUpdateTagsFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewayConnectionsUpdateTagsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewayConnectionsClient) (VirtualNetworkGatewayConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewayConnectionsUpdateTagsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewayConnectionsUpdateTagsFuture.Result.
func (future *VirtualNetworkGatewayConnectionsUpdateTagsFuture) result(client VirtualNetworkGatewayConnectionsClient) (vngc VirtualNetworkGatewayConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsUpdateTagsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vngc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewayConnectionsUpdateTagsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vngc.Response.Response, err = future.GetResult(sender); err == nil && vngc.Response.Response.StatusCode != http.StatusNoContent {
		vngc, err = client.UpdateTagsResponder(vngc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewayConnectionsUpdateTagsFuture", "Result", vngc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewayIPConfiguration IP configuration for virtual network gateway.
type VirtualNetworkGatewayIPConfiguration struct {
	// VirtualNetworkGatewayIPConfigurationPropertiesFormat - Properties of the virtual network gateway ip configuration.
	*VirtualNetworkGatewayIPConfigurationPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayIPConfiguration.
func (vngic VirtualNetworkGatewayIPConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngic.VirtualNetworkGatewayIPConfigurationPropertiesFormat != nil {
		objectMap["properties"] = vngic.VirtualNetworkGatewayIPConfigurationPropertiesFormat
	}
	if vngic.Name != nil {
		objectMap["name"] = vngic.Name
	}
	if vngic.ID != nil {
		objectMap["id"] = vngic.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetworkGatewayIPConfiguration struct.
func (vngic *VirtualNetworkGatewayIPConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualNetworkGatewayIPConfigurationPropertiesFormat VirtualNetworkGatewayIPConfigurationPropertiesFormat
				err = json.Unmarshal(*v, &virtualNetworkGatewayIPConfigurationPropertiesFormat)
				if err != nil {
					return err
				}
				vngic.VirtualNetworkGatewayIPConfigurationPropertiesFormat = &virtualNetworkGatewayIPConfigurationPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vngic.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vngic.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vngic.ID = &ID
			}
		}
	}

	return nil
}

// VirtualNetworkGatewayIPConfigurationPropertiesFormat properties of VirtualNetworkGatewayIPConfiguration.
type VirtualNetworkGatewayIPConfigurationPropertiesFormat struct {
	// PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'IPAllocationMethodStatic', 'IPAllocationMethodDynamic'
	PrivateIPAllocationMethod IPAllocationMethod `json:"privateIPAllocationMethod,omitempty"`
	// Subnet - The reference to the subnet resource.
	Subnet *SubResource `json:"subnet,omitempty"`
	// PublicIPAddress - The reference to the public IP resource.
	PublicIPAddress *SubResource `json:"publicIPAddress,omitempty"`
	// PrivateIPAddress - READ-ONLY; Private IP Address for this gateway.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual network gateway IP configuration resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayIPConfigurationPropertiesFormat.
func (vngicpf VirtualNetworkGatewayIPConfigurationPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngicpf.PrivateIPAllocationMethod != "" {
		objectMap["privateIPAllocationMethod"] = vngicpf.PrivateIPAllocationMethod
	}
	if vngicpf.Subnet != nil {
		objectMap["subnet"] = vngicpf.Subnet
	}
	if vngicpf.PublicIPAddress != nil {
		objectMap["publicIPAddress"] = vngicpf.PublicIPAddress
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkGatewayListConnectionsResult response for the VirtualNetworkGatewayListConnections API
// service call.
type VirtualNetworkGatewayListConnectionsResult struct {
	autorest.Response `json:"-"`
	// Value - A list of VirtualNetworkGatewayConnection resources that exists in a resource group.
	Value *[]VirtualNetworkGatewayConnectionListEntity `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayListConnectionsResult.
func (vnglcr VirtualNetworkGatewayListConnectionsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnglcr.Value != nil {
		objectMap["value"] = vnglcr.Value
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkGatewayListConnectionsResultIterator provides access to a complete listing of
// VirtualNetworkGatewayConnectionListEntity values.
type VirtualNetworkGatewayListConnectionsResultIterator struct {
	i    int
	page VirtualNetworkGatewayListConnectionsResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworkGatewayListConnectionsResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkGatewayListConnectionsResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworkGatewayListConnectionsResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworkGatewayListConnectionsResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworkGatewayListConnectionsResultIterator) Response() VirtualNetworkGatewayListConnectionsResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworkGatewayListConnectionsResultIterator) Value() VirtualNetworkGatewayConnectionListEntity {
	if !iter.page.NotDone() {
		return VirtualNetworkGatewayConnectionListEntity{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworkGatewayListConnectionsResultIterator type.
func NewVirtualNetworkGatewayListConnectionsResultIterator(page VirtualNetworkGatewayListConnectionsResultPage) VirtualNetworkGatewayListConnectionsResultIterator {
	return VirtualNetworkGatewayListConnectionsResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vnglcr VirtualNetworkGatewayListConnectionsResult) IsEmpty() bool {
	return vnglcr.Value == nil || len(*vnglcr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vnglcr VirtualNetworkGatewayListConnectionsResult) hasNextLink() bool {
	return vnglcr.NextLink != nil && len(*vnglcr.NextLink) != 0
}

// virtualNetworkGatewayListConnectionsResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vnglcr VirtualNetworkGatewayListConnectionsResult) virtualNetworkGatewayListConnectionsResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vnglcr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vnglcr.NextLink)))
}

// VirtualNetworkGatewayListConnectionsResultPage contains a page of
// VirtualNetworkGatewayConnectionListEntity values.
type VirtualNetworkGatewayListConnectionsResultPage struct {
	fn     func(context.Context, VirtualNetworkGatewayListConnectionsResult) (VirtualNetworkGatewayListConnectionsResult, error)
	vnglcr VirtualNetworkGatewayListConnectionsResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworkGatewayListConnectionsResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkGatewayListConnectionsResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vnglcr)
		if err != nil {
			return err
		}
		page.vnglcr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworkGatewayListConnectionsResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworkGatewayListConnectionsResultPage) NotDone() bool {
	return !page.vnglcr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworkGatewayListConnectionsResultPage) Response() VirtualNetworkGatewayListConnectionsResult {
	return page.vnglcr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworkGatewayListConnectionsResultPage) Values() []VirtualNetworkGatewayConnectionListEntity {
	if page.vnglcr.IsEmpty() {
		return nil
	}
	return *page.vnglcr.Value
}

// Creates a new instance of the VirtualNetworkGatewayListConnectionsResultPage type.
func NewVirtualNetworkGatewayListConnectionsResultPage(cur VirtualNetworkGatewayListConnectionsResult, getNextPage func(context.Context, VirtualNetworkGatewayListConnectionsResult) (VirtualNetworkGatewayListConnectionsResult, error)) VirtualNetworkGatewayListConnectionsResultPage {
	return VirtualNetworkGatewayListConnectionsResultPage{
		fn:     getNextPage,
		vnglcr: cur,
	}
}

// VirtualNetworkGatewayListResult response for the ListVirtualNetworkGateways API service call.
type VirtualNetworkGatewayListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of VirtualNetworkGateway resources that exists in a resource group.
	Value *[]VirtualNetworkGateway `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayListResult.
func (vnglr VirtualNetworkGatewayListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnglr.Value != nil {
		objectMap["value"] = vnglr.Value
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkGatewayListResultIterator provides access to a complete listing of VirtualNetworkGateway
// values.
type VirtualNetworkGatewayListResultIterator struct {
	i    int
	page VirtualNetworkGatewayListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworkGatewayListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkGatewayListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworkGatewayListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworkGatewayListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworkGatewayListResultIterator) Response() VirtualNetworkGatewayListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworkGatewayListResultIterator) Value() VirtualNetworkGateway {
	if !iter.page.NotDone() {
		return VirtualNetworkGateway{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworkGatewayListResultIterator type.
func NewVirtualNetworkGatewayListResultIterator(page VirtualNetworkGatewayListResultPage) VirtualNetworkGatewayListResultIterator {
	return VirtualNetworkGatewayListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vnglr VirtualNetworkGatewayListResult) IsEmpty() bool {
	return vnglr.Value == nil || len(*vnglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vnglr VirtualNetworkGatewayListResult) hasNextLink() bool {
	return vnglr.NextLink != nil && len(*vnglr.NextLink) != 0
}

// virtualNetworkGatewayListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vnglr VirtualNetworkGatewayListResult) virtualNetworkGatewayListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vnglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vnglr.NextLink)))
}

// VirtualNetworkGatewayListResultPage contains a page of VirtualNetworkGateway values.
type VirtualNetworkGatewayListResultPage struct {
	fn    func(context.Context, VirtualNetworkGatewayListResult) (VirtualNetworkGatewayListResult, error)
	vnglr VirtualNetworkGatewayListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworkGatewayListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkGatewayListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vnglr)
		if err != nil {
			return err
		}
		page.vnglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworkGatewayListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworkGatewayListResultPage) NotDone() bool {
	return !page.vnglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworkGatewayListResultPage) Response() VirtualNetworkGatewayListResult {
	return page.vnglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworkGatewayListResultPage) Values() []VirtualNetworkGateway {
	if page.vnglr.IsEmpty() {
		return nil
	}
	return *page.vnglr.Value
}

// Creates a new instance of the VirtualNetworkGatewayListResultPage type.
func NewVirtualNetworkGatewayListResultPage(cur VirtualNetworkGatewayListResult, getNextPage func(context.Context, VirtualNetworkGatewayListResult) (VirtualNetworkGatewayListResult, error)) VirtualNetworkGatewayListResultPage {
	return VirtualNetworkGatewayListResultPage{
		fn:    getNextPage,
		vnglr: cur,
	}
}

// VirtualNetworkGatewayPropertiesFormat virtualNetworkGateway properties.
type VirtualNetworkGatewayPropertiesFormat struct {
	// IPConfigurations - IP configurations for virtual network gateway.
	IPConfigurations *[]VirtualNetworkGatewayIPConfiguration `json:"ipConfigurations,omitempty"`
	// GatewayType - The type of this virtual network gateway. Possible values include: 'VirtualNetworkGatewayTypeVpn', 'VirtualNetworkGatewayTypeExpressRoute', 'VirtualNetworkGatewayTypeLocalGateway'
	GatewayType VirtualNetworkGatewayType `json:"gatewayType,omitempty"`
	// VpnType - The type of this virtual network gateway. Possible values include: 'VpnTypePolicyBased', 'VpnTypeRouteBased'
	VpnType VpnType `json:"vpnType,omitempty"`
	// VpnGatewayGeneration - The generation for this VirtualNetworkGateway. Must be None if gatewayType is not VPN. Possible values include: 'VpnGatewayGenerationNone', 'VpnGatewayGenerationGeneration1', 'VpnGatewayGenerationGeneration2'
	VpnGatewayGeneration VpnGatewayGeneration `json:"vpnGatewayGeneration,omitempty"`
	// EnableBgp - Whether BGP is enabled for this virtual network gateway or not.
	EnableBgp *bool `json:"enableBgp,omitempty"`
	// EnablePrivateIPAddress - Whether private IP needs to be enabled on this gateway for connections or not.
	EnablePrivateIPAddress *bool `json:"enablePrivateIpAddress,omitempty"`
	// ActiveActive - ActiveActive flag.
	ActiveActive *bool `json:"activeActive,omitempty"`
	// GatewayDefaultSite - The reference to the LocalNetworkGateway resource which represents local network site having default routes. Assign Null value in case of removing existing default site setting.
	GatewayDefaultSite *SubResource `json:"gatewayDefaultSite,omitempty"`
	// Sku - The reference to the VirtualNetworkGatewaySku resource which represents the SKU selected for Virtual network gateway.
	Sku *VirtualNetworkGatewaySku `json:"sku,omitempty"`
	// VpnClientConfiguration - The reference to the VpnClientConfiguration resource which represents the P2S VpnClient configurations.
	VpnClientConfiguration *VpnClientConfiguration `json:"vpnClientConfiguration,omitempty"`
	// BgpSettings - Virtual network gateway's BGP speaker settings.
	BgpSettings *BgpSettings `json:"bgpSettings,omitempty"`
	// CustomRoutes - The reference to the address space resource which represents the custom routes address space specified by the customer for virtual network gateway and VpnClient.
	CustomRoutes *AddressSpace `json:"customRoutes,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the virtual network gateway resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual network gateway resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// EnableDNSForwarding - Whether dns forwarding is enabled or not.
	EnableDNSForwarding *bool `json:"enableDnsForwarding,omitempty"`
	// InboundDNSForwardingEndpoint - READ-ONLY; The IP address allocated by the gateway to which dns requests can be sent.
	InboundDNSForwardingEndpoint *string `json:"inboundDnsForwardingEndpoint,omitempty"`
	// VNetExtendedLocationResourceID - Customer vnet resource id. VirtualNetworkGateway of type local gateway is associated with the customer vnet.
	VNetExtendedLocationResourceID *string `json:"vNetExtendedLocationResourceId,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewayPropertiesFormat.
func (vngpf VirtualNetworkGatewayPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngpf.IPConfigurations != nil {
		objectMap["ipConfigurations"] = vngpf.IPConfigurations
	}
	if vngpf.GatewayType != "" {
		objectMap["gatewayType"] = vngpf.GatewayType
	}
	if vngpf.VpnType != "" {
		objectMap["vpnType"] = vngpf.VpnType
	}
	if vngpf.VpnGatewayGeneration != "" {
		objectMap["vpnGatewayGeneration"] = vngpf.VpnGatewayGeneration
	}
	if vngpf.EnableBgp != nil {
		objectMap["enableBgp"] = vngpf.EnableBgp
	}
	if vngpf.EnablePrivateIPAddress != nil {
		objectMap["enablePrivateIpAddress"] = vngpf.EnablePrivateIPAddress
	}
	if vngpf.ActiveActive != nil {
		objectMap["activeActive"] = vngpf.ActiveActive
	}
	if vngpf.GatewayDefaultSite != nil {
		objectMap["gatewayDefaultSite"] = vngpf.GatewayDefaultSite
	}
	if vngpf.Sku != nil {
		objectMap["sku"] = vngpf.Sku
	}
	if vngpf.VpnClientConfiguration != nil {
		objectMap["vpnClientConfiguration"] = vngpf.VpnClientConfiguration
	}
	if vngpf.BgpSettings != nil {
		objectMap["bgpSettings"] = vngpf.BgpSettings
	}
	if vngpf.CustomRoutes != nil {
		objectMap["customRoutes"] = vngpf.CustomRoutes
	}
	if vngpf.EnableDNSForwarding != nil {
		objectMap["enableDnsForwarding"] = vngpf.EnableDNSForwarding
	}
	if vngpf.VNetExtendedLocationResourceID != nil {
		objectMap["vNetExtendedLocationResourceId"] = vngpf.VNetExtendedLocationResourceID
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkGatewaysCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworkGatewaysCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (VirtualNetworkGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysCreateOrUpdateFuture.Result.
func (future *VirtualNetworkGatewaysCreateOrUpdateFuture) result(client VirtualNetworkGatewaysClient) (vng VirtualNetworkGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vng.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vng.Response.Response, err = future.GetResult(sender); err == nil && vng.Response.Response.StatusCode != http.StatusNoContent {
		vng, err = client.CreateOrUpdateResponder(vng.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysCreateOrUpdateFuture", "Result", vng.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworkGatewaysDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysDeleteFuture.Result.
func (future *VirtualNetworkGatewaysDeleteFuture) result(client VirtualNetworkGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVpnConnectionsFuture an abstraction for monitoring
// and retrieving the results of a long-running operation.
type VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVpnConnectionsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVpnConnectionsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVpnConnectionsFuture.Result.
func (future *VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVpnConnectionsFuture) result(client VirtualNetworkGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVpnConnectionsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVpnConnectionsFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworkGatewaysGeneratevpnclientpackageFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewaysGeneratevpnclientpackageFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysGeneratevpnclientpackageFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysGeneratevpnclientpackageFuture.Result.
func (future *VirtualNetworkGatewaysGeneratevpnclientpackageFuture) result(client VirtualNetworkGatewaysClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGeneratevpnclientpackageFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysGeneratevpnclientpackageFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.GeneratevpnclientpackageResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGeneratevpnclientpackageFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysGenerateVpnProfileFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type VirtualNetworkGatewaysGenerateVpnProfileFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysGenerateVpnProfileFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysGenerateVpnProfileFuture.Result.
func (future *VirtualNetworkGatewaysGenerateVpnProfileFuture) result(client VirtualNetworkGatewaysClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGenerateVpnProfileFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysGenerateVpnProfileFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.GenerateVpnProfileResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGenerateVpnProfileFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysGetAdvertisedRoutesFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type VirtualNetworkGatewaysGetAdvertisedRoutesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (GatewayRouteListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysGetAdvertisedRoutesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysGetAdvertisedRoutesFuture.Result.
func (future *VirtualNetworkGatewaysGetAdvertisedRoutesFuture) result(client VirtualNetworkGatewaysClient) (grlr GatewayRouteListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetAdvertisedRoutesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		grlr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysGetAdvertisedRoutesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if grlr.Response.Response, err = future.GetResult(sender); err == nil && grlr.Response.Response.StatusCode != http.StatusNoContent {
		grlr, err = client.GetAdvertisedRoutesResponder(grlr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetAdvertisedRoutesFuture", "Result", grlr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysGetBgpPeerStatusFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type VirtualNetworkGatewaysGetBgpPeerStatusFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (BgpPeerStatusListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysGetBgpPeerStatusFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysGetBgpPeerStatusFuture.Result.
func (future *VirtualNetworkGatewaysGetBgpPeerStatusFuture) result(client VirtualNetworkGatewaysClient) (bpslr BgpPeerStatusListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetBgpPeerStatusFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bpslr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysGetBgpPeerStatusFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bpslr.Response.Response, err = future.GetResult(sender); err == nil && bpslr.Response.Response.StatusCode != http.StatusNoContent {
		bpslr, err = client.GetBgpPeerStatusResponder(bpslr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetBgpPeerStatusFuture", "Result", bpslr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysGetLearnedRoutesFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type VirtualNetworkGatewaysGetLearnedRoutesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (GatewayRouteListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysGetLearnedRoutesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysGetLearnedRoutesFuture.Result.
func (future *VirtualNetworkGatewaysGetLearnedRoutesFuture) result(client VirtualNetworkGatewaysClient) (grlr GatewayRouteListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetLearnedRoutesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		grlr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysGetLearnedRoutesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if grlr.Response.Response, err = future.GetResult(sender); err == nil && grlr.Response.Response.StatusCode != http.StatusNoContent {
		grlr, err = client.GetLearnedRoutesResponder(grlr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetLearnedRoutesFuture", "Result", grlr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysGetVpnclientConnectionHealthFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type VirtualNetworkGatewaysGetVpnclientConnectionHealthFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (VpnClientConnectionHealthDetailListResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysGetVpnclientConnectionHealthFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysGetVpnclientConnectionHealthFuture.Result.
func (future *VirtualNetworkGatewaysGetVpnclientConnectionHealthFuture) result(client VirtualNetworkGatewaysClient) (vcchdlr VpnClientConnectionHealthDetailListResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetVpnclientConnectionHealthFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vcchdlr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysGetVpnclientConnectionHealthFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vcchdlr.Response.Response, err = future.GetResult(sender); err == nil && vcchdlr.Response.Response.StatusCode != http.StatusNoContent {
		vcchdlr, err = client.GetVpnclientConnectionHealthResponder(vcchdlr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetVpnclientConnectionHealthFuture", "Result", vcchdlr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysGetVpnclientIpsecParametersFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewaysGetVpnclientIpsecParametersFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (VpnClientIPsecParameters, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysGetVpnclientIpsecParametersFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysGetVpnclientIpsecParametersFuture.Result.
func (future *VirtualNetworkGatewaysGetVpnclientIpsecParametersFuture) result(client VirtualNetworkGatewaysClient) (vcipp VpnClientIPsecParameters, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetVpnclientIpsecParametersFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vcipp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysGetVpnclientIpsecParametersFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vcipp.Response.Response, err = future.GetResult(sender); err == nil && vcipp.Response.Response.StatusCode != http.StatusNoContent {
		vcipp, err = client.GetVpnclientIpsecParametersResponder(vcipp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetVpnclientIpsecParametersFuture", "Result", vcipp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysGetVpnProfilePackageURLFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewaysGetVpnProfilePackageURLFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysGetVpnProfilePackageURLFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysGetVpnProfilePackageURLFuture.Result.
func (future *VirtualNetworkGatewaysGetVpnProfilePackageURLFuture) result(client VirtualNetworkGatewaysClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetVpnProfilePackageURLFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysGetVpnProfilePackageURLFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.GetVpnProfilePackageURLResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysGetVpnProfilePackageURLFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaySku virtualNetworkGatewaySku details.
type VirtualNetworkGatewaySku struct {
	// Name - Gateway SKU name. Possible values include: 'VirtualNetworkGatewaySkuNameBasic', 'VirtualNetworkGatewaySkuNameHighPerformance', 'VirtualNetworkGatewaySkuNameStandard', 'VirtualNetworkGatewaySkuNameUltraPerformance', 'VirtualNetworkGatewaySkuNameVpnGw1', 'VirtualNetworkGatewaySkuNameVpnGw2', 'VirtualNetworkGatewaySkuNameVpnGw3', 'VirtualNetworkGatewaySkuNameVpnGw4', 'VirtualNetworkGatewaySkuNameVpnGw5', 'VirtualNetworkGatewaySkuNameVpnGw1AZ', 'VirtualNetworkGatewaySkuNameVpnGw2AZ', 'VirtualNetworkGatewaySkuNameVpnGw3AZ', 'VirtualNetworkGatewaySkuNameVpnGw4AZ', 'VirtualNetworkGatewaySkuNameVpnGw5AZ', 'VirtualNetworkGatewaySkuNameErGw1AZ', 'VirtualNetworkGatewaySkuNameErGw2AZ', 'VirtualNetworkGatewaySkuNameErGw3AZ'
	Name VirtualNetworkGatewaySkuName `json:"name,omitempty"`
	// Tier - Gateway SKU tier. Possible values include: 'VirtualNetworkGatewaySkuTierBasic', 'VirtualNetworkGatewaySkuTierHighPerformance', 'VirtualNetworkGatewaySkuTierStandard', 'VirtualNetworkGatewaySkuTierUltraPerformance', 'VirtualNetworkGatewaySkuTierVpnGw1', 'VirtualNetworkGatewaySkuTierVpnGw2', 'VirtualNetworkGatewaySkuTierVpnGw3', 'VirtualNetworkGatewaySkuTierVpnGw4', 'VirtualNetworkGatewaySkuTierVpnGw5', 'VirtualNetworkGatewaySkuTierVpnGw1AZ', 'VirtualNetworkGatewaySkuTierVpnGw2AZ', 'VirtualNetworkGatewaySkuTierVpnGw3AZ', 'VirtualNetworkGatewaySkuTierVpnGw4AZ', 'VirtualNetworkGatewaySkuTierVpnGw5AZ', 'VirtualNetworkGatewaySkuTierErGw1AZ', 'VirtualNetworkGatewaySkuTierErGw2AZ', 'VirtualNetworkGatewaySkuTierErGw3AZ'
	Tier VirtualNetworkGatewaySkuTier `json:"tier,omitempty"`
	// Capacity - READ-ONLY; The capacity.
	Capacity *int32 `json:"capacity,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkGatewaySku.
func (vngs VirtualNetworkGatewaySku) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vngs.Name != "" {
		objectMap["name"] = vngs.Name
	}
	if vngs.Tier != "" {
		objectMap["tier"] = vngs.Tier
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkGatewaysResetFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworkGatewaysResetFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (VirtualNetworkGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysResetFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysResetFuture.Result.
func (future *VirtualNetworkGatewaysResetFuture) result(client VirtualNetworkGatewaysClient) (vng VirtualNetworkGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysResetFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vng.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysResetFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vng.Response.Response, err = future.GetResult(sender); err == nil && vng.Response.Response.StatusCode != http.StatusNoContent {
		vng, err = client.ResetResponder(vng.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysResetFuture", "Result", vng.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysResetVpnClientSharedKeyFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewaysResetVpnClientSharedKeyFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysResetVpnClientSharedKeyFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysResetVpnClientSharedKeyFuture.Result.
func (future *VirtualNetworkGatewaysResetVpnClientSharedKeyFuture) result(client VirtualNetworkGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysResetVpnClientSharedKeyFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysResetVpnClientSharedKeyFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworkGatewaysSetVpnclientIpsecParametersFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type VirtualNetworkGatewaysSetVpnclientIpsecParametersFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (VpnClientIPsecParameters, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysSetVpnclientIpsecParametersFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysSetVpnclientIpsecParametersFuture.Result.
func (future *VirtualNetworkGatewaysSetVpnclientIpsecParametersFuture) result(client VirtualNetworkGatewaysClient) (vcipp VpnClientIPsecParameters, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysSetVpnclientIpsecParametersFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vcipp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysSetVpnclientIpsecParametersFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vcipp.Response.Response, err = future.GetResult(sender); err == nil && vcipp.Response.Response.StatusCode != http.StatusNoContent {
		vcipp, err = client.SetVpnclientIpsecParametersResponder(vcipp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysSetVpnclientIpsecParametersFuture", "Result", vcipp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysStartPacketCaptureFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type VirtualNetworkGatewaysStartPacketCaptureFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysStartPacketCaptureFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysStartPacketCaptureFuture.Result.
func (future *VirtualNetworkGatewaysStartPacketCaptureFuture) result(client VirtualNetworkGatewaysClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysStartPacketCaptureFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysStartPacketCaptureFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.StartPacketCaptureResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysStartPacketCaptureFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysStopPacketCaptureFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type VirtualNetworkGatewaysStopPacketCaptureFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysStopPacketCaptureFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysStopPacketCaptureFuture.Result.
func (future *VirtualNetworkGatewaysStopPacketCaptureFuture) result(client VirtualNetworkGatewaysClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysStopPacketCaptureFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysStopPacketCaptureFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.StopPacketCaptureResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysStopPacketCaptureFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkGatewaysUpdateTagsFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworkGatewaysUpdateTagsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkGatewaysClient) (VirtualNetworkGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkGatewaysUpdateTagsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkGatewaysUpdateTagsFuture.Result.
func (future *VirtualNetworkGatewaysUpdateTagsFuture) result(client VirtualNetworkGatewaysClient) (vng VirtualNetworkGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysUpdateTagsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vng.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkGatewaysUpdateTagsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vng.Response.Response, err = future.GetResult(sender); err == nil && vng.Response.Response.StatusCode != http.StatusNoContent {
		vng, err = client.UpdateTagsResponder(vng.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkGatewaysUpdateTagsFuture", "Result", vng.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkListResult response for the ListVirtualNetworks API service call.
type VirtualNetworkListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of VirtualNetwork resources in a resource group.
	Value *[]VirtualNetwork `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VirtualNetworkListResultIterator provides access to a complete listing of VirtualNetwork values.
type VirtualNetworkListResultIterator struct {
	i    int
	page VirtualNetworkListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworkListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworkListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworkListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworkListResultIterator) Response() VirtualNetworkListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworkListResultIterator) Value() VirtualNetwork {
	if !iter.page.NotDone() {
		return VirtualNetwork{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworkListResultIterator type.
func NewVirtualNetworkListResultIterator(page VirtualNetworkListResultPage) VirtualNetworkListResultIterator {
	return VirtualNetworkListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vnlr VirtualNetworkListResult) IsEmpty() bool {
	return vnlr.Value == nil || len(*vnlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vnlr VirtualNetworkListResult) hasNextLink() bool {
	return vnlr.NextLink != nil && len(*vnlr.NextLink) != 0
}

// virtualNetworkListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vnlr VirtualNetworkListResult) virtualNetworkListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vnlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vnlr.NextLink)))
}

// VirtualNetworkListResultPage contains a page of VirtualNetwork values.
type VirtualNetworkListResultPage struct {
	fn   func(context.Context, VirtualNetworkListResult) (VirtualNetworkListResult, error)
	vnlr VirtualNetworkListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworkListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vnlr)
		if err != nil {
			return err
		}
		page.vnlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworkListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworkListResultPage) NotDone() bool {
	return !page.vnlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworkListResultPage) Response() VirtualNetworkListResult {
	return page.vnlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworkListResultPage) Values() []VirtualNetwork {
	if page.vnlr.IsEmpty() {
		return nil
	}
	return *page.vnlr.Value
}

// Creates a new instance of the VirtualNetworkListResultPage type.
func NewVirtualNetworkListResultPage(cur VirtualNetworkListResult, getNextPage func(context.Context, VirtualNetworkListResult) (VirtualNetworkListResult, error)) VirtualNetworkListResultPage {
	return VirtualNetworkListResultPage{
		fn:   getNextPage,
		vnlr: cur,
	}
}

// VirtualNetworkListUsageResult response for the virtual networks GetUsage API service call.
type VirtualNetworkListUsageResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; VirtualNetwork usage stats.
	Value *[]VirtualNetworkUsage `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkListUsageResult.
func (vnlur VirtualNetworkListUsageResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnlur.NextLink != nil {
		objectMap["nextLink"] = vnlur.NextLink
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkListUsageResultIterator provides access to a complete listing of VirtualNetworkUsage
// values.
type VirtualNetworkListUsageResultIterator struct {
	i    int
	page VirtualNetworkListUsageResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworkListUsageResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkListUsageResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworkListUsageResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworkListUsageResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworkListUsageResultIterator) Response() VirtualNetworkListUsageResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworkListUsageResultIterator) Value() VirtualNetworkUsage {
	if !iter.page.NotDone() {
		return VirtualNetworkUsage{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworkListUsageResultIterator type.
func NewVirtualNetworkListUsageResultIterator(page VirtualNetworkListUsageResultPage) VirtualNetworkListUsageResultIterator {
	return VirtualNetworkListUsageResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vnlur VirtualNetworkListUsageResult) IsEmpty() bool {
	return vnlur.Value == nil || len(*vnlur.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vnlur VirtualNetworkListUsageResult) hasNextLink() bool {
	return vnlur.NextLink != nil && len(*vnlur.NextLink) != 0
}

// virtualNetworkListUsageResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vnlur VirtualNetworkListUsageResult) virtualNetworkListUsageResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vnlur.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vnlur.NextLink)))
}

// VirtualNetworkListUsageResultPage contains a page of VirtualNetworkUsage values.
type VirtualNetworkListUsageResultPage struct {
	fn    func(context.Context, VirtualNetworkListUsageResult) (VirtualNetworkListUsageResult, error)
	vnlur VirtualNetworkListUsageResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworkListUsageResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkListUsageResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vnlur)
		if err != nil {
			return err
		}
		page.vnlur = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworkListUsageResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworkListUsageResultPage) NotDone() bool {
	return !page.vnlur.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworkListUsageResultPage) Response() VirtualNetworkListUsageResult {
	return page.vnlur
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworkListUsageResultPage) Values() []VirtualNetworkUsage {
	if page.vnlur.IsEmpty() {
		return nil
	}
	return *page.vnlur.Value
}

// Creates a new instance of the VirtualNetworkListUsageResultPage type.
func NewVirtualNetworkListUsageResultPage(cur VirtualNetworkListUsageResult, getNextPage func(context.Context, VirtualNetworkListUsageResult) (VirtualNetworkListUsageResult, error)) VirtualNetworkListUsageResultPage {
	return VirtualNetworkListUsageResultPage{
		fn:    getNextPage,
		vnlur: cur,
	}
}

// VirtualNetworkPeering peerings in a virtual network resource.
type VirtualNetworkPeering struct {
	autorest.Response `json:"-"`
	// VirtualNetworkPeeringPropertiesFormat - Properties of the virtual network peering.
	*VirtualNetworkPeeringPropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkPeering.
func (vnp VirtualNetworkPeering) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnp.VirtualNetworkPeeringPropertiesFormat != nil {
		objectMap["properties"] = vnp.VirtualNetworkPeeringPropertiesFormat
	}
	if vnp.Name != nil {
		objectMap["name"] = vnp.Name
	}
	if vnp.Type != nil {
		objectMap["type"] = vnp.Type
	}
	if vnp.ID != nil {
		objectMap["id"] = vnp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetworkPeering struct.
func (vnp *VirtualNetworkPeering) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualNetworkPeeringPropertiesFormat VirtualNetworkPeeringPropertiesFormat
				err = json.Unmarshal(*v, &virtualNetworkPeeringPropertiesFormat)
				if err != nil {
					return err
				}
				vnp.VirtualNetworkPeeringPropertiesFormat = &virtualNetworkPeeringPropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vnp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vnp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vnp.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vnp.ID = &ID
			}
		}
	}

	return nil
}

// VirtualNetworkPeeringListResult response for ListSubnets API service call. Retrieves all subnets that
// belong to a virtual network.
type VirtualNetworkPeeringListResult struct {
	autorest.Response `json:"-"`
	// Value - The peerings in a virtual network.
	Value *[]VirtualNetworkPeering `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VirtualNetworkPeeringListResultIterator provides access to a complete listing of VirtualNetworkPeering
// values.
type VirtualNetworkPeeringListResultIterator struct {
	i    int
	page VirtualNetworkPeeringListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworkPeeringListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkPeeringListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworkPeeringListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworkPeeringListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworkPeeringListResultIterator) Response() VirtualNetworkPeeringListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworkPeeringListResultIterator) Value() VirtualNetworkPeering {
	if !iter.page.NotDone() {
		return VirtualNetworkPeering{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworkPeeringListResultIterator type.
func NewVirtualNetworkPeeringListResultIterator(page VirtualNetworkPeeringListResultPage) VirtualNetworkPeeringListResultIterator {
	return VirtualNetworkPeeringListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vnplr VirtualNetworkPeeringListResult) IsEmpty() bool {
	return vnplr.Value == nil || len(*vnplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vnplr VirtualNetworkPeeringListResult) hasNextLink() bool {
	return vnplr.NextLink != nil && len(*vnplr.NextLink) != 0
}

// virtualNetworkPeeringListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vnplr VirtualNetworkPeeringListResult) virtualNetworkPeeringListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vnplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vnplr.NextLink)))
}

// VirtualNetworkPeeringListResultPage contains a page of VirtualNetworkPeering values.
type VirtualNetworkPeeringListResultPage struct {
	fn    func(context.Context, VirtualNetworkPeeringListResult) (VirtualNetworkPeeringListResult, error)
	vnplr VirtualNetworkPeeringListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworkPeeringListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkPeeringListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vnplr)
		if err != nil {
			return err
		}
		page.vnplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworkPeeringListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworkPeeringListResultPage) NotDone() bool {
	return !page.vnplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworkPeeringListResultPage) Response() VirtualNetworkPeeringListResult {
	return page.vnplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworkPeeringListResultPage) Values() []VirtualNetworkPeering {
	if page.vnplr.IsEmpty() {
		return nil
	}
	return *page.vnplr.Value
}

// Creates a new instance of the VirtualNetworkPeeringListResultPage type.
func NewVirtualNetworkPeeringListResultPage(cur VirtualNetworkPeeringListResult, getNextPage func(context.Context, VirtualNetworkPeeringListResult) (VirtualNetworkPeeringListResult, error)) VirtualNetworkPeeringListResultPage {
	return VirtualNetworkPeeringListResultPage{
		fn:    getNextPage,
		vnplr: cur,
	}
}

// VirtualNetworkPeeringPropertiesFormat properties of the virtual network peering.
type VirtualNetworkPeeringPropertiesFormat struct {
	// AllowVirtualNetworkAccess - Whether the VMs in the local virtual network space would be able to access the VMs in remote virtual network space.
	AllowVirtualNetworkAccess *bool `json:"allowVirtualNetworkAccess,omitempty"`
	// AllowForwardedTraffic - Whether the forwarded traffic from the VMs in the local virtual network will be allowed/disallowed in remote virtual network.
	AllowForwardedTraffic *bool `json:"allowForwardedTraffic,omitempty"`
	// AllowGatewayTransit - If gateway links can be used in remote virtual networking to link to this virtual network.
	AllowGatewayTransit *bool `json:"allowGatewayTransit,omitempty"`
	// UseRemoteGateways - If remote gateways can be used on this virtual network. If the flag is set to true, and allowGatewayTransit on remote peering is also true, virtual network will use gateways of remote virtual network for transit. Only one peering can have this flag set to true. This flag cannot be set if virtual network already has a gateway.
	UseRemoteGateways *bool `json:"useRemoteGateways,omitempty"`
	// RemoteVirtualNetwork - The reference to the remote virtual network. The remote virtual network can be in the same or different region (preview). See here to register for the preview and learn more (https://docs.microsoft.com/en-us/azure/virtual-network/virtual-network-create-peering).
	RemoteVirtualNetwork *SubResource `json:"remoteVirtualNetwork,omitempty"`
	// RemoteAddressSpace - The reference to the remote virtual network address space.
	RemoteAddressSpace *AddressSpace `json:"remoteAddressSpace,omitempty"`
	// RemoteBgpCommunities - The reference to the remote virtual network's Bgp Communities.
	RemoteBgpCommunities *VirtualNetworkBgpCommunities `json:"remoteBgpCommunities,omitempty"`
	// PeeringState - The status of the virtual network peering. Possible values include: 'VirtualNetworkPeeringStateInitiated', 'VirtualNetworkPeeringStateConnected', 'VirtualNetworkPeeringStateDisconnected'
	PeeringState VirtualNetworkPeeringState `json:"peeringState,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual network peering resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// DoNotVerifyRemoteGateways - If we need to verify the provisioning state of the remote gateway.
	DoNotVerifyRemoteGateways *bool `json:"doNotVerifyRemoteGateways,omitempty"`
	// ResourceGUID - READ-ONLY; The resourceGuid property of the Virtual Network peering resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkPeeringPropertiesFormat.
func (vnppf VirtualNetworkPeeringPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnppf.AllowVirtualNetworkAccess != nil {
		objectMap["allowVirtualNetworkAccess"] = vnppf.AllowVirtualNetworkAccess
	}
	if vnppf.AllowForwardedTraffic != nil {
		objectMap["allowForwardedTraffic"] = vnppf.AllowForwardedTraffic
	}
	if vnppf.AllowGatewayTransit != nil {
		objectMap["allowGatewayTransit"] = vnppf.AllowGatewayTransit
	}
	if vnppf.UseRemoteGateways != nil {
		objectMap["useRemoteGateways"] = vnppf.UseRemoteGateways
	}
	if vnppf.RemoteVirtualNetwork != nil {
		objectMap["remoteVirtualNetwork"] = vnppf.RemoteVirtualNetwork
	}
	if vnppf.RemoteAddressSpace != nil {
		objectMap["remoteAddressSpace"] = vnppf.RemoteAddressSpace
	}
	if vnppf.RemoteBgpCommunities != nil {
		objectMap["remoteBgpCommunities"] = vnppf.RemoteBgpCommunities
	}
	if vnppf.PeeringState != "" {
		objectMap["peeringState"] = vnppf.PeeringState
	}
	if vnppf.DoNotVerifyRemoteGateways != nil {
		objectMap["doNotVerifyRemoteGateways"] = vnppf.DoNotVerifyRemoteGateways
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkPeeringsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworkPeeringsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkPeeringsClient) (VirtualNetworkPeering, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkPeeringsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkPeeringsCreateOrUpdateFuture.Result.
func (future *VirtualNetworkPeeringsCreateOrUpdateFuture) result(client VirtualNetworkPeeringsClient) (vnp VirtualNetworkPeering, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkPeeringsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vnp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkPeeringsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vnp.Response.Response, err = future.GetResult(sender); err == nil && vnp.Response.Response.StatusCode != http.StatusNoContent {
		vnp, err = client.CreateOrUpdateResponder(vnp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkPeeringsCreateOrUpdateFuture", "Result", vnp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkPeeringsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworkPeeringsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkPeeringsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkPeeringsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkPeeringsDeleteFuture.Result.
func (future *VirtualNetworkPeeringsDeleteFuture) result(client VirtualNetworkPeeringsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkPeeringsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkPeeringsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworkPropertiesFormat properties of the virtual network.
type VirtualNetworkPropertiesFormat struct {
	// AddressSpace - The AddressSpace that contains an array of IP address ranges that can be used by subnets.
	AddressSpace *AddressSpace `json:"addressSpace,omitempty"`
	// DhcpOptions - The dhcpOptions that contains an array of DNS servers available to VMs deployed in the virtual network.
	DhcpOptions *DhcpOptions `json:"dhcpOptions,omitempty"`
	// Subnets - A list of subnets in a Virtual Network.
	Subnets *[]Subnet `json:"subnets,omitempty"`
	// VirtualNetworkPeerings - A list of peerings in a Virtual Network.
	VirtualNetworkPeerings *[]VirtualNetworkPeering `json:"virtualNetworkPeerings,omitempty"`
	// ResourceGUID - READ-ONLY; The resourceGuid property of the Virtual Network resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual network resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// EnableDdosProtection - Indicates if DDoS protection is enabled for all the protected resources in the virtual network. It requires a DDoS protection plan associated with the resource.
	EnableDdosProtection *bool `json:"enableDdosProtection,omitempty"`
	// EnableVMProtection - Indicates if VM protection is enabled for all the subnets in the virtual network.
	EnableVMProtection *bool `json:"enableVmProtection,omitempty"`
	// DdosProtectionPlan - The DDoS protection plan associated with the virtual network.
	DdosProtectionPlan *SubResource `json:"ddosProtectionPlan,omitempty"`
	// BgpCommunities - Bgp Communities sent over ExpressRoute with each route corresponding to a prefix in this VNET.
	BgpCommunities *VirtualNetworkBgpCommunities `json:"bgpCommunities,omitempty"`
	// IPAllocations - Array of IpAllocation which reference this VNET.
	IPAllocations *[]SubResource `json:"ipAllocations,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkPropertiesFormat.
func (vnpf VirtualNetworkPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnpf.AddressSpace != nil {
		objectMap["addressSpace"] = vnpf.AddressSpace
	}
	if vnpf.DhcpOptions != nil {
		objectMap["dhcpOptions"] = vnpf.DhcpOptions
	}
	if vnpf.Subnets != nil {
		objectMap["subnets"] = vnpf.Subnets
	}
	if vnpf.VirtualNetworkPeerings != nil {
		objectMap["virtualNetworkPeerings"] = vnpf.VirtualNetworkPeerings
	}
	if vnpf.EnableDdosProtection != nil {
		objectMap["enableDdosProtection"] = vnpf.EnableDdosProtection
	}
	if vnpf.EnableVMProtection != nil {
		objectMap["enableVmProtection"] = vnpf.EnableVMProtection
	}
	if vnpf.DdosProtectionPlan != nil {
		objectMap["ddosProtectionPlan"] = vnpf.DdosProtectionPlan
	}
	if vnpf.BgpCommunities != nil {
		objectMap["bgpCommunities"] = vnpf.BgpCommunities
	}
	if vnpf.IPAllocations != nil {
		objectMap["ipAllocations"] = vnpf.IPAllocations
	}
	return json.Marshal(objectMap)
}

// VirtualNetworksCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworksCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworksClient) (VirtualNetwork, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworksCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworksCreateOrUpdateFuture.Result.
func (future *VirtualNetworksCreateOrUpdateFuture) result(client VirtualNetworksClient) (vn VirtualNetwork, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworksCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vn.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworksCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vn.Response.Response, err = future.GetResult(sender); err == nil && vn.Response.Response.StatusCode != http.StatusNoContent {
		vn, err = client.CreateOrUpdateResponder(vn.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworksCreateOrUpdateFuture", "Result", vn.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworksDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualNetworksDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworksClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworksDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworksDeleteFuture.Result.
func (future *VirtualNetworksDeleteFuture) result(client VirtualNetworksClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworksDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworksDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworkTap virtual Network Tap resource.
type VirtualNetworkTap struct {
	autorest.Response `json:"-"`
	// VirtualNetworkTapPropertiesFormat - Virtual Network Tap Properties.
	*VirtualNetworkTapPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkTap.
func (vnt VirtualNetworkTap) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnt.VirtualNetworkTapPropertiesFormat != nil {
		objectMap["properties"] = vnt.VirtualNetworkTapPropertiesFormat
	}
	if vnt.ID != nil {
		objectMap["id"] = vnt.ID
	}
	if vnt.Location != nil {
		objectMap["location"] = vnt.Location
	}
	if vnt.Tags != nil {
		objectMap["tags"] = vnt.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetworkTap struct.
func (vnt *VirtualNetworkTap) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualNetworkTapPropertiesFormat VirtualNetworkTapPropertiesFormat
				err = json.Unmarshal(*v, &virtualNetworkTapPropertiesFormat)
				if err != nil {
					return err
				}
				vnt.VirtualNetworkTapPropertiesFormat = &virtualNetworkTapPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vnt.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vnt.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vnt.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vnt.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vnt.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vnt.Tags = tags
			}
		}
	}

	return nil
}

// VirtualNetworkTapListResult response for ListVirtualNetworkTap API service call.
type VirtualNetworkTapListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of VirtualNetworkTaps in a resource group.
	Value *[]VirtualNetworkTap `json:"value,omitempty"`
	// NextLink - The URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VirtualNetworkTapListResultIterator provides access to a complete listing of VirtualNetworkTap values.
type VirtualNetworkTapListResultIterator struct {
	i    int
	page VirtualNetworkTapListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworkTapListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkTapListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworkTapListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworkTapListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworkTapListResultIterator) Response() VirtualNetworkTapListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworkTapListResultIterator) Value() VirtualNetworkTap {
	if !iter.page.NotDone() {
		return VirtualNetworkTap{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworkTapListResultIterator type.
func NewVirtualNetworkTapListResultIterator(page VirtualNetworkTapListResultPage) VirtualNetworkTapListResultIterator {
	return VirtualNetworkTapListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vntlr VirtualNetworkTapListResult) IsEmpty() bool {
	return vntlr.Value == nil || len(*vntlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vntlr VirtualNetworkTapListResult) hasNextLink() bool {
	return vntlr.NextLink != nil && len(*vntlr.NextLink) != 0
}

// virtualNetworkTapListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vntlr VirtualNetworkTapListResult) virtualNetworkTapListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vntlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vntlr.NextLink)))
}

// VirtualNetworkTapListResultPage contains a page of VirtualNetworkTap values.
type VirtualNetworkTapListResultPage struct {
	fn    func(context.Context, VirtualNetworkTapListResult) (VirtualNetworkTapListResult, error)
	vntlr VirtualNetworkTapListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworkTapListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworkTapListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vntlr)
		if err != nil {
			return err
		}
		page.vntlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworkTapListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworkTapListResultPage) NotDone() bool {
	return !page.vntlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworkTapListResultPage) Response() VirtualNetworkTapListResult {
	return page.vntlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworkTapListResultPage) Values() []VirtualNetworkTap {
	if page.vntlr.IsEmpty() {
		return nil
	}
	return *page.vntlr.Value
}

// Creates a new instance of the VirtualNetworkTapListResultPage type.
func NewVirtualNetworkTapListResultPage(cur VirtualNetworkTapListResult, getNextPage func(context.Context, VirtualNetworkTapListResult) (VirtualNetworkTapListResult, error)) VirtualNetworkTapListResultPage {
	return VirtualNetworkTapListResultPage{
		fn:    getNextPage,
		vntlr: cur,
	}
}

// VirtualNetworkTapPropertiesFormat virtual Network Tap properties.
type VirtualNetworkTapPropertiesFormat struct {
	// NetworkInterfaceTapConfigurations - READ-ONLY; Specifies the list of resource IDs for the network interface IP configuration that needs to be tapped.
	NetworkInterfaceTapConfigurations *[]InterfaceTapConfiguration `json:"networkInterfaceTapConfigurations,omitempty"`
	// ResourceGUID - READ-ONLY; The resource GUID property of the virtual network tap resource.
	ResourceGUID *string `json:"resourceGuid,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual network tap resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// DestinationNetworkInterfaceIPConfiguration - The reference to the private IP Address of the collector nic that will receive the tap.
	DestinationNetworkInterfaceIPConfiguration *InterfaceIPConfiguration `json:"destinationNetworkInterfaceIPConfiguration,omitempty"`
	// DestinationLoadBalancerFrontEndIPConfiguration - The reference to the private IP address on the internal Load Balancer that will receive the tap.
	DestinationLoadBalancerFrontEndIPConfiguration *FrontendIPConfiguration `json:"destinationLoadBalancerFrontEndIPConfiguration,omitempty"`
	// DestinationPort - The VXLAN destination port that will receive the tapped traffic.
	DestinationPort *int32 `json:"destinationPort,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkTapPropertiesFormat.
func (vntpf VirtualNetworkTapPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vntpf.DestinationNetworkInterfaceIPConfiguration != nil {
		objectMap["destinationNetworkInterfaceIPConfiguration"] = vntpf.DestinationNetworkInterfaceIPConfiguration
	}
	if vntpf.DestinationLoadBalancerFrontEndIPConfiguration != nil {
		objectMap["destinationLoadBalancerFrontEndIPConfiguration"] = vntpf.DestinationLoadBalancerFrontEndIPConfiguration
	}
	if vntpf.DestinationPort != nil {
		objectMap["destinationPort"] = vntpf.DestinationPort
	}
	return json.Marshal(objectMap)
}

// VirtualNetworkTapsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworkTapsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkTapsClient) (VirtualNetworkTap, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkTapsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkTapsCreateOrUpdateFuture.Result.
func (future *VirtualNetworkTapsCreateOrUpdateFuture) result(client VirtualNetworkTapsClient) (vnt VirtualNetworkTap, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkTapsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vnt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkTapsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vnt.Response.Response, err = future.GetResult(sender); err == nil && vnt.Response.Response.StatusCode != http.StatusNoContent {
		vnt, err = client.CreateOrUpdateResponder(vnt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualNetworkTapsCreateOrUpdateFuture", "Result", vnt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworkTapsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualNetworkTapsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworkTapsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworkTapsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworkTapsDeleteFuture.Result.
func (future *VirtualNetworkTapsDeleteFuture) result(client VirtualNetworkTapsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualNetworkTapsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualNetworkTapsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworkUsage usage details for subnet.
type VirtualNetworkUsage struct {
	// CurrentValue - READ-ONLY; Indicates number of IPs used from the Subnet.
	CurrentValue *float64 `json:"currentValue,omitempty"`
	// ID - READ-ONLY; Subnet identifier.
	ID *string `json:"id,omitempty"`
	// Limit - READ-ONLY; Indicates the size of the subnet.
	Limit *float64 `json:"limit,omitempty"`
	// Name - READ-ONLY; The name containing common and localized value for usage.
	Name *VirtualNetworkUsageName `json:"name,omitempty"`
	// Unit - READ-ONLY; Usage units. Returns 'Count'.
	Unit *string `json:"unit,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkUsage.
func (vnu VirtualNetworkUsage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// VirtualNetworkUsageName usage strings container.
type VirtualNetworkUsageName struct {
	// LocalizedValue - READ-ONLY; Localized subnet size and usage string.
	LocalizedValue *string `json:"localizedValue,omitempty"`
	// Value - READ-ONLY; Subnet size and usage string.
	Value *string `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkUsageName.
func (vnun VirtualNetworkUsageName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// VirtualRouter virtualRouter Resource.
type VirtualRouter struct {
	autorest.Response `json:"-"`
	// VirtualRouterPropertiesFormat - Properties of the Virtual Router.
	*VirtualRouterPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualRouter.
func (vr VirtualRouter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vr.VirtualRouterPropertiesFormat != nil {
		objectMap["properties"] = vr.VirtualRouterPropertiesFormat
	}
	if vr.ID != nil {
		objectMap["id"] = vr.ID
	}
	if vr.Location != nil {
		objectMap["location"] = vr.Location
	}
	if vr.Tags != nil {
		objectMap["tags"] = vr.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualRouter struct.
func (vr *VirtualRouter) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualRouterPropertiesFormat VirtualRouterPropertiesFormat
				err = json.Unmarshal(*v, &virtualRouterPropertiesFormat)
				if err != nil {
					return err
				}
				vr.VirtualRouterPropertiesFormat = &virtualRouterPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vr.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vr.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vr.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vr.Tags = tags
			}
		}
	}

	return nil
}

// VirtualRouterListResult response for ListVirtualRouters API service call.
type VirtualRouterListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Virtual Routers.
	Value *[]VirtualRouter `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VirtualRouterListResultIterator provides access to a complete listing of VirtualRouter values.
type VirtualRouterListResultIterator struct {
	i    int
	page VirtualRouterListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualRouterListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualRouterListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualRouterListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualRouterListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualRouterListResultIterator) Response() VirtualRouterListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualRouterListResultIterator) Value() VirtualRouter {
	if !iter.page.NotDone() {
		return VirtualRouter{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualRouterListResultIterator type.
func NewVirtualRouterListResultIterator(page VirtualRouterListResultPage) VirtualRouterListResultIterator {
	return VirtualRouterListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vrlr VirtualRouterListResult) IsEmpty() bool {
	return vrlr.Value == nil || len(*vrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vrlr VirtualRouterListResult) hasNextLink() bool {
	return vrlr.NextLink != nil && len(*vrlr.NextLink) != 0
}

// virtualRouterListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vrlr VirtualRouterListResult) virtualRouterListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vrlr.NextLink)))
}

// VirtualRouterListResultPage contains a page of VirtualRouter values.
type VirtualRouterListResultPage struct {
	fn   func(context.Context, VirtualRouterListResult) (VirtualRouterListResult, error)
	vrlr VirtualRouterListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualRouterListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualRouterListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vrlr)
		if err != nil {
			return err
		}
		page.vrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualRouterListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualRouterListResultPage) NotDone() bool {
	return !page.vrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualRouterListResultPage) Response() VirtualRouterListResult {
	return page.vrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualRouterListResultPage) Values() []VirtualRouter {
	if page.vrlr.IsEmpty() {
		return nil
	}
	return *page.vrlr.Value
}

// Creates a new instance of the VirtualRouterListResultPage type.
func NewVirtualRouterListResultPage(cur VirtualRouterListResult, getNextPage func(context.Context, VirtualRouterListResult) (VirtualRouterListResult, error)) VirtualRouterListResultPage {
	return VirtualRouterListResultPage{
		fn:   getNextPage,
		vrlr: cur,
	}
}

// VirtualRouterPeering virtual Router Peering resource.
type VirtualRouterPeering struct {
	autorest.Response `json:"-"`
	// VirtualRouterPeeringProperties - The properties of the Virtual Router Peering.
	*VirtualRouterPeeringProperties `json:"properties,omitempty"`
	// Name - Name of the virtual router peering that is unique within a virtual router.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Peering type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualRouterPeering.
func (vrp VirtualRouterPeering) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vrp.VirtualRouterPeeringProperties != nil {
		objectMap["properties"] = vrp.VirtualRouterPeeringProperties
	}
	if vrp.Name != nil {
		objectMap["name"] = vrp.Name
	}
	if vrp.ID != nil {
		objectMap["id"] = vrp.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualRouterPeering struct.
func (vrp *VirtualRouterPeering) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualRouterPeeringProperties VirtualRouterPeeringProperties
				err = json.Unmarshal(*v, &virtualRouterPeeringProperties)
				if err != nil {
					return err
				}
				vrp.VirtualRouterPeeringProperties = &virtualRouterPeeringProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vrp.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vrp.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vrp.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vrp.ID = &ID
			}
		}
	}

	return nil
}

// VirtualRouterPeeringListResult response for ListVirtualRouterPeerings API service call.
type VirtualRouterPeeringListResult struct {
	autorest.Response `json:"-"`
	// Value - List of VirtualRouterPeerings in a VirtualRouter.
	Value *[]VirtualRouterPeering `json:"value,omitempty"`
	// NextLink - URL to get the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// VirtualRouterPeeringListResultIterator provides access to a complete listing of VirtualRouterPeering
// values.
type VirtualRouterPeeringListResultIterator struct {
	i    int
	page VirtualRouterPeeringListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualRouterPeeringListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualRouterPeeringListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualRouterPeeringListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualRouterPeeringListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualRouterPeeringListResultIterator) Response() VirtualRouterPeeringListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualRouterPeeringListResultIterator) Value() VirtualRouterPeering {
	if !iter.page.NotDone() {
		return VirtualRouterPeering{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualRouterPeeringListResultIterator type.
func NewVirtualRouterPeeringListResultIterator(page VirtualRouterPeeringListResultPage) VirtualRouterPeeringListResultIterator {
	return VirtualRouterPeeringListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vrplr VirtualRouterPeeringListResult) IsEmpty() bool {
	return vrplr.Value == nil || len(*vrplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vrplr VirtualRouterPeeringListResult) hasNextLink() bool {
	return vrplr.NextLink != nil && len(*vrplr.NextLink) != 0
}

// virtualRouterPeeringListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vrplr VirtualRouterPeeringListResult) virtualRouterPeeringListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vrplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vrplr.NextLink)))
}

// VirtualRouterPeeringListResultPage contains a page of VirtualRouterPeering values.
type VirtualRouterPeeringListResultPage struct {
	fn    func(context.Context, VirtualRouterPeeringListResult) (VirtualRouterPeeringListResult, error)
	vrplr VirtualRouterPeeringListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualRouterPeeringListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualRouterPeeringListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vrplr)
		if err != nil {
			return err
		}
		page.vrplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualRouterPeeringListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualRouterPeeringListResultPage) NotDone() bool {
	return !page.vrplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualRouterPeeringListResultPage) Response() VirtualRouterPeeringListResult {
	return page.vrplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualRouterPeeringListResultPage) Values() []VirtualRouterPeering {
	if page.vrplr.IsEmpty() {
		return nil
	}
	return *page.vrplr.Value
}

// Creates a new instance of the VirtualRouterPeeringListResultPage type.
func NewVirtualRouterPeeringListResultPage(cur VirtualRouterPeeringListResult, getNextPage func(context.Context, VirtualRouterPeeringListResult) (VirtualRouterPeeringListResult, error)) VirtualRouterPeeringListResultPage {
	return VirtualRouterPeeringListResultPage{
		fn:    getNextPage,
		vrplr: cur,
	}
}

// VirtualRouterPeeringProperties properties of the rule group.
type VirtualRouterPeeringProperties struct {
	// PeerAsn - Peer ASN.
	PeerAsn *int64 `json:"peerAsn,omitempty"`
	// PeerIP - Peer IP.
	PeerIP *string `json:"peerIp,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualRouterPeeringProperties.
func (vrpp VirtualRouterPeeringProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vrpp.PeerAsn != nil {
		objectMap["peerAsn"] = vrpp.PeerAsn
	}
	if vrpp.PeerIP != nil {
		objectMap["peerIp"] = vrpp.PeerIP
	}
	return json.Marshal(objectMap)
}

// VirtualRouterPeeringsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualRouterPeeringsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualRouterPeeringsClient) (VirtualRouterPeering, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualRouterPeeringsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualRouterPeeringsCreateOrUpdateFuture.Result.
func (future *VirtualRouterPeeringsCreateOrUpdateFuture) result(client VirtualRouterPeeringsClient) (vrp VirtualRouterPeering, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualRouterPeeringsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vrp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualRouterPeeringsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vrp.Response.Response, err = future.GetResult(sender); err == nil && vrp.Response.Response.StatusCode != http.StatusNoContent {
		vrp, err = client.CreateOrUpdateResponder(vrp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualRouterPeeringsCreateOrUpdateFuture", "Result", vrp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualRouterPeeringsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualRouterPeeringsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualRouterPeeringsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualRouterPeeringsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualRouterPeeringsDeleteFuture.Result.
func (future *VirtualRouterPeeringsDeleteFuture) result(client VirtualRouterPeeringsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualRouterPeeringsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualRouterPeeringsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualRouterPropertiesFormat virtual Router definition.
type VirtualRouterPropertiesFormat struct {
	// VirtualRouterAsn - VirtualRouter ASN.
	VirtualRouterAsn *int64 `json:"virtualRouterAsn,omitempty"`
	// VirtualRouterIps - VirtualRouter IPs.
	VirtualRouterIps *[]string `json:"virtualRouterIps,omitempty"`
	// HostedSubnet - The Subnet on which VirtualRouter is hosted.
	HostedSubnet *SubResource `json:"hostedSubnet,omitempty"`
	// HostedGateway - The Gateway on which VirtualRouter is hosted.
	HostedGateway *SubResource `json:"hostedGateway,omitempty"`
	// Peerings - READ-ONLY; List of references to VirtualRouterPeerings.
	Peerings *[]SubResource `json:"peerings,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualRouterPropertiesFormat.
func (vrpf VirtualRouterPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vrpf.VirtualRouterAsn != nil {
		objectMap["virtualRouterAsn"] = vrpf.VirtualRouterAsn
	}
	if vrpf.VirtualRouterIps != nil {
		objectMap["virtualRouterIps"] = vrpf.VirtualRouterIps
	}
	if vrpf.HostedSubnet != nil {
		objectMap["hostedSubnet"] = vrpf.HostedSubnet
	}
	if vrpf.HostedGateway != nil {
		objectMap["hostedGateway"] = vrpf.HostedGateway
	}
	return json.Marshal(objectMap)
}

// VirtualRoutersCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualRoutersCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualRoutersClient) (VirtualRouter, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualRoutersCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualRoutersCreateOrUpdateFuture.Result.
func (future *VirtualRoutersCreateOrUpdateFuture) result(client VirtualRoutersClient) (vr VirtualRouter, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualRoutersCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualRoutersCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vr.Response.Response, err = future.GetResult(sender); err == nil && vr.Response.Response.StatusCode != http.StatusNoContent {
		vr, err = client.CreateOrUpdateResponder(vr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualRoutersCreateOrUpdateFuture", "Result", vr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualRoutersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualRoutersDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualRoutersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualRoutersDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualRoutersDeleteFuture.Result.
func (future *VirtualRoutersDeleteFuture) result(client VirtualRoutersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualRoutersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualRoutersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualWAN virtualWAN Resource.
type VirtualWAN struct {
	autorest.Response `json:"-"`
	// VirtualWanProperties - Properties of the virtual WAN.
	*VirtualWanProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualWAN.
func (vw VirtualWAN) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vw.VirtualWanProperties != nil {
		objectMap["properties"] = vw.VirtualWanProperties
	}
	if vw.ID != nil {
		objectMap["id"] = vw.ID
	}
	if vw.Location != nil {
		objectMap["location"] = vw.Location
	}
	if vw.Tags != nil {
		objectMap["tags"] = vw.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualWAN struct.
func (vw *VirtualWAN) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualWanProperties VirtualWanProperties
				err = json.Unmarshal(*v, &virtualWanProperties)
				if err != nil {
					return err
				}
				vw.VirtualWanProperties = &virtualWanProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vw.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vw.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vw.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vw.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vw.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vw.Tags = tags
			}
		}
	}

	return nil
}

// VirtualWanProperties parameters for VirtualWAN.
type VirtualWanProperties struct {
	// DisableVpnEncryption - Vpn encryption to be disabled or not.
	DisableVpnEncryption *bool `json:"disableVpnEncryption,omitempty"`
	// VirtualHubs - READ-ONLY; List of VirtualHubs in the VirtualWAN.
	VirtualHubs *[]SubResource `json:"virtualHubs,omitempty"`
	// VpnSites - READ-ONLY; List of VpnSites in the VirtualWAN.
	VpnSites *[]SubResource `json:"vpnSites,omitempty"`
	// AllowBranchToBranchTraffic - True if branch to branch traffic is allowed.
	AllowBranchToBranchTraffic *bool `json:"allowBranchToBranchTraffic,omitempty"`
	// AllowVnetToVnetTraffic - True if Vnet to Vnet traffic is allowed.
	AllowVnetToVnetTraffic *bool `json:"allowVnetToVnetTraffic,omitempty"`
	// Office365LocalBreakoutCategory - The office local breakout category. Possible values include: 'OfficeTrafficCategoryOptimize', 'OfficeTrafficCategoryOptimizeAndAllow', 'OfficeTrafficCategoryAll', 'OfficeTrafficCategoryNone'
	Office365LocalBreakoutCategory OfficeTrafficCategory `json:"office365LocalBreakoutCategory,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the virtual WAN resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Type - The type of the VirtualWAN.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualWanProperties.
func (vwp VirtualWanProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vwp.DisableVpnEncryption != nil {
		objectMap["disableVpnEncryption"] = vwp.DisableVpnEncryption
	}
	if vwp.AllowBranchToBranchTraffic != nil {
		objectMap["allowBranchToBranchTraffic"] = vwp.AllowBranchToBranchTraffic
	}
	if vwp.AllowVnetToVnetTraffic != nil {
		objectMap["allowVnetToVnetTraffic"] = vwp.AllowVnetToVnetTraffic
	}
	if vwp.Office365LocalBreakoutCategory != "" {
		objectMap["office365LocalBreakoutCategory"] = vwp.Office365LocalBreakoutCategory
	}
	if vwp.Type != nil {
		objectMap["type"] = vwp.Type
	}
	return json.Marshal(objectMap)
}

// VirtualWansCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualWansCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualWansClient) (VirtualWAN, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualWansCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualWansCreateOrUpdateFuture.Result.
func (future *VirtualWansCreateOrUpdateFuture) result(client VirtualWansClient) (vw VirtualWAN, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualWansCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vw.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualWansCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vw.Response.Response, err = future.GetResult(sender); err == nil && vw.Response.Response.StatusCode != http.StatusNoContent {
		vw, err = client.CreateOrUpdateResponder(vw.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VirtualWansCreateOrUpdateFuture", "Result", vw.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualWansDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualWansDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualWansClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualWansDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualWansDeleteFuture.Result.
func (future *VirtualWansDeleteFuture) result(client VirtualWansClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VirtualWansDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VirtualWansDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualWanSecurityProvider collection of SecurityProviders.
type VirtualWanSecurityProvider struct {
	// Name - Name of the security provider.
	Name *string `json:"name,omitempty"`
	// URL - Url of the security provider.
	URL *string `json:"url,omitempty"`
	// Type - Name of the security provider. Possible values include: 'VirtualWanSecurityProviderTypeExternal', 'VirtualWanSecurityProviderTypeNative'
	Type VirtualWanSecurityProviderType `json:"type,omitempty"`
}

// VirtualWanSecurityProviders collection of SecurityProviders.
type VirtualWanSecurityProviders struct {
	autorest.Response `json:"-"`
	// SupportedProviders - List of VirtualWAN security providers.
	SupportedProviders *[]VirtualWanSecurityProvider `json:"supportedProviders,omitempty"`
}

// VirtualWanVpnProfileParameters virtual Wan Vpn profile parameters Vpn profile generation.
type VirtualWanVpnProfileParameters struct {
	// VpnServerConfigurationResourceID - VpnServerConfiguration partial resource uri with which VirtualWan is associated to.
	VpnServerConfigurationResourceID *string `json:"vpnServerConfigurationResourceId,omitempty"`
	// AuthenticationMethod - VPN client authentication method. Possible values include: 'AuthenticationMethodEAPTLS', 'AuthenticationMethodEAPMSCHAPv2'
	AuthenticationMethod AuthenticationMethod `json:"authenticationMethod,omitempty"`
}

// VM describes a Virtual Machine.
type VM struct {
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VM.
func (vVar VM) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vVar.ID != nil {
		objectMap["id"] = vVar.ID
	}
	if vVar.Location != nil {
		objectMap["location"] = vVar.Location
	}
	if vVar.Tags != nil {
		objectMap["tags"] = vVar.Tags
	}
	return json.Marshal(objectMap)
}

// VnetRoute list of routes that control routing from VirtualHub into a virtual network connection.
type VnetRoute struct {
	// StaticRoutes - List of all Static Routes.
	StaticRoutes *[]StaticRoute `json:"staticRoutes,omitempty"`
}

// VpnClientConfiguration vpnClientConfiguration for P2S client.
type VpnClientConfiguration struct {
	// VpnClientAddressPool - The reference to the address space resource which represents Address space for P2S VpnClient.
	VpnClientAddressPool *AddressSpace `json:"vpnClientAddressPool,omitempty"`
	// VpnClientRootCertificates - VpnClientRootCertificate for virtual network gateway.
	VpnClientRootCertificates *[]VpnClientRootCertificate `json:"vpnClientRootCertificates,omitempty"`
	// VpnClientRevokedCertificates - VpnClientRevokedCertificate for Virtual network gateway.
	VpnClientRevokedCertificates *[]VpnClientRevokedCertificate `json:"vpnClientRevokedCertificates,omitempty"`
	// VpnClientProtocols - VpnClientProtocols for Virtual network gateway.
	VpnClientProtocols *[]VpnClientProtocol `json:"vpnClientProtocols,omitempty"`
	// VpnAuthenticationTypes - VPN authentication types for the virtual network gateway..
	VpnAuthenticationTypes *[]VpnAuthenticationType `json:"vpnAuthenticationTypes,omitempty"`
	// VpnClientIpsecPolicies - VpnClientIpsecPolicies for virtual network gateway P2S client.
	VpnClientIpsecPolicies *[]IpsecPolicy `json:"vpnClientIpsecPolicies,omitempty"`
	// RadiusServerAddress - The radius server address property of the VirtualNetworkGateway resource for vpn client connection.
	RadiusServerAddress *string `json:"radiusServerAddress,omitempty"`
	// RadiusServerSecret - The radius secret property of the VirtualNetworkGateway resource for vpn client connection.
	RadiusServerSecret *string `json:"radiusServerSecret,omitempty"`
	// RadiusServers - The radiusServers property for multiple radius server configuration.
	RadiusServers *[]RadiusServer `json:"radiusServers,omitempty"`
	// AadTenant - The AADTenant property of the VirtualNetworkGateway resource for vpn client connection used for AAD authentication.
	AadTenant *string `json:"aadTenant,omitempty"`
	// AadAudience - The AADAudience property of the VirtualNetworkGateway resource for vpn client connection used for AAD authentication.
	AadAudience *string `json:"aadAudience,omitempty"`
	// AadIssuer - The AADIssuer property of the VirtualNetworkGateway resource for vpn client connection used for AAD authentication.
	AadIssuer *string `json:"aadIssuer,omitempty"`
}

// VpnClientConnectionHealth vpnClientConnectionHealth properties.
type VpnClientConnectionHealth struct {
	// TotalIngressBytesTransferred - READ-ONLY; Total of the Ingress Bytes Transferred in this P2S Vpn connection.
	TotalIngressBytesTransferred *int64 `json:"totalIngressBytesTransferred,omitempty"`
	// TotalEgressBytesTransferred - READ-ONLY; Total of the Egress Bytes Transferred in this connection.
	TotalEgressBytesTransferred *int64 `json:"totalEgressBytesTransferred,omitempty"`
	// VpnClientConnectionsCount - The total of p2s vpn clients connected at this time to this P2SVpnGateway.
	VpnClientConnectionsCount *int32 `json:"vpnClientConnectionsCount,omitempty"`
	// AllocatedIPAddresses - List of allocated ip addresses to the connected p2s vpn clients.
	AllocatedIPAddresses *[]string `json:"allocatedIpAddresses,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnClientConnectionHealth.
func (vcch VpnClientConnectionHealth) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vcch.VpnClientConnectionsCount != nil {
		objectMap["vpnClientConnectionsCount"] = vcch.VpnClientConnectionsCount
	}
	if vcch.AllocatedIPAddresses != nil {
		objectMap["allocatedIpAddresses"] = vcch.AllocatedIPAddresses
	}
	return json.Marshal(objectMap)
}

// VpnClientConnectionHealthDetail VPN client connection health detail.
type VpnClientConnectionHealthDetail struct {
	// VpnConnectionID - READ-ONLY; The vpn client Id.
	VpnConnectionID *string `json:"vpnConnectionId,omitempty"`
	// VpnConnectionDuration - READ-ONLY; The duration time of a connected vpn client.
	VpnConnectionDuration *int64 `json:"vpnConnectionDuration,omitempty"`
	// VpnConnectionTime - READ-ONLY; The start time of a connected vpn client.
	VpnConnectionTime *string `json:"vpnConnectionTime,omitempty"`
	// PublicIPAddress - READ-ONLY; The public Ip of a connected vpn client.
	PublicIPAddress *string `json:"publicIpAddress,omitempty"`
	// PrivateIPAddress - READ-ONLY; The assigned private Ip of a connected vpn client.
	PrivateIPAddress *string `json:"privateIpAddress,omitempty"`
	// VpnUserName - READ-ONLY; The user name of a connected vpn client.
	VpnUserName *string `json:"vpnUserName,omitempty"`
	// MaxBandwidth - READ-ONLY; The max band width.
	MaxBandwidth *int64 `json:"maxBandwidth,omitempty"`
	// EgressPacketsTransferred - READ-ONLY; The egress packets per second.
	EgressPacketsTransferred *int64 `json:"egressPacketsTransferred,omitempty"`
	// EgressBytesTransferred - READ-ONLY; The egress bytes per second.
	EgressBytesTransferred *int64 `json:"egressBytesTransferred,omitempty"`
	// IngressPacketsTransferred - READ-ONLY; The ingress packets per second.
	IngressPacketsTransferred *int64 `json:"ingressPacketsTransferred,omitempty"`
	// IngressBytesTransferred - READ-ONLY; The ingress bytes per second.
	IngressBytesTransferred *int64 `json:"ingressBytesTransferred,omitempty"`
	// MaxPacketsPerSecond - READ-ONLY; The max packets transferred per second.
	MaxPacketsPerSecond *int64 `json:"maxPacketsPerSecond,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnClientConnectionHealthDetail.
func (vcchd VpnClientConnectionHealthDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// VpnClientConnectionHealthDetailListResult list of virtual network gateway vpn client connection health.
type VpnClientConnectionHealthDetailListResult struct {
	autorest.Response `json:"-"`
	// Value - List of vpn client connection health.
	Value *[]VpnClientConnectionHealthDetail `json:"value,omitempty"`
}

// VpnClientIPsecParameters an IPSec parameters for a virtual network gateway P2S connection.
type VpnClientIPsecParameters struct {
	autorest.Response `json:"-"`
	// SaLifeTimeSeconds - The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for P2S client.
	SaLifeTimeSeconds *int32 `json:"saLifeTimeSeconds,omitempty"`
	// SaDataSizeKilobytes - The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for P2S client..
	SaDataSizeKilobytes *int32 `json:"saDataSizeKilobytes,omitempty"`
	// IpsecEncryption - The IPSec encryption algorithm (IKE phase 1). Possible values include: 'IpsecEncryptionNone', 'IpsecEncryptionDES', 'IpsecEncryptionDES3', 'IpsecEncryptionAES128', 'IpsecEncryptionAES192', 'IpsecEncryptionAES256', 'IpsecEncryptionGCMAES128', 'IpsecEncryptionGCMAES192', 'IpsecEncryptionGCMAES256'
	IpsecEncryption IpsecEncryption `json:"ipsecEncryption,omitempty"`
	// IpsecIntegrity - The IPSec integrity algorithm (IKE phase 1). Possible values include: 'IpsecIntegrityMD5', 'IpsecIntegritySHA1', 'IpsecIntegritySHA256', 'IpsecIntegrityGCMAES128', 'IpsecIntegrityGCMAES192', 'IpsecIntegrityGCMAES256'
	IpsecIntegrity IpsecIntegrity `json:"ipsecIntegrity,omitempty"`
	// IkeEncryption - The IKE encryption algorithm (IKE phase 2). Possible values include: 'IkeEncryptionDES', 'IkeEncryptionDES3', 'IkeEncryptionAES128', 'IkeEncryptionAES192', 'IkeEncryptionAES256', 'IkeEncryptionGCMAES256', 'IkeEncryptionGCMAES128'
	IkeEncryption IkeEncryption `json:"ikeEncryption,omitempty"`
	// IkeIntegrity - The IKE integrity algorithm (IKE phase 2). Possible values include: 'IkeIntegrityMD5', 'IkeIntegritySHA1', 'IkeIntegritySHA256', 'IkeIntegritySHA384', 'IkeIntegrityGCMAES256', 'IkeIntegrityGCMAES128'
	IkeIntegrity IkeIntegrity `json:"ikeIntegrity,omitempty"`
	// DhGroup - The DH Group used in IKE Phase 1 for initial SA. Possible values include: 'DhGroupNone', 'DhGroupDHGroup1', 'DhGroupDHGroup2', 'DhGroupDHGroup14', 'DhGroupDHGroup2048', 'DhGroupECP256', 'DhGroupECP384', 'DhGroupDHGroup24'
	DhGroup DhGroup `json:"dhGroup,omitempty"`
	// PfsGroup - The Pfs Group used in IKE Phase 2 for new child SA. Possible values include: 'PfsGroupNone', 'PfsGroupPFS1', 'PfsGroupPFS2', 'PfsGroupPFS2048', 'PfsGroupECP256', 'PfsGroupECP384', 'PfsGroupPFS24', 'PfsGroupPFS14', 'PfsGroupPFSMM'
	PfsGroup PfsGroup `json:"pfsGroup,omitempty"`
}

// VpnClientParameters vpn Client Parameters for package generation.
type VpnClientParameters struct {
	// ProcessorArchitecture - VPN client Processor Architecture. Possible values include: 'ProcessorArchitectureAmd64', 'ProcessorArchitectureX86'
	ProcessorArchitecture ProcessorArchitecture `json:"processorArchitecture,omitempty"`
	// AuthenticationMethod - VPN client authentication method. Possible values include: 'AuthenticationMethodEAPTLS', 'AuthenticationMethodEAPMSCHAPv2'
	AuthenticationMethod AuthenticationMethod `json:"authenticationMethod,omitempty"`
	// RadiusServerAuthCertificate - The public certificate data for the radius server authentication certificate as a Base-64 encoded string. Required only if external radius authentication has been configured with EAPTLS authentication.
	RadiusServerAuthCertificate *string `json:"radiusServerAuthCertificate,omitempty"`
	// ClientRootCertificates - A list of client root certificates public certificate data encoded as Base-64 strings. Optional parameter for external radius based authentication with EAPTLS.
	ClientRootCertificates *[]string `json:"clientRootCertificates,omitempty"`
}

// VpnClientRevokedCertificate VPN client revoked certificate of virtual network gateway.
type VpnClientRevokedCertificate struct {
	// VpnClientRevokedCertificatePropertiesFormat - Properties of the vpn client revoked certificate.
	*VpnClientRevokedCertificatePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnClientRevokedCertificate.
func (vcrc VpnClientRevokedCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vcrc.VpnClientRevokedCertificatePropertiesFormat != nil {
		objectMap["properties"] = vcrc.VpnClientRevokedCertificatePropertiesFormat
	}
	if vcrc.Name != nil {
		objectMap["name"] = vcrc.Name
	}
	if vcrc.ID != nil {
		objectMap["id"] = vcrc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnClientRevokedCertificate struct.
func (vcrc *VpnClientRevokedCertificate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnClientRevokedCertificatePropertiesFormat VpnClientRevokedCertificatePropertiesFormat
				err = json.Unmarshal(*v, &vpnClientRevokedCertificatePropertiesFormat)
				if err != nil {
					return err
				}
				vcrc.VpnClientRevokedCertificatePropertiesFormat = &vpnClientRevokedCertificatePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vcrc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vcrc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vcrc.ID = &ID
			}
		}
	}

	return nil
}

// VpnClientRevokedCertificatePropertiesFormat properties of the revoked VPN client certificate of virtual
// network gateway.
type VpnClientRevokedCertificatePropertiesFormat struct {
	// Thumbprint - The revoked VPN client certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the VPN client revoked certificate resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnClientRevokedCertificatePropertiesFormat.
func (vcrcpf VpnClientRevokedCertificatePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vcrcpf.Thumbprint != nil {
		objectMap["thumbprint"] = vcrcpf.Thumbprint
	}
	return json.Marshal(objectMap)
}

// VpnClientRootCertificate VPN client root certificate of virtual network gateway.
type VpnClientRootCertificate struct {
	// VpnClientRootCertificatePropertiesFormat - Properties of the vpn client root certificate.
	*VpnClientRootCertificatePropertiesFormat `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnClientRootCertificate.
func (vcrc VpnClientRootCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vcrc.VpnClientRootCertificatePropertiesFormat != nil {
		objectMap["properties"] = vcrc.VpnClientRootCertificatePropertiesFormat
	}
	if vcrc.Name != nil {
		objectMap["name"] = vcrc.Name
	}
	if vcrc.ID != nil {
		objectMap["id"] = vcrc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnClientRootCertificate struct.
func (vcrc *VpnClientRootCertificate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnClientRootCertificatePropertiesFormat VpnClientRootCertificatePropertiesFormat
				err = json.Unmarshal(*v, &vpnClientRootCertificatePropertiesFormat)
				if err != nil {
					return err
				}
				vcrc.VpnClientRootCertificatePropertiesFormat = &vpnClientRootCertificatePropertiesFormat
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vcrc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vcrc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vcrc.ID = &ID
			}
		}
	}

	return nil
}

// VpnClientRootCertificatePropertiesFormat properties of SSL certificates of application gateway.
type VpnClientRootCertificatePropertiesFormat struct {
	// PublicCertData - The certificate public data.
	PublicCertData *string `json:"publicCertData,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the VPN client root certificate resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnClientRootCertificatePropertiesFormat.
func (vcrcpf VpnClientRootCertificatePropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vcrcpf.PublicCertData != nil {
		objectMap["publicCertData"] = vcrcpf.PublicCertData
	}
	return json.Marshal(objectMap)
}

// VpnConnection vpnConnection Resource.
type VpnConnection struct {
	autorest.Response `json:"-"`
	// VpnConnectionProperties - Properties of the VPN connection.
	*VpnConnectionProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnConnection.
func (vc VpnConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vc.VpnConnectionProperties != nil {
		objectMap["properties"] = vc.VpnConnectionProperties
	}
	if vc.Name != nil {
		objectMap["name"] = vc.Name
	}
	if vc.ID != nil {
		objectMap["id"] = vc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnConnection struct.
func (vc *VpnConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnConnectionProperties VpnConnectionProperties
				err = json.Unmarshal(*v, &vpnConnectionProperties)
				if err != nil {
					return err
				}
				vc.VpnConnectionProperties = &vpnConnectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vc.ID = &ID
			}
		}
	}

	return nil
}

// VpnConnectionPacketCaptureStartParameters vpn Connection packet capture parameters supplied to start
// packet capture on gateway connection.
type VpnConnectionPacketCaptureStartParameters struct {
	// FilterData - Start Packet capture parameters on vpn connection.
	FilterData *string `json:"filterData,omitempty"`
	// LinkConnectionNames - List of site link connection names.
	LinkConnectionNames *[]string `json:"linkConnectionNames,omitempty"`
}

// VpnConnectionPacketCaptureStopParameters vpn Connection packet capture parameters supplied to stop
// packet capture on gateway connection.
type VpnConnectionPacketCaptureStopParameters struct {
	// SasURL - SAS url for packet capture on vpn connection.
	SasURL *string `json:"sasUrl,omitempty"`
	// LinkConnectionNames - List of site link connection names.
	LinkConnectionNames *[]string `json:"linkConnectionNames,omitempty"`
}

// VpnConnectionProperties parameters for VpnConnection.
type VpnConnectionProperties struct {
	// RemoteVpnSite - Id of the connected vpn site.
	RemoteVpnSite *SubResource `json:"remoteVpnSite,omitempty"`
	// RoutingWeight - Routing weight for vpn connection.
	RoutingWeight *int32 `json:"routingWeight,omitempty"`
	// DpdTimeoutSeconds - DPD timeout in seconds for vpn connection.
	DpdTimeoutSeconds *int32 `json:"dpdTimeoutSeconds,omitempty"`
	// ConnectionStatus - The connection status. Possible values include: 'VpnConnectionStatusUnknown', 'VpnConnectionStatusConnecting', 'VpnConnectionStatusConnected', 'VpnConnectionStatusNotConnected'
	ConnectionStatus VpnConnectionStatus `json:"connectionStatus,omitempty"`
	// VpnConnectionProtocolType - Connection protocol used for this connection. Possible values include: 'VirtualNetworkGatewayConnectionProtocolIKEv2', 'VirtualNetworkGatewayConnectionProtocolIKEv1'
	VpnConnectionProtocolType VirtualNetworkGatewayConnectionProtocol `json:"vpnConnectionProtocolType,omitempty"`
	// IngressBytesTransferred - READ-ONLY; Ingress bytes transferred.
	IngressBytesTransferred *int64 `json:"ingressBytesTransferred,omitempty"`
	// EgressBytesTransferred - READ-ONLY; Egress bytes transferred.
	EgressBytesTransferred *int64 `json:"egressBytesTransferred,omitempty"`
	// ConnectionBandwidth - Expected bandwidth in MBPS.
	ConnectionBandwidth *int32 `json:"connectionBandwidth,omitempty"`
	// SharedKey - SharedKey for the vpn connection.
	SharedKey *string `json:"sharedKey,omitempty"`
	// EnableBgp - EnableBgp flag.
	EnableBgp *bool `json:"enableBgp,omitempty"`
	// UsePolicyBasedTrafficSelectors - Enable policy-based traffic selectors.
	UsePolicyBasedTrafficSelectors *bool `json:"usePolicyBasedTrafficSelectors,omitempty"`
	// IpsecPolicies - The IPSec Policies to be considered by this connection.
	IpsecPolicies *[]IpsecPolicy `json:"ipsecPolicies,omitempty"`
	// TrafficSelectorPolicies - The Traffic Selector Policies to be considered by this connection.
	TrafficSelectorPolicies *[]TrafficSelectorPolicy `json:"trafficSelectorPolicies,omitempty"`
	// EnableRateLimiting - EnableBgp flag.
	EnableRateLimiting *bool `json:"enableRateLimiting,omitempty"`
	// EnableInternetSecurity - Enable internet security.
	EnableInternetSecurity *bool `json:"enableInternetSecurity,omitempty"`
	// UseLocalAzureIPAddress - Use local azure ip to initiate connection.
	UseLocalAzureIPAddress *bool `json:"useLocalAzureIpAddress,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the VPN connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// VpnLinkConnections - List of all vpn site link connections to the gateway.
	VpnLinkConnections *[]VpnSiteLinkConnection `json:"vpnLinkConnections,omitempty"`
	// RoutingConfiguration - The Routing Configuration indicating the associated and propagated route tables on this connection.
	RoutingConfiguration *RoutingConfiguration `json:"routingConfiguration,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnConnectionProperties.
func (vcp VpnConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vcp.RemoteVpnSite != nil {
		objectMap["remoteVpnSite"] = vcp.RemoteVpnSite
	}
	if vcp.RoutingWeight != nil {
		objectMap["routingWeight"] = vcp.RoutingWeight
	}
	if vcp.DpdTimeoutSeconds != nil {
		objectMap["dpdTimeoutSeconds"] = vcp.DpdTimeoutSeconds
	}
	if vcp.ConnectionStatus != "" {
		objectMap["connectionStatus"] = vcp.ConnectionStatus
	}
	if vcp.VpnConnectionProtocolType != "" {
		objectMap["vpnConnectionProtocolType"] = vcp.VpnConnectionProtocolType
	}
	if vcp.ConnectionBandwidth != nil {
		objectMap["connectionBandwidth"] = vcp.ConnectionBandwidth
	}
	if vcp.SharedKey != nil {
		objectMap["sharedKey"] = vcp.SharedKey
	}
	if vcp.EnableBgp != nil {
		objectMap["enableBgp"] = vcp.EnableBgp
	}
	if vcp.UsePolicyBasedTrafficSelectors != nil {
		objectMap["usePolicyBasedTrafficSelectors"] = vcp.UsePolicyBasedTrafficSelectors
	}
	if vcp.IpsecPolicies != nil {
		objectMap["ipsecPolicies"] = vcp.IpsecPolicies
	}
	if vcp.TrafficSelectorPolicies != nil {
		objectMap["trafficSelectorPolicies"] = vcp.TrafficSelectorPolicies
	}
	if vcp.EnableRateLimiting != nil {
		objectMap["enableRateLimiting"] = vcp.EnableRateLimiting
	}
	if vcp.EnableInternetSecurity != nil {
		objectMap["enableInternetSecurity"] = vcp.EnableInternetSecurity
	}
	if vcp.UseLocalAzureIPAddress != nil {
		objectMap["useLocalAzureIpAddress"] = vcp.UseLocalAzureIPAddress
	}
	if vcp.VpnLinkConnections != nil {
		objectMap["vpnLinkConnections"] = vcp.VpnLinkConnections
	}
	if vcp.RoutingConfiguration != nil {
		objectMap["routingConfiguration"] = vcp.RoutingConfiguration
	}
	return json.Marshal(objectMap)
}

// VpnConnectionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnConnectionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnConnectionsClient) (VpnConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnConnectionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnConnectionsCreateOrUpdateFuture.Result.
func (future *VpnConnectionsCreateOrUpdateFuture) result(client VpnConnectionsClient) (vc VpnConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnConnectionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnConnectionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vc.Response.Response, err = future.GetResult(sender); err == nil && vc.Response.Response.StatusCode != http.StatusNoContent {
		vc, err = client.CreateOrUpdateResponder(vc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnConnectionsCreateOrUpdateFuture", "Result", vc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnConnectionsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VpnConnectionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnConnectionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnConnectionsDeleteFuture.Result.
func (future *VpnConnectionsDeleteFuture) result(client VpnConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnConnectionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnConnectionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VpnConnectionsStartPacketCaptureFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnConnectionsStartPacketCaptureFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnConnectionsClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnConnectionsStartPacketCaptureFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnConnectionsStartPacketCaptureFuture.Result.
func (future *VpnConnectionsStartPacketCaptureFuture) result(client VpnConnectionsClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnConnectionsStartPacketCaptureFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnConnectionsStartPacketCaptureFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.StartPacketCaptureResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnConnectionsStartPacketCaptureFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnConnectionsStopPacketCaptureFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnConnectionsStopPacketCaptureFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnConnectionsClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnConnectionsStopPacketCaptureFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnConnectionsStopPacketCaptureFuture.Result.
func (future *VpnConnectionsStopPacketCaptureFuture) result(client VpnConnectionsClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnConnectionsStopPacketCaptureFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnConnectionsStopPacketCaptureFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.StopPacketCaptureResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnConnectionsStopPacketCaptureFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnDeviceScriptParameters vpn device configuration script generation parameters.
type VpnDeviceScriptParameters struct {
	// Vendor - The vendor for the vpn device.
	Vendor *string `json:"vendor,omitempty"`
	// DeviceFamily - The device family for the vpn device.
	DeviceFamily *string `json:"deviceFamily,omitempty"`
	// FirmwareVersion - The firmware version for the vpn device.
	FirmwareVersion *string `json:"firmwareVersion,omitempty"`
}

// VpnGateway vpnGateway Resource.
type VpnGateway struct {
	autorest.Response `json:"-"`
	// VpnGatewayProperties - Properties of the VPN gateway.
	*VpnGatewayProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VpnGateway.
func (vg VpnGateway) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vg.VpnGatewayProperties != nil {
		objectMap["properties"] = vg.VpnGatewayProperties
	}
	if vg.ID != nil {
		objectMap["id"] = vg.ID
	}
	if vg.Location != nil {
		objectMap["location"] = vg.Location
	}
	if vg.Tags != nil {
		objectMap["tags"] = vg.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnGateway struct.
func (vg *VpnGateway) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnGatewayProperties VpnGatewayProperties
				err = json.Unmarshal(*v, &vpnGatewayProperties)
				if err != nil {
					return err
				}
				vg.VpnGatewayProperties = &vpnGatewayProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vg.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vg.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vg.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vg.Tags = tags
			}
		}
	}

	return nil
}

// VpnGatewayIPConfiguration IP Configuration of a VPN Gateway Resource.
type VpnGatewayIPConfiguration struct {
	// ID - The identifier of the IP configuration for a VPN Gateway.
	ID *string `json:"id,omitempty"`
	// PublicIPAddress - The public IP address of this IP configuration.
	PublicIPAddress *string `json:"publicIpAddress,omitempty"`
	// PrivateIPAddress - The private IP address of this IP configuration.
	PrivateIPAddress *string `json:"privateIpAddress,omitempty"`
}

// VpnGatewayNatRule vpnGatewayNatRule Resource.
type VpnGatewayNatRule struct {
	autorest.Response `json:"-"`
	// VpnGatewayNatRuleProperties - Properties of the VpnGateway NAT rule.
	*VpnGatewayNatRuleProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnGatewayNatRule.
func (vgnr VpnGatewayNatRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vgnr.VpnGatewayNatRuleProperties != nil {
		objectMap["properties"] = vgnr.VpnGatewayNatRuleProperties
	}
	if vgnr.Name != nil {
		objectMap["name"] = vgnr.Name
	}
	if vgnr.ID != nil {
		objectMap["id"] = vgnr.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnGatewayNatRule struct.
func (vgnr *VpnGatewayNatRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnGatewayNatRuleProperties VpnGatewayNatRuleProperties
				err = json.Unmarshal(*v, &vpnGatewayNatRuleProperties)
				if err != nil {
					return err
				}
				vgnr.VpnGatewayNatRuleProperties = &vpnGatewayNatRuleProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vgnr.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vgnr.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vgnr.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vgnr.ID = &ID
			}
		}
	}

	return nil
}

// VpnGatewayNatRuleProperties parameters for VpnGatewayNatRule.
type VpnGatewayNatRuleProperties struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the NAT Rule resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Type - The type of NAT rule for VPN NAT. Possible values include: 'VpnNatRuleTypeStatic', 'VpnNatRuleTypeDynamic'
	Type VpnNatRuleType `json:"type,omitempty"`
	// Mode - The Source NAT direction of a VPN NAT. Possible values include: 'VpnNatRuleModeEgressSnat', 'VpnNatRuleModeIngressSnat'
	Mode VpnNatRuleMode `json:"mode,omitempty"`
	// InternalMappings - The private IP address internal mapping for NAT.
	InternalMappings *[]VpnNatRuleMapping `json:"internalMappings,omitempty"`
	// ExternalMappings - The private IP address external mapping for NAT.
	ExternalMappings *[]VpnNatRuleMapping `json:"externalMappings,omitempty"`
	// IPConfigurationID - The IP Configuration ID this NAT rule applies to.
	IPConfigurationID *string `json:"ipConfigurationId,omitempty"`
	// EgressVpnSiteLinkConnections - READ-ONLY; List of egress VpnSiteLinkConnections.
	EgressVpnSiteLinkConnections *[]SubResource `json:"egressVpnSiteLinkConnections,omitempty"`
	// IngressVpnSiteLinkConnections - READ-ONLY; List of ingress VpnSiteLinkConnections.
	IngressVpnSiteLinkConnections *[]SubResource `json:"ingressVpnSiteLinkConnections,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnGatewayNatRuleProperties.
func (vgnrp VpnGatewayNatRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vgnrp.Type != "" {
		objectMap["type"] = vgnrp.Type
	}
	if vgnrp.Mode != "" {
		objectMap["mode"] = vgnrp.Mode
	}
	if vgnrp.InternalMappings != nil {
		objectMap["internalMappings"] = vgnrp.InternalMappings
	}
	if vgnrp.ExternalMappings != nil {
		objectMap["externalMappings"] = vgnrp.ExternalMappings
	}
	if vgnrp.IPConfigurationID != nil {
		objectMap["ipConfigurationId"] = vgnrp.IPConfigurationID
	}
	return json.Marshal(objectMap)
}

// VpnGatewayPacketCaptureStartParameters start packet capture parameters.
type VpnGatewayPacketCaptureStartParameters struct {
	// FilterData - Start Packet capture parameters on vpn gateway.
	FilterData *string `json:"filterData,omitempty"`
}

// VpnGatewayPacketCaptureStopParameters stop packet capture parameters.
type VpnGatewayPacketCaptureStopParameters struct {
	// SasURL - SAS url for packet capture on vpn gateway.
	SasURL *string `json:"sasUrl,omitempty"`
}

// VpnGatewayProperties parameters for VpnGateway.
type VpnGatewayProperties struct {
	// VirtualHub - The VirtualHub to which the gateway belongs.
	VirtualHub *SubResource `json:"virtualHub,omitempty"`
	// Connections - List of all vpn connections to the gateway.
	Connections *[]VpnConnection `json:"connections,omitempty"`
	// BgpSettings - Local network gateway's BGP speaker settings.
	BgpSettings *BgpSettings `json:"bgpSettings,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the VPN gateway resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// VpnGatewayScaleUnit - The scale unit for this vpn gateway.
	VpnGatewayScaleUnit *int32 `json:"vpnGatewayScaleUnit,omitempty"`
	// IPConfigurations - READ-ONLY; List of all IPs configured on the gateway.
	IPConfigurations *[]VpnGatewayIPConfiguration `json:"ipConfigurations,omitempty"`
	// IsRoutingPreferenceInternet - Enable Routing Preference property for the Public IP Interface of the VpnGateway.
	IsRoutingPreferenceInternet *bool `json:"isRoutingPreferenceInternet,omitempty"`
	// NatRules - List of all the nat Rules associated with the gateway.
	NatRules *[]VpnGatewayNatRule `json:"natRules,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnGatewayProperties.
func (vgp VpnGatewayProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vgp.VirtualHub != nil {
		objectMap["virtualHub"] = vgp.VirtualHub
	}
	if vgp.Connections != nil {
		objectMap["connections"] = vgp.Connections
	}
	if vgp.BgpSettings != nil {
		objectMap["bgpSettings"] = vgp.BgpSettings
	}
	if vgp.VpnGatewayScaleUnit != nil {
		objectMap["vpnGatewayScaleUnit"] = vgp.VpnGatewayScaleUnit
	}
	if vgp.IsRoutingPreferenceInternet != nil {
		objectMap["isRoutingPreferenceInternet"] = vgp.IsRoutingPreferenceInternet
	}
	if vgp.NatRules != nil {
		objectMap["natRules"] = vgp.NatRules
	}
	return json.Marshal(objectMap)
}

// VpnGatewaysCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnGatewaysCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnGatewaysClient) (VpnGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnGatewaysCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnGatewaysCreateOrUpdateFuture.Result.
func (future *VpnGatewaysCreateOrUpdateFuture) result(client VpnGatewaysClient) (vg VpnGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnGatewaysCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnGatewaysCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vg.Response.Response, err = future.GetResult(sender); err == nil && vg.Response.Response.StatusCode != http.StatusNoContent {
		vg, err = client.CreateOrUpdateResponder(vg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnGatewaysCreateOrUpdateFuture", "Result", vg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnGatewaysDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VpnGatewaysDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnGatewaysClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnGatewaysDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnGatewaysDeleteFuture.Result.
func (future *VpnGatewaysDeleteFuture) result(client VpnGatewaysClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnGatewaysDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnGatewaysDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VpnGatewaysResetFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VpnGatewaysResetFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnGatewaysClient) (VpnGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnGatewaysResetFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnGatewaysResetFuture.Result.
func (future *VpnGatewaysResetFuture) result(client VpnGatewaysClient) (vg VpnGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnGatewaysResetFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnGatewaysResetFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vg.Response.Response, err = future.GetResult(sender); err == nil && vg.Response.Response.StatusCode != http.StatusNoContent {
		vg, err = client.ResetResponder(vg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnGatewaysResetFuture", "Result", vg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnGatewaysStartPacketCaptureFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnGatewaysStartPacketCaptureFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnGatewaysClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnGatewaysStartPacketCaptureFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnGatewaysStartPacketCaptureFuture.Result.
func (future *VpnGatewaysStartPacketCaptureFuture) result(client VpnGatewaysClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnGatewaysStartPacketCaptureFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnGatewaysStartPacketCaptureFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.StartPacketCaptureResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnGatewaysStartPacketCaptureFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnGatewaysStopPacketCaptureFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnGatewaysStopPacketCaptureFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnGatewaysClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnGatewaysStopPacketCaptureFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnGatewaysStopPacketCaptureFuture.Result.
func (future *VpnGatewaysStopPacketCaptureFuture) result(client VpnGatewaysClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnGatewaysStopPacketCaptureFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnGatewaysStopPacketCaptureFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.StopPacketCaptureResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnGatewaysStopPacketCaptureFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnGatewaysUpdateTagsFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VpnGatewaysUpdateTagsFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnGatewaysClient) (VpnGateway, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnGatewaysUpdateTagsFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnGatewaysUpdateTagsFuture.Result.
func (future *VpnGatewaysUpdateTagsFuture) result(client VpnGatewaysClient) (vg VpnGateway, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnGatewaysUpdateTagsFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnGatewaysUpdateTagsFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vg.Response.Response, err = future.GetResult(sender); err == nil && vg.Response.Response.StatusCode != http.StatusNoContent {
		vg, err = client.UpdateTagsResponder(vg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnGatewaysUpdateTagsFuture", "Result", vg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnLinkBgpSettings BGP settings details for a link.
type VpnLinkBgpSettings struct {
	// Asn - The BGP speaker's ASN.
	Asn *int64 `json:"asn,omitempty"`
	// BgpPeeringAddress - The BGP peering address and BGP identifier of this BGP speaker.
	BgpPeeringAddress *string `json:"bgpPeeringAddress,omitempty"`
}

// VpnLinkConnectionsGetIkeSasFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnLinkConnectionsGetIkeSasFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnLinkConnectionsClient) (String, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnLinkConnectionsGetIkeSasFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnLinkConnectionsGetIkeSasFuture.Result.
func (future *VpnLinkConnectionsGetIkeSasFuture) result(client VpnLinkConnectionsClient) (s String, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnLinkConnectionsGetIkeSasFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnLinkConnectionsGetIkeSasFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.GetIkeSasResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnLinkConnectionsGetIkeSasFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnLinkConnectionsResetConnectionFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnLinkConnectionsResetConnectionFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnLinkConnectionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnLinkConnectionsResetConnectionFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnLinkConnectionsResetConnectionFuture.Result.
func (future *VpnLinkConnectionsResetConnectionFuture) result(client VpnLinkConnectionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnLinkConnectionsResetConnectionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnLinkConnectionsResetConnectionFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VpnLinkProviderProperties list of properties of a link provider.
type VpnLinkProviderProperties struct {
	// LinkProviderName - Name of the link provider.
	LinkProviderName *string `json:"linkProviderName,omitempty"`
	// LinkSpeedInMbps - Link speed.
	LinkSpeedInMbps *int32 `json:"linkSpeedInMbps,omitempty"`
}

// VpnNatRuleMapping vpn NatRule mapping.
type VpnNatRuleMapping struct {
	// AddressSpace - Address space for Vpn NatRule mapping.
	AddressSpace *string `json:"addressSpace,omitempty"`
}

// VpnPacketCaptureStartParameters start packet capture parameters on virtual network gateway.
type VpnPacketCaptureStartParameters struct {
	// FilterData - Start Packet capture parameters.
	FilterData *string `json:"filterData,omitempty"`
}

// VpnPacketCaptureStopParameters stop packet capture parameters.
type VpnPacketCaptureStopParameters struct {
	// SasURL - SAS url for packet capture on virtual network gateway.
	SasURL *string `json:"sasUrl,omitempty"`
}

// VpnProfileResponse vpn Profile Response for package generation.
type VpnProfileResponse struct {
	autorest.Response `json:"-"`
	// ProfileURL - URL to the VPN profile.
	ProfileURL *string `json:"profileUrl,omitempty"`
}

// VpnServerConfigRadiusClientRootCertificate properties of the Radius client root certificate of
// VpnServerConfiguration.
type VpnServerConfigRadiusClientRootCertificate struct {
	// Name - The certificate name.
	Name *string `json:"name,omitempty"`
	// Thumbprint - The Radius client root certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
}

// VpnServerConfigRadiusServerRootCertificate properties of Radius Server root certificate of
// VpnServerConfiguration.
type VpnServerConfigRadiusServerRootCertificate struct {
	// Name - The certificate name.
	Name *string `json:"name,omitempty"`
	// PublicCertData - The certificate public data.
	PublicCertData *string `json:"publicCertData,omitempty"`
}

// VpnServerConfiguration vpnServerConfiguration Resource.
type VpnServerConfiguration struct {
	autorest.Response `json:"-"`
	// VpnServerConfigurationProperties - Properties of the P2SVpnServer configuration.
	*VpnServerConfigurationProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VpnServerConfiguration.
func (vsc VpnServerConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vsc.VpnServerConfigurationProperties != nil {
		objectMap["properties"] = vsc.VpnServerConfigurationProperties
	}
	if vsc.ID != nil {
		objectMap["id"] = vsc.ID
	}
	if vsc.Location != nil {
		objectMap["location"] = vsc.Location
	}
	if vsc.Tags != nil {
		objectMap["tags"] = vsc.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnServerConfiguration struct.
func (vsc *VpnServerConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnServerConfigurationProperties VpnServerConfigurationProperties
				err = json.Unmarshal(*v, &vpnServerConfigurationProperties)
				if err != nil {
					return err
				}
				vsc.VpnServerConfigurationProperties = &vpnServerConfigurationProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vsc.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vsc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vsc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vsc.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vsc.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vsc.Tags = tags
			}
		}
	}

	return nil
}

// VpnServerConfigurationProperties parameters for VpnServerConfiguration.
type VpnServerConfigurationProperties struct {
	// Name - The name of the VpnServerConfiguration that is unique within a resource group.
	Name *string `json:"name,omitempty"`
	// VpnProtocols - VPN protocols for the VpnServerConfiguration.
	VpnProtocols *[]VpnGatewayTunnelingProtocol `json:"vpnProtocols,omitempty"`
	// VpnAuthenticationTypes - VPN authentication types for the VpnServerConfiguration.
	VpnAuthenticationTypes *[]VpnAuthenticationType `json:"vpnAuthenticationTypes,omitempty"`
	// VpnClientRootCertificates - VPN client root certificate of VpnServerConfiguration.
	VpnClientRootCertificates *[]VpnServerConfigVpnClientRootCertificate `json:"vpnClientRootCertificates,omitempty"`
	// VpnClientRevokedCertificates - VPN client revoked certificate of VpnServerConfiguration.
	VpnClientRevokedCertificates *[]VpnServerConfigVpnClientRevokedCertificate `json:"vpnClientRevokedCertificates,omitempty"`
	// RadiusServerRootCertificates - Radius Server root certificate of VpnServerConfiguration.
	RadiusServerRootCertificates *[]VpnServerConfigRadiusServerRootCertificate `json:"radiusServerRootCertificates,omitempty"`
	// RadiusClientRootCertificates - Radius client root certificate of VpnServerConfiguration.
	RadiusClientRootCertificates *[]VpnServerConfigRadiusClientRootCertificate `json:"radiusClientRootCertificates,omitempty"`
	// VpnClientIpsecPolicies - VpnClientIpsecPolicies for VpnServerConfiguration.
	VpnClientIpsecPolicies *[]IpsecPolicy `json:"vpnClientIpsecPolicies,omitempty"`
	// RadiusServerAddress - The radius server address property of the VpnServerConfiguration resource for point to site client connection.
	RadiusServerAddress *string `json:"radiusServerAddress,omitempty"`
	// RadiusServerSecret - The radius secret property of the VpnServerConfiguration resource for point to site client connection.
	RadiusServerSecret *string `json:"radiusServerSecret,omitempty"`
	// RadiusServers - Multiple Radius Server configuration for VpnServerConfiguration.
	RadiusServers *[]RadiusServer `json:"radiusServers,omitempty"`
	// AadAuthenticationParameters - The set of aad vpn authentication parameters.
	AadAuthenticationParameters *AadAuthenticationParameters `json:"aadAuthenticationParameters,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the VpnServerConfiguration resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// P2SVpnGateways - READ-ONLY; List of references to P2SVpnGateways.
	P2SVpnGateways *[]P2SVpnGateway `json:"p2SVpnGateways,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnServerConfigurationProperties.
func (vscp VpnServerConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vscp.Name != nil {
		objectMap["name"] = vscp.Name
	}
	if vscp.VpnProtocols != nil {
		objectMap["vpnProtocols"] = vscp.VpnProtocols
	}
	if vscp.VpnAuthenticationTypes != nil {
		objectMap["vpnAuthenticationTypes"] = vscp.VpnAuthenticationTypes
	}
	if vscp.VpnClientRootCertificates != nil {
		objectMap["vpnClientRootCertificates"] = vscp.VpnClientRootCertificates
	}
	if vscp.VpnClientRevokedCertificates != nil {
		objectMap["vpnClientRevokedCertificates"] = vscp.VpnClientRevokedCertificates
	}
	if vscp.RadiusServerRootCertificates != nil {
		objectMap["radiusServerRootCertificates"] = vscp.RadiusServerRootCertificates
	}
	if vscp.RadiusClientRootCertificates != nil {
		objectMap["radiusClientRootCertificates"] = vscp.RadiusClientRootCertificates
	}
	if vscp.VpnClientIpsecPolicies != nil {
		objectMap["vpnClientIpsecPolicies"] = vscp.VpnClientIpsecPolicies
	}
	if vscp.RadiusServerAddress != nil {
		objectMap["radiusServerAddress"] = vscp.RadiusServerAddress
	}
	if vscp.RadiusServerSecret != nil {
		objectMap["radiusServerSecret"] = vscp.RadiusServerSecret
	}
	if vscp.RadiusServers != nil {
		objectMap["radiusServers"] = vscp.RadiusServers
	}
	if vscp.AadAuthenticationParameters != nil {
		objectMap["aadAuthenticationParameters"] = vscp.AadAuthenticationParameters
	}
	return json.Marshal(objectMap)
}

// VpnServerConfigurationsAssociatedWithVirtualWanListFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type VpnServerConfigurationsAssociatedWithVirtualWanListFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnServerConfigurationsAssociatedWithVirtualWanClient) (VpnServerConfigurationsResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnServerConfigurationsAssociatedWithVirtualWanListFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnServerConfigurationsAssociatedWithVirtualWanListFuture.Result.
func (future *VpnServerConfigurationsAssociatedWithVirtualWanListFuture) result(client VpnServerConfigurationsAssociatedWithVirtualWanClient) (vscr VpnServerConfigurationsResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnServerConfigurationsAssociatedWithVirtualWanListFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vscr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnServerConfigurationsAssociatedWithVirtualWanListFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vscr.Response.Response, err = future.GetResult(sender); err == nil && vscr.Response.Response.StatusCode != http.StatusNoContent {
		vscr, err = client.ListResponder(vscr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnServerConfigurationsAssociatedWithVirtualWanListFuture", "Result", vscr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnServerConfigurationsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type VpnServerConfigurationsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnServerConfigurationsClient) (VpnServerConfiguration, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnServerConfigurationsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnServerConfigurationsCreateOrUpdateFuture.Result.
func (future *VpnServerConfigurationsCreateOrUpdateFuture) result(client VpnServerConfigurationsClient) (vsc VpnServerConfiguration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnServerConfigurationsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vsc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnServerConfigurationsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vsc.Response.Response, err = future.GetResult(sender); err == nil && vsc.Response.Response.StatusCode != http.StatusNoContent {
		vsc, err = client.CreateOrUpdateResponder(vsc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnServerConfigurationsCreateOrUpdateFuture", "Result", vsc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnServerConfigurationsDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnServerConfigurationsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnServerConfigurationsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnServerConfigurationsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnServerConfigurationsDeleteFuture.Result.
func (future *VpnServerConfigurationsDeleteFuture) result(client VpnServerConfigurationsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnServerConfigurationsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnServerConfigurationsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VpnServerConfigurationsResponse vpnServerConfigurations list associated with VirtualWan Response.
type VpnServerConfigurationsResponse struct {
	autorest.Response `json:"-"`
	// VpnServerConfigurationResourceIds - List of VpnServerConfigurations associated with VirtualWan.
	VpnServerConfigurationResourceIds *[]string `json:"vpnServerConfigurationResourceIds,omitempty"`
}

// VpnServerConfigVpnClientRevokedCertificate properties of the revoked VPN client certificate of
// VpnServerConfiguration.
type VpnServerConfigVpnClientRevokedCertificate struct {
	// Name - The certificate name.
	Name *string `json:"name,omitempty"`
	// Thumbprint - The revoked VPN client certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
}

// VpnServerConfigVpnClientRootCertificate properties of VPN client root certificate of
// VpnServerConfiguration.
type VpnServerConfigVpnClientRootCertificate struct {
	// Name - The certificate name.
	Name *string `json:"name,omitempty"`
	// PublicCertData - The certificate public data.
	PublicCertData *string `json:"publicCertData,omitempty"`
}

// VpnSite vpnSite Resource.
type VpnSite struct {
	autorest.Response `json:"-"`
	// VpnSiteProperties - Properties of the VPN site.
	*VpnSiteProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VpnSite.
func (vs VpnSite) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vs.VpnSiteProperties != nil {
		objectMap["properties"] = vs.VpnSiteProperties
	}
	if vs.ID != nil {
		objectMap["id"] = vs.ID
	}
	if vs.Location != nil {
		objectMap["location"] = vs.Location
	}
	if vs.Tags != nil {
		objectMap["tags"] = vs.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnSite struct.
func (vs *VpnSite) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnSiteProperties VpnSiteProperties
				err = json.Unmarshal(*v, &vpnSiteProperties)
				if err != nil {
					return err
				}
				vs.VpnSiteProperties = &vpnSiteProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vs.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vs.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vs.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vs.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vs.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vs.Tags = tags
			}
		}
	}

	return nil
}

// VpnSiteID vpnSite Resource.
type VpnSiteID struct {
	// VpnSite - READ-ONLY; The resource-uri of the vpn-site for which config is to be fetched.
	VpnSite *string `json:"vpnSite,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnSiteID.
func (vsi VpnSiteID) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// VpnSiteLink vpnSiteLink Resource.
type VpnSiteLink struct {
	autorest.Response `json:"-"`
	// VpnSiteLinkProperties - Properties of the VPN site link.
	*VpnSiteLinkProperties `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnSiteLink.
func (vsl VpnSiteLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vsl.VpnSiteLinkProperties != nil {
		objectMap["properties"] = vsl.VpnSiteLinkProperties
	}
	if vsl.Name != nil {
		objectMap["name"] = vsl.Name
	}
	if vsl.ID != nil {
		objectMap["id"] = vsl.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnSiteLink struct.
func (vsl *VpnSiteLink) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnSiteLinkProperties VpnSiteLinkProperties
				err = json.Unmarshal(*v, &vpnSiteLinkProperties)
				if err != nil {
					return err
				}
				vsl.VpnSiteLinkProperties = &vpnSiteLinkProperties
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vsl.Etag = &etag
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vsl.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vsl.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vsl.ID = &ID
			}
		}
	}

	return nil
}

// VpnSiteLinkConnection vpnSiteLinkConnection Resource.
type VpnSiteLinkConnection struct {
	autorest.Response `json:"-"`
	// VpnSiteLinkConnectionProperties - Properties of the VPN site link connection.
	*VpnSiteLinkConnectionProperties `json:"properties,omitempty"`
	// Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnSiteLinkConnection.
func (vslc VpnSiteLinkConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vslc.VpnSiteLinkConnectionProperties != nil {
		objectMap["properties"] = vslc.VpnSiteLinkConnectionProperties
	}
	if vslc.Name != nil {
		objectMap["name"] = vslc.Name
	}
	if vslc.ID != nil {
		objectMap["id"] = vslc.ID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VpnSiteLinkConnection struct.
func (vslc *VpnSiteLinkConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vpnSiteLinkConnectionProperties VpnSiteLinkConnectionProperties
				err = json.Unmarshal(*v, &vpnSiteLinkConnectionProperties)
				if err != nil {
					return err
				}
				vslc.VpnSiteLinkConnectionProperties = &vpnSiteLinkConnectionProperties
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vslc.Name = &name
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				vslc.Etag = &etag
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vslc.Type = &typeVar
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vslc.ID = &ID
			}
		}
	}

	return nil
}

// VpnSiteLinkConnectionProperties parameters for VpnConnection.
type VpnSiteLinkConnectionProperties struct {
	// VpnSiteLink - Id of the connected vpn site link.
	VpnSiteLink *SubResource `json:"vpnSiteLink,omitempty"`
	// RoutingWeight - Routing weight for vpn connection.
	RoutingWeight *int32 `json:"routingWeight,omitempty"`
	// VpnLinkConnectionMode - Vpn link connection mode. Possible values include: 'VpnLinkConnectionModeDefault', 'VpnLinkConnectionModeResponderOnly', 'VpnLinkConnectionModeInitiatorOnly'
	VpnLinkConnectionMode VpnLinkConnectionMode `json:"vpnLinkConnectionMode,omitempty"`
	// ConnectionStatus - The connection status. Possible values include: 'VpnConnectionStatusUnknown', 'VpnConnectionStatusConnecting', 'VpnConnectionStatusConnected', 'VpnConnectionStatusNotConnected'
	ConnectionStatus VpnConnectionStatus `json:"connectionStatus,omitempty"`
	// VpnConnectionProtocolType - Connection protocol used for this connection. Possible values include: 'VirtualNetworkGatewayConnectionProtocolIKEv2', 'VirtualNetworkGatewayConnectionProtocolIKEv1'
	VpnConnectionProtocolType VirtualNetworkGatewayConnectionProtocol `json:"vpnConnectionProtocolType,omitempty"`
	// IngressBytesTransferred - READ-ONLY; Ingress bytes transferred.
	IngressBytesTransferred *int64 `json:"ingressBytesTransferred,omitempty"`
	// EgressBytesTransferred - READ-ONLY; Egress bytes transferred.
	EgressBytesTransferred *int64 `json:"egressBytesTransferred,omitempty"`
	// ConnectionBandwidth - Expected bandwidth in MBPS.
	ConnectionBandwidth *int32 `json:"connectionBandwidth,omitempty"`
	// SharedKey - SharedKey for the vpn connection.
	SharedKey *string `json:"sharedKey,omitempty"`
	// EnableBgp - EnableBgp flag.
	EnableBgp *bool `json:"enableBgp,omitempty"`
	// UsePolicyBasedTrafficSelectors - Enable policy-based traffic selectors.
	UsePolicyBasedTrafficSelectors *bool `json:"usePolicyBasedTrafficSelectors,omitempty"`
	// IpsecPolicies - The IPSec Policies to be considered by this connection.
	IpsecPolicies *[]IpsecPolicy `json:"ipsecPolicies,omitempty"`
	// EnableRateLimiting - EnableBgp flag.
	EnableRateLimiting *bool `json:"enableRateLimiting,omitempty"`
	// UseLocalAzureIPAddress - Use local azure ip to initiate connection.
	UseLocalAzureIPAddress *bool `json:"useLocalAzureIpAddress,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the VPN site link connection resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// IngressNatRules - List of ingress NatRules.
	IngressNatRules *[]SubResource `json:"ingressNatRules,omitempty"`
	// EgressNatRules - List of egress NatRules.
	EgressNatRules *[]SubResource `json:"egressNatRules,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnSiteLinkConnectionProperties.
func (vslcp VpnSiteLinkConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vslcp.VpnSiteLink != nil {
		objectMap["vpnSiteLink"] = vslcp.VpnSiteLink
	}
	if vslcp.RoutingWeight != nil {
		objectMap["routingWeight"] = vslcp.RoutingWeight
	}
	if vslcp.VpnLinkConnectionMode != "" {
		objectMap["vpnLinkConnectionMode"] = vslcp.VpnLinkConnectionMode
	}
	if vslcp.ConnectionStatus != "" {
		objectMap["connectionStatus"] = vslcp.ConnectionStatus
	}
	if vslcp.VpnConnectionProtocolType != "" {
		objectMap["vpnConnectionProtocolType"] = vslcp.VpnConnectionProtocolType
	}
	if vslcp.ConnectionBandwidth != nil {
		objectMap["connectionBandwidth"] = vslcp.ConnectionBandwidth
	}
	if vslcp.SharedKey != nil {
		objectMap["sharedKey"] = vslcp.SharedKey
	}
	if vslcp.EnableBgp != nil {
		objectMap["enableBgp"] = vslcp.EnableBgp
	}
	if vslcp.UsePolicyBasedTrafficSelectors != nil {
		objectMap["usePolicyBasedTrafficSelectors"] = vslcp.UsePolicyBasedTrafficSelectors
	}
	if vslcp.IpsecPolicies != nil {
		objectMap["ipsecPolicies"] = vslcp.IpsecPolicies
	}
	if vslcp.EnableRateLimiting != nil {
		objectMap["enableRateLimiting"] = vslcp.EnableRateLimiting
	}
	if vslcp.UseLocalAzureIPAddress != nil {
		objectMap["useLocalAzureIpAddress"] = vslcp.UseLocalAzureIPAddress
	}
	if vslcp.IngressNatRules != nil {
		objectMap["ingressNatRules"] = vslcp.IngressNatRules
	}
	if vslcp.EgressNatRules != nil {
		objectMap["egressNatRules"] = vslcp.EgressNatRules
	}
	return json.Marshal(objectMap)
}

// VpnSiteLinkProperties parameters for VpnSite.
type VpnSiteLinkProperties struct {
	// LinkProperties - The link provider properties.
	LinkProperties *VpnLinkProviderProperties `json:"linkProperties,omitempty"`
	// IPAddress - The ip-address for the vpn-site-link.
	IPAddress *string `json:"ipAddress,omitempty"`
	// Fqdn - FQDN of vpn-site-link.
	Fqdn *string `json:"fqdn,omitempty"`
	// BgpProperties - The set of bgp properties.
	BgpProperties *VpnLinkBgpSettings `json:"bgpProperties,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the VPN site link resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnSiteLinkProperties.
func (vslp VpnSiteLinkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vslp.LinkProperties != nil {
		objectMap["linkProperties"] = vslp.LinkProperties
	}
	if vslp.IPAddress != nil {
		objectMap["ipAddress"] = vslp.IPAddress
	}
	if vslp.Fqdn != nil {
		objectMap["fqdn"] = vslp.Fqdn
	}
	if vslp.BgpProperties != nil {
		objectMap["bgpProperties"] = vslp.BgpProperties
	}
	return json.Marshal(objectMap)
}

// VpnSiteProperties parameters for VpnSite.
type VpnSiteProperties struct {
	// VirtualWan - The VirtualWAN to which the vpnSite belongs.
	VirtualWan *SubResource `json:"virtualWan,omitempty"`
	// DeviceProperties - The device properties.
	DeviceProperties *DeviceProperties `json:"deviceProperties,omitempty"`
	// IPAddress - The ip-address for the vpn-site.
	IPAddress *string `json:"ipAddress,omitempty"`
	// SiteKey - The key for vpn-site that can be used for connections.
	SiteKey *string `json:"siteKey,omitempty"`
	// AddressSpace - The AddressSpace that contains an array of IP address ranges.
	AddressSpace *AddressSpace `json:"addressSpace,omitempty"`
	// BgpProperties - The set of bgp properties.
	BgpProperties *BgpSettings `json:"bgpProperties,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the VPN site resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// IsSecuritySite - IsSecuritySite flag.
	IsSecuritySite *bool `json:"isSecuritySite,omitempty"`
	// VpnSiteLinks - List of all vpn site links.
	VpnSiteLinks *[]VpnSiteLink `json:"vpnSiteLinks,omitempty"`
	// O365Policy - Office365 Policy.
	O365Policy *O365PolicyProperties `json:"o365Policy,omitempty"`
}

// MarshalJSON is the custom marshaler for VpnSiteProperties.
func (vsp VpnSiteProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vsp.VirtualWan != nil {
		objectMap["virtualWan"] = vsp.VirtualWan
	}
	if vsp.DeviceProperties != nil {
		objectMap["deviceProperties"] = vsp.DeviceProperties
	}
	if vsp.IPAddress != nil {
		objectMap["ipAddress"] = vsp.IPAddress
	}
	if vsp.SiteKey != nil {
		objectMap["siteKey"] = vsp.SiteKey
	}
	if vsp.AddressSpace != nil {
		objectMap["addressSpace"] = vsp.AddressSpace
	}
	if vsp.BgpProperties != nil {
		objectMap["bgpProperties"] = vsp.BgpProperties
	}
	if vsp.IsSecuritySite != nil {
		objectMap["isSecuritySite"] = vsp.IsSecuritySite
	}
	if vsp.VpnSiteLinks != nil {
		objectMap["vpnSiteLinks"] = vsp.VpnSiteLinks
	}
	if vsp.O365Policy != nil {
		objectMap["o365Policy"] = vsp.O365Policy
	}
	return json.Marshal(objectMap)
}

// VpnSitesConfigurationDownloadFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VpnSitesConfigurationDownloadFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnSitesConfigurationClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnSitesConfigurationDownloadFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnSitesConfigurationDownloadFuture.Result.
func (future *VpnSitesConfigurationDownloadFuture) result(client VpnSitesConfigurationClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnSitesConfigurationDownloadFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnSitesConfigurationDownloadFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VpnSitesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VpnSitesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnSitesClient) (VpnSite, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnSitesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnSitesCreateOrUpdateFuture.Result.
func (future *VpnSitesCreateOrUpdateFuture) result(client VpnSitesClient) (vs VpnSite, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnSitesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vs.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnSitesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vs.Response.Response, err = future.GetResult(sender); err == nil && vs.Response.Response.StatusCode != http.StatusNoContent {
		vs, err = client.CreateOrUpdateResponder(vs.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.VpnSitesCreateOrUpdateFuture", "Result", vs.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VpnSitesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VpnSitesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VpnSitesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VpnSitesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VpnSitesDeleteFuture.Result.
func (future *VpnSitesDeleteFuture) result(client VpnSitesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.VpnSitesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.VpnSitesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// Watcher network watcher in a resource group.
type Watcher struct {
	autorest.Response `json:"-"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// WatcherPropertiesFormat - Properties of the network watcher.
	*WatcherPropertiesFormat `json:"properties,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Watcher.
func (w Watcher) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if w.WatcherPropertiesFormat != nil {
		objectMap["properties"] = w.WatcherPropertiesFormat
	}
	if w.ID != nil {
		objectMap["id"] = w.ID
	}
	if w.Location != nil {
		objectMap["location"] = w.Location
	}
	if w.Tags != nil {
		objectMap["tags"] = w.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Watcher struct.
func (w *Watcher) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				w.Etag = &etag
			}
		case "properties":
			if v != nil {
				var watcherPropertiesFormat WatcherPropertiesFormat
				err = json.Unmarshal(*v, &watcherPropertiesFormat)
				if err != nil {
					return err
				}
				w.WatcherPropertiesFormat = &watcherPropertiesFormat
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				w.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				w.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				w.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				w.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				w.Tags = tags
			}
		}
	}

	return nil
}

// WatcherListResult response for ListNetworkWatchers API service call.
type WatcherListResult struct {
	autorest.Response `json:"-"`
	// Value - List of network watcher resources.
	Value *[]Watcher `json:"value,omitempty"`
}

// WatcherPropertiesFormat the network watcher properties.
type WatcherPropertiesFormat struct {
	// ProvisioningState - READ-ONLY; The provisioning state of the network watcher resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for WatcherPropertiesFormat.
func (wpf WatcherPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// WatchersCheckConnectivityFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WatchersCheckConnectivityFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (ConnectivityInformation, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersCheckConnectivityFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersCheckConnectivityFuture.Result.
func (future *WatchersCheckConnectivityFuture) result(client WatchersClient) (ci ConnectivityInformation, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersCheckConnectivityFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ci.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersCheckConnectivityFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ci.Response.Response, err = future.GetResult(sender); err == nil && ci.Response.Response.StatusCode != http.StatusNoContent {
		ci, err = client.CheckConnectivityResponder(ci.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersCheckConnectivityFuture", "Result", ci.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WatchersDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersDeleteFuture.Result.
func (future *WatchersDeleteFuture) result(client WatchersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// WatchersGetAzureReachabilityReportFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WatchersGetAzureReachabilityReportFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (AzureReachabilityReport, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersGetAzureReachabilityReportFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersGetAzureReachabilityReportFuture.Result.
func (future *WatchersGetAzureReachabilityReportFuture) result(client WatchersClient) (arr AzureReachabilityReport, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersGetAzureReachabilityReportFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		arr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersGetAzureReachabilityReportFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if arr.Response.Response, err = future.GetResult(sender); err == nil && arr.Response.Response.StatusCode != http.StatusNoContent {
		arr, err = client.GetAzureReachabilityReportResponder(arr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersGetAzureReachabilityReportFuture", "Result", arr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersGetFlowLogStatusFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WatchersGetFlowLogStatusFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (FlowLogInformation, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersGetFlowLogStatusFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersGetFlowLogStatusFuture.Result.
func (future *WatchersGetFlowLogStatusFuture) result(client WatchersClient) (fli FlowLogInformation, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersGetFlowLogStatusFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		fli.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersGetFlowLogStatusFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fli.Response.Response, err = future.GetResult(sender); err == nil && fli.Response.Response.StatusCode != http.StatusNoContent {
		fli, err = client.GetFlowLogStatusResponder(fli.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersGetFlowLogStatusFuture", "Result", fli.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersGetNetworkConfigurationDiagnosticFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type WatchersGetNetworkConfigurationDiagnosticFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (ConfigurationDiagnosticResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersGetNetworkConfigurationDiagnosticFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersGetNetworkConfigurationDiagnosticFuture.Result.
func (future *WatchersGetNetworkConfigurationDiagnosticFuture) result(client WatchersClient) (cdr ConfigurationDiagnosticResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersGetNetworkConfigurationDiagnosticFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cdr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersGetNetworkConfigurationDiagnosticFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cdr.Response.Response, err = future.GetResult(sender); err == nil && cdr.Response.Response.StatusCode != http.StatusNoContent {
		cdr, err = client.GetNetworkConfigurationDiagnosticResponder(cdr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersGetNetworkConfigurationDiagnosticFuture", "Result", cdr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersGetNextHopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WatchersGetNextHopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (NextHopResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersGetNextHopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersGetNextHopFuture.Result.
func (future *WatchersGetNextHopFuture) result(client WatchersClient) (nhr NextHopResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersGetNextHopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		nhr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersGetNextHopFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if nhr.Response.Response, err = future.GetResult(sender); err == nil && nhr.Response.Response.StatusCode != http.StatusNoContent {
		nhr, err = client.GetNextHopResponder(nhr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersGetNextHopFuture", "Result", nhr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersGetTroubleshootingFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WatchersGetTroubleshootingFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (TroubleshootingResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersGetTroubleshootingFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersGetTroubleshootingFuture.Result.
func (future *WatchersGetTroubleshootingFuture) result(client WatchersClient) (tr TroubleshootingResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersGetTroubleshootingFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		tr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersGetTroubleshootingFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if tr.Response.Response, err = future.GetResult(sender); err == nil && tr.Response.Response.StatusCode != http.StatusNoContent {
		tr, err = client.GetTroubleshootingResponder(tr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersGetTroubleshootingFuture", "Result", tr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersGetTroubleshootingResultFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WatchersGetTroubleshootingResultFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (TroubleshootingResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersGetTroubleshootingResultFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersGetTroubleshootingResultFuture.Result.
func (future *WatchersGetTroubleshootingResultFuture) result(client WatchersClient) (tr TroubleshootingResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersGetTroubleshootingResultFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		tr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersGetTroubleshootingResultFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if tr.Response.Response, err = future.GetResult(sender); err == nil && tr.Response.Response.StatusCode != http.StatusNoContent {
		tr, err = client.GetTroubleshootingResultResponder(tr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersGetTroubleshootingResultFuture", "Result", tr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersGetVMSecurityRulesFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WatchersGetVMSecurityRulesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (SecurityGroupViewResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersGetVMSecurityRulesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersGetVMSecurityRulesFuture.Result.
func (future *WatchersGetVMSecurityRulesFuture) result(client WatchersClient) (sgvr SecurityGroupViewResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersGetVMSecurityRulesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sgvr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersGetVMSecurityRulesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sgvr.Response.Response, err = future.GetResult(sender); err == nil && sgvr.Response.Response.StatusCode != http.StatusNoContent {
		sgvr, err = client.GetVMSecurityRulesResponder(sgvr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersGetVMSecurityRulesFuture", "Result", sgvr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersListAvailableProvidersFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WatchersListAvailableProvidersFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (AvailableProvidersList, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersListAvailableProvidersFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersListAvailableProvidersFuture.Result.
func (future *WatchersListAvailableProvidersFuture) result(client WatchersClient) (apl AvailableProvidersList, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersListAvailableProvidersFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		apl.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersListAvailableProvidersFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if apl.Response.Response, err = future.GetResult(sender); err == nil && apl.Response.Response.StatusCode != http.StatusNoContent {
		apl, err = client.ListAvailableProvidersResponder(apl.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersListAvailableProvidersFuture", "Result", apl.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersSetFlowLogConfigurationFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WatchersSetFlowLogConfigurationFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (FlowLogInformation, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersSetFlowLogConfigurationFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersSetFlowLogConfigurationFuture.Result.
func (future *WatchersSetFlowLogConfigurationFuture) result(client WatchersClient) (fli FlowLogInformation, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersSetFlowLogConfigurationFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		fli.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersSetFlowLogConfigurationFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fli.Response.Response, err = future.GetResult(sender); err == nil && fli.Response.Response.StatusCode != http.StatusNoContent {
		fli, err = client.SetFlowLogConfigurationResponder(fli.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersSetFlowLogConfigurationFuture", "Result", fli.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WatchersVerifyIPFlowFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WatchersVerifyIPFlowFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WatchersClient) (VerificationIPFlowResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WatchersVerifyIPFlowFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WatchersVerifyIPFlowFuture.Result.
func (future *WatchersVerifyIPFlowFuture) result(client WatchersClient) (vifr VerificationIPFlowResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WatchersVerifyIPFlowFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vifr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WatchersVerifyIPFlowFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vifr.Response.Response, err = future.GetResult(sender); err == nil && vifr.Response.Response.StatusCode != http.StatusNoContent {
		vifr, err = client.VerifyIPFlowResponder(vifr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "network.WatchersVerifyIPFlowFuture", "Result", vifr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WebApplicationFirewallCustomRule defines contents of a web application rule.
type WebApplicationFirewallCustomRule struct {
	// Name - The name of the resource that is unique within a policy. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// Priority - Priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
	Priority *int32 `json:"priority,omitempty"`
	// RuleType - The rule type. Possible values include: 'WebApplicationFirewallRuleTypeMatchRule', 'WebApplicationFirewallRuleTypeInvalid'
	RuleType WebApplicationFirewallRuleType `json:"ruleType,omitempty"`
	// MatchConditions - List of match conditions.
	MatchConditions *[]MatchCondition `json:"matchConditions,omitempty"`
	// Action - Type of Actions. Possible values include: 'WebApplicationFirewallActionAllow', 'WebApplicationFirewallActionBlock', 'WebApplicationFirewallActionLog'
	Action WebApplicationFirewallAction `json:"action,omitempty"`
}

// MarshalJSON is the custom marshaler for WebApplicationFirewallCustomRule.
func (wafcr WebApplicationFirewallCustomRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wafcr.Name != nil {
		objectMap["name"] = wafcr.Name
	}
	if wafcr.Priority != nil {
		objectMap["priority"] = wafcr.Priority
	}
	if wafcr.RuleType != "" {
		objectMap["ruleType"] = wafcr.RuleType
	}
	if wafcr.MatchConditions != nil {
		objectMap["matchConditions"] = wafcr.MatchConditions
	}
	if wafcr.Action != "" {
		objectMap["action"] = wafcr.Action
	}
	return json.Marshal(objectMap)
}

// WebApplicationFirewallPoliciesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WebApplicationFirewallPoliciesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WebApplicationFirewallPoliciesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WebApplicationFirewallPoliciesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WebApplicationFirewallPoliciesDeleteFuture.Result.
func (future *WebApplicationFirewallPoliciesDeleteFuture) result(client WebApplicationFirewallPoliciesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "network.WebApplicationFirewallPoliciesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("network.WebApplicationFirewallPoliciesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// WebApplicationFirewallPolicy defines web application firewall policy.
type WebApplicationFirewallPolicy struct {
	autorest.Response `json:"-"`
	// WebApplicationFirewallPolicyPropertiesFormat - Properties of the web application firewall policy.
	*WebApplicationFirewallPolicyPropertiesFormat `json:"properties,omitempty"`
	// Etag - READ-ONLY; A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`
	// ID - Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Location - Resource location.
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for WebApplicationFirewallPolicy.
func (wafp WebApplicationFirewallPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wafp.WebApplicationFirewallPolicyPropertiesFormat != nil {
		objectMap["properties"] = wafp.WebApplicationFirewallPolicyPropertiesFormat
	}
	if wafp.ID != nil {
		objectMap["id"] = wafp.ID
	}
	if wafp.Location != nil {
		objectMap["location"] = wafp.Location
	}
	if wafp.Tags != nil {
		objectMap["tags"] = wafp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WebApplicationFirewallPolicy struct.
func (wafp *WebApplicationFirewallPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var webApplicationFirewallPolicyPropertiesFormat WebApplicationFirewallPolicyPropertiesFormat
				err = json.Unmarshal(*v, &webApplicationFirewallPolicyPropertiesFormat)
				if err != nil {
					return err
				}
				wafp.WebApplicationFirewallPolicyPropertiesFormat = &webApplicationFirewallPolicyPropertiesFormat
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				wafp.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wafp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wafp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wafp.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				wafp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				wafp.Tags = tags
			}
		}
	}

	return nil
}

// WebApplicationFirewallPolicyListResult result of the request to list WebApplicationFirewallPolicies. It
// contains a list of WebApplicationFirewallPolicy objects and a URL link to get the next set of results.
type WebApplicationFirewallPolicyListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; List of WebApplicationFirewallPolicies within a resource group.
	Value *[]WebApplicationFirewallPolicy `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of WebApplicationFirewallPolicy objects if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for WebApplicationFirewallPolicyListResult.
func (wafplr WebApplicationFirewallPolicyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// WebApplicationFirewallPolicyListResultIterator provides access to a complete listing of
// WebApplicationFirewallPolicy values.
type WebApplicationFirewallPolicyListResultIterator struct {
	i    int
	page WebApplicationFirewallPolicyListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WebApplicationFirewallPolicyListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WebApplicationFirewallPolicyListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WebApplicationFirewallPolicyListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WebApplicationFirewallPolicyListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WebApplicationFirewallPolicyListResultIterator) Response() WebApplicationFirewallPolicyListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WebApplicationFirewallPolicyListResultIterator) Value() WebApplicationFirewallPolicy {
	if !iter.page.NotDone() {
		return WebApplicationFirewallPolicy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WebApplicationFirewallPolicyListResultIterator type.
func NewWebApplicationFirewallPolicyListResultIterator(page WebApplicationFirewallPolicyListResultPage) WebApplicationFirewallPolicyListResultIterator {
	return WebApplicationFirewallPolicyListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wafplr WebApplicationFirewallPolicyListResult) IsEmpty() bool {
	return wafplr.Value == nil || len(*wafplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wafplr WebApplicationFirewallPolicyListResult) hasNextLink() bool {
	return wafplr.NextLink != nil && len(*wafplr.NextLink) != 0
}

// webApplicationFirewallPolicyListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wafplr WebApplicationFirewallPolicyListResult) webApplicationFirewallPolicyListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wafplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wafplr.NextLink)))
}

// WebApplicationFirewallPolicyListResultPage contains a page of WebApplicationFirewallPolicy values.
type WebApplicationFirewallPolicyListResultPage struct {
	fn     func(context.Context, WebApplicationFirewallPolicyListResult) (WebApplicationFirewallPolicyListResult, error)
	wafplr WebApplicationFirewallPolicyListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WebApplicationFirewallPolicyListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WebApplicationFirewallPolicyListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wafplr)
		if err != nil {
			return err
		}
		page.wafplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WebApplicationFirewallPolicyListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WebApplicationFirewallPolicyListResultPage) NotDone() bool {
	return !page.wafplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WebApplicationFirewallPolicyListResultPage) Response() WebApplicationFirewallPolicyListResult {
	return page.wafplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WebApplicationFirewallPolicyListResultPage) Values() []WebApplicationFirewallPolicy {
	if page.wafplr.IsEmpty() {
		return nil
	}
	return *page.wafplr.Value
}

// Creates a new instance of the WebApplicationFirewallPolicyListResultPage type.
func NewWebApplicationFirewallPolicyListResultPage(cur WebApplicationFirewallPolicyListResult, getNextPage func(context.Context, WebApplicationFirewallPolicyListResult) (WebApplicationFirewallPolicyListResult, error)) WebApplicationFirewallPolicyListResultPage {
	return WebApplicationFirewallPolicyListResultPage{
		fn:     getNextPage,
		wafplr: cur,
	}
}

// WebApplicationFirewallPolicyPropertiesFormat defines web application firewall policy properties.
type WebApplicationFirewallPolicyPropertiesFormat struct {
	// PolicySettings - The PolicySettings for policy.
	PolicySettings *PolicySettings `json:"policySettings,omitempty"`
	// CustomRules - The custom rules inside the policy.
	CustomRules *[]WebApplicationFirewallCustomRule `json:"customRules,omitempty"`
	// ApplicationGateways - READ-ONLY; A collection of references to application gateways.
	ApplicationGateways *[]ApplicationGateway `json:"applicationGateways,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the web application firewall policy resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ResourceState - READ-ONLY; Resource status of the policy. Possible values include: 'WebApplicationFirewallPolicyResourceStateCreating', 'WebApplicationFirewallPolicyResourceStateEnabling', 'WebApplicationFirewallPolicyResourceStateEnabled', 'WebApplicationFirewallPolicyResourceStateDisabling', 'WebApplicationFirewallPolicyResourceStateDisabled', 'WebApplicationFirewallPolicyResourceStateDeleting'
	ResourceState WebApplicationFirewallPolicyResourceState `json:"resourceState,omitempty"`
	// ManagedRules - Describes the managedRules structure.
	ManagedRules *ManagedRulesDefinition `json:"managedRules,omitempty"`
	// HTTPListeners - READ-ONLY; A collection of references to application gateway http listeners.
	HTTPListeners *[]SubResource `json:"httpListeners,omitempty"`
	// PathBasedRules - READ-ONLY; A collection of references to application gateway path rules.
	PathBasedRules *[]SubResource `json:"pathBasedRules,omitempty"`
}

// MarshalJSON is the custom marshaler for WebApplicationFirewallPolicyPropertiesFormat.
func (wafppf WebApplicationFirewallPolicyPropertiesFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wafppf.PolicySettings != nil {
		objectMap["policySettings"] = wafppf.PolicySettings
	}
	if wafppf.CustomRules != nil {
		objectMap["customRules"] = wafppf.CustomRules
	}
	if wafppf.ManagedRules != nil {
		objectMap["managedRules"] = wafppf.ManagedRules
	}
	return json.Marshal(objectMap)
}
