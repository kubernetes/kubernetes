package redis

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/redis/mgmt/2020-06-01/redis"

// AccessKeys redis cache access keys.
type AccessKeys struct {
	autorest.Response `json:"-"`
	// PrimaryKey - READ-ONLY; The current primary key that clients can use to authenticate with Redis cache.
	PrimaryKey *string `json:"primaryKey,omitempty"`
	// SecondaryKey - READ-ONLY; The current secondary key that clients can use to authenticate with Redis cache.
	SecondaryKey *string `json:"secondaryKey,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessKeys.
func (ak AccessKeys) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// CheckNameAvailabilityParameters parameters body to pass for resource name availability check.
type CheckNameAvailabilityParameters struct {
	// Name - Resource name.
	Name *string `json:"name,omitempty"`
	// Type - Resource type. The only legal value of this property for checking redis cache name availability is 'Microsoft.Cache/redis'.
	Type *string `json:"type,omitempty"`
}

// CommonProperties create/Update/Get common properties of the redis cache.
type CommonProperties struct {
	// RedisConfiguration - All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
	RedisConfiguration map[string]*string `json:"redisConfiguration"`
	// EnableNonSslPort - Specifies whether the non-ssl Redis server port (6379) is enabled.
	EnableNonSslPort *bool `json:"enableNonSslPort,omitempty"`
	// ReplicasPerMaster - The number of replicas to be created per master.
	ReplicasPerMaster *int32 `json:"replicasPerMaster,omitempty"`
	// TenantSettings - A dictionary of tenant settings
	TenantSettings map[string]*string `json:"tenantSettings"`
	// ShardCount - The number of shards to be created on a Premium Cluster Cache.
	ShardCount *int32 `json:"shardCount,omitempty"`
	// MinimumTLSVersion - Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2'). Possible values include: 'OneFullStopZero', 'OneFullStopOne', 'OneFullStopTwo'
	MinimumTLSVersion TLSVersion `json:"minimumTlsVersion,omitempty"`
	// PublicNetworkAccess - Whether or not public endpoint access is allowed for this cache.  Value is optional but if passed in, must be 'Enabled' or 'Disabled'. If 'Disabled', private endpoints are the exclusive access method. Default value is 'Enabled'. Possible values include: 'Enabled', 'Disabled'
	PublicNetworkAccess PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for CommonProperties.
func (cp CommonProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.RedisConfiguration != nil {
		objectMap["redisConfiguration"] = cp.RedisConfiguration
	}
	if cp.EnableNonSslPort != nil {
		objectMap["enableNonSslPort"] = cp.EnableNonSslPort
	}
	if cp.ReplicasPerMaster != nil {
		objectMap["replicasPerMaster"] = cp.ReplicasPerMaster
	}
	if cp.TenantSettings != nil {
		objectMap["tenantSettings"] = cp.TenantSettings
	}
	if cp.ShardCount != nil {
		objectMap["shardCount"] = cp.ShardCount
	}
	if cp.MinimumTLSVersion != "" {
		objectMap["minimumTlsVersion"] = cp.MinimumTLSVersion
	}
	if cp.PublicNetworkAccess != "" {
		objectMap["publicNetworkAccess"] = cp.PublicNetworkAccess
	}
	return json.Marshal(objectMap)
}

// CreateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type CreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (ResourceType, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *CreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for CreateFuture.Result.
func (future *CreateFuture) result(client Client) (rt ResourceType, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "redis.CreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("redis.CreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rt.Response.Response, err = future.GetResult(sender); err == nil && rt.Response.Response.StatusCode != http.StatusNoContent {
		rt, err = client.CreateResponder(rt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "redis.CreateFuture", "Result", rt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// CreateParameters parameters supplied to the Create Redis operation.
type CreateParameters struct {
	// CreateProperties - Redis cache properties.
	*CreateProperties `json:"properties,omitempty"`
	// Zones - A list of availability zones denoting where the resource needs to come from.
	Zones *[]string `json:"zones,omitempty"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for CreateParameters.
func (cp CreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.CreateProperties != nil {
		objectMap["properties"] = cp.CreateProperties
	}
	if cp.Zones != nil {
		objectMap["zones"] = cp.Zones
	}
	if cp.Location != nil {
		objectMap["location"] = cp.Location
	}
	if cp.Tags != nil {
		objectMap["tags"] = cp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CreateParameters struct.
func (cp *CreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var createProperties CreateProperties
				err = json.Unmarshal(*v, &createProperties)
				if err != nil {
					return err
				}
				cp.CreateProperties = &createProperties
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				cp.Zones = &zones
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				cp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cp.Tags = tags
			}
		}
	}

	return nil
}

// CreateProperties properties supplied to Create Redis operation.
type CreateProperties struct {
	// Sku - The SKU of the Redis cache to deploy.
	Sku *Sku `json:"sku,omitempty"`
	// SubnetID - The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1
	SubnetID *string `json:"subnetId,omitempty"`
	// StaticIP - Static IP address. Required when deploying a Redis cache inside an existing Azure Virtual Network.
	StaticIP *string `json:"staticIP,omitempty"`
	// RedisConfiguration - All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
	RedisConfiguration map[string]*string `json:"redisConfiguration"`
	// EnableNonSslPort - Specifies whether the non-ssl Redis server port (6379) is enabled.
	EnableNonSslPort *bool `json:"enableNonSslPort,omitempty"`
	// ReplicasPerMaster - The number of replicas to be created per master.
	ReplicasPerMaster *int32 `json:"replicasPerMaster,omitempty"`
	// TenantSettings - A dictionary of tenant settings
	TenantSettings map[string]*string `json:"tenantSettings"`
	// ShardCount - The number of shards to be created on a Premium Cluster Cache.
	ShardCount *int32 `json:"shardCount,omitempty"`
	// MinimumTLSVersion - Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2'). Possible values include: 'OneFullStopZero', 'OneFullStopOne', 'OneFullStopTwo'
	MinimumTLSVersion TLSVersion `json:"minimumTlsVersion,omitempty"`
	// PublicNetworkAccess - Whether or not public endpoint access is allowed for this cache.  Value is optional but if passed in, must be 'Enabled' or 'Disabled'. If 'Disabled', private endpoints are the exclusive access method. Default value is 'Enabled'. Possible values include: 'Enabled', 'Disabled'
	PublicNetworkAccess PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for CreateProperties.
func (cp CreateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.Sku != nil {
		objectMap["sku"] = cp.Sku
	}
	if cp.SubnetID != nil {
		objectMap["subnetId"] = cp.SubnetID
	}
	if cp.StaticIP != nil {
		objectMap["staticIP"] = cp.StaticIP
	}
	if cp.RedisConfiguration != nil {
		objectMap["redisConfiguration"] = cp.RedisConfiguration
	}
	if cp.EnableNonSslPort != nil {
		objectMap["enableNonSslPort"] = cp.EnableNonSslPort
	}
	if cp.ReplicasPerMaster != nil {
		objectMap["replicasPerMaster"] = cp.ReplicasPerMaster
	}
	if cp.TenantSettings != nil {
		objectMap["tenantSettings"] = cp.TenantSettings
	}
	if cp.ShardCount != nil {
		objectMap["shardCount"] = cp.ShardCount
	}
	if cp.MinimumTLSVersion != "" {
		objectMap["minimumTlsVersion"] = cp.MinimumTLSVersion
	}
	if cp.PublicNetworkAccess != "" {
		objectMap["publicNetworkAccess"] = cp.PublicNetworkAccess
	}
	return json.Marshal(objectMap)
}

// DeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type DeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DeleteFuture.Result.
func (future *DeleteFuture) result(client Client) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "redis.DeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("redis.DeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorAdditionalInfo.
func (eai ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetail.
func (ed ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// ExportDataFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ExportDataFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExportDataFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExportDataFuture.Result.
func (future *ExportDataFuture) result(client Client) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "redis.ExportDataFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("redis.ExportDataFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ExportRDBParameters parameters for Redis export operation.
type ExportRDBParameters struct {
	// Format - File format.
	Format *string `json:"format,omitempty"`
	// Prefix - Prefix to use for exported files.
	Prefix *string `json:"prefix,omitempty"`
	// Container - Container name to export to.
	Container *string `json:"container,omitempty"`
}

// FirewallRule a firewall rule on a redis cache has a name, and describes a contiguous range of IP
// addresses permitted to connect
type FirewallRule struct {
	autorest.Response `json:"-"`
	// FirewallRuleProperties - redis cache firewall rule properties
	*FirewallRuleProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallRule.
func (fr FirewallRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fr.FirewallRuleProperties != nil {
		objectMap["properties"] = fr.FirewallRuleProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FirewallRule struct.
func (fr *FirewallRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var firewallRuleProperties FirewallRuleProperties
				err = json.Unmarshal(*v, &firewallRuleProperties)
				if err != nil {
					return err
				}
				fr.FirewallRuleProperties = &firewallRuleProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fr.Type = &typeVar
			}
		}
	}

	return nil
}

// FirewallRuleCreateParameters parameters required for creating a firewall rule on redis cache.
type FirewallRuleCreateParameters struct {
	// FirewallRuleProperties - Properties required to create a firewall rule .
	*FirewallRuleProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallRuleCreateParameters.
func (frcp FirewallRuleCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if frcp.FirewallRuleProperties != nil {
		objectMap["properties"] = frcp.FirewallRuleProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FirewallRuleCreateParameters struct.
func (frcp *FirewallRuleCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var firewallRuleProperties FirewallRuleProperties
				err = json.Unmarshal(*v, &firewallRuleProperties)
				if err != nil {
					return err
				}
				frcp.FirewallRuleProperties = &firewallRuleProperties
			}
		}
	}

	return nil
}

// FirewallRuleListResult the response of list firewall rules Redis operation.
type FirewallRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - Results of the list firewall rules operation.
	Value *[]FirewallRule `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link for next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallRuleListResult.
func (frlr FirewallRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if frlr.Value != nil {
		objectMap["value"] = frlr.Value
	}
	return json.Marshal(objectMap)
}

// FirewallRuleListResultIterator provides access to a complete listing of FirewallRule values.
type FirewallRuleListResultIterator struct {
	i    int
	page FirewallRuleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FirewallRuleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FirewallRuleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FirewallRuleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FirewallRuleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FirewallRuleListResultIterator) Response() FirewallRuleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FirewallRuleListResultIterator) Value() FirewallRule {
	if !iter.page.NotDone() {
		return FirewallRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FirewallRuleListResultIterator type.
func NewFirewallRuleListResultIterator(page FirewallRuleListResultPage) FirewallRuleListResultIterator {
	return FirewallRuleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (frlr FirewallRuleListResult) IsEmpty() bool {
	return frlr.Value == nil || len(*frlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (frlr FirewallRuleListResult) hasNextLink() bool {
	return frlr.NextLink != nil && len(*frlr.NextLink) != 0
}

// firewallRuleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (frlr FirewallRuleListResult) firewallRuleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !frlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(frlr.NextLink)))
}

// FirewallRuleListResultPage contains a page of FirewallRule values.
type FirewallRuleListResultPage struct {
	fn   func(context.Context, FirewallRuleListResult) (FirewallRuleListResult, error)
	frlr FirewallRuleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FirewallRuleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FirewallRuleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.frlr)
		if err != nil {
			return err
		}
		page.frlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FirewallRuleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FirewallRuleListResultPage) NotDone() bool {
	return !page.frlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FirewallRuleListResultPage) Response() FirewallRuleListResult {
	return page.frlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FirewallRuleListResultPage) Values() []FirewallRule {
	if page.frlr.IsEmpty() {
		return nil
	}
	return *page.frlr.Value
}

// Creates a new instance of the FirewallRuleListResultPage type.
func NewFirewallRuleListResultPage(cur FirewallRuleListResult, getNextPage func(context.Context, FirewallRuleListResult) (FirewallRuleListResult, error)) FirewallRuleListResultPage {
	return FirewallRuleListResultPage{
		fn:   getNextPage,
		frlr: cur,
	}
}

// FirewallRuleProperties specifies a range of IP addresses permitted to connect to the cache
type FirewallRuleProperties struct {
	// StartIP - lowest IP address included in the range
	StartIP *string `json:"startIP,omitempty"`
	// EndIP - highest IP address included in the range
	EndIP *string `json:"endIP,omitempty"`
}

// ForceRebootResponse response to force reboot for Redis cache.
type ForceRebootResponse struct {
	autorest.Response `json:"-"`
	// Message - READ-ONLY; Status message
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for ForceRebootResponse.
func (frr ForceRebootResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ImportDataFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ImportDataFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ImportDataFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ImportDataFuture.Result.
func (future *ImportDataFuture) result(client Client) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "redis.ImportDataFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("redis.ImportDataFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ImportRDBParameters parameters for Redis import operation.
type ImportRDBParameters struct {
	// Format - File format.
	Format *string `json:"format,omitempty"`
	// Files - files to import.
	Files *[]string `json:"files,omitempty"`
}

// InstanceDetails details of single instance of redis.
type InstanceDetails struct {
	// SslPort - READ-ONLY; Redis instance SSL port.
	SslPort *int32 `json:"sslPort,omitempty"`
	// NonSslPort - READ-ONLY; If enableNonSslPort is true, provides Redis instance Non-SSL port.
	NonSslPort *int32 `json:"nonSslPort,omitempty"`
	// Zone - READ-ONLY; If the Cache uses availability zones, specifies availability zone where this instance is located.
	Zone *string `json:"zone,omitempty"`
	// ShardID - READ-ONLY; If clustering is enabled, the Shard ID of Redis Instance
	ShardID *int32 `json:"shardId,omitempty"`
	// IsMaster - READ-ONLY; Specifies whether the instance is a master node.
	IsMaster *bool `json:"isMaster,omitempty"`
}

// MarshalJSON is the custom marshaler for InstanceDetails.
func (ID InstanceDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// LinkedServer linked server Id
type LinkedServer struct {
	// ID - READ-ONLY; Linked server Id.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for LinkedServer.
func (ls LinkedServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// LinkedServerCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LinkedServerCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(LinkedServerClient) (LinkedServerWithProperties, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *LinkedServerCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for LinkedServerCreateFuture.Result.
func (future *LinkedServerCreateFuture) result(client LinkedServerClient) (lswp LinkedServerWithProperties, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "redis.LinkedServerCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lswp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("redis.LinkedServerCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lswp.Response.Response, err = future.GetResult(sender); err == nil && lswp.Response.Response.StatusCode != http.StatusNoContent {
		lswp, err = client.CreateResponder(lswp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "redis.LinkedServerCreateFuture", "Result", lswp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// LinkedServerCreateParameters parameter required for creating a linked server to redis cache.
type LinkedServerCreateParameters struct {
	// LinkedServerCreateProperties - Properties required to create a linked server.
	*LinkedServerCreateProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for LinkedServerCreateParameters.
func (lscp LinkedServerCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lscp.LinkedServerCreateProperties != nil {
		objectMap["properties"] = lscp.LinkedServerCreateProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LinkedServerCreateParameters struct.
func (lscp *LinkedServerCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var linkedServerCreateProperties LinkedServerCreateProperties
				err = json.Unmarshal(*v, &linkedServerCreateProperties)
				if err != nil {
					return err
				}
				lscp.LinkedServerCreateProperties = &linkedServerCreateProperties
			}
		}
	}

	return nil
}

// LinkedServerCreateProperties create properties for a linked server
type LinkedServerCreateProperties struct {
	// LinkedRedisCacheID - Fully qualified resourceId of the linked redis cache.
	LinkedRedisCacheID *string `json:"linkedRedisCacheId,omitempty"`
	// LinkedRedisCacheLocation - Location of the linked redis cache.
	LinkedRedisCacheLocation *string `json:"linkedRedisCacheLocation,omitempty"`
	// ServerRole - Role of the linked server. Possible values include: 'ReplicationRolePrimary', 'ReplicationRoleSecondary'
	ServerRole ReplicationRole `json:"serverRole,omitempty"`
}

// LinkedServerProperties properties of a linked server to be returned in get/put response
type LinkedServerProperties struct {
	// ProvisioningState - READ-ONLY; Terminal state of the link between primary and secondary redis cache.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// LinkedRedisCacheID - Fully qualified resourceId of the linked redis cache.
	LinkedRedisCacheID *string `json:"linkedRedisCacheId,omitempty"`
	// LinkedRedisCacheLocation - Location of the linked redis cache.
	LinkedRedisCacheLocation *string `json:"linkedRedisCacheLocation,omitempty"`
	// ServerRole - Role of the linked server. Possible values include: 'ReplicationRolePrimary', 'ReplicationRoleSecondary'
	ServerRole ReplicationRole `json:"serverRole,omitempty"`
}

// MarshalJSON is the custom marshaler for LinkedServerProperties.
func (lsp LinkedServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lsp.LinkedRedisCacheID != nil {
		objectMap["linkedRedisCacheId"] = lsp.LinkedRedisCacheID
	}
	if lsp.LinkedRedisCacheLocation != nil {
		objectMap["linkedRedisCacheLocation"] = lsp.LinkedRedisCacheLocation
	}
	if lsp.ServerRole != "" {
		objectMap["serverRole"] = lsp.ServerRole
	}
	return json.Marshal(objectMap)
}

// LinkedServerWithProperties response to put/get linked server (with properties) for Redis cache.
type LinkedServerWithProperties struct {
	autorest.Response `json:"-"`
	// LinkedServerProperties - Properties of the linked server.
	*LinkedServerProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for LinkedServerWithProperties.
func (lswp LinkedServerWithProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lswp.LinkedServerProperties != nil {
		objectMap["properties"] = lswp.LinkedServerProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LinkedServerWithProperties struct.
func (lswp *LinkedServerWithProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var linkedServerProperties LinkedServerProperties
				err = json.Unmarshal(*v, &linkedServerProperties)
				if err != nil {
					return err
				}
				lswp.LinkedServerProperties = &linkedServerProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				lswp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lswp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lswp.Type = &typeVar
			}
		}
	}

	return nil
}

// LinkedServerWithPropertiesList list of linked servers (with properties) of a Redis cache.
type LinkedServerWithPropertiesList struct {
	autorest.Response `json:"-"`
	// Value - List of linked servers (with properties) of a Redis cache.
	Value *[]LinkedServerWithProperties `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link for next set.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for LinkedServerWithPropertiesList.
func (lswpl LinkedServerWithPropertiesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lswpl.Value != nil {
		objectMap["value"] = lswpl.Value
	}
	return json.Marshal(objectMap)
}

// LinkedServerWithPropertiesListIterator provides access to a complete listing of
// LinkedServerWithProperties values.
type LinkedServerWithPropertiesListIterator struct {
	i    int
	page LinkedServerWithPropertiesListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LinkedServerWithPropertiesListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LinkedServerWithPropertiesListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LinkedServerWithPropertiesListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LinkedServerWithPropertiesListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LinkedServerWithPropertiesListIterator) Response() LinkedServerWithPropertiesList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LinkedServerWithPropertiesListIterator) Value() LinkedServerWithProperties {
	if !iter.page.NotDone() {
		return LinkedServerWithProperties{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LinkedServerWithPropertiesListIterator type.
func NewLinkedServerWithPropertiesListIterator(page LinkedServerWithPropertiesListPage) LinkedServerWithPropertiesListIterator {
	return LinkedServerWithPropertiesListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lswpl LinkedServerWithPropertiesList) IsEmpty() bool {
	return lswpl.Value == nil || len(*lswpl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lswpl LinkedServerWithPropertiesList) hasNextLink() bool {
	return lswpl.NextLink != nil && len(*lswpl.NextLink) != 0
}

// linkedServerWithPropertiesListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lswpl LinkedServerWithPropertiesList) linkedServerWithPropertiesListPreparer(ctx context.Context) (*http.Request, error) {
	if !lswpl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lswpl.NextLink)))
}

// LinkedServerWithPropertiesListPage contains a page of LinkedServerWithProperties values.
type LinkedServerWithPropertiesListPage struct {
	fn    func(context.Context, LinkedServerWithPropertiesList) (LinkedServerWithPropertiesList, error)
	lswpl LinkedServerWithPropertiesList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LinkedServerWithPropertiesListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LinkedServerWithPropertiesListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lswpl)
		if err != nil {
			return err
		}
		page.lswpl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LinkedServerWithPropertiesListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LinkedServerWithPropertiesListPage) NotDone() bool {
	return !page.lswpl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LinkedServerWithPropertiesListPage) Response() LinkedServerWithPropertiesList {
	return page.lswpl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LinkedServerWithPropertiesListPage) Values() []LinkedServerWithProperties {
	if page.lswpl.IsEmpty() {
		return nil
	}
	return *page.lswpl.Value
}

// Creates a new instance of the LinkedServerWithPropertiesListPage type.
func NewLinkedServerWithPropertiesListPage(cur LinkedServerWithPropertiesList, getNextPage func(context.Context, LinkedServerWithPropertiesList) (LinkedServerWithPropertiesList, error)) LinkedServerWithPropertiesListPage {
	return LinkedServerWithPropertiesListPage{
		fn:    getNextPage,
		lswpl: cur,
	}
}

// ListResult the response of list Redis operation.
type ListResult struct {
	autorest.Response `json:"-"`
	// Value - List of Redis cache instances.
	Value *[]ResourceType `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link for next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ListResult.
func (lr ListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lr.Value != nil {
		objectMap["value"] = lr.Value
	}
	return json.Marshal(objectMap)
}

// ListResultIterator provides access to a complete listing of ResourceType values.
type ListResultIterator struct {
	i    int
	page ListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListResultIterator) Response() ListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListResultIterator) Value() ResourceType {
	if !iter.page.NotDone() {
		return ResourceType{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListResultIterator type.
func NewListResultIterator(page ListResultPage) ListResultIterator {
	return ListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lr ListResult) IsEmpty() bool {
	return lr.Value == nil || len(*lr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lr ListResult) hasNextLink() bool {
	return lr.NextLink != nil && len(*lr.NextLink) != 0
}

// listResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lr ListResult) listResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lr.NextLink)))
}

// ListResultPage contains a page of ResourceType values.
type ListResultPage struct {
	fn func(context.Context, ListResult) (ListResult, error)
	lr ListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lr)
		if err != nil {
			return err
		}
		page.lr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListResultPage) NotDone() bool {
	return !page.lr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListResultPage) Response() ListResult {
	return page.lr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListResultPage) Values() []ResourceType {
	if page.lr.IsEmpty() {
		return nil
	}
	return *page.lr.Value
}

// Creates a new instance of the ListResultPage type.
func NewListResultPage(cur ListResult, getNextPage func(context.Context, ListResult) (ListResult, error)) ListResultPage {
	return ListResultPage{
		fn: getNextPage,
		lr: cur,
	}
}

// NotificationListResponse the response of listUpgradeNotifications.
type NotificationListResponse struct {
	autorest.Response `json:"-"`
	// Value - List of all notifications.
	Value *[]UpgradeNotification `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link for next set of notifications.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for NotificationListResponse.
func (nlr NotificationListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if nlr.Value != nil {
		objectMap["value"] = nlr.Value
	}
	return json.Marshal(objectMap)
}

// Operation REST API operation
type Operation struct {
	// Name - Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`
	// Display - The object that describes the operation.
	Display *OperationDisplay `json:"display,omitempty"`
}

// OperationDisplay the object that describes the operation.
type OperationDisplay struct {
	// Provider - Friendly name of the resource provider
	Provider *string `json:"provider,omitempty"`
	// Operation - Operation type: read, write, delete, listKeys/action, etc.
	Operation *string `json:"operation,omitempty"`
	// Resource - Resource type on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Description - Friendly name of the operation
	Description *string `json:"description,omitempty"`
}

// OperationListResult result of the request to list REST API operations. It contains a list of operations
// and a URL nextLink to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - List of operations supported by the resource provider.
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if olr.Value != nil {
		objectMap["value"] = olr.Value
	}
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// PatchSchedule response to put/get patch schedules for Redis cache.
type PatchSchedule struct {
	autorest.Response `json:"-"`
	// ScheduleEntries - List of patch schedules for a Redis cache.
	*ScheduleEntries `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PatchSchedule.
func (ps PatchSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ps.ScheduleEntries != nil {
		objectMap["properties"] = ps.ScheduleEntries
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PatchSchedule struct.
func (ps *PatchSchedule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scheduleEntries ScheduleEntries
				err = json.Unmarshal(*v, &scheduleEntries)
				if err != nil {
					return err
				}
				ps.ScheduleEntries = &scheduleEntries
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ps.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ps.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ps.Type = &typeVar
			}
		}
	}

	return nil
}

// PatchScheduleListResult the response of list patch schedules Redis operation.
type PatchScheduleListResult struct {
	autorest.Response `json:"-"`
	// Value - Results of the list patch schedules operation.
	Value *[]PatchSchedule `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link for next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PatchScheduleListResult.
func (pslr PatchScheduleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pslr.Value != nil {
		objectMap["value"] = pslr.Value
	}
	return json.Marshal(objectMap)
}

// PatchScheduleListResultIterator provides access to a complete listing of PatchSchedule values.
type PatchScheduleListResultIterator struct {
	i    int
	page PatchScheduleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PatchScheduleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PatchScheduleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PatchScheduleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PatchScheduleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PatchScheduleListResultIterator) Response() PatchScheduleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PatchScheduleListResultIterator) Value() PatchSchedule {
	if !iter.page.NotDone() {
		return PatchSchedule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PatchScheduleListResultIterator type.
func NewPatchScheduleListResultIterator(page PatchScheduleListResultPage) PatchScheduleListResultIterator {
	return PatchScheduleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pslr PatchScheduleListResult) IsEmpty() bool {
	return pslr.Value == nil || len(*pslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pslr PatchScheduleListResult) hasNextLink() bool {
	return pslr.NextLink != nil && len(*pslr.NextLink) != 0
}

// patchScheduleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pslr PatchScheduleListResult) patchScheduleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pslr.NextLink)))
}

// PatchScheduleListResultPage contains a page of PatchSchedule values.
type PatchScheduleListResultPage struct {
	fn   func(context.Context, PatchScheduleListResult) (PatchScheduleListResult, error)
	pslr PatchScheduleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PatchScheduleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PatchScheduleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pslr)
		if err != nil {
			return err
		}
		page.pslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PatchScheduleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PatchScheduleListResultPage) NotDone() bool {
	return !page.pslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PatchScheduleListResultPage) Response() PatchScheduleListResult {
	return page.pslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PatchScheduleListResultPage) Values() []PatchSchedule {
	if page.pslr.IsEmpty() {
		return nil
	}
	return *page.pslr.Value
}

// Creates a new instance of the PatchScheduleListResultPage type.
func NewPatchScheduleListResultPage(cur PatchScheduleListResult, getNextPage func(context.Context, PatchScheduleListResult) (PatchScheduleListResult, error)) PatchScheduleListResultPage {
	return PatchScheduleListResultPage{
		fn:   getNextPage,
		pslr: cur,
	}
}

// PrivateEndpoint the Private Endpoint resource.
type PrivateEndpoint struct {
	// ID - READ-ONLY; The ARM identifier for Private Endpoint
	ID *string `json:"id,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpoint.
func (peVar PrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PrivateEndpointConnection the Private Endpoint Connection resource.
type PrivateEndpointConnection struct {
	autorest.Response `json:"-"`
	// PrivateEndpointConnectionProperties - Resource properties.
	*PrivateEndpointConnectionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointConnection.
func (pec PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pec.PrivateEndpointConnectionProperties != nil {
		objectMap["properties"] = pec.PrivateEndpointConnectionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateEndpointConnection struct.
func (pec *PrivateEndpointConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateEndpointConnectionProperties PrivateEndpointConnectionProperties
				err = json.Unmarshal(*v, &privateEndpointConnectionProperties)
				if err != nil {
					return err
				}
				pec.PrivateEndpointConnectionProperties = &privateEndpointConnectionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pec.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pec.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pec.Type = &typeVar
			}
		}
	}

	return nil
}

// PrivateEndpointConnectionListResult list of private endpoint connection associated with the specified
// storage account
type PrivateEndpointConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - Array of private endpoint connections
	Value *[]PrivateEndpointConnection `json:"value,omitempty"`
}

// PrivateEndpointConnectionProperties properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// PrivateEndpoint - The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`
	// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
	// ProvisioningState - The provisioning state of the private endpoint connection resource. Possible values include: 'Succeeded', 'Creating', 'Deleting', 'Failed'
	ProvisioningState PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty"`
}

// PrivateEndpointConnectionsPutFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PrivateEndpointConnectionsPutFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PrivateEndpointConnectionsClient) (PrivateEndpointConnection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PrivateEndpointConnectionsPutFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PrivateEndpointConnectionsPutFuture.Result.
func (future *PrivateEndpointConnectionsPutFuture) result(client PrivateEndpointConnectionsClient) (pec PrivateEndpointConnection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "redis.PrivateEndpointConnectionsPutFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pec.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("redis.PrivateEndpointConnectionsPutFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pec.Response.Response, err = future.GetResult(sender); err == nil && pec.Response.Response.StatusCode != http.StatusNoContent {
		pec, err = client.PutResponder(pec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "redis.PrivateEndpointConnectionsPutFuture", "Result", pec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PrivateLinkResource a private link resource
type PrivateLinkResource struct {
	// PrivateLinkResourceProperties - Resource properties.
	*PrivateLinkResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkResource.
func (plr PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plr.PrivateLinkResourceProperties != nil {
		objectMap["properties"] = plr.PrivateLinkResourceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateLinkResource struct.
func (plr *PrivateLinkResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateLinkResourceProperties PrivateLinkResourceProperties
				err = json.Unmarshal(*v, &privateLinkResourceProperties)
				if err != nil {
					return err
				}
				plr.PrivateLinkResourceProperties = &privateLinkResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				plr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				plr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				plr.Type = &typeVar
			}
		}
	}

	return nil
}

// PrivateLinkResourceListResult a list of private link resources
type PrivateLinkResourceListResult struct {
	autorest.Response `json:"-"`
	// Value - Array of private link resources
	Value *[]PrivateLinkResource `json:"value,omitempty"`
}

// PrivateLinkResourceProperties properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// GroupID - READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty"`
	// RequiredMembers - READ-ONLY; The private link resource required member names.
	RequiredMembers *[]string `json:"requiredMembers,omitempty"`
	// RequiredZoneNames - The private link resource Private link DNS zone name.
	RequiredZoneNames *[]string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkResourceProperties.
func (plrp PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plrp.RequiredZoneNames != nil {
		objectMap["requiredZoneNames"] = plrp.RequiredZoneNames
	}
	return json.Marshal(objectMap)
}

// PrivateLinkServiceConnectionState a collection of information about the state of the connection between
// service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// Status - Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service. Possible values include: 'Pending', 'Approved', 'Rejected'
	Status PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
	// Description - The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`
	// ActionsRequired - A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `json:"actionsRequired,omitempty"`
}

// Properties properties of the redis cache.
type Properties struct {
	// RedisVersion - READ-ONLY; Redis version.
	RedisVersion *string `json:"redisVersion,omitempty"`
	// ProvisioningState - READ-ONLY; Redis instance provisioning status. Possible values include: 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateDisabled', 'ProvisioningStateFailed', 'ProvisioningStateLinking', 'ProvisioningStateProvisioning', 'ProvisioningStateRecoveringScaleFailure', 'ProvisioningStateScaling', 'ProvisioningStateSucceeded', 'ProvisioningStateUnlinking', 'ProvisioningStateUnprovisioning', 'ProvisioningStateUpdating'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// HostName - READ-ONLY; Redis host name.
	HostName *string `json:"hostName,omitempty"`
	// Port - READ-ONLY; Redis non-SSL port.
	Port *int32 `json:"port,omitempty"`
	// SslPort - READ-ONLY; Redis SSL port.
	SslPort *int32 `json:"sslPort,omitempty"`
	// AccessKeys - READ-ONLY; The keys of the Redis cache - not set if this object is not the response to Create or Update redis cache
	AccessKeys *AccessKeys `json:"accessKeys,omitempty"`
	// LinkedServers - READ-ONLY; List of the linked servers associated with the cache
	LinkedServers *[]LinkedServer `json:"linkedServers,omitempty"`
	// Instances - READ-ONLY; List of the Redis instances associated with the cache
	Instances *[]InstanceDetails `json:"instances,omitempty"`
	// PrivateEndpointConnections - READ-ONLY; List of private endpoint connection associated with the specified redis cache
	PrivateEndpointConnections *[]PrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`
	// Sku - The SKU of the Redis cache to deploy.
	Sku *Sku `json:"sku,omitempty"`
	// SubnetID - The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1
	SubnetID *string `json:"subnetId,omitempty"`
	// StaticIP - Static IP address. Required when deploying a Redis cache inside an existing Azure Virtual Network.
	StaticIP *string `json:"staticIP,omitempty"`
	// RedisConfiguration - All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
	RedisConfiguration map[string]*string `json:"redisConfiguration"`
	// EnableNonSslPort - Specifies whether the non-ssl Redis server port (6379) is enabled.
	EnableNonSslPort *bool `json:"enableNonSslPort,omitempty"`
	// ReplicasPerMaster - The number of replicas to be created per master.
	ReplicasPerMaster *int32 `json:"replicasPerMaster,omitempty"`
	// TenantSettings - A dictionary of tenant settings
	TenantSettings map[string]*string `json:"tenantSettings"`
	// ShardCount - The number of shards to be created on a Premium Cluster Cache.
	ShardCount *int32 `json:"shardCount,omitempty"`
	// MinimumTLSVersion - Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2'). Possible values include: 'OneFullStopZero', 'OneFullStopOne', 'OneFullStopTwo'
	MinimumTLSVersion TLSVersion `json:"minimumTlsVersion,omitempty"`
	// PublicNetworkAccess - Whether or not public endpoint access is allowed for this cache.  Value is optional but if passed in, must be 'Enabled' or 'Disabled'. If 'Disabled', private endpoints are the exclusive access method. Default value is 'Enabled'. Possible values include: 'Enabled', 'Disabled'
	PublicNetworkAccess PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for Properties.
func (p Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.Sku != nil {
		objectMap["sku"] = p.Sku
	}
	if p.SubnetID != nil {
		objectMap["subnetId"] = p.SubnetID
	}
	if p.StaticIP != nil {
		objectMap["staticIP"] = p.StaticIP
	}
	if p.RedisConfiguration != nil {
		objectMap["redisConfiguration"] = p.RedisConfiguration
	}
	if p.EnableNonSslPort != nil {
		objectMap["enableNonSslPort"] = p.EnableNonSslPort
	}
	if p.ReplicasPerMaster != nil {
		objectMap["replicasPerMaster"] = p.ReplicasPerMaster
	}
	if p.TenantSettings != nil {
		objectMap["tenantSettings"] = p.TenantSettings
	}
	if p.ShardCount != nil {
		objectMap["shardCount"] = p.ShardCount
	}
	if p.MinimumTLSVersion != "" {
		objectMap["minimumTlsVersion"] = p.MinimumTLSVersion
	}
	if p.PublicNetworkAccess != "" {
		objectMap["publicNetworkAccess"] = p.PublicNetworkAccess
	}
	return json.Marshal(objectMap)
}

// ProxyResource the resource model definition for a ARM proxy resource. It will have everything other than
// required location and tags
type ProxyResource struct {
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RebootParameters specifies which Redis node(s) to reboot.
type RebootParameters struct {
	// RebootType - Which Redis node(s) to reboot. Depending on this value data loss is possible. Possible values include: 'PrimaryNode', 'SecondaryNode', 'AllNodes'
	RebootType RebootType `json:"rebootType,omitempty"`
	// ShardID - If clustering is enabled, the ID of the shard to be rebooted.
	ShardID *int32 `json:"shardId,omitempty"`
	// Ports - A list of redis instances to reboot, specified by per-instance SSL ports or non-SSL ports.
	Ports *[]int32 `json:"ports,omitempty"`
}

// RegenerateKeyParameters specifies which Redis access keys to reset.
type RegenerateKeyParameters struct {
	// KeyType - The Redis access key to regenerate. Possible values include: 'Primary', 'Secondary'
	KeyType KeyType `json:"keyType,omitempty"`
}

// Resource the Resource definition.
type Resource struct {
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceType a single Redis item in List or Get Operation.
type ResourceType struct {
	autorest.Response `json:"-"`
	// Properties - Redis cache properties.
	*Properties `json:"properties,omitempty"`
	// Zones - A list of availability zones denoting where the resource needs to come from.
	Zones *[]string `json:"zones,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceType.
func (rt ResourceType) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rt.Properties != nil {
		objectMap["properties"] = rt.Properties
	}
	if rt.Zones != nil {
		objectMap["zones"] = rt.Zones
	}
	if rt.Tags != nil {
		objectMap["tags"] = rt.Tags
	}
	if rt.Location != nil {
		objectMap["location"] = rt.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ResourceType struct.
func (rt *ResourceType) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var properties Properties
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				rt.Properties = &properties
			}
		case "zones":
			if v != nil {
				var zones []string
				err = json.Unmarshal(*v, &zones)
				if err != nil {
					return err
				}
				rt.Zones = &zones
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				rt.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				rt.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rt.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rt.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rt.Type = &typeVar
			}
		}
	}

	return nil
}

// ScheduleEntries list of patch schedules for a Redis cache.
type ScheduleEntries struct {
	// ScheduleEntries - List of patch schedules for a Redis cache.
	ScheduleEntries *[]ScheduleEntry `json:"scheduleEntries,omitempty"`
}

// ScheduleEntry patch schedule entry for a Premium Redis Cache.
type ScheduleEntry struct {
	// DayOfWeek - Day of the week when a cache can be patched. Possible values include: 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', 'Everyday', 'Weekend'
	DayOfWeek DayOfWeek `json:"dayOfWeek,omitempty"`
	// StartHourUtc - Start hour after which cache patching can start.
	StartHourUtc *int32 `json:"startHourUtc,omitempty"`
	// MaintenanceWindow - ISO8601 timespan specifying how much time cache patching can take.
	MaintenanceWindow *string `json:"maintenanceWindow,omitempty"`
}

// Sku SKU parameters supplied to the create Redis operation.
type Sku struct {
	// Name - The type of Redis cache to deploy. Valid values: (Basic, Standard, Premium). Possible values include: 'Basic', 'Standard', 'Premium'
	Name SkuName `json:"name,omitempty"`
	// Family - The SKU family to use. Valid values: (C, P). (C = Basic/Standard, P = Premium). Possible values include: 'C', 'P'
	Family SkuFamily `json:"family,omitempty"`
	// Capacity - The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4).
	Capacity *int32 `json:"capacity,omitempty"`
}

// TrackedResource the resource model definition for a ARM tracked top level resource
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// UpdateParameters parameters supplied to the Update Redis operation.
type UpdateParameters struct {
	// UpdateProperties - Redis cache properties.
	*UpdateProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for UpdateParameters.
func (up UpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if up.UpdateProperties != nil {
		objectMap["properties"] = up.UpdateProperties
	}
	if up.Tags != nil {
		objectMap["tags"] = up.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for UpdateParameters struct.
func (up *UpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var updateProperties UpdateProperties
				err = json.Unmarshal(*v, &updateProperties)
				if err != nil {
					return err
				}
				up.UpdateProperties = &updateProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				up.Tags = tags
			}
		}
	}

	return nil
}

// UpdateProperties patchable properties of the redis cache.
type UpdateProperties struct {
	// Sku - The SKU of the Redis cache to deploy.
	Sku *Sku `json:"sku,omitempty"`
	// RedisConfiguration - All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
	RedisConfiguration map[string]*string `json:"redisConfiguration"`
	// EnableNonSslPort - Specifies whether the non-ssl Redis server port (6379) is enabled.
	EnableNonSslPort *bool `json:"enableNonSslPort,omitempty"`
	// ReplicasPerMaster - The number of replicas to be created per master.
	ReplicasPerMaster *int32 `json:"replicasPerMaster,omitempty"`
	// TenantSettings - A dictionary of tenant settings
	TenantSettings map[string]*string `json:"tenantSettings"`
	// ShardCount - The number of shards to be created on a Premium Cluster Cache.
	ShardCount *int32 `json:"shardCount,omitempty"`
	// MinimumTLSVersion - Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2'). Possible values include: 'OneFullStopZero', 'OneFullStopOne', 'OneFullStopTwo'
	MinimumTLSVersion TLSVersion `json:"minimumTlsVersion,omitempty"`
	// PublicNetworkAccess - Whether or not public endpoint access is allowed for this cache.  Value is optional but if passed in, must be 'Enabled' or 'Disabled'. If 'Disabled', private endpoints are the exclusive access method. Default value is 'Enabled'. Possible values include: 'Enabled', 'Disabled'
	PublicNetworkAccess PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for UpdateProperties.
func (up UpdateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if up.Sku != nil {
		objectMap["sku"] = up.Sku
	}
	if up.RedisConfiguration != nil {
		objectMap["redisConfiguration"] = up.RedisConfiguration
	}
	if up.EnableNonSslPort != nil {
		objectMap["enableNonSslPort"] = up.EnableNonSslPort
	}
	if up.ReplicasPerMaster != nil {
		objectMap["replicasPerMaster"] = up.ReplicasPerMaster
	}
	if up.TenantSettings != nil {
		objectMap["tenantSettings"] = up.TenantSettings
	}
	if up.ShardCount != nil {
		objectMap["shardCount"] = up.ShardCount
	}
	if up.MinimumTLSVersion != "" {
		objectMap["minimumTlsVersion"] = up.MinimumTLSVersion
	}
	if up.PublicNetworkAccess != "" {
		objectMap["publicNetworkAccess"] = up.PublicNetworkAccess
	}
	return json.Marshal(objectMap)
}

// UpgradeNotification properties of upgrade notification.
type UpgradeNotification struct {
	// Name - READ-ONLY; Name of upgrade notification.
	Name *string `json:"name,omitempty"`
	// Timestamp - READ-ONLY; Timestamp when upgrade notification occurred.
	Timestamp *date.Time `json:"timestamp,omitempty"`
	// UpsellNotification - READ-ONLY; Details about this upgrade notification
	UpsellNotification map[string]*string `json:"upsellNotification"`
}

// MarshalJSON is the custom marshaler for UpgradeNotification.
func (un UpgradeNotification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}
