package authorization

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/authorization/mgmt/2020-04-01-preview/authorization"

// ClassicAdministrator classic Administrators
type ClassicAdministrator struct {
	// ID - The ID of the administrator.
	ID *string `json:"id,omitempty"`
	// Name - The name of the administrator.
	Name *string `json:"name,omitempty"`
	// Type - The type of the administrator.
	Type *string `json:"type,omitempty"`
	// ClassicAdministratorProperties - Properties for the classic administrator.
	*ClassicAdministratorProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ClassicAdministrator.
func (ca ClassicAdministrator) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ca.ID != nil {
		objectMap["id"] = ca.ID
	}
	if ca.Name != nil {
		objectMap["name"] = ca.Name
	}
	if ca.Type != nil {
		objectMap["type"] = ca.Type
	}
	if ca.ClassicAdministratorProperties != nil {
		objectMap["properties"] = ca.ClassicAdministratorProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ClassicAdministrator struct.
func (ca *ClassicAdministrator) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ca.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ca.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ca.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var classicAdministratorProperties ClassicAdministratorProperties
				err = json.Unmarshal(*v, &classicAdministratorProperties)
				if err != nil {
					return err
				}
				ca.ClassicAdministratorProperties = &classicAdministratorProperties
			}
		}
	}

	return nil
}

// ClassicAdministratorListResult classicAdministrator list result information.
type ClassicAdministratorListResult struct {
	autorest.Response `json:"-"`
	// Value - An array of administrators.
	Value *[]ClassicAdministrator `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ClassicAdministratorListResultIterator provides access to a complete listing of ClassicAdministrator
// values.
type ClassicAdministratorListResultIterator struct {
	i    int
	page ClassicAdministratorListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ClassicAdministratorListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ClassicAdministratorListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ClassicAdministratorListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ClassicAdministratorListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ClassicAdministratorListResultIterator) Response() ClassicAdministratorListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ClassicAdministratorListResultIterator) Value() ClassicAdministrator {
	if !iter.page.NotDone() {
		return ClassicAdministrator{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ClassicAdministratorListResultIterator type.
func NewClassicAdministratorListResultIterator(page ClassicAdministratorListResultPage) ClassicAdministratorListResultIterator {
	return ClassicAdministratorListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (calr ClassicAdministratorListResult) IsEmpty() bool {
	return calr.Value == nil || len(*calr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (calr ClassicAdministratorListResult) hasNextLink() bool {
	return calr.NextLink != nil && len(*calr.NextLink) != 0
}

// classicAdministratorListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (calr ClassicAdministratorListResult) classicAdministratorListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !calr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(calr.NextLink)))
}

// ClassicAdministratorListResultPage contains a page of ClassicAdministrator values.
type ClassicAdministratorListResultPage struct {
	fn   func(context.Context, ClassicAdministratorListResult) (ClassicAdministratorListResult, error)
	calr ClassicAdministratorListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ClassicAdministratorListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ClassicAdministratorListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.calr)
		if err != nil {
			return err
		}
		page.calr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ClassicAdministratorListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ClassicAdministratorListResultPage) NotDone() bool {
	return !page.calr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ClassicAdministratorListResultPage) Response() ClassicAdministratorListResult {
	return page.calr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ClassicAdministratorListResultPage) Values() []ClassicAdministrator {
	if page.calr.IsEmpty() {
		return nil
	}
	return *page.calr.Value
}

// Creates a new instance of the ClassicAdministratorListResultPage type.
func NewClassicAdministratorListResultPage(cur ClassicAdministratorListResult, getNextPage func(context.Context, ClassicAdministratorListResult) (ClassicAdministratorListResult, error)) ClassicAdministratorListResultPage {
	return ClassicAdministratorListResultPage{
		fn:   getNextPage,
		calr: cur,
	}
}

// ClassicAdministratorProperties classic Administrator properties.
type ClassicAdministratorProperties struct {
	// EmailAddress - The email address of the administrator.
	EmailAddress *string `json:"emailAddress,omitempty"`
	// Role - The role of the administrator.
	Role *string `json:"role,omitempty"`
}

// DenyAssignment deny Assignment
type DenyAssignment struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The deny assignment ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The deny assignment name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The deny assignment type.
	Type *string `json:"type,omitempty"`
	// DenyAssignmentProperties - Deny assignment properties.
	*DenyAssignmentProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for DenyAssignment.
func (da DenyAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if da.DenyAssignmentProperties != nil {
		objectMap["properties"] = da.DenyAssignmentProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DenyAssignment struct.
func (da *DenyAssignment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				da.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				da.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				da.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var denyAssignmentProperties DenyAssignmentProperties
				err = json.Unmarshal(*v, &denyAssignmentProperties)
				if err != nil {
					return err
				}
				da.DenyAssignmentProperties = &denyAssignmentProperties
			}
		}
	}

	return nil
}

// DenyAssignmentFilter deny Assignments filter
type DenyAssignmentFilter struct {
	// DenyAssignmentName - Return deny assignment with specified name.
	DenyAssignmentName *string `json:"denyAssignmentName,omitempty"`
	// PrincipalID - Return all deny assignments where the specified principal is listed in the principals list of deny assignments.
	PrincipalID *string `json:"principalId,omitempty"`
	// GdprExportPrincipalID - Return all deny assignments where the specified principal is listed either in the principals list or exclude principals list of deny assignments.
	GdprExportPrincipalID *string `json:"gdprExportPrincipalId,omitempty"`
}

// DenyAssignmentListResult deny assignment list operation result.
type DenyAssignmentListResult struct {
	autorest.Response `json:"-"`
	// Value - Deny assignment list.
	Value *[]DenyAssignment `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// DenyAssignmentListResultIterator provides access to a complete listing of DenyAssignment values.
type DenyAssignmentListResultIterator struct {
	i    int
	page DenyAssignmentListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DenyAssignmentListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DenyAssignmentListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DenyAssignmentListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DenyAssignmentListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DenyAssignmentListResultIterator) Response() DenyAssignmentListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DenyAssignmentListResultIterator) Value() DenyAssignment {
	if !iter.page.NotDone() {
		return DenyAssignment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DenyAssignmentListResultIterator type.
func NewDenyAssignmentListResultIterator(page DenyAssignmentListResultPage) DenyAssignmentListResultIterator {
	return DenyAssignmentListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dalr DenyAssignmentListResult) IsEmpty() bool {
	return dalr.Value == nil || len(*dalr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dalr DenyAssignmentListResult) hasNextLink() bool {
	return dalr.NextLink != nil && len(*dalr.NextLink) != 0
}

// denyAssignmentListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dalr DenyAssignmentListResult) denyAssignmentListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !dalr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dalr.NextLink)))
}

// DenyAssignmentListResultPage contains a page of DenyAssignment values.
type DenyAssignmentListResultPage struct {
	fn   func(context.Context, DenyAssignmentListResult) (DenyAssignmentListResult, error)
	dalr DenyAssignmentListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DenyAssignmentListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DenyAssignmentListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dalr)
		if err != nil {
			return err
		}
		page.dalr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DenyAssignmentListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DenyAssignmentListResultPage) NotDone() bool {
	return !page.dalr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DenyAssignmentListResultPage) Response() DenyAssignmentListResult {
	return page.dalr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DenyAssignmentListResultPage) Values() []DenyAssignment {
	if page.dalr.IsEmpty() {
		return nil
	}
	return *page.dalr.Value
}

// Creates a new instance of the DenyAssignmentListResultPage type.
func NewDenyAssignmentListResultPage(cur DenyAssignmentListResult, getNextPage func(context.Context, DenyAssignmentListResult) (DenyAssignmentListResult, error)) DenyAssignmentListResultPage {
	return DenyAssignmentListResultPage{
		fn:   getNextPage,
		dalr: cur,
	}
}

// DenyAssignmentPermission deny assignment permissions.
type DenyAssignmentPermission struct {
	// Actions - Actions to which the deny assignment does not grant access.
	Actions *[]string `json:"actions,omitempty"`
	// NotActions - Actions to exclude from that the deny assignment does not grant access.
	NotActions *[]string `json:"notActions,omitempty"`
	// DataActions - Data actions to which the deny assignment does not grant access.
	DataActions *[]string `json:"dataActions,omitempty"`
	// NotDataActions - Data actions to exclude from that the deny assignment does not grant access.
	NotDataActions *[]string `json:"notDataActions,omitempty"`
}

// DenyAssignmentProperties deny assignment properties.
type DenyAssignmentProperties struct {
	// DenyAssignmentName - The display name of the deny assignment.
	DenyAssignmentName *string `json:"denyAssignmentName,omitempty"`
	// Description - The description of the deny assignment.
	Description *string `json:"description,omitempty"`
	// Permissions - An array of permissions that are denied by the deny assignment.
	Permissions *[]DenyAssignmentPermission `json:"permissions,omitempty"`
	// Scope - The deny assignment scope.
	Scope *string `json:"scope,omitempty"`
	// DoNotApplyToChildScopes - Determines if the deny assignment applies to child scopes. Default value is false.
	DoNotApplyToChildScopes *bool `json:"doNotApplyToChildScopes,omitempty"`
	// Principals - Array of principals to which the deny assignment applies.
	Principals *[]Principal `json:"principals,omitempty"`
	// ExcludePrincipals - Array of principals to which the deny assignment does not apply.
	ExcludePrincipals *[]Principal `json:"excludePrincipals,omitempty"`
	// IsSystemProtected - Specifies whether this deny assignment was created by Azure and cannot be edited or deleted.
	IsSystemProtected *bool `json:"isSystemProtected,omitempty"`
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorAdditionalInfo.
func (eai ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetail.
func (ed ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// Permission role definition permissions.
type Permission struct {
	// Actions - Allowed actions.
	Actions *[]string `json:"actions,omitempty"`
	// NotActions - Denied actions.
	NotActions *[]string `json:"notActions,omitempty"`
	// DataActions - Allowed Data actions.
	DataActions *[]string `json:"dataActions,omitempty"`
	// NotDataActions - Denied Data actions.
	NotDataActions *[]string `json:"notDataActions,omitempty"`
}

// PermissionGetResult permissions information.
type PermissionGetResult struct {
	autorest.Response `json:"-"`
	// Value - An array of permissions.
	Value *[]Permission `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PermissionGetResultIterator provides access to a complete listing of Permission values.
type PermissionGetResultIterator struct {
	i    int
	page PermissionGetResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PermissionGetResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PermissionGetResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PermissionGetResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PermissionGetResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PermissionGetResultIterator) Response() PermissionGetResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PermissionGetResultIterator) Value() Permission {
	if !iter.page.NotDone() {
		return Permission{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PermissionGetResultIterator type.
func NewPermissionGetResultIterator(page PermissionGetResultPage) PermissionGetResultIterator {
	return PermissionGetResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pgr PermissionGetResult) IsEmpty() bool {
	return pgr.Value == nil || len(*pgr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pgr PermissionGetResult) hasNextLink() bool {
	return pgr.NextLink != nil && len(*pgr.NextLink) != 0
}

// permissionGetResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pgr PermissionGetResult) permissionGetResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pgr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pgr.NextLink)))
}

// PermissionGetResultPage contains a page of Permission values.
type PermissionGetResultPage struct {
	fn  func(context.Context, PermissionGetResult) (PermissionGetResult, error)
	pgr PermissionGetResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PermissionGetResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PermissionGetResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pgr)
		if err != nil {
			return err
		}
		page.pgr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PermissionGetResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PermissionGetResultPage) NotDone() bool {
	return !page.pgr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PermissionGetResultPage) Response() PermissionGetResult {
	return page.pgr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PermissionGetResultPage) Values() []Permission {
	if page.pgr.IsEmpty() {
		return nil
	}
	return *page.pgr.Value
}

// Creates a new instance of the PermissionGetResultPage type.
func NewPermissionGetResultPage(cur PermissionGetResult, getNextPage func(context.Context, PermissionGetResult) (PermissionGetResult, error)) PermissionGetResultPage {
	return PermissionGetResultPage{
		fn:  getNextPage,
		pgr: cur,
	}
}

// Principal deny assignment principal.
type Principal struct {
	// ID - READ-ONLY; Object ID of the Azure AD principal (user, group, or service principal) to which the deny assignment applies. An empty guid '00000000-0000-0000-0000-000000000000' as principal id and principal type as 'Everyone' represents all users, groups and service principals.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Type of object represented by principal id (user, group, or service principal). An empty guid '00000000-0000-0000-0000-000000000000' as principal id and principal type as 'Everyone' represents all users, groups and service principals.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Principal.
func (p Principal) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ProviderOperation operation
type ProviderOperation struct {
	// Name - The operation name.
	Name *string `json:"name,omitempty"`
	// DisplayName - The operation display name.
	DisplayName *string `json:"displayName,omitempty"`
	// Description - The operation description.
	Description *string `json:"description,omitempty"`
	// Origin - The operation origin.
	Origin *string `json:"origin,omitempty"`
	// Properties - The operation properties.
	Properties interface{} `json:"properties,omitempty"`
	// IsDataAction - The dataAction flag to specify the operation type.
	IsDataAction *bool `json:"isDataAction,omitempty"`
}

// ProviderOperationsMetadata provider Operations metadata
type ProviderOperationsMetadata struct {
	autorest.Response `json:"-"`
	// ID - The provider id.
	ID *string `json:"id,omitempty"`
	// Name - The provider name.
	Name *string `json:"name,omitempty"`
	// Type - The provider type.
	Type *string `json:"type,omitempty"`
	// DisplayName - The provider display name.
	DisplayName *string `json:"displayName,omitempty"`
	// ResourceTypes - The provider resource types
	ResourceTypes *[]ResourceType `json:"resourceTypes,omitempty"`
	// Operations - The provider operations.
	Operations *[]ProviderOperation `json:"operations,omitempty"`
}

// ProviderOperationsMetadataListResult provider operations metadata list
type ProviderOperationsMetadataListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of providers.
	Value *[]ProviderOperationsMetadata `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ProviderOperationsMetadataListResultIterator provides access to a complete listing of
// ProviderOperationsMetadata values.
type ProviderOperationsMetadataListResultIterator struct {
	i    int
	page ProviderOperationsMetadataListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProviderOperationsMetadataListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderOperationsMetadataListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProviderOperationsMetadataListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProviderOperationsMetadataListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProviderOperationsMetadataListResultIterator) Response() ProviderOperationsMetadataListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProviderOperationsMetadataListResultIterator) Value() ProviderOperationsMetadata {
	if !iter.page.NotDone() {
		return ProviderOperationsMetadata{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProviderOperationsMetadataListResultIterator type.
func NewProviderOperationsMetadataListResultIterator(page ProviderOperationsMetadataListResultPage) ProviderOperationsMetadataListResultIterator {
	return ProviderOperationsMetadataListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pomlr ProviderOperationsMetadataListResult) IsEmpty() bool {
	return pomlr.Value == nil || len(*pomlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pomlr ProviderOperationsMetadataListResult) hasNextLink() bool {
	return pomlr.NextLink != nil && len(*pomlr.NextLink) != 0
}

// providerOperationsMetadataListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pomlr ProviderOperationsMetadataListResult) providerOperationsMetadataListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pomlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pomlr.NextLink)))
}

// ProviderOperationsMetadataListResultPage contains a page of ProviderOperationsMetadata values.
type ProviderOperationsMetadataListResultPage struct {
	fn    func(context.Context, ProviderOperationsMetadataListResult) (ProviderOperationsMetadataListResult, error)
	pomlr ProviderOperationsMetadataListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProviderOperationsMetadataListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderOperationsMetadataListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pomlr)
		if err != nil {
			return err
		}
		page.pomlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProviderOperationsMetadataListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProviderOperationsMetadataListResultPage) NotDone() bool {
	return !page.pomlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProviderOperationsMetadataListResultPage) Response() ProviderOperationsMetadataListResult {
	return page.pomlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProviderOperationsMetadataListResultPage) Values() []ProviderOperationsMetadata {
	if page.pomlr.IsEmpty() {
		return nil
	}
	return *page.pomlr.Value
}

// Creates a new instance of the ProviderOperationsMetadataListResultPage type.
func NewProviderOperationsMetadataListResultPage(cur ProviderOperationsMetadataListResult, getNextPage func(context.Context, ProviderOperationsMetadataListResult) (ProviderOperationsMetadataListResult, error)) ProviderOperationsMetadataListResultPage {
	return ProviderOperationsMetadataListResultPage{
		fn:    getNextPage,
		pomlr: cur,
	}
}

// ResourceType resource Type
type ResourceType struct {
	// Name - The resource type name.
	Name *string `json:"name,omitempty"`
	// DisplayName - The resource type display name.
	DisplayName *string `json:"displayName,omitempty"`
	// Operations - The resource type operations.
	Operations *[]ProviderOperation `json:"operations,omitempty"`
}

// RoleAssignment role Assignments
type RoleAssignment struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role assignment ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role assignment name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role assignment type.
	Type *string `json:"type,omitempty"`
	// RoleAssignmentPropertiesWithScope - Role assignment properties.
	*RoleAssignmentPropertiesWithScope `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignment.
func (ra RoleAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ra.RoleAssignmentPropertiesWithScope != nil {
		objectMap["properties"] = ra.RoleAssignmentPropertiesWithScope
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleAssignment struct.
func (ra *RoleAssignment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ra.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ra.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ra.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleAssignmentPropertiesWithScope RoleAssignmentPropertiesWithScope
				err = json.Unmarshal(*v, &roleAssignmentPropertiesWithScope)
				if err != nil {
					return err
				}
				ra.RoleAssignmentPropertiesWithScope = &roleAssignmentPropertiesWithScope
			}
		}
	}

	return nil
}

// RoleAssignmentCreateParameters role assignment create parameters.
type RoleAssignmentCreateParameters struct {
	// RoleAssignmentProperties - Role assignment properties.
	*RoleAssignmentProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentCreateParameters.
func (racp RoleAssignmentCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if racp.RoleAssignmentProperties != nil {
		objectMap["properties"] = racp.RoleAssignmentProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleAssignmentCreateParameters struct.
func (racp *RoleAssignmentCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var roleAssignmentProperties RoleAssignmentProperties
				err = json.Unmarshal(*v, &roleAssignmentProperties)
				if err != nil {
					return err
				}
				racp.RoleAssignmentProperties = &roleAssignmentProperties
			}
		}
	}

	return nil
}

// RoleAssignmentFilter role Assignments filter
type RoleAssignmentFilter struct {
	// PrincipalID - Returns role assignment of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
	// CanDelegate - The Delegation flag for the role assignment
	CanDelegate *bool `json:"canDelegate,omitempty"`
}

// RoleAssignmentListResult role assignment list operation result.
type RoleAssignmentListResult struct {
	autorest.Response `json:"-"`
	// Value - Role assignment list.
	Value *[]RoleAssignment `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleAssignmentListResultIterator provides access to a complete listing of RoleAssignment values.
type RoleAssignmentListResultIterator struct {
	i    int
	page RoleAssignmentListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleAssignmentListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleAssignmentListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleAssignmentListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleAssignmentListResultIterator) Response() RoleAssignmentListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleAssignmentListResultIterator) Value() RoleAssignment {
	if !iter.page.NotDone() {
		return RoleAssignment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleAssignmentListResultIterator type.
func NewRoleAssignmentListResultIterator(page RoleAssignmentListResultPage) RoleAssignmentListResultIterator {
	return RoleAssignmentListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ralr RoleAssignmentListResult) IsEmpty() bool {
	return ralr.Value == nil || len(*ralr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ralr RoleAssignmentListResult) hasNextLink() bool {
	return ralr.NextLink != nil && len(*ralr.NextLink) != 0
}

// roleAssignmentListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ralr RoleAssignmentListResult) roleAssignmentListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ralr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ralr.NextLink)))
}

// RoleAssignmentListResultPage contains a page of RoleAssignment values.
type RoleAssignmentListResultPage struct {
	fn   func(context.Context, RoleAssignmentListResult) (RoleAssignmentListResult, error)
	ralr RoleAssignmentListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleAssignmentListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ralr)
		if err != nil {
			return err
		}
		page.ralr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleAssignmentListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleAssignmentListResultPage) NotDone() bool {
	return !page.ralr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleAssignmentListResultPage) Response() RoleAssignmentListResult {
	return page.ralr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleAssignmentListResultPage) Values() []RoleAssignment {
	if page.ralr.IsEmpty() {
		return nil
	}
	return *page.ralr.Value
}

// Creates a new instance of the RoleAssignmentListResultPage type.
func NewRoleAssignmentListResultPage(cur RoleAssignmentListResult, getNextPage func(context.Context, RoleAssignmentListResult) (RoleAssignmentListResult, error)) RoleAssignmentListResultPage {
	return RoleAssignmentListResultPage{
		fn:   getNextPage,
		ralr: cur,
	}
}

// RoleAssignmentMetricsResult role Assignment Metrics
type RoleAssignmentMetricsResult struct {
	autorest.Response `json:"-"`
	// SubscriptionID - READ-ONLY; The subscription ID.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// RoleAssignmentsLimit - READ-ONLY; The role assignment limit.
	RoleAssignmentsLimit *int64 `json:"roleAssignmentsLimit,omitempty"`
	// RoleAssignmentsCurrentCount - READ-ONLY; The number of current role assignments.
	RoleAssignmentsCurrentCount *int64 `json:"roleAssignmentsCurrentCount,omitempty"`
	// RoleAssignmentsRemainingCount - READ-ONLY; The number of remaining role assignments available.
	RoleAssignmentsRemainingCount *int64 `json:"roleAssignmentsRemainingCount,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentMetricsResult.
func (ramr RoleAssignmentMetricsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RoleAssignmentProperties role assignment properties.
type RoleAssignmentProperties struct {
	// RoleDefinitionID - The role definition ID used in the role assignment.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID assigned to the role. This maps to the ID inside the Active Directory. It can point to a user, service principal, or security group.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - The principal type of the assigned principal ID. Possible values include: 'User', 'Group', 'ServicePrincipal', 'Unknown', 'DirectoryRoleTemplate', 'ForeignGroup', 'Application', 'MSI', 'DirectoryObjectOrGroup', 'Everyone'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// CanDelegate - The delegation flag used for creating a role assignment
	CanDelegate *bool `json:"canDelegate,omitempty"`
	// Description - Description of role assignment
	Description *string `json:"description,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// DelegatedManagedIdentityResourceID - Id of the delegated managed identity resource
	DelegatedManagedIdentityResourceID *string `json:"delegatedManagedIdentityResourceId,omitempty"`
}

// RoleAssignmentPropertiesWithScope role assignment properties with scope.
type RoleAssignmentPropertiesWithScope struct {
	// Scope - The role assignment scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - The principal type of the assigned principal ID. Possible values include: 'User', 'Group', 'ServicePrincipal', 'Unknown', 'DirectoryRoleTemplate', 'ForeignGroup', 'Application', 'MSI', 'DirectoryObjectOrGroup', 'Everyone'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// CanDelegate - The Delegation flag for the role assignment
	CanDelegate *bool `json:"canDelegate,omitempty"`
	// Description - Description of role assignment
	Description *string `json:"description,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// CreatedOn - Time it was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// UpdatedOn - Time it was updated
	UpdatedOn *date.Time `json:"updatedOn,omitempty"`
	// CreatedBy - Id of the user who created the assignment
	CreatedBy *string `json:"createdBy,omitempty"`
	// UpdatedBy - Id of the user who updated the assignment
	UpdatedBy *string `json:"updatedBy,omitempty"`
	// DelegatedManagedIdentityResourceID - Id of the delegated managed identity resource
	DelegatedManagedIdentityResourceID *string `json:"delegatedManagedIdentityResourceId,omitempty"`
}

// RoleDefinition role definition.
type RoleDefinition struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role definition ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role definition name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role definition type.
	Type *string `json:"type,omitempty"`
	// RoleDefinitionProperties - Role definition properties.
	*RoleDefinitionProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleDefinition.
func (rd RoleDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rd.RoleDefinitionProperties != nil {
		objectMap["properties"] = rd.RoleDefinitionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleDefinition struct.
func (rd *RoleDefinition) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rd.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rd.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleDefinitionProperties RoleDefinitionProperties
				err = json.Unmarshal(*v, &roleDefinitionProperties)
				if err != nil {
					return err
				}
				rd.RoleDefinitionProperties = &roleDefinitionProperties
			}
		}
	}

	return nil
}

// RoleDefinitionFilter role Definitions filter
type RoleDefinitionFilter struct {
	// RoleName - Returns role definition with the specific name.
	RoleName *string `json:"roleName,omitempty"`
	// Type - Returns role definition with the specific type.
	Type *string `json:"type,omitempty"`
}

// RoleDefinitionListResult role definition list operation result.
type RoleDefinitionListResult struct {
	autorest.Response `json:"-"`
	// Value - Role definition list.
	Value *[]RoleDefinition `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleDefinitionListResultIterator provides access to a complete listing of RoleDefinition values.
type RoleDefinitionListResultIterator struct {
	i    int
	page RoleDefinitionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleDefinitionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleDefinitionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleDefinitionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleDefinitionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleDefinitionListResultIterator) Response() RoleDefinitionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleDefinitionListResultIterator) Value() RoleDefinition {
	if !iter.page.NotDone() {
		return RoleDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleDefinitionListResultIterator type.
func NewRoleDefinitionListResultIterator(page RoleDefinitionListResultPage) RoleDefinitionListResultIterator {
	return RoleDefinitionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rdlr RoleDefinitionListResult) IsEmpty() bool {
	return rdlr.Value == nil || len(*rdlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rdlr RoleDefinitionListResult) hasNextLink() bool {
	return rdlr.NextLink != nil && len(*rdlr.NextLink) != 0
}

// roleDefinitionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rdlr RoleDefinitionListResult) roleDefinitionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rdlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rdlr.NextLink)))
}

// RoleDefinitionListResultPage contains a page of RoleDefinition values.
type RoleDefinitionListResultPage struct {
	fn   func(context.Context, RoleDefinitionListResult) (RoleDefinitionListResult, error)
	rdlr RoleDefinitionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleDefinitionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleDefinitionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rdlr)
		if err != nil {
			return err
		}
		page.rdlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleDefinitionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleDefinitionListResultPage) NotDone() bool {
	return !page.rdlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleDefinitionListResultPage) Response() RoleDefinitionListResult {
	return page.rdlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleDefinitionListResultPage) Values() []RoleDefinition {
	if page.rdlr.IsEmpty() {
		return nil
	}
	return *page.rdlr.Value
}

// Creates a new instance of the RoleDefinitionListResultPage type.
func NewRoleDefinitionListResultPage(cur RoleDefinitionListResult, getNextPage func(context.Context, RoleDefinitionListResult) (RoleDefinitionListResult, error)) RoleDefinitionListResultPage {
	return RoleDefinitionListResultPage{
		fn:   getNextPage,
		rdlr: cur,
	}
}

// RoleDefinitionProperties role definition properties.
type RoleDefinitionProperties struct {
	// RoleName - The role name.
	RoleName *string `json:"roleName,omitempty"`
	// Description - The role definition description.
	Description *string `json:"description,omitempty"`
	// RoleType - The role type.
	RoleType *string `json:"type,omitempty"`
	// Permissions - Role definition permissions.
	Permissions *[]Permission `json:"permissions,omitempty"`
	// AssignableScopes - Role definition assignable scopes.
	AssignableScopes *[]string `json:"assignableScopes,omitempty"`
}
