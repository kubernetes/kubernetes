package billing

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/billing/mgmt/2020-05-01-preview/billing"

// Account a billing account.
type Account struct {
	autorest.Response `json:"-"`
	// AccountProperties - The properties of the billing account.
	*AccountProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Account.
func (a Account) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.AccountProperties != nil {
		objectMap["properties"] = a.AccountProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Account struct.
func (a *Account) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var accountProperties AccountProperties
				err = json.Unmarshal(*v, &accountProperties)
				if err != nil {
					return err
				}
				a.AccountProperties = &accountProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				a.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				a.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				a.Type = &typeVar
			}
		}
	}

	return nil
}

// AccountListResult the list of billing accounts.
type AccountListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing accounts.
	Value *[]Account `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountListResult.
func (alr AccountListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AccountListResultIterator provides access to a complete listing of Account values.
type AccountListResultIterator struct {
	i    int
	page AccountListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccountListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccountListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccountListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccountListResultIterator) Response() AccountListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccountListResultIterator) Value() Account {
	if !iter.page.NotDone() {
		return Account{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccountListResultIterator type.
func NewAccountListResultIterator(page AccountListResultPage) AccountListResultIterator {
	return AccountListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (alr AccountListResult) IsEmpty() bool {
	return alr.Value == nil || len(*alr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (alr AccountListResult) hasNextLink() bool {
	return alr.NextLink != nil && len(*alr.NextLink) != 0
}

// accountListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (alr AccountListResult) accountListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !alr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(alr.NextLink)))
}

// AccountListResultPage contains a page of Account values.
type AccountListResultPage struct {
	fn  func(context.Context, AccountListResult) (AccountListResult, error)
	alr AccountListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccountListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.alr)
		if err != nil {
			return err
		}
		page.alr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccountListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccountListResultPage) NotDone() bool {
	return !page.alr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccountListResultPage) Response() AccountListResult {
	return page.alr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccountListResultPage) Values() []Account {
	if page.alr.IsEmpty() {
		return nil
	}
	return *page.alr.Value
}

// Creates a new instance of the AccountListResultPage type.
func NewAccountListResultPage(cur AccountListResult, getNextPage func(context.Context, AccountListResult) (AccountListResult, error)) AccountListResultPage {
	return AccountListResultPage{
		fn:  getNextPage,
		alr: cur,
	}
}

// AccountProperties the properties of the billing account.
type AccountProperties struct {
	// DisplayName - The billing account name.
	DisplayName *string `json:"displayName,omitempty"`
	// SoldTo - The address of the individual or organization that is responsible for the billing account.
	SoldTo *AddressDetails `json:"soldTo,omitempty"`
	// AgreementType - READ-ONLY; The type of agreement. Possible values include: 'MicrosoftCustomerAgreement', 'EnterpriseAgreement', 'MicrosoftOnlineServicesProgram', 'MicrosoftPartnerAgreement'
	AgreementType AgreementType `json:"agreementType,omitempty"`
	// AccountType - READ-ONLY; The type of customer. Possible values include: 'Enterprise', 'Individual', 'Partner'
	AccountType AccountType `json:"accountType,omitempty"`
	// AccountStatus - READ-ONLY; The current status of the billing account. Possible values include: 'Active', 'Deleted', 'Disabled', 'Expired', 'Transferred', 'Extended', 'Terminated'
	AccountStatus AccountStatus `json:"accountStatus,omitempty"`
	// BillingProfiles - The billing profiles associated with the billing account. By default this is not populated, unless it's specified in $expand.
	BillingProfiles *ProfilesOnExpand `json:"billingProfiles,omitempty"`
	// EnrollmentDetails - READ-ONLY; The details about the associated legacy enrollment. By default this is not populated, unless it's specified in $expand.
	EnrollmentDetails *Enrollment `json:"enrollmentDetails,omitempty"`
	// Departments - The departments associated to the enrollment.
	Departments *[]Department `json:"departments,omitempty"`
	// EnrollmentAccounts - The accounts associated to the enrollment.
	EnrollmentAccounts *[]EnrollmentAccount `json:"enrollmentAccounts,omitempty"`
	// HasReadAccess - READ-ONLY; Indicates whether user has read access to the billing account.
	HasReadAccess *bool `json:"hasReadAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountProperties.
func (ap AccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ap.DisplayName != nil {
		objectMap["displayName"] = ap.DisplayName
	}
	if ap.SoldTo != nil {
		objectMap["soldTo"] = ap.SoldTo
	}
	if ap.BillingProfiles != nil {
		objectMap["billingProfiles"] = ap.BillingProfiles
	}
	if ap.Departments != nil {
		objectMap["departments"] = ap.Departments
	}
	if ap.EnrollmentAccounts != nil {
		objectMap["enrollmentAccounts"] = ap.EnrollmentAccounts
	}
	return json.Marshal(objectMap)
}

// AccountsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountsClient) (Account, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountsUpdateFuture.Result.
func (future *AccountsUpdateFuture) result(client AccountsClient) (a Account, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.AccountsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		a.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.AccountsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if a.Response.Response, err = future.GetResult(sender); err == nil && a.Response.Response.StatusCode != http.StatusNoContent {
		a, err = client.UpdateResponder(a.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.AccountsUpdateFuture", "Result", a.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AccountUpdateRequest the request properties of the billing account that can be updated.
type AccountUpdateRequest struct {
	// AccountProperties - A billing property.
	*AccountProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountUpdateRequest.
func (aur AccountUpdateRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aur.AccountProperties != nil {
		objectMap["properties"] = aur.AccountProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccountUpdateRequest struct.
func (aur *AccountUpdateRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var accountProperties AccountProperties
				err = json.Unmarshal(*v, &accountProperties)
				if err != nil {
					return err
				}
				aur.AccountProperties = &accountProperties
			}
		}
	}

	return nil
}

// AddressDetails address details.
type AddressDetails struct {
	// FirstName - First name.
	FirstName *string `json:"firstName,omitempty"`
	// LastName - Last name.
	LastName *string `json:"lastName,omitempty"`
	// CompanyName - Company name.
	CompanyName *string `json:"companyName,omitempty"`
	// AddressLine1 - Address line 1.
	AddressLine1 *string `json:"addressLine1,omitempty"`
	// AddressLine2 - Address line 2.
	AddressLine2 *string `json:"addressLine2,omitempty"`
	// AddressLine3 - Address line 3.
	AddressLine3 *string `json:"addressLine3,omitempty"`
	// City - Address city.
	City *string `json:"city,omitempty"`
	// District - Address district.
	District *string `json:"district,omitempty"`
	// Region - Address region.
	Region *string `json:"region,omitempty"`
	// Country - Country code uses ISO2, 2-digit format.
	Country *string `json:"country,omitempty"`
	// PostalCode - Postal code.
	PostalCode *string `json:"postalCode,omitempty"`
	// Email - Email address.
	Email *string `json:"email,omitempty"`
	// PhoneNumber - Phone number.
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// Agreement an agreement.
type Agreement struct {
	autorest.Response `json:"-"`
	// AgreementProperties - The properties of an agreement.
	*AgreementProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Agreement.
func (a Agreement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.AgreementProperties != nil {
		objectMap["properties"] = a.AgreementProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Agreement struct.
func (a *Agreement) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var agreementProperties AgreementProperties
				err = json.Unmarshal(*v, &agreementProperties)
				if err != nil {
					return err
				}
				a.AgreementProperties = &agreementProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				a.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				a.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				a.Type = &typeVar
			}
		}
	}

	return nil
}

// AgreementListResult result of listing agreements.
type AgreementListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of agreements.
	Value *[]Agreement `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AgreementListResult.
func (alr AgreementListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AgreementListResultIterator provides access to a complete listing of Agreement values.
type AgreementListResultIterator struct {
	i    int
	page AgreementListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AgreementListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AgreementListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AgreementListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AgreementListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AgreementListResultIterator) Response() AgreementListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AgreementListResultIterator) Value() Agreement {
	if !iter.page.NotDone() {
		return Agreement{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AgreementListResultIterator type.
func NewAgreementListResultIterator(page AgreementListResultPage) AgreementListResultIterator {
	return AgreementListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (alr AgreementListResult) IsEmpty() bool {
	return alr.Value == nil || len(*alr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (alr AgreementListResult) hasNextLink() bool {
	return alr.NextLink != nil && len(*alr.NextLink) != 0
}

// agreementListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (alr AgreementListResult) agreementListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !alr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(alr.NextLink)))
}

// AgreementListResultPage contains a page of Agreement values.
type AgreementListResultPage struct {
	fn  func(context.Context, AgreementListResult) (AgreementListResult, error)
	alr AgreementListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AgreementListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AgreementListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.alr)
		if err != nil {
			return err
		}
		page.alr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AgreementListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AgreementListResultPage) NotDone() bool {
	return !page.alr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AgreementListResultPage) Response() AgreementListResult {
	return page.alr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AgreementListResultPage) Values() []Agreement {
	if page.alr.IsEmpty() {
		return nil
	}
	return *page.alr.Value
}

// Creates a new instance of the AgreementListResultPage type.
func NewAgreementListResultPage(cur AgreementListResult, getNextPage func(context.Context, AgreementListResult) (AgreementListResult, error)) AgreementListResultPage {
	return AgreementListResultPage{
		fn:  getNextPage,
		alr: cur,
	}
}

// AgreementProperties the properties of an agreement.
type AgreementProperties struct {
	// AgreementLink - READ-ONLY; The URL to download the agreement.
	AgreementLink *string `json:"agreementLink,omitempty"`
	// Category - READ-ONLY; The category of the agreement signed by a customer. Possible values include: 'CategoryMicrosoftCustomerAgreement', 'CategoryAffiliatePurchaseTerms', 'CategoryOther'
	Category Category `json:"category,omitempty"`
	// AcceptanceMode - READ-ONLY; The mode of acceptance for an agreement. Possible values include: 'ClickToAccept', 'ESignEmbedded', 'ESignOffline'
	AcceptanceMode AcceptanceMode `json:"acceptanceMode,omitempty"`
	// EffectiveDate - READ-ONLY; The date from which the agreement is effective.
	EffectiveDate *date.Time `json:"effectiveDate,omitempty"`
	// ExpirationDate - READ-ONLY; The date when the agreement expires.
	ExpirationDate *date.Time `json:"expirationDate,omitempty"`
	// Participants - The list of participants that participates in acceptance of an agreement.
	Participants *[]Participants `json:"participants,omitempty"`
	// Status - READ-ONLY; The current status of the agreement.
	Status *string `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for AgreementProperties.
func (ap AgreementProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ap.Participants != nil {
		objectMap["participants"] = ap.Participants
	}
	return json.Marshal(objectMap)
}

// Amount the amount.
type Amount struct {
	// Currency - READ-ONLY; The currency for the amount value.
	Currency *string `json:"currency,omitempty"`
	// Value - Amount value.
	Value *float64 `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for Amount.
func (a Amount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.Value != nil {
		objectMap["value"] = a.Value
	}
	return json.Marshal(objectMap)
}

// AvailableBalance the latest Azure credit balance. This is the balance available for pay now.
type AvailableBalance struct {
	autorest.Response           `json:"-"`
	*AvailableBalanceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AvailableBalance.
func (ab AvailableBalance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ab.AvailableBalanceProperties != nil {
		objectMap["properties"] = ab.AvailableBalanceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AvailableBalance struct.
func (ab *AvailableBalance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var availableBalanceProperties AvailableBalanceProperties
				err = json.Unmarshal(*v, &availableBalanceProperties)
				if err != nil {
					return err
				}
				ab.AvailableBalanceProperties = &availableBalanceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ab.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ab.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ab.Type = &typeVar
			}
		}
	}

	return nil
}

// AvailableBalanceProperties the properties of available balance.
type AvailableBalanceProperties struct {
	// Amount - READ-ONLY; Balance amount.
	Amount *Amount `json:"amount,omitempty"`
}

// MarshalJSON is the custom marshaler for AvailableBalanceProperties.
func (abp AvailableBalanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AzurePlan details of the Azure plan.
type AzurePlan struct {
	// SkuID - The sku id.
	SkuID *string `json:"skuId,omitempty"`
	// SkuDescription - READ-ONLY; The sku description.
	SkuDescription *string `json:"skuDescription,omitempty"`
}

// MarshalJSON is the custom marshaler for AzurePlan.
func (ap AzurePlan) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ap.SkuID != nil {
		objectMap["skuId"] = ap.SkuID
	}
	return json.Marshal(objectMap)
}

// Customer a partner's customer.
type Customer struct {
	autorest.Response `json:"-"`
	// CustomerProperties - The customer.
	*CustomerProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Customer.
func (c Customer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.CustomerProperties != nil {
		objectMap["properties"] = c.CustomerProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Customer struct.
func (c *Customer) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var customerProperties CustomerProperties
				err = json.Unmarshal(*v, &customerProperties)
				if err != nil {
					return err
				}
				c.CustomerProperties = &customerProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				c.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				c.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				c.Type = &typeVar
			}
		}
	}

	return nil
}

// CustomerListResult the list of customers.
type CustomerListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of customers.
	Value *[]Customer `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomerListResult.
func (clr CustomerListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// CustomerListResultIterator provides access to a complete listing of Customer values.
type CustomerListResultIterator struct {
	i    int
	page CustomerListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CustomerListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomerListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CustomerListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CustomerListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CustomerListResultIterator) Response() CustomerListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CustomerListResultIterator) Value() Customer {
	if !iter.page.NotDone() {
		return Customer{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CustomerListResultIterator type.
func NewCustomerListResultIterator(page CustomerListResultPage) CustomerListResultIterator {
	return CustomerListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (clr CustomerListResult) IsEmpty() bool {
	return clr.Value == nil || len(*clr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (clr CustomerListResult) hasNextLink() bool {
	return clr.NextLink != nil && len(*clr.NextLink) != 0
}

// customerListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (clr CustomerListResult) customerListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !clr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(clr.NextLink)))
}

// CustomerListResultPage contains a page of Customer values.
type CustomerListResultPage struct {
	fn  func(context.Context, CustomerListResult) (CustomerListResult, error)
	clr CustomerListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CustomerListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomerListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.clr)
		if err != nil {
			return err
		}
		page.clr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CustomerListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CustomerListResultPage) NotDone() bool {
	return !page.clr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CustomerListResultPage) Response() CustomerListResult {
	return page.clr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CustomerListResultPage) Values() []Customer {
	if page.clr.IsEmpty() {
		return nil
	}
	return *page.clr.Value
}

// Creates a new instance of the CustomerListResultPage type.
func NewCustomerListResultPage(cur CustomerListResult, getNextPage func(context.Context, CustomerListResult) (CustomerListResult, error)) CustomerListResultPage {
	return CustomerListResultPage{
		fn:  getNextPage,
		clr: cur,
	}
}

// CustomerPolicy the customer's Policy.
type CustomerPolicy struct {
	autorest.Response         `json:"-"`
	*CustomerPolicyProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomerPolicy.
func (cp CustomerPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.CustomerPolicyProperties != nil {
		objectMap["properties"] = cp.CustomerPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CustomerPolicy struct.
func (cp *CustomerPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var customerPolicyProperties CustomerPolicyProperties
				err = json.Unmarshal(*v, &customerPolicyProperties)
				if err != nil {
					return err
				}
				cp.CustomerPolicyProperties = &customerPolicyProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cp.Type = &typeVar
			}
		}
	}

	return nil
}

// CustomerPolicyProperties the properties of a customer's policy.
type CustomerPolicyProperties struct {
	// ViewCharges - The policy that controls whether the users in customer's organization can view charges at pay-as-you-go prices. Possible values include: 'ViewChargesAllowed', 'ViewChargesNotAllowed'
	ViewCharges ViewCharges `json:"viewCharges,omitempty"`
}

// CustomerProperties the properties of a customer.
type CustomerProperties struct {
	// BillingProfileID - READ-ONLY; The ID of the billing profile for the invoice section.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingProfileDisplayName - READ-ONLY; The name of the billing profile for the invoice section.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// DisplayName - The name of the customer.
	DisplayName *string `json:"displayName,omitempty"`
	// EnabledAzurePlans - Azure plans enabled for the customer.
	EnabledAzurePlans *[]AzurePlan `json:"enabledAzurePlans,omitempty"`
	// Resellers - The list of resellers for which an Azure plan is enabled for the customer.
	Resellers *[]Reseller `json:"resellers,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomerProperties.
func (cp CustomerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.DisplayName != nil {
		objectMap["displayName"] = cp.DisplayName
	}
	if cp.EnabledAzurePlans != nil {
		objectMap["enabledAzurePlans"] = cp.EnabledAzurePlans
	}
	if cp.Resellers != nil {
		objectMap["resellers"] = cp.Resellers
	}
	return json.Marshal(objectMap)
}

// Department a department.
type Department struct {
	// DepartmentProperties - A department.
	*DepartmentProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Department.
func (d Department) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DepartmentProperties != nil {
		objectMap["properties"] = d.DepartmentProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Department struct.
func (d *Department) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var departmentProperties DepartmentProperties
				err = json.Unmarshal(*v, &departmentProperties)
				if err != nil {
					return err
				}
				d.DepartmentProperties = &departmentProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				d.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				d.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				d.Type = &typeVar
			}
		}
	}

	return nil
}

// DepartmentProperties the properties of a department.
type DepartmentProperties struct {
	// DepartmentName - The name of the department.
	DepartmentName *string `json:"departmentName,omitempty"`
	// CostCenter - The cost center associated with the department.
	CostCenter *string `json:"costCenter,omitempty"`
	// Status - The status of the department.
	Status *string `json:"status,omitempty"`
	// EnrollmentAccounts - Associated enrollment accounts. By default this is not populated, unless it's specified in $expand.
	EnrollmentAccounts *[]EnrollmentAccount `json:"enrollmentAccounts,omitempty"`
}

// Document the properties of a document.
type Document struct {
	// Kind - READ-ONLY; The type of the document. Possible values include: 'DocumentTypeInvoice', 'DocumentTypeVoidNote', 'DocumentTypeTaxReceipt', 'DocumentTypeCreditNote'
	Kind DocumentType `json:"kind,omitempty"`
	// URL - READ-ONLY; Document URL.
	URL *string `json:"url,omitempty"`
	// Source - READ-ONLY; The source of the document. ENF for Brazil and DRS for rest of the world. Possible values include: 'DRS', 'ENF'
	Source DocumentSource `json:"source,omitempty"`
}

// MarshalJSON is the custom marshaler for Document.
func (d Document) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DownloadURL a secure URL that can be used to download a an entity until the URL expires.
type DownloadURL struct {
	autorest.Response `json:"-"`
	// ExpiryTime - READ-ONLY; The time in UTC when the download URL will expire.
	ExpiryTime *date.Time `json:"expiryTime,omitempty"`
	// URL - READ-ONLY; The URL to the PDF file.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for DownloadURL.
func (du DownloadURL) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Enrollment the properties of an enrollment.
type Enrollment struct {
	// StartDate - The start date of the enrollment.
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - The end date of the enrollment.
	EndDate *date.Time `json:"endDate,omitempty"`
	// Currency - READ-ONLY; The billing currency for the enrollment.
	Currency *string `json:"currency,omitempty"`
	// Channel - READ-ONLY; The channel type of the enrollment.
	Channel *string `json:"channel,omitempty"`
	// Policies - READ-ONLY; The policies for Enterprise Agreement enrollments.
	Policies *EnrollmentPolicies `json:"policies,omitempty"`
	// Language - READ-ONLY; The language for the enrollment.
	Language *string `json:"language,omitempty"`
	// CountryCode - READ-ONLY; The country code of the enrollment.
	CountryCode *string `json:"countryCode,omitempty"`
	// Status - READ-ONLY; The current status of the enrollment.
	Status *string `json:"status,omitempty"`
	// BillingCycle - READ-ONLY; The billing cycle for the enrollment.
	BillingCycle *string `json:"billingCycle,omitempty"`
}

// MarshalJSON is the custom marshaler for Enrollment.
func (e Enrollment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if e.StartDate != nil {
		objectMap["startDate"] = e.StartDate
	}
	if e.EndDate != nil {
		objectMap["endDate"] = e.EndDate
	}
	return json.Marshal(objectMap)
}

// EnrollmentAccount an enrollment account.
type EnrollmentAccount struct {
	// EnrollmentAccountProperties - The properties of an enrollment account.
	*EnrollmentAccountProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for EnrollmentAccount.
func (ea EnrollmentAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ea.EnrollmentAccountProperties != nil {
		objectMap["properties"] = ea.EnrollmentAccountProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for EnrollmentAccount struct.
func (ea *EnrollmentAccount) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var enrollmentAccountProperties EnrollmentAccountProperties
				err = json.Unmarshal(*v, &enrollmentAccountProperties)
				if err != nil {
					return err
				}
				ea.EnrollmentAccountProperties = &enrollmentAccountProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ea.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ea.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ea.Type = &typeVar
			}
		}
	}

	return nil
}

// EnrollmentAccountContext the enrollment account context
type EnrollmentAccountContext struct {
	// CostCenter - The cost center associated with the enrollment account.
	CostCenter *string `json:"costCenter,omitempty"`
	// StartDate - The start date of the enrollment account.
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - The end date of the enrollment account.
	EndDate *date.Time `json:"endDate,omitempty"`
	// EnrollmentAccountName - The ID of the enrollment account.
	EnrollmentAccountName *string `json:"enrollmentAccountName,omitempty"`
}

// EnrollmentAccountListResult result of listing enrollment accounts.
type EnrollmentAccountListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of enrollment accounts.
	Value *[]EnrollmentAccountSummary `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for EnrollmentAccountListResult.
func (ealr EnrollmentAccountListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// EnrollmentAccountListResultIterator provides access to a complete listing of EnrollmentAccountSummary
// values.
type EnrollmentAccountListResultIterator struct {
	i    int
	page EnrollmentAccountListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EnrollmentAccountListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EnrollmentAccountListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EnrollmentAccountListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EnrollmentAccountListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EnrollmentAccountListResultIterator) Response() EnrollmentAccountListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EnrollmentAccountListResultIterator) Value() EnrollmentAccountSummary {
	if !iter.page.NotDone() {
		return EnrollmentAccountSummary{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EnrollmentAccountListResultIterator type.
func NewEnrollmentAccountListResultIterator(page EnrollmentAccountListResultPage) EnrollmentAccountListResultIterator {
	return EnrollmentAccountListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ealr EnrollmentAccountListResult) IsEmpty() bool {
	return ealr.Value == nil || len(*ealr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ealr EnrollmentAccountListResult) hasNextLink() bool {
	return ealr.NextLink != nil && len(*ealr.NextLink) != 0
}

// enrollmentAccountListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ealr EnrollmentAccountListResult) enrollmentAccountListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ealr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ealr.NextLink)))
}

// EnrollmentAccountListResultPage contains a page of EnrollmentAccountSummary values.
type EnrollmentAccountListResultPage struct {
	fn   func(context.Context, EnrollmentAccountListResult) (EnrollmentAccountListResult, error)
	ealr EnrollmentAccountListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EnrollmentAccountListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EnrollmentAccountListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ealr)
		if err != nil {
			return err
		}
		page.ealr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EnrollmentAccountListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EnrollmentAccountListResultPage) NotDone() bool {
	return !page.ealr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EnrollmentAccountListResultPage) Response() EnrollmentAccountListResult {
	return page.ealr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EnrollmentAccountListResultPage) Values() []EnrollmentAccountSummary {
	if page.ealr.IsEmpty() {
		return nil
	}
	return *page.ealr.Value
}

// Creates a new instance of the EnrollmentAccountListResultPage type.
func NewEnrollmentAccountListResultPage(cur EnrollmentAccountListResult, getNextPage func(context.Context, EnrollmentAccountListResult) (EnrollmentAccountListResult, error)) EnrollmentAccountListResultPage {
	return EnrollmentAccountListResultPage{
		fn:   getNextPage,
		ealr: cur,
	}
}

// EnrollmentAccountProperties the properties of an enrollment account.
type EnrollmentAccountProperties struct {
	// AccountName - The name of the enrollment account.
	AccountName *string `json:"accountName,omitempty"`
	// CostCenter - The cost center associated with the enrollment account.
	CostCenter *string `json:"costCenter,omitempty"`
	// AccountOwner - The owner of the enrollment account.
	AccountOwner *string `json:"accountOwner,omitempty"`
	// Status - The status of the enrollment account.
	Status *string `json:"status,omitempty"`
	// StartDate - The start date of the enrollment account.
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - The end date of the enrollment account.
	EndDate *date.Time `json:"endDate,omitempty"`
	// Department - Associated department. By default this is not populated, unless it's specified in $expand.
	Department *Department `json:"department,omitempty"`
}

// EnrollmentAccountSummary an enrollment account resource.
type EnrollmentAccountSummary struct {
	autorest.Response `json:"-"`
	// EnrollmentAccountSummaryProperties - An enrollment account.
	*EnrollmentAccountSummaryProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for EnrollmentAccountSummary.
func (eas EnrollmentAccountSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if eas.EnrollmentAccountSummaryProperties != nil {
		objectMap["properties"] = eas.EnrollmentAccountSummaryProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for EnrollmentAccountSummary struct.
func (eas *EnrollmentAccountSummary) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var enrollmentAccountSummaryProperties EnrollmentAccountSummaryProperties
				err = json.Unmarshal(*v, &enrollmentAccountSummaryProperties)
				if err != nil {
					return err
				}
				eas.EnrollmentAccountSummaryProperties = &enrollmentAccountSummaryProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				eas.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				eas.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				eas.Type = &typeVar
			}
		}
	}

	return nil
}

// EnrollmentAccountSummaryProperties the properties of the enrollment account.
type EnrollmentAccountSummaryProperties struct {
	// PrincipalName - READ-ONLY; The account owner's principal name.
	PrincipalName *string `json:"principalName,omitempty"`
}

// MarshalJSON is the custom marshaler for EnrollmentAccountSummaryProperties.
func (easp EnrollmentAccountSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// EnrollmentPolicies the policies for Enterprise Agreement enrollments.
type EnrollmentPolicies struct {
	// AccountOwnerViewCharges - READ-ONLY; The policy that controls whether Account Owners can view charges.
	AccountOwnerViewCharges *bool `json:"accountOwnerViewCharges,omitempty"`
	// DepartmentAdminViewCharges - READ-ONLY; The policy that controls whether Department Administrators can view charges.
	DepartmentAdminViewCharges *bool `json:"departmentAdminViewCharges,omitempty"`
	// MarketplacesEnabled - READ-ONLY; The policy that controls whether Azure marketplace purchases are allowed in the enrollment.
	MarketplacesEnabled *bool `json:"marketplacesEnabled,omitempty"`
	// ReservedInstancesEnabled - READ-ONLY; The policy that controls whether Azure reservation purchases are allowed in the enrollment.
	ReservedInstancesEnabled *bool `json:"reservedInstancesEnabled,omitempty"`
}

// MarshalJSON is the custom marshaler for EnrollmentPolicies.
func (ep EnrollmentPolicies) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetails the details of the error.
type ErrorDetails struct {
	// Code - READ-ONLY; Error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The target of the particular error.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The sub details of the error.
	Details *[]ErrorSubDetailsItem `json:"details,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetails.
func (ed ErrorDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse error response indicates that the service is not able to process the incoming request. The
// reason is provided in the error message.
type ErrorResponse struct {
	// Error - The details of the error.
	Error *ErrorDetails `json:"error,omitempty"`
}

// ErrorSubDetailsItem ...
type ErrorSubDetailsItem struct {
	// Code - READ-ONLY; Error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The target of the particular error.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorSubDetailsItem.
func (esdi ErrorSubDetailsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// IndirectRelationshipInfo the billing profile details of the partner of the customer for an indirect
// motion.
type IndirectRelationshipInfo struct {
	// BillingAccountName - The billing account name of the partner or the customer for an indirect motion.
	BillingAccountName *string `json:"billingAccountName,omitempty"`
	// BillingProfileName - The billing profile name of the partner or the customer for an indirect motion.
	BillingProfileName *string `json:"billingProfileName,omitempty"`
	// DisplayName - The display name of the partner or customer for an indirect motion.
	DisplayName *string `json:"displayName,omitempty"`
}

// Instruction an instruction.
type Instruction struct {
	autorest.Response `json:"-"`
	// InstructionProperties - A billing instruction used during invoice generation.
	*InstructionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Instruction.
func (i Instruction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.InstructionProperties != nil {
		objectMap["properties"] = i.InstructionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Instruction struct.
func (i *Instruction) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var instructionProperties InstructionProperties
				err = json.Unmarshal(*v, &instructionProperties)
				if err != nil {
					return err
				}
				i.InstructionProperties = &instructionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				i.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				i.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				i.Type = &typeVar
			}
		}
	}

	return nil
}

// InstructionListResult the list of billing instructions used during invoice generation.
type InstructionListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing instructions used during invoice generation.
	Value *[]Instruction `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InstructionListResult.
func (ilr InstructionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// InstructionListResultIterator provides access to a complete listing of Instruction values.
type InstructionListResultIterator struct {
	i    int
	page InstructionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InstructionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InstructionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InstructionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InstructionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InstructionListResultIterator) Response() InstructionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InstructionListResultIterator) Value() Instruction {
	if !iter.page.NotDone() {
		return Instruction{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InstructionListResultIterator type.
func NewInstructionListResultIterator(page InstructionListResultPage) InstructionListResultIterator {
	return InstructionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ilr InstructionListResult) IsEmpty() bool {
	return ilr.Value == nil || len(*ilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ilr InstructionListResult) hasNextLink() bool {
	return ilr.NextLink != nil && len(*ilr.NextLink) != 0
}

// instructionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ilr InstructionListResult) instructionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ilr.NextLink)))
}

// InstructionListResultPage contains a page of Instruction values.
type InstructionListResultPage struct {
	fn  func(context.Context, InstructionListResult) (InstructionListResult, error)
	ilr InstructionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InstructionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InstructionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ilr)
		if err != nil {
			return err
		}
		page.ilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InstructionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InstructionListResultPage) NotDone() bool {
	return !page.ilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InstructionListResultPage) Response() InstructionListResult {
	return page.ilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InstructionListResultPage) Values() []Instruction {
	if page.ilr.IsEmpty() {
		return nil
	}
	return *page.ilr.Value
}

// Creates a new instance of the InstructionListResultPage type.
func NewInstructionListResultPage(cur InstructionListResult, getNextPage func(context.Context, InstructionListResult) (InstructionListResult, error)) InstructionListResultPage {
	return InstructionListResultPage{
		fn:  getNextPage,
		ilr: cur,
	}
}

// InstructionProperties a billing instruction used during invoice generation.
type InstructionProperties struct {
	// Amount - The amount budgeted for this billing instruction.
	Amount *float64 `json:"amount,omitempty"`
	// StartDate - The date this billing instruction goes into effect.
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - The date this billing instruction is no longer in effect.
	EndDate *date.Time `json:"endDate,omitempty"`
	// CreationDate - The date this billing instruction was created.
	CreationDate *date.Time `json:"creationDate,omitempty"`
}

// Invoice an invoice.
type Invoice struct {
	autorest.Response `json:"-"`
	// InvoiceProperties - An invoice.
	*InvoiceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Invoice.
func (i Invoice) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.InvoiceProperties != nil {
		objectMap["properties"] = i.InvoiceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Invoice struct.
func (i *Invoice) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var invoiceProperties InvoiceProperties
				err = json.Unmarshal(*v, &invoiceProperties)
				if err != nil {
					return err
				}
				i.InvoiceProperties = &invoiceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				i.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				i.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				i.Type = &typeVar
			}
		}
	}

	return nil
}

// InvoiceListResult the list of invoices.
type InvoiceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of invoices.
	Value *[]Invoice `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InvoiceListResult.
func (ilr InvoiceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// InvoiceListResultIterator provides access to a complete listing of Invoice values.
type InvoiceListResultIterator struct {
	i    int
	page InvoiceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InvoiceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvoiceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InvoiceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InvoiceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InvoiceListResultIterator) Response() InvoiceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InvoiceListResultIterator) Value() Invoice {
	if !iter.page.NotDone() {
		return Invoice{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InvoiceListResultIterator type.
func NewInvoiceListResultIterator(page InvoiceListResultPage) InvoiceListResultIterator {
	return InvoiceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ilr InvoiceListResult) IsEmpty() bool {
	return ilr.Value == nil || len(*ilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ilr InvoiceListResult) hasNextLink() bool {
	return ilr.NextLink != nil && len(*ilr.NextLink) != 0
}

// invoiceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ilr InvoiceListResult) invoiceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ilr.NextLink)))
}

// InvoiceListResultPage contains a page of Invoice values.
type InvoiceListResultPage struct {
	fn  func(context.Context, InvoiceListResult) (InvoiceListResult, error)
	ilr InvoiceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InvoiceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvoiceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ilr)
		if err != nil {
			return err
		}
		page.ilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InvoiceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InvoiceListResultPage) NotDone() bool {
	return !page.ilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InvoiceListResultPage) Response() InvoiceListResult {
	return page.ilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InvoiceListResultPage) Values() []Invoice {
	if page.ilr.IsEmpty() {
		return nil
	}
	return *page.ilr.Value
}

// Creates a new instance of the InvoiceListResultPage type.
func NewInvoiceListResultPage(cur InvoiceListResult, getNextPage func(context.Context, InvoiceListResult) (InvoiceListResult, error)) InvoiceListResultPage {
	return InvoiceListResultPage{
		fn:  getNextPage,
		ilr: cur,
	}
}

// InvoiceProperties the properties of the invoice.
type InvoiceProperties struct {
	// DueDate - READ-ONLY; The due date for the invoice.
	DueDate *date.Time `json:"dueDate,omitempty"`
	// InvoiceDate - READ-ONLY; The date when the invoice was generated.
	InvoiceDate *date.Time `json:"invoiceDate,omitempty"`
	// Status - READ-ONLY; The current status of the invoice. Possible values include: 'Due', 'OverDue', 'Paid', 'Void'
	Status InvoiceStatus `json:"status,omitempty"`
	// AmountDue - READ-ONLY; The amount due as of now.
	AmountDue *Amount `json:"amountDue,omitempty"`
	// AzurePrepaymentApplied - READ-ONLY; The amount of Azure prepayment applied to the charges. This field is applicable to billing accounts with agreement type Microsoft Customer Agreement.
	AzurePrepaymentApplied *Amount `json:"azurePrepaymentApplied,omitempty"`
	// BilledAmount - READ-ONLY; The total charges for the invoice billing period.
	BilledAmount *Amount `json:"billedAmount,omitempty"`
	// CreditAmount - READ-ONLY; The total refund for returns and cancellations during the invoice billing period. This field is applicable to billing accounts with agreement type Microsoft Customer Agreement.
	CreditAmount *Amount `json:"creditAmount,omitempty"`
	// FreeAzureCreditApplied - READ-ONLY; The amount of free Azure credits applied to the charges. This field is applicable to billing accounts with agreement type Microsoft Customer Agreement.
	FreeAzureCreditApplied *Amount `json:"freeAzureCreditApplied,omitempty"`
	// SubTotal - READ-ONLY; The pre-tax amount due. This field is applicable to billing accounts with agreement type Microsoft Customer Agreement.
	SubTotal *Amount `json:"subTotal,omitempty"`
	// TaxAmount - READ-ONLY; The amount of tax charged for the billing period. This field is applicable to billing accounts with agreement type Microsoft Customer Agreement.
	TaxAmount *Amount `json:"taxAmount,omitempty"`
	// TotalAmount - READ-ONLY; The amount due when the invoice was generated. This field is applicable to billing accounts with agreement type Microsoft Customer Agreement.
	TotalAmount *Amount `json:"totalAmount,omitempty"`
	// InvoicePeriodStartDate - READ-ONLY; The start date of the billing period for which the invoice is generated.
	InvoicePeriodStartDate *date.Time `json:"invoicePeriodStartDate,omitempty"`
	// InvoicePeriodEndDate - READ-ONLY; The end date of the billing period for which the invoice is generated.
	InvoicePeriodEndDate *date.Time `json:"invoicePeriodEndDate,omitempty"`
	// InvoiceType - READ-ONLY; Invoice type. Possible values include: 'AzureService', 'AzureMarketplace', 'AzureSupport'
	InvoiceType InvoiceType `json:"invoiceType,omitempty"`
	// IsMonthlyInvoice - READ-ONLY; Specifies if the invoice is generated as part of monthly invoicing cycle or not. This field is applicable to billing accounts with agreement type Microsoft Customer Agreement.
	IsMonthlyInvoice *bool `json:"isMonthlyInvoice,omitempty"`
	// BillingProfileID - READ-ONLY; The ID of the billing profile for which the invoice is generated.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingProfileDisplayName - READ-ONLY; The name of the billing profile for which the invoice is generated.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// PurchaseOrderNumber - READ-ONLY; An optional purchase order number for the invoice.
	PurchaseOrderNumber *string `json:"purchaseOrderNumber,omitempty"`
	// Documents - READ-ONLY; List of documents available to download such as invoice and tax receipt.
	Documents *[]Document `json:"documents,omitempty"`
	// Payments - READ-ONLY; List of payments.
	Payments *[]PaymentProperties `json:"payments,omitempty"`
	// RebillDetails - READ-ONLY; Rebill details for an invoice.
	RebillDetails map[string]*RebillDetails `json:"rebillDetails"`
	// DocumentType - READ-ONLY; The type of the document. Possible values include: 'InvoiceDocumentTypeInvoice', 'InvoiceDocumentTypeCreditNote'
	DocumentType InvoiceDocumentType `json:"documentType,omitempty"`
	// BilledDocumentID - READ-ONLY; The Id of the active invoice which is originally billed after this invoice was voided. This field is applicable to the void invoices only.
	BilledDocumentID *string `json:"billedDocumentId,omitempty"`
	// CreditForDocumentID - READ-ONLY; The Id of the invoice which got voided and this credit note was issued as a result. This field is applicable to the credit notes only.
	CreditForDocumentID *string `json:"creditForDocumentId,omitempty"`
	// SubscriptionID - READ-ONLY; The ID of the subscription for which the invoice is generated.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
}

// MarshalJSON is the custom marshaler for InvoiceProperties.
func (IP InvoiceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// InvoicesDownloadBillingSubscriptionInvoiceFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type InvoicesDownloadBillingSubscriptionInvoiceFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InvoicesClient) (DownloadURL, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InvoicesDownloadBillingSubscriptionInvoiceFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InvoicesDownloadBillingSubscriptionInvoiceFuture.Result.
func (future *InvoicesDownloadBillingSubscriptionInvoiceFuture) result(client InvoicesClient) (du DownloadURL, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.InvoicesDownloadBillingSubscriptionInvoiceFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		du.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.InvoicesDownloadBillingSubscriptionInvoiceFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if du.Response.Response, err = future.GetResult(sender); err == nil && du.Response.Response.StatusCode != http.StatusNoContent {
		du, err = client.DownloadBillingSubscriptionInvoiceResponder(du.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.InvoicesDownloadBillingSubscriptionInvoiceFuture", "Result", du.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InvoicesDownloadInvoiceFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type InvoicesDownloadInvoiceFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InvoicesClient) (DownloadURL, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InvoicesDownloadInvoiceFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InvoicesDownloadInvoiceFuture.Result.
func (future *InvoicesDownloadInvoiceFuture) result(client InvoicesClient) (du DownloadURL, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.InvoicesDownloadInvoiceFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		du.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.InvoicesDownloadInvoiceFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if du.Response.Response, err = future.GetResult(sender); err == nil && du.Response.Response.StatusCode != http.StatusNoContent {
		du, err = client.DownloadInvoiceResponder(du.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.InvoicesDownloadInvoiceFuture", "Result", du.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InvoicesDownloadMultipleBillingProfileInvoicesFuture an abstraction for monitoring and retrieving the
// results of a long-running operation.
type InvoicesDownloadMultipleBillingProfileInvoicesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InvoicesClient) (DownloadURL, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InvoicesDownloadMultipleBillingProfileInvoicesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InvoicesDownloadMultipleBillingProfileInvoicesFuture.Result.
func (future *InvoicesDownloadMultipleBillingProfileInvoicesFuture) result(client InvoicesClient) (du DownloadURL, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.InvoicesDownloadMultipleBillingProfileInvoicesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		du.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.InvoicesDownloadMultipleBillingProfileInvoicesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if du.Response.Response, err = future.GetResult(sender); err == nil && du.Response.Response.StatusCode != http.StatusNoContent {
		du, err = client.DownloadMultipleBillingProfileInvoicesResponder(du.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.InvoicesDownloadMultipleBillingProfileInvoicesFuture", "Result", du.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InvoicesDownloadMultipleBillingSubscriptionInvoicesFuture an abstraction for monitoring and retrieving
// the results of a long-running operation.
type InvoicesDownloadMultipleBillingSubscriptionInvoicesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InvoicesClient) (DownloadURL, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InvoicesDownloadMultipleBillingSubscriptionInvoicesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InvoicesDownloadMultipleBillingSubscriptionInvoicesFuture.Result.
func (future *InvoicesDownloadMultipleBillingSubscriptionInvoicesFuture) result(client InvoicesClient) (du DownloadURL, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.InvoicesDownloadMultipleBillingSubscriptionInvoicesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		du.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.InvoicesDownloadMultipleBillingSubscriptionInvoicesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if du.Response.Response, err = future.GetResult(sender); err == nil && du.Response.Response.StatusCode != http.StatusNoContent {
		du, err = client.DownloadMultipleBillingSubscriptionInvoicesResponder(du.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.InvoicesDownloadMultipleBillingSubscriptionInvoicesFuture", "Result", du.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InvoiceSection an invoice section.
type InvoiceSection struct {
	autorest.Response `json:"-"`
	// InvoiceSectionProperties - The properties of an invoice section.
	*InvoiceSectionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for InvoiceSection.
func (is InvoiceSection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if is.InvoiceSectionProperties != nil {
		objectMap["properties"] = is.InvoiceSectionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InvoiceSection struct.
func (is *InvoiceSection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var invoiceSectionProperties InvoiceSectionProperties
				err = json.Unmarshal(*v, &invoiceSectionProperties)
				if err != nil {
					return err
				}
				is.InvoiceSectionProperties = &invoiceSectionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				is.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				is.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				is.Type = &typeVar
			}
		}
	}

	return nil
}

// InvoiceSectionCreationRequest the properties of the invoice section.
type InvoiceSectionCreationRequest struct {
	// DisplayName - The name of the invoice section.
	DisplayName *string `json:"displayName,omitempty"`
}

// InvoiceSectionListResult the list of invoice sections.
type InvoiceSectionListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of invoice sections.
	Value *[]InvoiceSection `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InvoiceSectionListResult.
func (islr InvoiceSectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// InvoiceSectionListResultIterator provides access to a complete listing of InvoiceSection values.
type InvoiceSectionListResultIterator struct {
	i    int
	page InvoiceSectionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InvoiceSectionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvoiceSectionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InvoiceSectionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InvoiceSectionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InvoiceSectionListResultIterator) Response() InvoiceSectionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InvoiceSectionListResultIterator) Value() InvoiceSection {
	if !iter.page.NotDone() {
		return InvoiceSection{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InvoiceSectionListResultIterator type.
func NewInvoiceSectionListResultIterator(page InvoiceSectionListResultPage) InvoiceSectionListResultIterator {
	return InvoiceSectionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (islr InvoiceSectionListResult) IsEmpty() bool {
	return islr.Value == nil || len(*islr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (islr InvoiceSectionListResult) hasNextLink() bool {
	return islr.NextLink != nil && len(*islr.NextLink) != 0
}

// invoiceSectionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (islr InvoiceSectionListResult) invoiceSectionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !islr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(islr.NextLink)))
}

// InvoiceSectionListResultPage contains a page of InvoiceSection values.
type InvoiceSectionListResultPage struct {
	fn   func(context.Context, InvoiceSectionListResult) (InvoiceSectionListResult, error)
	islr InvoiceSectionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InvoiceSectionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvoiceSectionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.islr)
		if err != nil {
			return err
		}
		page.islr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InvoiceSectionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InvoiceSectionListResultPage) NotDone() bool {
	return !page.islr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InvoiceSectionListResultPage) Response() InvoiceSectionListResult {
	return page.islr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InvoiceSectionListResultPage) Values() []InvoiceSection {
	if page.islr.IsEmpty() {
		return nil
	}
	return *page.islr.Value
}

// Creates a new instance of the InvoiceSectionListResultPage type.
func NewInvoiceSectionListResultPage(cur InvoiceSectionListResult, getNextPage func(context.Context, InvoiceSectionListResult) (InvoiceSectionListResult, error)) InvoiceSectionListResultPage {
	return InvoiceSectionListResultPage{
		fn:   getNextPage,
		islr: cur,
	}
}

// InvoiceSectionListWithCreateSubPermissionResult the list of invoice section properties with create
// subscription permission.
type InvoiceSectionListWithCreateSubPermissionResult struct {
	autorest.Response `json:"-"`
	// Value - The list of invoice section properties with create subscription permission.
	Value *[]InvoiceSectionWithCreateSubPermission `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for InvoiceSectionListWithCreateSubPermissionResult.
func (islwcspr InvoiceSectionListWithCreateSubPermissionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if islwcspr.Value != nil {
		objectMap["value"] = islwcspr.Value
	}
	return json.Marshal(objectMap)
}

// InvoiceSectionListWithCreateSubPermissionResultIterator provides access to a complete listing of
// InvoiceSectionWithCreateSubPermission values.
type InvoiceSectionListWithCreateSubPermissionResultIterator struct {
	i    int
	page InvoiceSectionListWithCreateSubPermissionResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InvoiceSectionListWithCreateSubPermissionResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvoiceSectionListWithCreateSubPermissionResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InvoiceSectionListWithCreateSubPermissionResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InvoiceSectionListWithCreateSubPermissionResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InvoiceSectionListWithCreateSubPermissionResultIterator) Response() InvoiceSectionListWithCreateSubPermissionResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InvoiceSectionListWithCreateSubPermissionResultIterator) Value() InvoiceSectionWithCreateSubPermission {
	if !iter.page.NotDone() {
		return InvoiceSectionWithCreateSubPermission{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InvoiceSectionListWithCreateSubPermissionResultIterator type.
func NewInvoiceSectionListWithCreateSubPermissionResultIterator(page InvoiceSectionListWithCreateSubPermissionResultPage) InvoiceSectionListWithCreateSubPermissionResultIterator {
	return InvoiceSectionListWithCreateSubPermissionResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (islwcspr InvoiceSectionListWithCreateSubPermissionResult) IsEmpty() bool {
	return islwcspr.Value == nil || len(*islwcspr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (islwcspr InvoiceSectionListWithCreateSubPermissionResult) hasNextLink() bool {
	return islwcspr.NextLink != nil && len(*islwcspr.NextLink) != 0
}

// invoiceSectionListWithCreateSubPermissionResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (islwcspr InvoiceSectionListWithCreateSubPermissionResult) invoiceSectionListWithCreateSubPermissionResultPreparer(ctx context.Context) (*http.Request, error) {
	if !islwcspr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(islwcspr.NextLink)))
}

// InvoiceSectionListWithCreateSubPermissionResultPage contains a page of
// InvoiceSectionWithCreateSubPermission values.
type InvoiceSectionListWithCreateSubPermissionResultPage struct {
	fn       func(context.Context, InvoiceSectionListWithCreateSubPermissionResult) (InvoiceSectionListWithCreateSubPermissionResult, error)
	islwcspr InvoiceSectionListWithCreateSubPermissionResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InvoiceSectionListWithCreateSubPermissionResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvoiceSectionListWithCreateSubPermissionResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.islwcspr)
		if err != nil {
			return err
		}
		page.islwcspr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InvoiceSectionListWithCreateSubPermissionResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InvoiceSectionListWithCreateSubPermissionResultPage) NotDone() bool {
	return !page.islwcspr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InvoiceSectionListWithCreateSubPermissionResultPage) Response() InvoiceSectionListWithCreateSubPermissionResult {
	return page.islwcspr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InvoiceSectionListWithCreateSubPermissionResultPage) Values() []InvoiceSectionWithCreateSubPermission {
	if page.islwcspr.IsEmpty() {
		return nil
	}
	return *page.islwcspr.Value
}

// Creates a new instance of the InvoiceSectionListWithCreateSubPermissionResultPage type.
func NewInvoiceSectionListWithCreateSubPermissionResultPage(cur InvoiceSectionListWithCreateSubPermissionResult, getNextPage func(context.Context, InvoiceSectionListWithCreateSubPermissionResult) (InvoiceSectionListWithCreateSubPermissionResult, error)) InvoiceSectionListWithCreateSubPermissionResultPage {
	return InvoiceSectionListWithCreateSubPermissionResultPage{
		fn:       getNextPage,
		islwcspr: cur,
	}
}

// InvoiceSectionProperties the properties of an invoice section.
type InvoiceSectionProperties struct {
	// DisplayName - The name of the invoice section.
	DisplayName *string `json:"displayName,omitempty"`
	// Labels - Dictionary of metadata associated with the invoice section.
	Labels map[string]*string `json:"labels"`
	// State - READ-ONLY; Identifies the state of an invoice section. Possible values include: 'InvoiceSectionStateActive', 'InvoiceSectionStateRestricted'
	State InvoiceSectionState `json:"state,omitempty"`
	// SystemID - READ-ONLY; The system generated unique identifier for an invoice section.
	SystemID *string `json:"systemId,omitempty"`
	// TargetCloud - READ-ONLY; Identifies the cloud environments that are associated with an invoice section. This is a system managed optional field and gets updated as the invoice section gets associated with accounts in various clouds. Possible values include: 'USGov', 'USNat', 'USSec'
	TargetCloud TargetCloud `json:"targetCloud,omitempty"`
}

// MarshalJSON is the custom marshaler for InvoiceSectionProperties.
func (isp InvoiceSectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if isp.DisplayName != nil {
		objectMap["displayName"] = isp.DisplayName
	}
	if isp.Labels != nil {
		objectMap["labels"] = isp.Labels
	}
	return json.Marshal(objectMap)
}

// InvoiceSectionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type InvoiceSectionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(InvoiceSectionsClient) (InvoiceSection, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *InvoiceSectionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for InvoiceSectionsCreateOrUpdateFuture.Result.
func (future *InvoiceSectionsCreateOrUpdateFuture) result(client InvoiceSectionsClient) (is InvoiceSection, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.InvoiceSectionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		is.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.InvoiceSectionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if is.Response.Response, err = future.GetResult(sender); err == nil && is.Response.Response.StatusCode != http.StatusNoContent {
		is, err = client.CreateOrUpdateResponder(is.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.InvoiceSectionsCreateOrUpdateFuture", "Result", is.Response.Response, "Failure responding to request")
		}
	}
	return
}

// InvoiceSectionsOnExpand the invoice sections associated to the billing profile. By default this is not
// populated, unless it's specified in $expand.
type InvoiceSectionsOnExpand struct {
	// HasMoreResults - READ-ONLY; Indicates whether there are more invoice sections than the ones listed in this collection. The collection lists a maximum of 50 invoice sections. To get all invoice sections, use the list invoice sections API.
	HasMoreResults *bool `json:"hasMoreResults,omitempty"`
	// Value - The invoice sections associated to the billing profile.
	Value *[]InvoiceSection `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for InvoiceSectionsOnExpand.
func (isoe InvoiceSectionsOnExpand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if isoe.Value != nil {
		objectMap["value"] = isoe.Value
	}
	return json.Marshal(objectMap)
}

// InvoiceSectionWithCreateSubPermission invoice section properties with create subscription permission.
type InvoiceSectionWithCreateSubPermission struct {
	// InvoiceSectionID - READ-ONLY; The ID of the invoice section.
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty"`
	// InvoiceSectionDisplayName - READ-ONLY; The name of the invoice section.
	InvoiceSectionDisplayName *string `json:"invoiceSectionDisplayName,omitempty"`
	// InvoiceSectionSystemID - READ-ONLY; The system generated unique identifier for an invoice section.
	InvoiceSectionSystemID *string `json:"invoiceSectionSystemId,omitempty"`
	// BillingProfileID - READ-ONLY; The ID of the billing profile for the invoice section.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingProfileDisplayName - READ-ONLY; The name of the billing profile for the invoice section.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// BillingProfileStatus - READ-ONLY; The status of the billing profile. Possible values include: 'ProfileStatusActive', 'ProfileStatusDisabled', 'ProfileStatusWarned'
	BillingProfileStatus ProfileStatus `json:"billingProfileStatus,omitempty"`
	// BillingProfileStatusReasonCode - READ-ONLY; Reason for the specified billing profile status. Possible values include: 'StatusReasonCodeForBillingProfilePastDue', 'StatusReasonCodeForBillingProfileSpendingLimitReached', 'StatusReasonCodeForBillingProfileSpendingLimitExpired'
	BillingProfileStatusReasonCode StatusReasonCodeForBillingProfile `json:"billingProfileStatusReasonCode,omitempty"`
	// BillingProfileSpendingLimit - READ-ONLY; The billing profile spending limit. Possible values include: 'SpendingLimitForBillingProfileOff', 'SpendingLimitForBillingProfileOn'
	BillingProfileSpendingLimit SpendingLimitForBillingProfile `json:"billingProfileSpendingLimit,omitempty"`
	// BillingProfileSystemID - READ-ONLY; The system generated unique identifier for a billing profile.
	BillingProfileSystemID *string `json:"billingProfileSystemId,omitempty"`
	// EnabledAzurePlans - Enabled azure plans for the associated billing profile.
	EnabledAzurePlans *[]AzurePlan `json:"enabledAzurePlans,omitempty"`
}

// MarshalJSON is the custom marshaler for InvoiceSectionWithCreateSubPermission.
func (iswcsp InvoiceSectionWithCreateSubPermission) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if iswcsp.EnabledAzurePlans != nil {
		objectMap["enabledAzurePlans"] = iswcsp.EnabledAzurePlans
	}
	return json.Marshal(objectMap)
}

// Operation a Billing REST API operation.
type Operation struct {
	// Name - READ-ONLY; Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty"`
	// Display - The object that represents the operation.
	Display *OperationDisplay `json:"display,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	return json.Marshal(objectMap)
}

// OperationDisplay the object that represents the operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; Service provider: Microsoft.Billing.
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; Resource on which the operation is performed such as invoice and billing subscription.
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; Operation type such as read, write and delete.
	Operation *string `json:"operation,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult the list of billing operations and a URL link to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing operations supported by the Microsoft.Billing resource provider.
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// Participants the details about a participant.
type Participants struct {
	// Status - READ-ONLY; The acceptance status of the participant.
	Status *string `json:"status,omitempty"`
	// StatusDate - READ-ONLY; The date when the status got changed.
	StatusDate *date.Time `json:"statusDate,omitempty"`
	// Email - READ-ONLY; The email address of the participant.
	Email *string `json:"email,omitempty"`
}

// MarshalJSON is the custom marshaler for Participants.
func (p Participants) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PaymentProperties the properties of a payment.
type PaymentProperties struct {
	// PaymentType - READ-ONLY; The type of payment.
	PaymentType *string `json:"paymentType,omitempty"`
	// Amount - READ-ONLY; The paid amount.
	Amount *Amount `json:"amount,omitempty"`
	// Date - READ-ONLY; The date when the payment was made.
	Date *date.Time `json:"date,omitempty"`
	// PaymentMethodFamily - The family of payment method. Possible values include: 'Credits', 'CheckWire', 'CreditCard', 'None'
	PaymentMethodFamily PaymentMethodFamily `json:"paymentMethodFamily,omitempty"`
	// PaymentMethodType - READ-ONLY; The type of payment method.
	PaymentMethodType *string `json:"paymentMethodType,omitempty"`
}

// MarshalJSON is the custom marshaler for PaymentProperties.
func (pp PaymentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.PaymentMethodFamily != "" {
		objectMap["paymentMethodFamily"] = pp.PaymentMethodFamily
	}
	return json.Marshal(objectMap)
}

// Period a billing period resource.
type Period struct {
	autorest.Response `json:"-"`
	// PeriodProperties - A billing period.
	*PeriodProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Period.
func (p Period) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.PeriodProperties != nil {
		objectMap["properties"] = p.PeriodProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Period struct.
func (p *Period) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var periodProperties PeriodProperties
				err = json.Unmarshal(*v, &periodProperties)
				if err != nil {
					return err
				}
				p.PeriodProperties = &periodProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// PeriodProperties the properties of the billing period.
type PeriodProperties struct {
	// BillingPeriodStartDate - READ-ONLY; The start of the date range covered by the billing period.
	BillingPeriodStartDate *date.Date `json:"billingPeriodStartDate,omitempty"`
	// BillingPeriodEndDate - READ-ONLY; The end of the date range covered by the billing period.
	BillingPeriodEndDate *date.Date `json:"billingPeriodEndDate,omitempty"`
	// InvoiceIds - READ-ONLY; Array of invoice ids that associated with.
	InvoiceIds *[]string `json:"invoiceIds,omitempty"`
}

// MarshalJSON is the custom marshaler for PeriodProperties.
func (pp PeriodProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PeriodsListResult result of listing billing periods. It contains a list of available billing periods in
// reverse chronological order.
type PeriodsListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing periods.
	Value *[]Period `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PeriodsListResult.
func (plr PeriodsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PeriodsListResultIterator provides access to a complete listing of Period values.
type PeriodsListResultIterator struct {
	i    int
	page PeriodsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PeriodsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PeriodsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PeriodsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PeriodsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PeriodsListResultIterator) Response() PeriodsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PeriodsListResultIterator) Value() Period {
	if !iter.page.NotDone() {
		return Period{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PeriodsListResultIterator type.
func NewPeriodsListResultIterator(page PeriodsListResultPage) PeriodsListResultIterator {
	return PeriodsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plr PeriodsListResult) IsEmpty() bool {
	return plr.Value == nil || len(*plr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plr PeriodsListResult) hasNextLink() bool {
	return plr.NextLink != nil && len(*plr.NextLink) != 0
}

// periodsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plr PeriodsListResult) periodsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plr.NextLink)))
}

// PeriodsListResultPage contains a page of Period values.
type PeriodsListResultPage struct {
	fn  func(context.Context, PeriodsListResult) (PeriodsListResult, error)
	plr PeriodsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PeriodsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PeriodsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plr)
		if err != nil {
			return err
		}
		page.plr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PeriodsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PeriodsListResultPage) NotDone() bool {
	return !page.plr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PeriodsListResultPage) Response() PeriodsListResult {
	return page.plr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PeriodsListResultPage) Values() []Period {
	if page.plr.IsEmpty() {
		return nil
	}
	return *page.plr.Value
}

// Creates a new instance of the PeriodsListResultPage type.
func NewPeriodsListResultPage(cur PeriodsListResult, getNextPage func(context.Context, PeriodsListResult) (PeriodsListResult, error)) PeriodsListResultPage {
	return PeriodsListResultPage{
		fn:  getNextPage,
		plr: cur,
	}
}

// PermissionsListResult result of list billingPermissions a caller has on a billing account.
type PermissionsListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billingPermissions a caller has on a billing account.
	Value *[]PermissionsProperties `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PermissionsListResult.
func (plr PermissionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PermissionsListResultIterator provides access to a complete listing of PermissionsProperties values.
type PermissionsListResultIterator struct {
	i    int
	page PermissionsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PermissionsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PermissionsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PermissionsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PermissionsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PermissionsListResultIterator) Response() PermissionsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PermissionsListResultIterator) Value() PermissionsProperties {
	if !iter.page.NotDone() {
		return PermissionsProperties{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PermissionsListResultIterator type.
func NewPermissionsListResultIterator(page PermissionsListResultPage) PermissionsListResultIterator {
	return PermissionsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plr PermissionsListResult) IsEmpty() bool {
	return plr.Value == nil || len(*plr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plr PermissionsListResult) hasNextLink() bool {
	return plr.NextLink != nil && len(*plr.NextLink) != 0
}

// permissionsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plr PermissionsListResult) permissionsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plr.NextLink)))
}

// PermissionsListResultPage contains a page of PermissionsProperties values.
type PermissionsListResultPage struct {
	fn  func(context.Context, PermissionsListResult) (PermissionsListResult, error)
	plr PermissionsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PermissionsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PermissionsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plr)
		if err != nil {
			return err
		}
		page.plr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PermissionsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PermissionsListResultPage) NotDone() bool {
	return !page.plr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PermissionsListResultPage) Response() PermissionsListResult {
	return page.plr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PermissionsListResultPage) Values() []PermissionsProperties {
	if page.plr.IsEmpty() {
		return nil
	}
	return *page.plr.Value
}

// Creates a new instance of the PermissionsListResultPage type.
func NewPermissionsListResultPage(cur PermissionsListResult, getNextPage func(context.Context, PermissionsListResult) (PermissionsListResult, error)) PermissionsListResultPage {
	return PermissionsListResultPage{
		fn:  getNextPage,
		plr: cur,
	}
}

// PermissionsProperties the set of allowed action and not allowed actions a caller has on a billing
// account
type PermissionsProperties struct {
	// Actions - READ-ONLY; The set of actions that the caller is allowed to perform.
	Actions *[]string `json:"actions,omitempty"`
	// NotActions - READ-ONLY; The set of actions that the caller is not allowed to perform.
	NotActions *[]string `json:"notActions,omitempty"`
}

// MarshalJSON is the custom marshaler for PermissionsProperties.
func (pp PermissionsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Policy a policy.
type Policy struct {
	autorest.Response `json:"-"`
	*PolicyProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Policy.
func (p Policy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.PolicyProperties != nil {
		objectMap["properties"] = p.PolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Policy struct.
func (p *Policy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var policyProperties PolicyProperties
				err = json.Unmarshal(*v, &policyProperties)
				if err != nil {
					return err
				}
				p.PolicyProperties = &policyProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// PolicyProperties the properties of a policy.
type PolicyProperties struct {
	// MarketplacePurchases - The policy that controls whether Azure marketplace purchases are allowed for a billing profile. Possible values include: 'AllAllowed', 'OnlyFreeAllowed', 'NotAllowed'
	MarketplacePurchases MarketplacePurchasesPolicy `json:"marketplacePurchases,omitempty"`
	// ReservationPurchases - The policy that controls whether Azure reservation purchases are allowed for a billing profile. Possible values include: 'ReservationPurchasesPolicyAllowed', 'ReservationPurchasesPolicyNotAllowed'
	ReservationPurchases ReservationPurchasesPolicy `json:"reservationPurchases,omitempty"`
	// ViewCharges - The policy that controls whether users with Azure RBAC access to a subscription can view its charges. Possible values include: 'ViewChargesPolicyAllowed', 'ViewChargesPolicyNotAllowed'
	ViewCharges ViewChargesPolicy `json:"viewCharges,omitempty"`
}

// Product a product.
type Product struct {
	autorest.Response  `json:"-"`
	*ProductProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Product.
func (p Product) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ProductProperties != nil {
		objectMap["properties"] = p.ProductProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Product struct.
func (p *Product) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var productProperties ProductProperties
				err = json.Unmarshal(*v, &productProperties)
				if err != nil {
					return err
				}
				p.ProductProperties = &productProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// ProductProperties the properties of a product.
type ProductProperties struct {
	// AutoRenew - Indicates whether auto renewal is turned on or off for a product. Possible values include: 'Off', 'On'
	AutoRenew AutoRenew `json:"autoRenew,omitempty"`
	// DisplayName - READ-ONLY; The display name of the product.
	DisplayName *string `json:"displayName,omitempty"`
	// PurchaseDate - READ-ONLY; The date when the product was purchased.
	PurchaseDate *date.Time `json:"purchaseDate,omitempty"`
	// ProductTypeID - READ-ONLY; The ID of the type of product.
	ProductTypeID *string `json:"productTypeId,omitempty"`
	// ProductType - READ-ONLY; The description of the type of product.
	ProductType *string `json:"productType,omitempty"`
	// Status - The current status of the product. Possible values include: 'ProductStatusTypeActive', 'ProductStatusTypeInactive', 'ProductStatusTypePastDue', 'ProductStatusTypeExpiring', 'ProductStatusTypeExpired', 'ProductStatusTypeDisabled', 'ProductStatusTypeCancelled', 'ProductStatusTypeAutoRenew'
	Status ProductStatusType `json:"status,omitempty"`
	// EndDate - READ-ONLY; The date when the product will be renewed or canceled.
	EndDate *date.Time `json:"endDate,omitempty"`
	// BillingFrequency - The frequency at which the product will be billed. Possible values include: 'OneTime', 'Monthly', 'UsageBased'
	BillingFrequency Frequency `json:"billingFrequency,omitempty"`
	// LastCharge - READ-ONLY; The last month charges.
	LastCharge *Amount `json:"lastCharge,omitempty"`
	// LastChargeDate - READ-ONLY; The date of the last charge.
	LastChargeDate *date.Time `json:"lastChargeDate,omitempty"`
	// Quantity - READ-ONLY; The quantity purchased for the product.
	Quantity *float64 `json:"quantity,omitempty"`
	// SkuID - READ-ONLY; The sku ID of the product.
	SkuID *string `json:"skuId,omitempty"`
	// SkuDescription - READ-ONLY; The sku description of the product.
	SkuDescription *string `json:"skuDescription,omitempty"`
	// TenantID - READ-ONLY; The id of the tenant in which the product is used.
	TenantID *string `json:"tenantId,omitempty"`
	// AvailabilityID - READ-ONLY; The availability of the product.
	AvailabilityID *string `json:"availabilityId,omitempty"`
	// InvoiceSectionID - READ-ONLY; The ID of the invoice section to which the product is billed.
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty"`
	// InvoiceSectionDisplayName - READ-ONLY; The name of the invoice section to which the product is billed.
	InvoiceSectionDisplayName *string `json:"invoiceSectionDisplayName,omitempty"`
	// BillingProfileID - READ-ONLY; The ID of the billing profile to which the product is billed.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingProfileDisplayName - READ-ONLY; The name of the billing profile to which the product is billed.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// CustomerID - READ-ONLY; The ID of the customer for whom the product was purchased. The field is applicable only for Microsoft Partner Agreement billing account.
	CustomerID *string `json:"customerId,omitempty"`
	// CustomerDisplayName - READ-ONLY; The name of the customer for whom the product was purchased. The field is applicable only for Microsoft Partner Agreement billing account.
	CustomerDisplayName *string `json:"customerDisplayName,omitempty"`
	// Reseller - READ-ONLY; Reseller for this product.
	Reseller *Reseller `json:"reseller,omitempty"`
}

// MarshalJSON is the custom marshaler for ProductProperties.
func (pp ProductProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.AutoRenew != "" {
		objectMap["autoRenew"] = pp.AutoRenew
	}
	if pp.Status != "" {
		objectMap["status"] = pp.Status
	}
	if pp.BillingFrequency != "" {
		objectMap["billingFrequency"] = pp.BillingFrequency
	}
	return json.Marshal(objectMap)
}

// ProductsListResult the list of products. It contains a list of available product summaries in reverse
// chronological order by purchase date.
type ProductsListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of products.
	Value *[]Product `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ProductsListResult.
func (plr ProductsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ProductsListResultIterator provides access to a complete listing of Product values.
type ProductsListResultIterator struct {
	i    int
	page ProductsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProductsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProductsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProductsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProductsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProductsListResultIterator) Response() ProductsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProductsListResultIterator) Value() Product {
	if !iter.page.NotDone() {
		return Product{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProductsListResultIterator type.
func NewProductsListResultIterator(page ProductsListResultPage) ProductsListResultIterator {
	return ProductsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plr ProductsListResult) IsEmpty() bool {
	return plr.Value == nil || len(*plr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plr ProductsListResult) hasNextLink() bool {
	return plr.NextLink != nil && len(*plr.NextLink) != 0
}

// productsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plr ProductsListResult) productsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plr.NextLink)))
}

// ProductsListResultPage contains a page of Product values.
type ProductsListResultPage struct {
	fn  func(context.Context, ProductsListResult) (ProductsListResult, error)
	plr ProductsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProductsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProductsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plr)
		if err != nil {
			return err
		}
		page.plr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProductsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProductsListResultPage) NotDone() bool {
	return !page.plr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProductsListResultPage) Response() ProductsListResult {
	return page.plr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProductsListResultPage) Values() []Product {
	if page.plr.IsEmpty() {
		return nil
	}
	return *page.plr.Value
}

// Creates a new instance of the ProductsListResultPage type.
func NewProductsListResultPage(cur ProductsListResult, getNextPage func(context.Context, ProductsListResult) (ProductsListResult, error)) ProductsListResultPage {
	return ProductsListResultPage{
		fn:  getNextPage,
		plr: cur,
	}
}

// Profile a billing profile.
type Profile struct {
	autorest.Response `json:"-"`
	// ProfileProperties - The properties of the billing profile.
	*ProfileProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Profile.
func (p Profile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ProfileProperties != nil {
		objectMap["properties"] = p.ProfileProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Profile struct.
func (p *Profile) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var profileProperties ProfileProperties
				err = json.Unmarshal(*v, &profileProperties)
				if err != nil {
					return err
				}
				p.ProfileProperties = &profileProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// ProfileCreationRequest the request parameters for creating a new billing profile.
type ProfileCreationRequest struct {
	// DisplayName - The name of the billing profile.
	DisplayName *string `json:"displayName,omitempty"`
	// PoNumber - The purchase order name that will appear on the invoices generated for the billing profile.
	PoNumber *string `json:"poNumber,omitempty"`
	// BillTo - The address of the individual or organization that is responsible for the billing profile.
	BillTo *AddressDetails `json:"billTo,omitempty"`
	// InvoiceEmailOptIn - Flag controlling whether the invoices for the billing profile are sent through email.
	InvoiceEmailOptIn *bool `json:"invoiceEmailOptIn,omitempty"`
	// EnabledAzurePlans - Enabled azure plans for the billing profile.
	EnabledAzurePlans *[]AzurePlan `json:"enabledAzurePlans,omitempty"`
}

// ProfileListResult the list of billing profiles.
type ProfileListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing profiles.
	Value *[]Profile `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ProfileListResult.
func (plr ProfileListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ProfileListResultIterator provides access to a complete listing of Profile values.
type ProfileListResultIterator struct {
	i    int
	page ProfileListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProfileListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProfileListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProfileListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProfileListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProfileListResultIterator) Response() ProfileListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProfileListResultIterator) Value() Profile {
	if !iter.page.NotDone() {
		return Profile{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProfileListResultIterator type.
func NewProfileListResultIterator(page ProfileListResultPage) ProfileListResultIterator {
	return ProfileListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plr ProfileListResult) IsEmpty() bool {
	return plr.Value == nil || len(*plr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plr ProfileListResult) hasNextLink() bool {
	return plr.NextLink != nil && len(*plr.NextLink) != 0
}

// profileListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plr ProfileListResult) profileListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plr.NextLink)))
}

// ProfileListResultPage contains a page of Profile values.
type ProfileListResultPage struct {
	fn  func(context.Context, ProfileListResult) (ProfileListResult, error)
	plr ProfileListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProfileListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProfileListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plr)
		if err != nil {
			return err
		}
		page.plr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProfileListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProfileListResultPage) NotDone() bool {
	return !page.plr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProfileListResultPage) Response() ProfileListResult {
	return page.plr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProfileListResultPage) Values() []Profile {
	if page.plr.IsEmpty() {
		return nil
	}
	return *page.plr.Value
}

// Creates a new instance of the ProfileListResultPage type.
func NewProfileListResultPage(cur ProfileListResult, getNextPage func(context.Context, ProfileListResult) (ProfileListResult, error)) ProfileListResultPage {
	return ProfileListResultPage{
		fn:  getNextPage,
		plr: cur,
	}
}

// ProfileProperties the properties of the billing profile.
type ProfileProperties struct {
	// DisplayName - The name of the billing profile.
	DisplayName *string `json:"displayName,omitempty"`
	// PoNumber - The purchase order name that will appear on the invoices generated for the billing profile.
	PoNumber *string `json:"poNumber,omitempty"`
	// BillingRelationshipType - READ-ONLY; Identifies which services and purchases are paid by a billing profile. Possible values include: 'Direct', 'IndirectCustomer', 'IndirectPartner', 'CSPPartner'
	BillingRelationshipType RelationshipType `json:"billingRelationshipType,omitempty"`
	// BillTo - Billing address.
	BillTo *AddressDetails `json:"billTo,omitempty"`
	// IndirectRelationshipInfo - READ-ONLY; Identifies the billing profile that is linked to another billing profile in indirect purchase motion.
	IndirectRelationshipInfo *IndirectRelationshipInfo `json:"indirectRelationshipInfo,omitempty"`
	// InvoiceEmailOptIn - Flag controlling whether the invoices for the billing profile are sent through email.
	InvoiceEmailOptIn *bool `json:"invoiceEmailOptIn,omitempty"`
	// InvoiceDay - READ-ONLY; The day of the month when the invoice for the billing profile is generated.
	InvoiceDay *int32 `json:"invoiceDay,omitempty"`
	// Currency - READ-ONLY; The currency in which the charges for the billing profile are billed.
	Currency *string `json:"currency,omitempty"`
	// EnabledAzurePlans - Information about the enabled azure plans.
	EnabledAzurePlans *[]AzurePlan `json:"enabledAzurePlans,omitempty"`
	// InvoiceSections - The invoice sections associated to the billing profile. By default this is not populated, unless it's specified in $expand.
	InvoiceSections *InvoiceSectionsOnExpand `json:"invoiceSections,omitempty"`
	// HasReadAccess - READ-ONLY; Indicates whether user has read access to the billing profile.
	HasReadAccess *bool `json:"hasReadAccess,omitempty"`
	// SystemID - READ-ONLY; The system generated unique identifier for a billing profile.
	SystemID *string `json:"systemId,omitempty"`
	// Status - READ-ONLY; The status of the billing profile. Possible values include: 'ProfileStatusActive', 'ProfileStatusDisabled', 'ProfileStatusWarned'
	Status ProfileStatus `json:"status,omitempty"`
	// StatusReasonCode - READ-ONLY; Reason for the specified billing profile status. Possible values include: 'StatusReasonCodePastDue', 'StatusReasonCodeSpendingLimitReached', 'StatusReasonCodeSpendingLimitExpired'
	StatusReasonCode StatusReasonCode `json:"statusReasonCode,omitempty"`
	// SpendingLimit - READ-ONLY; The billing profile spending limit. Possible values include: 'SpendingLimitOff', 'SpendingLimitOn'
	SpendingLimit SpendingLimit `json:"spendingLimit,omitempty"`
	// TargetClouds - READ-ONLY; Identifies the cloud environments that are associated with a billing profile. This is a system managed optional field and gets updated as the billing profile gets associated with accounts in various clouds.
	TargetClouds *[]TargetCloud `json:"targetClouds,omitempty"`
}

// MarshalJSON is the custom marshaler for ProfileProperties.
func (pp ProfileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.DisplayName != nil {
		objectMap["displayName"] = pp.DisplayName
	}
	if pp.PoNumber != nil {
		objectMap["poNumber"] = pp.PoNumber
	}
	if pp.BillTo != nil {
		objectMap["billTo"] = pp.BillTo
	}
	if pp.InvoiceEmailOptIn != nil {
		objectMap["invoiceEmailOptIn"] = pp.InvoiceEmailOptIn
	}
	if pp.EnabledAzurePlans != nil {
		objectMap["enabledAzurePlans"] = pp.EnabledAzurePlans
	}
	if pp.InvoiceSections != nil {
		objectMap["invoiceSections"] = pp.InvoiceSections
	}
	return json.Marshal(objectMap)
}

// ProfilesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ProfilesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ProfilesClient) (Profile, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ProfilesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ProfilesCreateOrUpdateFuture.Result.
func (future *ProfilesCreateOrUpdateFuture) result(client ProfilesClient) (p Profile, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.ProfilesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		p.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.ProfilesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.CreateOrUpdateResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.ProfilesCreateOrUpdateFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProfilesOnExpand the billing profiles associated with the billing account. By default this is not
// populated, unless it's specified in $expand.
type ProfilesOnExpand struct {
	// HasMoreResults - READ-ONLY; Indicates whether there are more billing profiles than the ones listed in this collection. The collection lists a maximum of 50 billing profiles. To get all billing profiles, use the list billing profiles API.
	HasMoreResults *bool `json:"hasMoreResults,omitempty"`
	// Value - The billing profiles associated with the billing account.
	Value *[]Profile `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for ProfilesOnExpand.
func (poe ProfilesOnExpand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if poe.Value != nil {
		objectMap["value"] = poe.Value
	}
	return json.Marshal(objectMap)
}

// Property a billing property.
type Property struct {
	autorest.Response `json:"-"`
	// PropertyProperties - A billing property.
	*PropertyProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Property.
func (p Property) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.PropertyProperties != nil {
		objectMap["properties"] = p.PropertyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Property struct.
func (p *Property) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var propertyProperties PropertyProperties
				err = json.Unmarshal(*v, &propertyProperties)
				if err != nil {
					return err
				}
				p.PropertyProperties = &propertyProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// PropertyProperties the billing property.
type PropertyProperties struct {
	// AccountAdminNotificationEmailAddress - READ-ONLY; The email address on which the account admin gets all Azure notifications.
	AccountAdminNotificationEmailAddress *string `json:"accountAdminNotificationEmailAddress,omitempty"`
	// BillingTenantID - READ-ONLY; The Azure AD tenant ID of the billing account for the subscription.
	BillingTenantID *string `json:"billingTenantId,omitempty"`
	// BillingAccountID - READ-ONLY; The ID of the billing account to which the subscription is billed.
	BillingAccountID *string `json:"billingAccountId,omitempty"`
	// BillingAccountDisplayName - READ-ONLY; The name of the billing account to which the subscription is billed.
	BillingAccountDisplayName *string `json:"billingAccountDisplayName,omitempty"`
	// BillingProfileID - READ-ONLY; The ID of the billing profile to which the subscription is billed.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingProfileDisplayName - READ-ONLY; The name of the billing profile to which the subscription is billed.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// BillingProfileStatus - READ-ONLY; The status of the billing profile. Possible values include: 'ProfileStatusActive', 'ProfileStatusDisabled', 'ProfileStatusWarned'
	BillingProfileStatus ProfileStatus `json:"billingProfileStatus,omitempty"`
	// BillingProfileStatusReasonCode - READ-ONLY; Reason for the specified billing profile status. Possible values include: 'PastDue', 'SpendingLimitReached', 'SpendingLimitExpired'
	BillingProfileStatusReasonCode ProfileStatusReasonCode `json:"billingProfileStatusReasonCode,omitempty"`
	// BillingProfileSpendingLimit - READ-ONLY; The billing profile spending limit. Possible values include: 'ProfileSpendingLimitOff', 'ProfileSpendingLimitOn'
	BillingProfileSpendingLimit ProfileSpendingLimit `json:"billingProfileSpendingLimit,omitempty"`
	// CostCenter - The cost center applied to the subscription.
	CostCenter *string `json:"costCenter,omitempty"`
	// InvoiceSectionID - READ-ONLY; The ID of the invoice section to which the subscription is billed.
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty"`
	// InvoiceSectionDisplayName - READ-ONLY; The name of the invoice section to which the subscription is billed.
	InvoiceSectionDisplayName *string `json:"invoiceSectionDisplayName,omitempty"`
	// IsAccountAdmin - READ-ONLY; Indicates whether user is the account admin.
	IsAccountAdmin *bool `json:"isAccountAdmin,omitempty"`
	// ProductID - READ-ONLY; The product ID of the Azure plan.
	ProductID *string `json:"productId,omitempty"`
	// ProductName - READ-ONLY; The product name of the Azure plan.
	ProductName *string `json:"productName,omitempty"`
	// SkuID - READ-ONLY; The sku ID of the Azure plan for the subscription.
	SkuID *string `json:"skuId,omitempty"`
	// SkuDescription - READ-ONLY; The sku description of the Azure plan for the subscription.
	SkuDescription *string `json:"skuDescription,omitempty"`
}

// MarshalJSON is the custom marshaler for PropertyProperties.
func (pp PropertyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.CostCenter != nil {
		objectMap["costCenter"] = pp.CostCenter
	}
	return json.Marshal(objectMap)
}

// RebillDetails the rebill details of an invoice.
type RebillDetails struct {
	// CreditNoteDocumentID - READ-ONLY; The ID of credit note.
	CreditNoteDocumentID *string `json:"creditNoteDocumentId,omitempty"`
	// InvoiceDocumentID - READ-ONLY; The ID of invoice.
	InvoiceDocumentID *string `json:"invoiceDocumentId,omitempty"`
	// RebillDetails - READ-ONLY; Rebill details for an invoice.
	RebillDetails map[string]*RebillDetails `json:"rebillDetails"`
}

// MarshalJSON is the custom marshaler for RebillDetails.
func (rd RebillDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Reseller details of the reseller.
type Reseller struct {
	// ResellerID - READ-ONLY; The MPN ID of the reseller.
	ResellerID *string `json:"resellerId,omitempty"`
	// Description - READ-ONLY; The name of the reseller.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for Reseller.
func (r Reseller) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource the Resource model definition.
type Resource struct {
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RoleAssignment the role assignment
type RoleAssignment struct {
	autorest.Response `json:"-"`
	// RoleAssignmentProperties - The properties of the role assignment.
	*RoleAssignmentProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignment.
func (ra RoleAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ra.RoleAssignmentProperties != nil {
		objectMap["properties"] = ra.RoleAssignmentProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleAssignment struct.
func (ra *RoleAssignment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var roleAssignmentProperties RoleAssignmentProperties
				err = json.Unmarshal(*v, &roleAssignmentProperties)
				if err != nil {
					return err
				}
				ra.RoleAssignmentProperties = &roleAssignmentProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ra.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ra.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ra.Type = &typeVar
			}
		}
	}

	return nil
}

// RoleAssignmentListResult the list of role assignments.
type RoleAssignmentListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of role assignments.
	Value *[]RoleAssignment `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentListResult.
func (ralr RoleAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RoleAssignmentListResultIterator provides access to a complete listing of RoleAssignment values.
type RoleAssignmentListResultIterator struct {
	i    int
	page RoleAssignmentListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleAssignmentListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleAssignmentListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleAssignmentListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleAssignmentListResultIterator) Response() RoleAssignmentListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleAssignmentListResultIterator) Value() RoleAssignment {
	if !iter.page.NotDone() {
		return RoleAssignment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleAssignmentListResultIterator type.
func NewRoleAssignmentListResultIterator(page RoleAssignmentListResultPage) RoleAssignmentListResultIterator {
	return RoleAssignmentListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ralr RoleAssignmentListResult) IsEmpty() bool {
	return ralr.Value == nil || len(*ralr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ralr RoleAssignmentListResult) hasNextLink() bool {
	return ralr.NextLink != nil && len(*ralr.NextLink) != 0
}

// roleAssignmentListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ralr RoleAssignmentListResult) roleAssignmentListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ralr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ralr.NextLink)))
}

// RoleAssignmentListResultPage contains a page of RoleAssignment values.
type RoleAssignmentListResultPage struct {
	fn   func(context.Context, RoleAssignmentListResult) (RoleAssignmentListResult, error)
	ralr RoleAssignmentListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleAssignmentListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ralr)
		if err != nil {
			return err
		}
		page.ralr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleAssignmentListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleAssignmentListResultPage) NotDone() bool {
	return !page.ralr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleAssignmentListResultPage) Response() RoleAssignmentListResult {
	return page.ralr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleAssignmentListResultPage) Values() []RoleAssignment {
	if page.ralr.IsEmpty() {
		return nil
	}
	return *page.ralr.Value
}

// Creates a new instance of the RoleAssignmentListResultPage type.
func NewRoleAssignmentListResultPage(cur RoleAssignmentListResult, getNextPage func(context.Context, RoleAssignmentListResult) (RoleAssignmentListResult, error)) RoleAssignmentListResultPage {
	return RoleAssignmentListResultPage{
		fn:   getNextPage,
		ralr: cur,
	}
}

// RoleAssignmentProperties the properties of the role assignment.
type RoleAssignmentProperties struct {
	// CreatedOn - READ-ONLY; The date the role assignment was created.
	CreatedOn *string `json:"createdOn,omitempty"`
	// CreatedByPrincipalTenantID - READ-ONLY; The tenant Id of the user who created the role assignment.
	CreatedByPrincipalTenantID *string `json:"createdByPrincipalTenantId,omitempty"`
	// CreatedByPrincipalID - READ-ONLY; The principal Id of the user who created the role assignment.
	CreatedByPrincipalID *string `json:"createdByPrincipalId,omitempty"`
	// CreatedByUserEmailAddress - READ-ONLY; The email address of the user who created the role assignment.
	CreatedByUserEmailAddress *string `json:"createdByUserEmailAddress,omitempty"`
	// PrincipalID - The principal id of the user to whom the role was assigned.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalTenantID - The principal tenant id of the user to whom the role was assigned.
	PrincipalTenantID *string `json:"principalTenantId,omitempty"`
	// RoleDefinitionID - The ID of the role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// Scope - READ-ONLY; The scope at which the role was assigned.
	Scope *string `json:"scope,omitempty"`
	// UserAuthenticationType - The authentication type.
	UserAuthenticationType *string `json:"userAuthenticationType,omitempty"`
	// UserEmailAddress - The email address of the user.
	UserEmailAddress *string `json:"userEmailAddress,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentProperties.
func (rap RoleAssignmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rap.PrincipalID != nil {
		objectMap["principalId"] = rap.PrincipalID
	}
	if rap.PrincipalTenantID != nil {
		objectMap["principalTenantId"] = rap.PrincipalTenantID
	}
	if rap.RoleDefinitionID != nil {
		objectMap["roleDefinitionId"] = rap.RoleDefinitionID
	}
	if rap.UserAuthenticationType != nil {
		objectMap["userAuthenticationType"] = rap.UserAuthenticationType
	}
	if rap.UserEmailAddress != nil {
		objectMap["userEmailAddress"] = rap.UserEmailAddress
	}
	return json.Marshal(objectMap)
}

// RoleDefinition the properties of a role definition.
type RoleDefinition struct {
	autorest.Response `json:"-"`
	// RoleDefinitionProperties - The properties of the a role definition.
	*RoleDefinitionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleDefinition.
func (rd RoleDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rd.RoleDefinitionProperties != nil {
		objectMap["properties"] = rd.RoleDefinitionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleDefinition struct.
func (rd *RoleDefinition) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var roleDefinitionProperties RoleDefinitionProperties
				err = json.Unmarshal(*v, &roleDefinitionProperties)
				if err != nil {
					return err
				}
				rd.RoleDefinitionProperties = &roleDefinitionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rd.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rd.Type = &typeVar
			}
		}
	}

	return nil
}

// RoleDefinitionListResult the list of role definitions.
type RoleDefinitionListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The role definitions.
	Value *[]RoleDefinition `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleDefinitionListResult.
func (rdlr RoleDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RoleDefinitionListResultIterator provides access to a complete listing of RoleDefinition values.
type RoleDefinitionListResultIterator struct {
	i    int
	page RoleDefinitionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleDefinitionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleDefinitionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleDefinitionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleDefinitionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleDefinitionListResultIterator) Response() RoleDefinitionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleDefinitionListResultIterator) Value() RoleDefinition {
	if !iter.page.NotDone() {
		return RoleDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleDefinitionListResultIterator type.
func NewRoleDefinitionListResultIterator(page RoleDefinitionListResultPage) RoleDefinitionListResultIterator {
	return RoleDefinitionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rdlr RoleDefinitionListResult) IsEmpty() bool {
	return rdlr.Value == nil || len(*rdlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rdlr RoleDefinitionListResult) hasNextLink() bool {
	return rdlr.NextLink != nil && len(*rdlr.NextLink) != 0
}

// roleDefinitionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rdlr RoleDefinitionListResult) roleDefinitionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rdlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rdlr.NextLink)))
}

// RoleDefinitionListResultPage contains a page of RoleDefinition values.
type RoleDefinitionListResultPage struct {
	fn   func(context.Context, RoleDefinitionListResult) (RoleDefinitionListResult, error)
	rdlr RoleDefinitionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleDefinitionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleDefinitionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rdlr)
		if err != nil {
			return err
		}
		page.rdlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleDefinitionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleDefinitionListResultPage) NotDone() bool {
	return !page.rdlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleDefinitionListResultPage) Response() RoleDefinitionListResult {
	return page.rdlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleDefinitionListResultPage) Values() []RoleDefinition {
	if page.rdlr.IsEmpty() {
		return nil
	}
	return *page.rdlr.Value
}

// Creates a new instance of the RoleDefinitionListResultPage type.
func NewRoleDefinitionListResultPage(cur RoleDefinitionListResult, getNextPage func(context.Context, RoleDefinitionListResult) (RoleDefinitionListResult, error)) RoleDefinitionListResultPage {
	return RoleDefinitionListResultPage{
		fn:   getNextPage,
		rdlr: cur,
	}
}

// RoleDefinitionProperties the properties of the a role definition.
type RoleDefinitionProperties struct {
	// Description - READ-ONLY; The role description
	Description *string `json:"description,omitempty"`
	// Permissions - The billingPermissions the role has
	Permissions *[]PermissionsProperties `json:"permissions,omitempty"`
	// RoleName - READ-ONLY; The name of the role
	RoleName *string `json:"roleName,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleDefinitionProperties.
func (rdp RoleDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rdp.Permissions != nil {
		objectMap["permissions"] = rdp.Permissions
	}
	return json.Marshal(objectMap)
}

// Subscription a billing subscription.
type Subscription struct {
	autorest.Response       `json:"-"`
	*SubscriptionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Subscription.
func (s Subscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.SubscriptionProperties != nil {
		objectMap["properties"] = s.SubscriptionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Subscription struct.
func (s *Subscription) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var subscriptionProperties SubscriptionProperties
				err = json.Unmarshal(*v, &subscriptionProperties)
				if err != nil {
					return err
				}
				s.SubscriptionProperties = &subscriptionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				s.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				s.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				s.Type = &typeVar
			}
		}
	}

	return nil
}

// SubscriptionProperties the billing properties of a subscription.
type SubscriptionProperties struct {
	// DisplayName - READ-ONLY; The name of the subscription.
	DisplayName *string `json:"displayName,omitempty"`
	// SubscriptionID - READ-ONLY; The ID of the subscription.
	SubscriptionID *uuid.UUID `json:"subscriptionId,omitempty"`
	// SubscriptionBillingStatus - The current billing status of the subscription. Possible values include: 'SubscriptionStatusTypeActive', 'SubscriptionStatusTypeInactive', 'SubscriptionStatusTypeAbandoned', 'SubscriptionStatusTypeDeleted', 'SubscriptionStatusTypeWarning'
	SubscriptionBillingStatus SubscriptionStatusType `json:"subscriptionBillingStatus,omitempty"`
	// LastMonthCharges - READ-ONLY; The last month charges.
	LastMonthCharges *Amount `json:"lastMonthCharges,omitempty"`
	// MonthToDateCharges - READ-ONLY; The current month to date charges.
	MonthToDateCharges *Amount `json:"monthToDateCharges,omitempty"`
	// BillingProfileID - READ-ONLY; The ID of the billing profile to which the subscription is billed.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingProfileDisplayName - READ-ONLY; The name of the billing profile to which the subscription is billed.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// CostCenter - The cost center applied to the subscription.
	CostCenter *string `json:"costCenter,omitempty"`
	// CustomerID - READ-ONLY; The ID of the customer for whom the subscription was created. The field is applicable only for Microsoft Partner Agreement billing account.
	CustomerID *string `json:"customerId,omitempty"`
	// CustomerDisplayName - READ-ONLY; The name of the customer for whom the subscription was created. The field is applicable only for Microsoft Partner Agreement billing account.
	CustomerDisplayName *string `json:"customerDisplayName,omitempty"`
	// InvoiceSectionID - READ-ONLY; The ID of the invoice section to which the subscription is billed.
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty"`
	// InvoiceSectionDisplayName - READ-ONLY; The name of the invoice section to which the subscription is billed.
	InvoiceSectionDisplayName *string `json:"invoiceSectionDisplayName,omitempty"`
	// Reseller - READ-ONLY; Reseller for this subscription.
	Reseller *Reseller `json:"reseller,omitempty"`
	// SkuID - The sku ID of the Azure plan for the subscription.
	SkuID *string `json:"skuId,omitempty"`
	// SkuDescription - READ-ONLY; The sku description of the Azure plan for the subscription.
	SkuDescription *string `json:"skuDescription,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionProperties.
func (sp SubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.SubscriptionBillingStatus != "" {
		objectMap["subscriptionBillingStatus"] = sp.SubscriptionBillingStatus
	}
	if sp.CostCenter != nil {
		objectMap["costCenter"] = sp.CostCenter
	}
	if sp.SkuID != nil {
		objectMap["skuId"] = sp.SkuID
	}
	return json.Marshal(objectMap)
}

// SubscriptionsListResult the list of billing subscriptions.
type SubscriptionsListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing subscriptions.
	Value *[]Subscription `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionsListResult.
func (slr SubscriptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SubscriptionsListResultIterator provides access to a complete listing of Subscription values.
type SubscriptionsListResultIterator struct {
	i    int
	page SubscriptionsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SubscriptionsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubscriptionsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SubscriptionsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SubscriptionsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SubscriptionsListResultIterator) Response() SubscriptionsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SubscriptionsListResultIterator) Value() Subscription {
	if !iter.page.NotDone() {
		return Subscription{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SubscriptionsListResultIterator type.
func NewSubscriptionsListResultIterator(page SubscriptionsListResultPage) SubscriptionsListResultIterator {
	return SubscriptionsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (slr SubscriptionsListResult) IsEmpty() bool {
	return slr.Value == nil || len(*slr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (slr SubscriptionsListResult) hasNextLink() bool {
	return slr.NextLink != nil && len(*slr.NextLink) != 0
}

// subscriptionsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (slr SubscriptionsListResult) subscriptionsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !slr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(slr.NextLink)))
}

// SubscriptionsListResultPage contains a page of Subscription values.
type SubscriptionsListResultPage struct {
	fn  func(context.Context, SubscriptionsListResult) (SubscriptionsListResult, error)
	slr SubscriptionsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SubscriptionsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubscriptionsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.slr)
		if err != nil {
			return err
		}
		page.slr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SubscriptionsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SubscriptionsListResultPage) NotDone() bool {
	return !page.slr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SubscriptionsListResultPage) Response() SubscriptionsListResult {
	return page.slr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SubscriptionsListResultPage) Values() []Subscription {
	if page.slr.IsEmpty() {
		return nil
	}
	return *page.slr.Value
}

// Creates a new instance of the SubscriptionsListResultPage type.
func NewSubscriptionsListResultPage(cur SubscriptionsListResult, getNextPage func(context.Context, SubscriptionsListResult) (SubscriptionsListResult, error)) SubscriptionsListResultPage {
	return SubscriptionsListResultPage{
		fn:  getNextPage,
		slr: cur,
	}
}

// SubscriptionsMoveFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubscriptionsMoveFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionsClient) (Subscription, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubscriptionsMoveFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubscriptionsMoveFuture.Result.
func (future *SubscriptionsMoveFuture) result(client SubscriptionsClient) (s Subscription, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.SubscriptionsMoveFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.SubscriptionsMoveFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.MoveResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.SubscriptionsMoveFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Transaction a transaction.
type Transaction struct {
	*TransactionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Transaction.
func (t Transaction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.TransactionProperties != nil {
		objectMap["properties"] = t.TransactionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Transaction struct.
func (t *Transaction) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var transactionProperties TransactionProperties
				err = json.Unmarshal(*v, &transactionProperties)
				if err != nil {
					return err
				}
				t.TransactionProperties = &transactionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				t.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				t.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				t.Type = &typeVar
			}
		}
	}

	return nil
}

// TransactionListResult the list of transactions.
type TransactionListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of transactions.
	Value *[]Transaction `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for TransactionListResult.
func (tlr TransactionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// TransactionListResultIterator provides access to a complete listing of Transaction values.
type TransactionListResultIterator struct {
	i    int
	page TransactionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TransactionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TransactionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TransactionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TransactionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TransactionListResultIterator) Response() TransactionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TransactionListResultIterator) Value() Transaction {
	if !iter.page.NotDone() {
		return Transaction{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TransactionListResultIterator type.
func NewTransactionListResultIterator(page TransactionListResultPage) TransactionListResultIterator {
	return TransactionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (tlr TransactionListResult) IsEmpty() bool {
	return tlr.Value == nil || len(*tlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (tlr TransactionListResult) hasNextLink() bool {
	return tlr.NextLink != nil && len(*tlr.NextLink) != 0
}

// transactionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (tlr TransactionListResult) transactionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !tlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(tlr.NextLink)))
}

// TransactionListResultPage contains a page of Transaction values.
type TransactionListResultPage struct {
	fn  func(context.Context, TransactionListResult) (TransactionListResult, error)
	tlr TransactionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TransactionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TransactionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.tlr)
		if err != nil {
			return err
		}
		page.tlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TransactionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TransactionListResultPage) NotDone() bool {
	return !page.tlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TransactionListResultPage) Response() TransactionListResult {
	return page.tlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TransactionListResultPage) Values() []Transaction {
	if page.tlr.IsEmpty() {
		return nil
	}
	return *page.tlr.Value
}

// Creates a new instance of the TransactionListResultPage type.
func NewTransactionListResultPage(cur TransactionListResult, getNextPage func(context.Context, TransactionListResult) (TransactionListResult, error)) TransactionListResultPage {
	return TransactionListResultPage{
		fn:  getNextPage,
		tlr: cur,
	}
}

// TransactionProperties the properties of a transaction.
type TransactionProperties struct {
	// Kind - The kind of transaction. Options are all or reservation. Possible values include: 'All', 'Reservation'
	Kind TransactionTypeKind `json:"kind,omitempty"`
	// Date - READ-ONLY; The date of transaction.
	Date *date.Time `json:"date,omitempty"`
	// Invoice - READ-ONLY; Invoice on which the transaction was billed or 'pending' if the transaction is not billed.
	Invoice *string `json:"invoice,omitempty"`
	// InvoiceID - READ-ONLY; The ID of the invoice on which the transaction was billed. This field is only applicable for transactions which are billed.
	InvoiceID *string `json:"invoiceId,omitempty"`
	// OrderID - READ-ONLY; The order ID of the reservation. The field is only applicable for transaction of kind reservation.
	OrderID *string `json:"orderId,omitempty"`
	// OrderName - READ-ONLY; The name of the reservation order. The field is only applicable for transactions of kind reservation.
	OrderName *string `json:"orderName,omitempty"`
	// ProductFamily - READ-ONLY; The family of the product for which the transaction took place.
	ProductFamily *string `json:"productFamily,omitempty"`
	// ProductTypeID - READ-ONLY; The ID of the product type for which the transaction took place.
	ProductTypeID *string `json:"productTypeId,omitempty"`
	// ProductType - READ-ONLY; The type of the product for which the transaction took place.
	ProductType *string `json:"productType,omitempty"`
	// ProductDescription - READ-ONLY; The description of the product for which the transaction took place.
	ProductDescription *string `json:"productDescription,omitempty"`
	// TransactionType - The type of transaction. Possible values include: 'Purchase', 'UsageCharge'
	TransactionType ReservationType `json:"transactionType,omitempty"`
	// TransactionAmount - READ-ONLY; The charge associated with the transaction.
	TransactionAmount *Amount `json:"transactionAmount,omitempty"`
	// Quantity - READ-ONLY; The quantity purchased in the transaction.
	Quantity *int32 `json:"quantity,omitempty"`
	// InvoiceSectionID - READ-ONLY; The ID of the invoice section which will be billed for the transaction.
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty"`
	// InvoiceSectionDisplayName - READ-ONLY; The name of the invoice section which will be billed for the transaction.
	InvoiceSectionDisplayName *string `json:"invoiceSectionDisplayName,omitempty"`
	// BillingProfileID - READ-ONLY; The ID of the billing profile which will be billed for the transaction.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingProfileDisplayName - READ-ONLY; The name of the billing profile which will be billed for the transaction.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// CustomerID - READ-ONLY; The ID of the customer for which the transaction took place. The field is applicable only for Microsoft Partner Agreement billing account.
	CustomerID *string `json:"customerId,omitempty"`
	// CustomerDisplayName - READ-ONLY; The name of the customer for which the transaction took place. The field is applicable only for Microsoft Partner Agreement billing account.
	CustomerDisplayName *string `json:"customerDisplayName,omitempty"`
	// SubscriptionID - READ-ONLY; The ID of the subscription that was used for the transaction. The field is only applicable for transaction of kind reservation.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// SubscriptionName - READ-ONLY; The name of the subscription that was used for the transaction. The field is only applicable for transaction of kind reservation.
	SubscriptionName *string `json:"subscriptionName,omitempty"`
	// AzurePlan - READ-ONLY; The type of azure plan of the subscription that was used for the transaction.
	AzurePlan *string `json:"azurePlan,omitempty"`
	// AzureCreditApplied - READ-ONLY; The amount of any Azure credits automatically applied to this transaction.
	AzureCreditApplied *Amount `json:"azureCreditApplied,omitempty"`
	// BillingCurrency - READ-ONLY; The ISO 4217 code for the currency in which this transaction is billed.
	BillingCurrency *string `json:"billingCurrency,omitempty"`
	// Discount - READ-ONLY; The percentage discount, if any, applied to this transaction.
	Discount *float64 `json:"discount,omitempty"`
	// EffectivePrice - READ-ONLY; The price of the product after applying any discounts.
	EffectivePrice *Amount `json:"effectivePrice,omitempty"`
	// ExchangeRate - READ-ONLY; The exchange rate used to convert charged amount to billing currency, if applicable.
	ExchangeRate *float64 `json:"exchangeRate,omitempty"`
	// MarketPrice - READ-ONLY; The retail price of the product.
	MarketPrice *Amount `json:"marketPrice,omitempty"`
	// PricingCurrency - READ-ONLY; The ISO 4217 code for the currency in which the product is priced.
	PricingCurrency *string `json:"pricingCurrency,omitempty"`
	// ServicePeriodStartDate - READ-ONLY; The date of the purchase of the product, or the start date of the month in which usage started.
	ServicePeriodStartDate *date.Time `json:"servicePeriodStartDate,omitempty"`
	// ServicePeriodEndDate - READ-ONLY; The end date of the product term, or the end date of the month in which usage ended.
	ServicePeriodEndDate *date.Time `json:"servicePeriodEndDate,omitempty"`
	// SubTotal - READ-ONLY; The pre-tax charged amount for the transaction.
	SubTotal *Amount `json:"subTotal,omitempty"`
	// Tax - READ-ONLY; The tax amount applied to the transaction.
	Tax *Amount `json:"tax,omitempty"`
	// UnitOfMeasure - READ-ONLY; The unit of measure used to bill for the product. For example, compute services are billed per hour.
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
	// Units - READ-ONLY; The number of units used for a given product.
	Units *float64 `json:"units,omitempty"`
	// UnitType - READ-ONLY; The description for the unit of measure for a given product.
	UnitType *string `json:"unitType,omitempty"`
}

// MarshalJSON is the custom marshaler for TransactionProperties.
func (tp TransactionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tp.Kind != "" {
		objectMap["kind"] = tp.Kind
	}
	if tp.TransactionType != "" {
		objectMap["transactionType"] = tp.TransactionType
	}
	return json.Marshal(objectMap)
}

// TransferBillingSubscriptionRequestProperties request parameters to transfer billing subscription.
type TransferBillingSubscriptionRequestProperties struct {
	// DestinationInvoiceSectionID - The destination invoice section id.
	DestinationInvoiceSectionID *string `json:"destinationInvoiceSectionId,omitempty"`
}

// TransferProductRequestProperties the properties of the product to initiate a transfer.
type TransferProductRequestProperties struct {
	// DestinationInvoiceSectionID - The destination invoice section id.
	DestinationInvoiceSectionID *string `json:"destinationInvoiceSectionId,omitempty"`
}

// ValidateAddressResponse result of the address validation
type ValidateAddressResponse struct {
	autorest.Response `json:"-"`
	// Status - status of the address validation. Possible values include: 'Valid', 'Invalid'
	Status AddressValidationStatus `json:"status,omitempty"`
	// SuggestedAddresses - The list of suggested addresses.
	SuggestedAddresses *[]AddressDetails `json:"suggestedAddresses,omitempty"`
	// ValidationMessage - Validation error message.
	ValidationMessage *string `json:"validationMessage,omitempty"`
}

// ValidateProductTransferEligibilityError error details of the product transfer eligibility validation.
type ValidateProductTransferEligibilityError struct {
	// Code - Error code for the product transfer validation. Possible values include: 'InvalidSource', 'ProductNotActive', 'InsufficientPermissionOnSource', 'InsufficientPermissionOnDestination', 'DestinationBillingProfilePastDue', 'ProductTypeNotSupported', 'CrossBillingAccountNotAllowed', 'NotAvailableForDestinationMarket', 'OneTimePurchaseProductTransferNotAllowed'
	Code ProductTransferValidationErrorCode `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Details - Detailed error message explaining the error.
	Details *string `json:"details,omitempty"`
}

// ValidateProductTransferEligibilityResult result of the product transfer eligibility validation.
type ValidateProductTransferEligibilityResult struct {
	autorest.Response `json:"-"`
	// IsMoveEligible - READ-ONLY; Specifies whether the transfer is eligible or not.
	IsMoveEligible *bool `json:"isMoveEligible,omitempty"`
	// ErrorDetails - Validation error details.
	ErrorDetails *ValidateProductTransferEligibilityError `json:"errorDetails,omitempty"`
}

// MarshalJSON is the custom marshaler for ValidateProductTransferEligibilityResult.
func (vpter ValidateProductTransferEligibilityResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vpter.ErrorDetails != nil {
		objectMap["errorDetails"] = vpter.ErrorDetails
	}
	return json.Marshal(objectMap)
}

// ValidateSubscriptionTransferEligibilityError error details of the transfer eligibility validation
type ValidateSubscriptionTransferEligibilityError struct {
	// Code - Error code for the product transfer validation. Possible values include: 'SubscriptionTransferValidationErrorCodeInvalidSource', 'SubscriptionTransferValidationErrorCodeSubscriptionNotActive', 'SubscriptionTransferValidationErrorCodeInsufficientPermissionOnSource', 'SubscriptionTransferValidationErrorCodeInsufficientPermissionOnDestination', 'SubscriptionTransferValidationErrorCodeDestinationBillingProfilePastDue', 'SubscriptionTransferValidationErrorCodeSubscriptionTypeNotSupported', 'SubscriptionTransferValidationErrorCodeCrossBillingAccountNotAllowed', 'SubscriptionTransferValidationErrorCodeNotAvailableForDestinationMarket'
	Code SubscriptionTransferValidationErrorCode `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Details - Detailed error message explaining the error.
	Details *string `json:"details,omitempty"`
}

// ValidateSubscriptionTransferEligibilityResult result of the transfer eligibility validation.
type ValidateSubscriptionTransferEligibilityResult struct {
	autorest.Response `json:"-"`
	// IsMoveEligible - READ-ONLY; Specifies whether the subscription is eligible to be transferred.
	IsMoveEligible *bool `json:"isMoveEligible,omitempty"`
	// ErrorDetails - Validation error details.
	ErrorDetails *ValidateSubscriptionTransferEligibilityError `json:"errorDetails,omitempty"`
}

// MarshalJSON is the custom marshaler for ValidateSubscriptionTransferEligibilityResult.
func (vster ValidateSubscriptionTransferEligibilityResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vster.ErrorDetails != nil {
		objectMap["errorDetails"] = vster.ErrorDetails
	}
	return json.Marshal(objectMap)
}
